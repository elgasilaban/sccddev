/*
	Copyright (c) 2004-2011, The Dojo Foundation All Rights Reserved.
	Available via Academic Free License >= 2.1 OR the modified BSD license.
	see: http://dojotoolkit.org/license for details
*/

/*
	This is an optimized version of Dojo, built for deployment and not for
	development. To get sources and documentation, please visit:

		http://dojotoolkit.org
*/

//>>built
require({cache:{
'dijit/form/nls/validate':function(){
define({ root:
//begin v1.x content
({
	invalidMessage: "The value entered is not valid.",
	missingMessage: "This value is required.",
	rangeMessage: "This value is out of range."
})
//end v1.x content
,
"zh": true,
"zh-tw": true,
"tr": true,
"th": true,
"sv": true,
"sl": true,
"sk": true,
"ru": true,
"ro": true,
"pt": true,
"pt-pt": true,
"pl": true,
"nl": true,
"nb": true,
"ko": true,
"kk": true,
"ja": true,
"it": true,
"hu": true,
"hr": true,
"he": true,
"fr": true,
"fi": true,
"es": true,
"el": true,
"de": true,
"da": true,
"cs": true,
"ca": true,
"az": true,
"ar": true
});

},
'dojox/data/AndOrReadStore':function(){
define("dojox/data/AndOrReadStore", ["dojo/_base/kernel", "dojo/_base/declare", "dojo/_base/lang", "dojo/data/util/filter", "dojo/data/util/simpleFetch",
		"dojo/_base/array", "dojo/date/stamp", "dojo/_base/json", "dojo/_base/window", "dojo/_base/xhr"], 
  function(kernel, declare, lang, filterUtil, simpleFetch, array, dateStamp, json, winUtil, xhr) {

var AndOrReadStore = declare("dojox.data.AndOrReadStore", null, {
	//	summary:
	//		AndOrReadStore uses ItemFileReadStore as a base, modifying only the query (_fetchItems) section.
	//		Supports queries of the form: query:"id:1* OR dept:'Sales Department' || (id:2* && NOT dept:S*)"
	//		Includes legacy/widget support via:
	//			query:{complexQuery:"id:1* OR dept:'Sales Department' || (id:2* && NOT dept:S*)"}
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}
	
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dateStamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];

		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
	},
	
	url: "", // use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null, //Make this parser settable.

	typeMap: null, //Make this parser settable.

	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,

	//Parameter to indicate to process data from the url as hierarchical
	//(data items can contain other data items in js form).  Default is true
	//for backwards compatibility.  False means only root items are processed
	//as items, all child objects outside of type-mapped objects and those in
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error("dojox.data.AndOrReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error("dojox.data.AndOrReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		//	summary:
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		var arr = item[attribute] || [];
		// Clone it before returning.  refs: #10474
		return arr.slice(0, arr.length); // Array
	},

	getAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		//	summary:
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = filterUtil.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary:
		//		Internal function for looking at the values contained by the item.
		//	description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return array.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !lang.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			} else if(value === possibleValue){
				return true; // Boolean
			} else {
				return false;
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary:
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		//		filter modified to permit complex queries where
		//			logical operators are case insensitive:
		//			, NOT AND OR ( ) ! && ||
		//			Note:  "," included for quoted/string legacy queries.
		var self = this;
		var filter = function(requestArgs, arrayOfItems){
			var items = [];
			if(requestArgs.query){
				//Complete copy, we may have to mess with it.
				//Safer than clone, which does a shallow copy, I believe.
				var query = json.fromJson(json.toJson(requestArgs.query));
				//Okay, object form query, we have to check to see if someone mixed query methods (such as using FilteringSelect
				//with a complexQuery).  In that case, the params need to be anded to the complex query statement.
				//See defect #7980
				if(typeof query == "object" ){
					var count = 0;
					var p;
					for(p in query){
						count++;
					}
					if(count > 1 && query.complexQuery){
						var cq = query.complexQuery;
						var wrapped = false;
						for(p in query){
							if(p !== "complexQuery"){
								//We should wrap this in () as it should and with the entire complex query
								//Not just part of it.
								if(!wrapped){
									cq = "( " + cq + " )";
									wrapped = true;
								}
								//Make sure strings are quoted when going into complexQuery merge.
								var v = requestArgs.query[p];
								if(lang.isString(v)){
									v = "'" + v + "'";
								}
								cq += " AND " + p + ":" + v;
								delete query[p];
								
							}
						}
						query.complexQuery = cq;
					}
				}

				var ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;
				//for complex queries only:  pattern = query[:|=]"NOT id:23* AND (type:'test*' OR dept:'bob') && !filed:true"
				//logical operators are case insensitive:  , NOT AND OR ( ) ! && ||  // "," included for quoted/string legacy queries.
				if(typeof query != "string"){
					query = json.toJson(query);
					query = query.replace(/\\\\/g,"\\"); //counter toJson expansion of backslashes, e.g., foo\\*bar test.
				}
				query = query.replace(/\\"/g,"\"");   //ditto, for embedded \" in lieu of " availability.
				var complexQuery = lang.trim(query.replace(/{|}/g,"")); //we can handle these, too.
				var pos2, i;
				if(complexQuery.match(/"? *complexQuery *"?:/)){ //case where widget required a json object, so use complexQuery:'the real query'
					complexQuery = lang.trim(complexQuery.replace(/"?\s*complexQuery\s*"?:/,""));
					var quotes = ["'",'"'];
					var pos1,colon;
					var flag = false;
					for(i = 0; i<quotes.length; i++){
						pos1 = complexQuery.indexOf(quotes[i]);
						pos2 = complexQuery.indexOf(quotes[i],1);
						colon = complexQuery.indexOf(":",1);
						if(pos1 === 0 && pos2 != -1 && colon < pos2){
							flag = true;
							break;
						} //first two sets of quotes don't occur before the first colon.
					}
					if(flag){	//dojo.toJson, and maybe user, adds surrounding quotes, which we need to remove.
						complexQuery = complexQuery.replace(/^\"|^\'|\"$|\'$/g,"");
					}
				} //end query="{complexQuery:'id:1* || dept:Sales'}" parsing (for when widget required json object query).
				var complexQuerySave = complexQuery;
				//valid logical operators.
				var begRegExp = /^,|^NOT |^AND |^OR |^\(|^\)|^!|^&&|^\|\|/i; //trailing space on some tokens on purpose.
				var sQuery = ""; //will be eval'ed for each i-th candidateItem, based on query components.
				var op = "";
				var val = "";
				var pos = -1;
				var err = false;
				var key = "";
				var value = "";
				var tok = "";
				pos2 = -1;
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						//process entire string for this i-th candidateItem.
						complexQuery = complexQuerySave; //restore query for next candidateItem.
						sQuery = "";
						//work left to right, finding either key:value pair or logical operator at the beginning of the complexQuery string.
						//when found, concatenate to sQuery and remove from complexQuery and loop back.
						while(complexQuery.length > 0 && !err){
							op = complexQuery.match(begRegExp);
							
							//get/process/append one or two leading logical operators.
							while(op && !err){ //look for leading logical operators.
								complexQuery = lang.trim(complexQuery.replace(op[0],""));
								op = lang.trim(op[0]).toUpperCase();
								//convert some logical operators to their javascript equivalents for later eval.
								op = op == "NOT" ? "!" : op == "AND" || op == "," ? "&&" : op == "OR" ? "||" : op;
								op = " " + op + " ";
								sQuery += op;
								op = complexQuery.match(begRegExp);
							}//end op && !err
							
							//now get/process/append one key:value pair.
							if(complexQuery.length > 0){
								pos = complexQuery.indexOf(":");
								if(pos == -1){
									err = true;
									break;
								}else{
									key = lang.trim(complexQuery.substring(0,pos).replace(/\"|\'/g,""));
									complexQuery = lang.trim(complexQuery.substring(pos + 1));
									tok = complexQuery.match(/^\'|^\"/);	//quoted?
									if(tok){
										tok = tok[0];
										pos = complexQuery.indexOf(tok);
										pos2 = complexQuery.indexOf(tok,pos + 1);
										if(pos2 == -1){
											err = true;
											break;
										}
										value = complexQuery.substring(pos + 1,pos2);
										if(pos2 == complexQuery.length - 1){ //quote is last character
											complexQuery = "";
										}else{
											complexQuery = lang.trim(complexQuery.substring(pos2 + 1));
										}
										sQuery += self._containsValue(candidateItem, key, value, filterUtil.patternToRegExp(value, ignoreCase));
									}
									else{ //not quoted, so a space, comma, or closing parens (or the end) will be the break.
										tok = complexQuery.match(/\s|\)|,/);
										if(tok){
											var pos3 = new Array(tok.length);
											for(var j = 0;j<tok.length;j++){
												pos3[j] = complexQuery.indexOf(tok[j]);
											}
											pos = pos3[0];
											if(pos3.length > 1){
												for(var j=1;j<pos3.length;j++){
													pos = Math.min(pos,pos3[j]);
												}
											}
											value = lang.trim(complexQuery.substring(0,pos));
											complexQuery = lang.trim(complexQuery.substring(pos));
										}else{ //not a space, so must be at the end of the complexQuery.
											value = lang.trim(complexQuery);
											complexQuery = "";
										} //end  inner if(tok) else
										sQuery += self._containsValue(candidateItem, key, value, filterUtil.patternToRegExp(value, ignoreCase));
									} //end outer if(tok) else
								} //end found ":"
							} //end if(complexQuery.length > 0)
						} //end while complexQuery.length > 0 && !err, so finished the i-th item.
						match = eval(sQuery);
					} //end else is non-null candidateItem.
					if(match){
						items.push(candidateItem);
					}
				} //end for/next of all items.
				if(err){
					//soft fail.
					items = [];
					console.log("The store's _fetchItems failed, probably due to a syntax error in query.");
				}
				findCallback(items, requestArgs);
			}else{
				// No query...
				// We want a copy to pass back in case the parent wishes to sort the array.
				// We shouldn't allow resort of the internal list, so that multiple callers
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(var i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			} //end if there is a query.
		}; //end filter function

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			if(this._jsonFileUrl !== this._ccUrl){
				kernel.deprecated("dojox.data.AndOrReadStore: ",
								"To change the url, set the url property of the store," +
								" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}
			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
						};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							
							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});
					
					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojox.data.AndOrReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		} //end deferred fetching.
	}, //end _fetchItems

	_handleQueuedFetches: function(){
		//	summary:
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i];
				var delayedQuery = fData.args;
				var delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions));
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary:
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems;
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		//	summary:
		//		See dojo.data.api.Read.close()
		if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) &&
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojox.data.AndOrReadStore: WARNING!  Data reload " +
					" information has not been provided." +
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.
		
		// First, we define a couple little utility functions...
		
		var self = this;
		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'May 14, 1802'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			var isItem = (
				(aValue !== null) &&
				(typeof aValue === "object") &&
				(!lang.isArray(aValue)) &&
				(!lang.isFunction(aValue)) &&
				(aValue.constructor == Object) &&
				(typeof aValue._reference === "undefined") &&
				(typeof aValue._type === "undefined") &&
				(typeof aValue._value === "undefined") &&
				self.hierarchical
			);
			return isItem;
		}
		
		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(lang.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i;
		var item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items,
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		//
		// We also store the attribute names so we can validate our store
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {};
		var key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!lang.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is
		// the name of an attribute that holds the identity of each item.
		// If this data file specified an identifier attribute, then build a
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!this._itemsByIdentity[identity]){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojox.data.AndOrReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojox.data.AndOrReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] }
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'July 18, 1918'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date('July 18, 1918')) }
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){
								throw new Error("dojox.data.AndOrReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(lang.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(lang.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojox.data.AndOrReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!lang.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k];
									var found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){
											found = false;
										}
									}
									if(found){
										arrayOfValues[j] = candidateItem;
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.
		 
		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		if(!this._loadFinished){
			var self = this;
			if(this._jsonFileUrl !== this._ccUrl){
				kernel.deprecated("dojox.data.AndOrReadStore: ",
								"To change the url, set the url property of the store," +
								" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}
			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}
			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache
					};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:winUtil.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							var item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:winUtil.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				var item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					var scope = keywordArgs.scope?keywordArgs.scope:winUtil.global;
					keywordArgs.onItem.call(scope, item);
				}
			}
		}else{
			// Already loaded.  We can just look it up and call back.
			var item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				var scope = keywordArgs.scope?keywordArgs.scope:winUtil.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			item = this._itemsByIdentity[identity];
		}else{
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentifierAttributes()
		 
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed
			// of attributes
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},
	
	_forceLoad: function(){
		//	summary:
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.
		var self = this;
		if(this._jsonFileUrl !== this._ccUrl){
			kernel.deprecated("dojox.data.AndOrReadStore: ",
							"To change the url, set the url property of the store," +
							" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}
		//See if there was any forced reset of data.
		if(this.data != null && this._jsonData == null){
			this._jsonData = this.data;
			this.data = null;
		}
		if(this._jsonFileUrl){
				var getArgs = {
					url: self._jsonFileUrl,
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					sync: true
				};
			var getHandler = xhr.get(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojox.data.AndOrReadStore:  Unable to perform a synchronous load, an async load is in progress.");
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		}
	}
});
//Mix in the simple fetch implementation to this class.
lang.extend(AndOrReadStore, simpleFetch);

return AndOrReadStore;
});



},
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n",
'ibm/tivoli/simplesrm/srm/dijit/MyCatalogRequestsGrid':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dijit/MyRecordsGrid,ibm/tivoli/simplesrm/srm/dijit/RequestDetails,dijit/Dialog"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MyCatalogRequestsGrid");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ShowRequestDetails");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MyApprovalsGrid");

// include modules
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.RequestDetails");
dojo.require("dijit.Dialog");


// Summary:
//	A mixin for showing request details.
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ShowRequestDetails",
			 ibm.tivoli.simplesrm.srm.dijit.CreatorFactory,
{
	_approveRights: false,

	popup: null,
	
	showRecordDetails: function(selected_record)
	{
		//this.createAndShowInputForm(selected_record, true);
		if(this.popup) {
			this.popup.destroy();
			this.popup = null;
		}
		if(selected_record) {
			console.log("ShowRequestDetails", selected_record);
			var d = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestDetails(selected_record);
			d.addCallback(dojo.hitch(this, function(response)
			{
				var rd = new ibm.tivoli.simplesrm.srm.dijit.RequestDetails({approval: this._approveRights});
				rd.setData(response);
			}));
		}
	},
	
	/**
	 * Specify whether the parent grid allows the approval panel to be displayed
	 * or not.
	 */
	setApprContext: function(approvalContext) {
		this._approveRights = approvalContext;
	}
});

// Summary:
//	TODO: write this
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.MyCatalogRequestsGrid",
	[dijit._Widget, ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid, ibm.tivoli.simplesrm.srm.dijit.ShowRequestDetails],
{
 
	// constructor defines "static" properties for this class, and
	// declares "instance" properties for this class
	constructor: function()
	{
		console.log("CatalogRequestsGrid.ctor");
		
//		this._hoverer = new  ibm.tivoli.simplesrm.srm.dojo.Hoverer();
//		this._conn_onHover = dojo.connect(this._hoverer, "OnHover", this, "_showGridTooltip");
		
 		// the column definitions
 		// the order they are listed here is the order they will be displayed in the tooltip
		

        	var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			if (product!=null && product.indexOf("srm")>=0)  //fpb
		    {
				this._column_defs = [
				 {field: 'key',			name: "",							 	width: '5%',	compare: dojo.hitch(this, "_sortDefault"), showInTooltip: false}
				,{field: 'id', 			name: 'id',								width: '5%',	compare: dojo.hitch(this, "_sortNumber")}
				,{field: 'type', 		name: "Object Type",					width: '5%',	compare: dojo.hitch(this, "_sortString"), showInTooltip: false}
				,{field: 'DESCRIPTION', name: this._uiStringTable.Description, 	width: '25%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
				];

				 
				indeces = 1;
				this._initial_view_cols = [indeces+2];	// indeces into _column_defs
				this._initial_sort_index = 1;	 	// SR ID (column index, not field index)

				for (key in colAttrNameArray) 
				{
					 
					formatString = "_formatStringSafe";
					colWidth = '13%';

					var dateMatch = key.match(/DATE/gi);
					if(dateMatch != null)
						formatString = "_formatDateTimeReally";

					var widthMatch = key.match(/ID/gi);
					if(widthMatch != null)
						colWidth = '6%';

					var colValue = key;
					if(colValue == "STATUS")
						colValue= "StatusString";
					this._column_defs.push({field: colValue,  name: colAttrNameArray[key],   width: colWidth,  compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, formatString)});

					this._initial_view_cols[indeces++] = indeces+2;
				}

			} else
			{

				this._column_defs = [
				 {field: 'key',			name: "",							 	width: '10%',	compare: dojo.hitch(this, "_sortDefault"), showInTooltip: false}
				,{field: 'id', 			name: 'id',								width: '10%',	compare: dojo.hitch(this, "_sortNumber")}
				,{field: 'type', 		name: "Object Type",					width: '10%',	compare: dojo.hitch(this, "_sortString"), showInTooltip: false}
				,{field: 'STATUSDATE',  name: this._uiStringTable.StatusDate,   width: '20%',  compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")}		
				,{field: 'DESCRIPTION', name: this._uiStringTable.Description, 	width: '40%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'REQUESTEDBY',	name: this._uiStringTable.RequestedBy, 	width: '15%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'REQUESTEDFOR',name: this._uiStringTable.RequestedFor,	width: '15%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'StatusString',name: this._uiStringTable.Status,		width: '15%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'PMSCCRID',    name: this._uiStringTable.CartID,	    width: '10%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe")}
			   ];

			   this._initial_view_cols = [4, 7, 8,  3, 6];	// indeces into _column_defs
			   this._initial_sort_index = 3;	 	// change date (column index, not field index)
			 
			}

			
		this._data_key_field = 0;
		this._initial_sort_asc = false;		// descending
		
		// query parameters
		this._queryErrorMessage = "CTJZH2313E";


	},


	ajaxQueryData: function()
	{
		var params = [];
		params._fd = this._fd;  //filtering domain
		params.os = this._os;   //OS name
		params.sr_object = this._ticket_object;  //Main object
		
		params._maxItems=500;  
		var amt = parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty("MaxRequestsPodRecords"),10);
		if (!isNaN(amt) && amt > 0) {
         params._maxItems=amt;  
		}
		params._orderbydesc="changedate";	

		return ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getServiceRequests(params);
	},
	
	// load handler for the data query
	_processQueryResult: function(response)
	{
		if(!dojo.isArray(response.Requests)) {
			response.requests = [];
		}
		var requests = response.Requests;
		this._loadGrid(response.Requests);
		return this.inherited(arguments);
	},

	_dummy:null
});

//Summary:
//TODO: write this
dojo.declare(
"ibm.tivoli.simplesrm.srm.dijit.MyApprovalsGrid",
[dijit._Widget, ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid, ibm.tivoli.simplesrm.srm.dijit.ShowRequestDetails],
{		

// constructor defines "static" properties for this class, and
// declares "instance" properties for this class
	approveBtn: null,
	rejectBtn: null,
	
 	_processErrorMessage: null,
	
constructor: function()
{
	console.log("MyApprovalsGrid.ctor()");
	
//	this._hoverer = new  ibm.tivoli.simplesrm.srm.dojo.Hoverer();
//	this._conn_onHover = dojo.connect(this._hoverer, "OnHover", this, "_showGridTooltip");
	
		// the column definitions
		// the order they are listed here is the order they will be displayed in the tooltip
	this._column_defs = [
		 {field: 'key',			name: "",							 	width: '10%',	compare: dojo.hitch(this, "_sortDefault"), showInTooltip: false}
		,{field: 'id', 			name: 'id',								width: '10%',	compare: dojo.hitch(this, "_sortNumber")}
		,{field: 'type', 		name: "Object Type",					width: '10%',	compare: dojo.hitch(this, "_sortString"), showInTooltip: false}
		,{field: 'DESCRIPTION', name: this._uiStringTable.Description, 	width: '40%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
		,{field: 'StatusString',name: this._uiStringTable.Status,		width: '15%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe")}
		,{field: 'STATUSDATE',	name: this._uiStringTable.DueDate, 		width: '20%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDate")}
		,{field: 'CREATIONDATE',name: this._uiStringTable.CreatedDate,  width: '20%',  compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")} /* datetime */
		,{field: 'TARGETSTART', name: this._uiStringTable.StartDate,    width: '20%',  compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDate")} /* date */
	];
	this._data_key_field = 0;

	this._initial_view_cols = [3, 5, 6];	// indeces into _column_defs
	this._initial_sort_index = 5;	 	// change date (column index, not field index)
	this._initial_sort_asc = true;		// accending
	
	this._queryErrorMessage = "CTJZH2313E";

	this._isApproval = "true";
	
	this._processErrorMessage = "CTJZH2331E";
},
buildRendering: function()
{
	this.inherited(arguments);
	
    this.approveBtn = new ibm.tivoli.simplesrm.srm.dijit.ToolbarButton(
    		{id: this.id+"_approve_btn", disabled:true, iconClass:"approve_btn", tooltip:this._uiStringTable.ApproveSelectedRequest.htmlencode(),
    			onClick: dojo.hitch( this, "_approveRequest" )
    	} );
    this.approveBtn._scroll = false;
    this.toolBar.getToolbar().addChild(this.approveBtn);
    
    this.rejectBtn = new ibm.tivoli.simplesrm.srm.dijit.ToolbarButton(
    		{id: this.id+"_reject_btn", disabled:true, iconClass:"reject_btn", tooltip:this._uiStringTable.RejectSelectedRequest.htmlencode(),
    			onClick: dojo.hitch( this, "_rejectRequest" )
    	} );
    this.rejectBtn._scroll = false;
    this.toolBar.getToolbar().addChild(this.rejectBtn);
},
	
postMixInProperties: function() {
	this.setApprContext(true);
	this.inherited(arguments);
},

ajaxQueryData: function()
{
	var statusMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('SRSTATUS');
	var params = {
		_fd: "PMZHBT_SRAPPRLIST"
	};
	var df = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getServiceRequests(params);

	return df;
},

// load handler for the data query
_processQueryResult: function(response)
{
	console.log("MyApprovalGrid._processQueryResult()");
	if(!dojo.isArray(response.Requests)) {
		response.requests = [];
	}
	var requests = response.Requests;
	this._loadGrid(requests);
	return this.inherited(arguments);
},

_processReq: function(decision)
{
	var tid = this._getSelectedTid();
	
	if (tid){
		this.showProgressSpinner();
		
		console.log("In _processReq: tid is : " + tid + " ,decision is : " + decision);
		
		var emptyStr = "";
		
		var bSuccess = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().approveRequest(tid, emptyStr, decision);

		if(!bSuccess) {
			bSuccess.addCallbacks(dojo.hitch(this, "_processQueryResult"), dojo.hitch(this, "_onProcessError"));
			bSuccess.addBoth(dojo.hitch(this, "_cleanupQuery"));
		}else{
			this._cleanupQuery();
			this.refresh();
		}
		
		return bSuccess;
	}
},
_getSelectedTid: function()
{
	var tid = null;
	
	if(this._activeRow >= 0) {	
		var selected_record = this.simpleGrid.getItem(this._activeRow);
		selected_record = this._gridItemToObject(selected_record);
		tid = selected_record.TICKETID;
		var tuid = selected_record.TICKETUID;
		console.log("_getSelectedTid: tid is : " + tid);
		console.log("_getSelectedTid: tuid is : " + tuid);
	}
	
	return tid;		
},
_approveRequest: function()
{
	this._processReq(true);	
},
_rejectRequest: function()
{
	this._processReq(false);
},

_dummy:null
});

});

},
'dijit/form/TextBox':function(){
require({cache:{
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"}});
define("dijit/form/TextBox", [
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/sniff", // has("ie") has("mozilla")
	"dojo/_base/window", // win.doc.selection.createRange
	"./_FormValueWidget",
	"./_TextBoxMixin",
	"dojo/text!./templates/TextBox.html",
	".."	// to export dijit._setSelectionRange, remove in 2.0
], function(declare, domConstruct, domStyle, kernel, lang, has, win,
			_FormValueWidget, _TextBoxMixin, template, dijit){

/*=====
	var _FormValueWidget = dijit.form._FormValueWidget;
	var _TextBoxMixin = dijit.form._TextBoxMixin;
=====*/

	// module:
	//		dijit/form/TextBox
	// summary:
	//		A base class for textbox form inputs

	var TextBox = declare(/*====="dijit.form.TextBox", =====*/ [_FormValueWidget, _TextBoxMixin], {
		// summary:
		//		A base class for textbox form inputs

		templateString: template,
		_singleNodeTemplate: '<input class="dijit dijitReset dijitLeft dijitInputField" data-dojo-attach-point="textbox,focusNode" autocomplete="off" type="${type}" ${!nameAttrSetting} />',

		_buttonInputDisabled: has("ie") ? "disabled" : "", // allows IE to disallow focus, but Firefox cannot be disabled for mousedown events

		baseClass: "dijitTextBox",

		postMixInProperties: function(){
			var type = this.type.toLowerCase();
			if(this.templateString && this.templateString.toLowerCase() == "input" || ((type == "hidden" || type == "file") && this.templateString == this.constructor.prototype.templateString)){
				this.templateString = this._singleNodeTemplate;
			}
			this.inherited(arguments);
		},

		_onInput: function(e){
			this.inherited(arguments);
			if(this.intermediateChanges){ // _TextBoxMixin uses onInput
				var _this = this;
				// the setTimeout allows the key to post to the widget input box
				setTimeout(function(){ _this._handleOnChange(_this.get('value'), false); }, 0);
			}
		},

		_setPlaceHolderAttr: function(v){
			this._set("placeHolder", v);
			if(!this._phspan){
				this._attachPoints.push('_phspan');
				// dijitInputField class gives placeHolder same padding as the input field
				// parent node already has dijitInputField class but it doesn't affect this <span>
				// since it's position: absolute.
				this._phspan = domConstruct.create('span',{className:'dijitPlaceHolder dijitInputField'},this.textbox,'after');
			}
			this._phspan.innerHTML="";
			this._phspan.appendChild(document.createTextNode(v));
			this._updatePlaceHolder();
		},

		_updatePlaceHolder: function(){
			if(this._phspan){
				this._phspan.style.display=(this.placeHolder&&!this.focused&&!this.textbox.value)?"":"none";
			}
		},

		_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		getDisplayedValue: function(){
			// summary:
			//		Deprecated.  Use get('displayedValue') instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::getDisplayedValue() is deprecated. Use set('displayedValue') instead.", "", "2.0");
			return this.get('displayedValue');
		},

		setDisplayedValue: function(/*String*/ value){
			// summary:
			//		Deprecated.  Use set('displayedValue', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated(this.declaredClass+"::setDisplayedValue() is deprecated. Use set('displayedValue', ...) instead.", "", "2.0");
			this.set('displayedValue', value);
		},

		_onBlur: function(e){
			if(this.disabled){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		},

		_onFocus: function(/*String*/ by){
			if(this.disabled || this.readOnly){ return; }
			this.inherited(arguments);
			this._updatePlaceHolder();
		}
	});

	if(has("ie")){
		TextBox = declare(/*===== "dijit.form.TextBox.IEMixin", =====*/ TextBox, {
			declaredClass: "dijit.form.TextBox",	// for user code referencing declaredClass

			_isTextSelected: function(){
				var range = win.doc.selection.createRange();
				var parent = range.parentElement();
				return parent == this.textbox && range.text.length == 0;
			},

			postCreate: function(){
				this.inherited(arguments);
				// IE INPUT tag fontFamily has to be set directly using STYLE
				// the setTimeout gives IE a chance to render the TextBox and to deal with font inheritance
				setTimeout(lang.hitch(this, function(){
					try{
						var s = domStyle.getComputedStyle(this.domNode); // can throw an exception if widget is immediately destroyed
						if(s){
							var ff = s.fontFamily;
							if(ff){
								var inputs = this.domNode.getElementsByTagName("INPUT");
								if(inputs){
									for(var i=0; i < inputs.length; i++){
										inputs[i].style.fontFamily = ff;
									}
								}
							}
						}
					}catch(e){/*when used in a Dialog, and this is called before the dialog is
						shown, s.fontFamily would trigger "Invalid Argument" error.*/}
				}), 0);
			}
		});

		// Overrides definition of _setSelectionRange from _TextBoxMixin (TODO: move to _TextBoxMixin.js?)
		dijit._setSelectionRange = _TextBoxMixin._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
			if(element.createTextRange){
				var r = element.createTextRange();
				r.collapse(true);
				r.moveStart("character", -99999); // move to 0
				r.moveStart("character", start); // delta from 0 is the correct position
				r.moveEnd("character", stop-start);
				r.select();
			}
		}
	}else if(has("mozilla")){
		TextBox = declare(/*===== "dijit.form.TextBox.MozMixin", =====*/TextBox, {
			declaredClass: "dijit.form.TextBox",	// for user code referencing declaredClass

			_onBlur: function(e){
				this.inherited(arguments);
				if(this.selectOnClick){
						// clear selection so that the next mouse click doesn't reselect
					this.textbox.selectionStart = this.textbox.selectionEnd = undefined;
				}
			}
		});
	}else{
		TextBox.prototype.declaredClass = "dijit.form.TextBox";
	}
	lang.setObject("dijit.form.TextBox", TextBox);	// don't do direct assignment, it confuses API doc parser

	return TextBox;
});

},
'ibm/tivoli/tip/dijit/TextInputBox':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Templated,ibm/tivoli/tip/dijit/Widget,ibm/tivoli/tip/dijit/Caret"], function(dijit,dojo,dojox){
dojo.provide("ibm.tivoli.tip.dijit.TextInputBox"); 

dojo.require("dijit._Templated");
dojo.require("ibm.tivoli.tip.dijit.Widget");
dojo.require("ibm.tivoli.tip.dijit.Caret");

/** 
 * A text input box widget.
 * 
 * Such widget displays a text input box which implements
 * the user-provided validations and adapts the look&feel reflecting
 * to its current status.
 * The widget accepts the following parameters:
 * 
 *  - value: the initial value the widget must show when created.
 *  - constraints: an object containing the validation constraints.
 *    The same constraints can be provided as single properties.
 *    A constraint provided as a single property overrides the 
 *    corresponding constraint provided in the constraints object.
 *    The possible constraints are:
 *      
 *      - minlen: (Number) the minimum number of required characters.
 *      - maxlen: (Number) the maximum number of required characters.   
 *      - regexp: (RegExp) a regular expression (object) which must
 *        be matched.
 *      - regexpMessage: (String) the message to show if the regular 
 *        expression has not been matched.
 *      - required: (Boolean) if true the value cannot be empty ("").
 *      - validator: (Function) an external validator function to be 
 *        invoked. The validator accepts the value has parameters and
 *        returns a status object which will affect the widget status.
 *        If null is returned, the validation goes ahead.  
 * 
 *  -  minLength: (String) the same of constraints.minlen.
 *  -  maxLength: (String) the same of constraints.maxlen.
 *  -  regExp: (String) the same of constraints.regexp.
 *  -  regExpMessage: (String) the same of constraints.regexpMessage.
 *  -  required: (String) the same of constraints.required.
 * 
 * Example of a declaration:
 * 
 *       <div 
 *          dojoType="ibm.tivoli.tip.dijit.TextInputBox" 
 *          constraints="{required: true, minlen:5,regexp: /^[0-9]+$/g}"
 *          maxLength="10"/>
 *
 * @author: Marco Lerro (marco.lerro@it.ibm.com)    
 */
dojo.declare(
    "ibm.tivoli.tip.dijit.TextInputBox",
    [ibm.tivoli.tip.dijit.Widget, dijit._Templated],
    {
        /** the initial value */
        value: "",
        /** the constraints */
        constraints: {},
        /** the minlen */
        minLength: "",
        /** the maxlen */
        maxLength: "",
        /** the regular expression */  
        regExp: "",
        /** the regular expression message */
        regExpMessage: "",
        /** required */
        required: "",
        /** the text box type ("text" or "password") */
        type: "text",
        
        /** the size of the input field */
        size: "16",
        
        /** the field name */
        name: '',
        
        /** the widget template path */
        templateString:"<span class=\"tip-tib-normal\" dojoAttachEvent=\"onclick:_onClick\">\n<table border=\"0\" cellspacing=\"0\" cellpadding=\"0\" style=\"\">\n\t<tr>\n\t\t<td class=\"tf-l\"><div class=\"tf-err\"></div></td>\n\t\t<td class=\"tf-m\" valign=\"middle\"><input class=\"tf\" type=\"${type}\"\n\t\t\tvalue=\"\" size=\"${size}\" name=\"${name}\" dojoAttachPoint=\"_inputNode, _focusNode\"\n\t\t\tdojoAttachEvent=\"onkeyup:_onKeyUp, onkeypress:_onKeyPress, onchange:_onChange\" /></td>\n\t\t<td class=\"tf-r\">\n\t\t\t<img src=\"images/trans.gif\" width=\"16\" alt=\"\" height=\"4\" />\n\t\t\t<span dojoattachpoint=\"altText\" class=\"alternativeText\"></span> \n\t\t</td>\n\t</tr>\n</table>\n<span style=\"clear: left;height:0;\"></span>\n</span>\n",
        
        /** input box DOM node */
        _inputNode: null,

        /** the widget value */
        _value: null,
        /** the caret */
        _caret: null,

        /**
         * Widget constructor.
         */
        constructor: function()
        {
            /** the widget's constraints */
            this.constraints = {};

            // set the widget constants
            // default icon url
            this.constants.DEFAULT_ICON = dojo.moduleUrl("ibm.tivoli.tip.dijit", "templates/images/transparent.gif");                
            // error icon url
            this.constants.ERROR_ICON = dojo.moduleUrl("ibm.tivoli.tip.dijit", "templates/images/error.gif");
        },
        
        /**
         * Post mixin properties.
         * Validates attributes.
         */
        postMixInProperties: function()
        {
            // call the superclass's method
            this.inherited(arguments);
            
            // validate attributes
            if ( this.type !== "text" && this.type !== "password" ) {
                this.type = "text";
            }  
            
            // if a name was provided in the markup, use it.
            // if not, use the id
            if( 0 == this.name.length ) {
            	this.name = this.id;   
            }
        },
        
        /**
         * Sets the initial value: this triggers the first validation.
         * The initial value can be externally provided by setting the 
         * value property.  
         */
        startup: function() 
        {
            // call the superclass's method
            this.inherited(arguments);
           
            // get parameters
            // get the required
            if ( this.required !== "" ) {
                this.constraints.required = this.required === "true" ? true : false;
            }
            // get the minlen
            if ( this.minLength !== "" ) {
                this.constraints.minlen = parseInt(this.minLength, 10);
            }
            // get the maxlen
            if ( this.maxLength !== "" ) {
                this.constraints.maxlen = parseInt(this.maxLength, 10);
            }          
            // get the regular expression  
            if ( this.regExp !== "" ) {
                this.constraints.regexp = new RegExp(this.regExp);
                console.debug("TestInputBox.startup: Regular expression source =" +this.constraints.regexp.source);
            }
            // get the regular expression message  
            if ( this.regExpMessage !== "" ) {
                this.constraints.regexpMessage = this.regExpMessage;
            }
            // set the default regexp message if no message has been provided
            if ( ! this.constraints.regexpMessage || this.constraints.regexpMessage === "" ) {
                this.constraints.regexpMessage = this._resources.TEXT_INVALID_CHARS;
            }
            
       
            if( this.constraints.size !== undefined ){
              this.constraints.size = this.size;
              this._inputNode.size = this.size;
            }
            
            // create the caret
            this._caret = new ibm.tivoli.tip.dijit.Caret(this._inputNode);
            
            // get the value
            this.setValue( this.value || "" );
            
            if(this.isRequired()){
            	console.log("required: " + this.id);
            	this.altText.innerHTML = "*";
            }
        },
        
        /**        
         * Returns an object which represent the widget value.
         */
        getValue: function()
        {
            // return the value
            return this._value;
        },
        
        /**        
         * Sets the widget value.
         */
        setValue: function(value)
        {
            // store the internal value
            this._value = value;
            // update the input box
            this._inputNode.value = value;
            // validate
            this._validate();
        },
        
        /**
         * Returns true if the widget's value is not set.
         */
        isEmpty: function()
        {
            return ( this._value === "" );
        },

        /**
         * Enables the widget for editing. 
         */
        setDisabled: function(isDisabled)
        {
            if ( isDisabled != this.isDisabled() ) {
                // update the enablement status
                this.inherited(arguments);
                // update the widget
                this._updateWidget();
            }
        },
        
        /**
         * Sets the widget status: the status is an object with the
         * following two properties:
         * 
         *  - state: the state of the widget (e.g. constants.ERROR)
         *  - message: the message related to the current state.
         */
        setStatus: function(status)
        {
            // update the status
            this.inherited(arguments);
            // update the widget
            this._updateWidget();
        },
        
        /**
         * Sets the widget required constraint.
         * 
         *  @param required:
         *      true if the value is required, false otherwise.
         */
        setRequired: function(required)
        {
            if ( this.constraints.required != required ) {
                // store the requried constraint
                this.constraints.required = required;
                // trigger the validation
                this._validate();
            }
        },
        
        /**
         * Returns true if the widget's value is required.
         */
        isRequired: function()
        {
            return this.constraints.required;
        },
        
        /**
         * Asks the widget to revalidate its value and to set its status accordingly.
         */
        validate: function() 
        {
        	this._validate();
        },

        /**
         * Gives the focus to the widget.
         */
        setFocus: function()
        {
            this._inputNode.focus();
        },
        
        /**
         * Returns the caret position.
         */
        getCaretPosition: function()
		{
			return this._caret.getPosition();
		},
		
		/**
         * Sets the caret position.
         */
		setCaretPosition: function(index)
		{
		    this._caret.setPosition(index);
		},
		        
        /**
         * Handles the onkeypress event. Prevents container to catch
         * the key pression. 
         */
        _onKeyPress: function(e)
        {
            // let the enter and tab to be propagated
            if ( e.keyCode !== 13 && e.keyCode !== 9 &&
            		e.keyCode!=dojo.keys.F1 && e.keyCode!=dojo.keys.ESCAPE) {
                // stop event propagation
                e.stopPropagation();
            }
        },
        
        /**
         * Handles the onkeyup event. The internal value is updated and
         * the validation is triggered. 
         */
        _onKeyUp: function(e)
        {
            // get the value from the input text box
            this._value = this._inputNode.value;
            // trigger the validation
            this._validate();
            // stop event propagation
            e.stopPropagation();
        },
        
        /**
         * Handles the onchange event.  
         */
        _onChange: function()
        {
            // notify the change
            this.onValueChanged(this.getValue());
        },
         
        /**
         * Handles the onclick event.  
         */        
        _onClick: function(e)
        {
			if ( e.target.tagName === "SPAN" ) {
				this.setCaretPosition(this._inputNode.value.length); 	
			}
        },
        
        /**
         * Validates the current value applying all the user-provided
         * constraints. The status is then updated.
         */
        _validate: function()
        {
            // check if we've some constraints 
            if ( this.constraints !== {} ) {
                // set the widget in error, eventually reset ahead in case of no errors  
                this._isInError = true;
                
                // check if the field is required
                if( this.constraints.required && this._value === "" ) {
                    this.setStatus({ 
                        state: this.constants.REQUIRED, 
                        message: ""  
                    });
                    return;
                }
                                
                // check the min length (if any)
                if ( this.constraints.minlen !== undefined ) {
                    if ( this._value.length < this.constraints.minlen ) {
                        this.setStatus({ 
                            state: this.constants.ERROR, 
                            message: dojo.string.substitute(this._resources.TEXT_MIN_LIMIT, {minlen: this.constraints.minlen})
                        });
                        return;
                    }
                }
                
                // check the max length (if any)
                if ( this.constraints.maxlen !== undefined ) {
                    if ( this._value.length > this.constraints.maxlen ) {
                        this.setStatus({ 
                            state: this.constants.ERROR,
                            message: dojo.string.substitute(this._resources.TEXT_MAX_LIMIT, {maxlen: this.constraints.maxlen})
                        });
                        return;
                    }
                }
                
                // match the regex (if any)
                if ( this.constraints.regexp !== undefined ) {
                    if ( ! this._value.match(this.constraints.regexp) ) {   
                        this.setStatus({ 
                            state: this.constants.ERROR,
                            message: this.constraints.regexpMessage  
                        });
                        return;
                    }
                }
                
                // call the external validator (if any)
                if ( this.constraints.validator !== undefined ) {
                    var status = this.constraints.validator(this._value);
                    if ( status ) {
                        this.setStatus(status);
                        return;
                    }
                }  
            }
                        
            // if we've reached this point, no error is present
            this._isInError = false;
            this.setStatus({ 
                state: this.constants.DEFAULT, 
                message: ""  
            });
        },
        
        /**
         * Updates the widget look&feel depending on the widget' status.
         */
        _updateWidget: function()
        {
            this._inputNode.disabled = this.isDisabled();
            this._inputNode.size = this.size;
  
            if ( this.isDisabled() ) { 
                // the widget is disabled
                this.domNode.className = "tip-tib-disabled";
            }
            else {  
                // the widget is enabled
                var status = this.getStatus();
                
                if( status.state === this.constants.ERROR ) {
                    this.domNode.className = "tip-tib-error";
                }
                else if( this.isRequired() ) {
                    this.domNode.className = "tip-tib-required";                    
                }
                else {
                   this.domNode.className = "tip-tib-normal";      
                }
            }
        }
    }
);


});

},
'dojox/grid/DataGrid':function(){
define("dojox/grid/DataGrid", [
	"../main",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/json",
	"dojo/_base/sniff",
	"dojo/_base/declare",
	"./_Grid",
	"./DataSelection",
	"dojo/_base/html"
], function(dojox, array, lang, json, has, declare, _Grid, DataSelection, html){

/*=====
declare("dojox.grid.__DataCellDef", dojox.grid.__CellDef, {
	constructor: function(){
		//	field: String?
		//		The attribute to read from the dojo.data item for the row.
		//  fields: String[]?
		//		An array of fields to grab the values of and pass as an array to the grid
		//	get: Function?
		//		function(rowIndex, item?){} rowIndex is of type Integer, item is of type
		//		Object.  This function will be called when a cell requests data.  Returns
		//		the unformatted data for the cell.
	}
});
=====*/

/*=====
declare("dojox.grid.__DataViewDef", dojox.grid.__ViewDef, {
	constructor: function(){
		//	cells: dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]?
		//		The structure of the cells within this grid.
		//	defaultCell: dojox.grid.__DataCellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
	}
});
=====*/

var DataGrid = declare("dojox.grid.DataGrid", _Grid, {
	store: null,
	query: null,
	queryOptions: null,
	fetchText: '...',
	sortFields: null,
	
	// updateDelay: int
	//		Time, in milliseconds, to delay updates automatically so that multiple
	//		calls to onSet/onNew/onDelete don't keep rerendering the grid.  Set
	//		to 0 to immediately cause updates.  A higher value will result in
	//		better performance at the expense of responsiveness of the grid.
	updateDelay: 1,

/*=====
	// structure: dojox.grid.__DataViewDef|dojox.grid.__DataViewDef[]|dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]
	//		View layout defintion.
	structure: '',
=====*/

	// You can specify items instead of a query, if you like.  They do not need
	// to be loaded - but the must be items in the store
	items: null,
	
	_store_connects: null,
	_by_idty: null,
	_by_idx: null,
	_cache: null,
	_pages: null,
	_pending_requests: null,
	_bop: -1,
	_eop: -1,
	_requests: 0,
	rowCount: 0,

	_isLoaded: false,
	_isLoading: false,
	
	//keepSelection: Boolean
	//		Whether keep selection after sort, filter etc.
	keepSelection: false,	
	
	postCreate: function(){
		this._pages = [];
		this._store_connects = [];
		this._by_idty = {};
		this._by_idx = [];
		this._cache = [];
		this._pending_requests = {};

		this._setStore(this.store);
		this.inherited(arguments);
	},
	
	destroy: function(){
		this.selection.destroy();
		this.inherited(arguments);
	},

	createSelection: function(){
		this.selection = new DataSelection(this);
	},

	get: function(inRowIndex, inItem){
		// summary: Default data getter.
		// description:
		//		Provides data to display in a grid cell. Called in grid cell context.
		//		So this.cell.index is the column index.
		// inRowIndex: Integer
		//		Row for which to provide data
		// returns:
		//		Data to display for a given grid cell.
		
		if(inItem && this.field == "_item" && !this.fields){
			return inItem;
		}else if(inItem && this.fields){
			var ret = [];
			var s = this.grid.store;
			array.forEach(this.fields, function(f){
				ret = ret.concat(s.getValues(inItem, f));
			});
			return ret;
		}else if(!inItem && typeof inRowIndex === "string"){
			return this.inherited(arguments);
		}
		return (!inItem ? this.defaultValue : (!this.field ? this.value : (this.field == "_item" ? inItem : this.grid.store.getValue(inItem, this.field))));
	},

	_checkUpdateStatus: function(){
		if(this.updateDelay > 0){
			var iStarted = false;
			if(this._endUpdateDelay){
				clearTimeout(this._endUpdateDelay);
				delete this._endUpdateDelay;
				iStarted = true;
			}
			if(!this.updating){
				this.beginUpdate();
				iStarted = true;
			}
			if(iStarted){
				var _this = this;
				this._endUpdateDelay = setTimeout(function(){
					delete _this._endUpdateDelay;
					_this.endUpdate();
				}, this.updateDelay);
			}
		}
	},
	
	_onSet: function(item, attribute, oldValue, newValue){
		this._checkUpdateStatus();
		var idx = this.getItemIndex(item);
		if(idx>-1){
			this.updateRow(idx);
		}
	},
	
	_createItem: function(item, index){
		var idty = this._hasIdentity ? this.store.getIdentity(item) : json.toJson(this.query) + ":idx:" + index + ":sort:" + json.toJson(this.getSortProps());
		var o = this._by_idty[idty] = { idty: idty, item: item };
		return o;
	},

	_addItem: function(item, index, noUpdate){
		this._by_idx[index] = this._createItem(item, index);
		if(!noUpdate){
			this.updateRow(index);
		}
	},

	_onNew: function(item, parentInfo){
		this._checkUpdateStatus();
		var rowCount = this.get('rowCount');
		this._addingItem = true;
		this.updateRowCount(rowCount+1);
		this._addingItem = false;
		this._addItem(item, rowCount);
		this.showMessage();
	},

	_onDelete: function(item){
		this._checkUpdateStatus();
		var idx = this._getItemIndex(item, true);

		if(idx >= 0){
			// When a row is deleted, all rest rows are shifted down,
			// and migrate from page to page. If some page is not
			// loaded yet empty rows can migrate to initialized pages
			// without refreshing. It causes empty rows in some pages, see:
			// http://bugs.dojotoolkit.org/ticket/6818
			// this code fix this problem by reseting loaded page info
			this._pages = [];
			this._bop = -1;
			this._eop = -1;

			var o = this._by_idx[idx];
			this._by_idx.splice(idx, 1);
			delete this._by_idty[o.idty];
			this.updateRowCount(this.get('rowCount')-1);
			if(this.get('rowCount') === 0){
				this.showMessage(this.noDataMessage);
			}
		}
		if(this.selection.isSelected(idx)){
			this.selection.deselect(idx);
			this.selection.selected.splice(idx, 1);
		}
	},

	_onRevert: function(){
		this._refresh();
	},

	setStore: function(store, query, queryOptions){
		if(this._requestsPending(0)){
			return;
		}
		this._setQuery(query, queryOptions);
		this._setStore(store);
		this._refresh(true);
	},
	
	setQuery: function(query, queryOptions){
		if(this._requestsPending(0)){
			return;
		}
		this._setQuery(query, queryOptions);
		this._refresh(true);
	},
	
	setItems: function(items){
		this.items = items;
		this._setStore(this.store);
		this._refresh(true);
	},
	
	_setQuery: function(query, queryOptions){
		this.query = query;
		this.queryOptions = queryOptions || this.queryOptions;
	},

	_setStore: function(store){
		if(this.store && this._store_connects){
			array.forEach(this._store_connects, this.disconnect, this);
		}
		this.store = store;

		if(this.store){
			var f = this.store.getFeatures();
			var h = [];

			this._canEdit = !!f["dojo.data.api.Write"] && !!f["dojo.data.api.Identity"];
			this._hasIdentity = !!f["dojo.data.api.Identity"];

			if(!!f["dojo.data.api.Notification"] && !this.items){
				h.push(this.connect(this.store, "onSet", "_onSet"));
				h.push(this.connect(this.store, "onNew", "_onNew"));
				h.push(this.connect(this.store, "onDelete", "_onDelete"));
			}
			if(this._canEdit){
				h.push(this.connect(this.store, "revert", "_onRevert"));
			}

			this._store_connects = h;
		}
	},

	_onFetchBegin: function(size, req){
		if(!this.scroller){ return; }
		if(this.rowCount != size){
			if(req.isRender){
				this.scroller.init(size, this.keepRows, this.rowsPerPage);
				this.rowCount = size;
				this._setAutoHeightAttr(this.autoHeight, true);
				this._skipRowRenormalize = true;
				this.prerender();
				this._skipRowRenormalize = false;
			}else{
				this.updateRowCount(size);
			}
		}
		if(!size){
			this.views.render();
			this._resize();
			this.showMessage(this.noDataMessage);
			this.focus.initFocusView();
		}else{
			this.showMessage();
		}
	},

	_onFetchComplete: function(items, req){
		if(!this.scroller){ return; }
		if(items && items.length > 0){
			//console.log(items);
			array.forEach(items, function(item, idx){
				this._addItem(item, req.start+idx, true);
			}, this);
			this.updateRows(req.start, items.length);
			if(req.isRender){
				this.setScrollTop(0);
				this.postrender();
			}else if(this._lastScrollTop){
				this.setScrollTop(this._lastScrollTop);
			}
			if(has("ie")){
				html.setSelectable(this.domNode, this.selectable);
			}	
		}
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
		}
		this._pending_requests[req.start] = false;
	},

	_onFetchError: function(err, req){
		console.log(err);
		delete this._lastScrollTop;
		if(!this._isLoaded){
			this._isLoading = false;
			this._isLoaded = true;
			this.showMessage(this.errorMessage);
		}
		this._pending_requests[req.start] = false;
		this.onFetchError(err, req);
	},

	onFetchError: function(err, req){
	},

	_fetch: function(start, isRender){
		start = start || 0;
		if(this.store && !this._pending_requests[start]){
			if(!this._isLoaded && !this._isLoading){
				this._isLoading = true;
				this.showMessage(this.loadingMessage);
			}
			this._pending_requests[start] = true;
			//console.log("fetch: ", start);
			try{
				if(this.items){
					var items = this.items;
					var store = this.store;
					this.rowsPerPage = items.length;
					var req = {
						start: start,
						count: this.rowsPerPage,
						isRender: isRender
					};
					this._onFetchBegin(items.length, req);
					
					// Load them if we need to
					var waitCount = 0;
					array.forEach(items, function(i){
						if(!store.isItemLoaded(i)){ waitCount++; }
					});
					if(waitCount === 0){
						this._onFetchComplete(items, req);
					}else{
						var onItem = function(item){
							waitCount--;
							if(waitCount === 0){
								this._onFetchComplete(items, req);
							}
						};
						array.forEach(items, function(i){
							if(!store.isItemLoaded(i)){
								store.loadItem({item: i, onItem: onItem, scope: this});
							}
						}, this);
					}
				}else{
					this.store.fetch({
						start: start,
						count: this.rowsPerPage,
						query: this.query,
						sort: this.getSortProps(),
						queryOptions: this.queryOptions,
						isRender: isRender,
						onBegin: lang.hitch(this, "_onFetchBegin"),
						onComplete: lang.hitch(this, "_onFetchComplete"),
						onError: lang.hitch(this, "_onFetchError")
					});
				}
			}catch(e){
				this._onFetchError(e, {start: start, count: this.rowsPerPage});
			}
		}
	},

	_clearData: function(){
		this.updateRowCount(0);
		this._by_idty = {};
		this._by_idx = [];
		this._pages = [];
		this._bop = this._eop = -1;
		this._isLoaded = false;
		this._isLoading = false;
	},

	getItem: function(idx){
		var data = this._by_idx[idx];
		if(!data||(data&&!data.item)){
			this._preparePage(idx);
			return null;
		}
		return data.item;
	},

	getItemIndex: function(item){
		return this._getItemIndex(item, false);
	},
	
	_getItemIndex: function(item, isDeleted){
		if(!isDeleted && !this.store.isItem(item)){
			return -1;
		}

		var idty = this._hasIdentity ? this.store.getIdentity(item) : null;

		for(var i=0, l=this._by_idx.length; i<l; i++){
			var d = this._by_idx[i];
			if(d && ((idty && d.idty == idty) || (d.item === item))){
				return i;
			}
		}
		return -1;
	},

	filter: function(query, reRender){
		this.query = query;
		if(reRender){
			this._clearData();
		}
		this._fetch();
	},

	_getItemAttr: function(idx, attr){
		var item = this.getItem(idx);
		return (!item ? this.fetchText : this.store.getValue(item, attr));
	},

	// rendering
	_render: function(){
		if(this.domNode.parentNode){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this._fetch(0, true);
		}
	},

	// paging
	_requestsPending: function(inRowIndex){
		return this._pending_requests[inRowIndex];
	},

	_rowToPage: function(inRowIndex){
		return (this.rowsPerPage ? Math.floor(inRowIndex / this.rowsPerPage) : inRowIndex);
	},

	_pageToRow: function(inPageIndex){
		return (this.rowsPerPage ? this.rowsPerPage * inPageIndex : inPageIndex);
	},

	_preparePage: function(inRowIndex){
		if((inRowIndex < this._bop || inRowIndex >= this._eop) && !this._addingItem){
			var pageIndex = this._rowToPage(inRowIndex);
			this._needPage(pageIndex);
			this._bop = pageIndex * this.rowsPerPage;
			this._eop = this._bop + (this.rowsPerPage || this.get('rowCount'));
		}
	},

	_needPage: function(inPageIndex){
		if(!this._pages[inPageIndex]){
			this._pages[inPageIndex] = true;
			this._requestPage(inPageIndex);
		}
	},

	_requestPage: function(inPageIndex){
		var row = this._pageToRow(inPageIndex);
		var count = Math.min(this.rowsPerPage, this.get('rowCount') - row);
		if(count > 0){
			this._requests++;
			if(!this._requestsPending(row)){
				setTimeout(lang.hitch(this, "_fetch", row, false), 1);
				//this.requestRows(row, count);
			}
		}
	},

	getCellName: function(inCell){
		return inCell.field;
		//console.log(inCell);
	},

	_refresh: function(isRender){
		this._clearData();
		this._fetch(0, isRender);
	},

	sort: function(){
		this.edit.apply();
		this._lastScrollTop = this.scrollTop;
		this._refresh();
	},

	canSort: function(){
		return (!this._isLoading);
	},

	getSortProps: function(){
		var c = this.getCell(this.getSortIndex());
		if(!c){
			if(this.sortFields){
				return this.sortFields;
			}
			return null;
		}else{
			var desc = c["sortDesc"];
			var si = !(this.sortInfo>0);
			if(typeof desc == "undefined"){
				desc = si;
			}else{
				desc = si ? !desc : desc;
			}
			return [{ attribute: c.field, descending: desc }];
		}
	},

	styleRowState: function(inRow){
		// summary: Perform row styling
		if(this.store && this.store.getState){
			var states=this.store.getState(inRow.index), c='';
			for(var i=0, ss=["inflight", "error", "inserting"], s; s=ss[i]; i++){
				if(states[s]){
					c = ' dojoxGridRow-' + s;
					break;
				}
			}
			inRow.customClasses += c;
		}
	},

	onStyleRow: function(inRow){
		this.styleRowState(inRow);
		this.inherited(arguments);
	},

	// editing
	canEdit: function(inCell, inRowIndex){
		return this._canEdit;
	},

	_copyAttr: function(idx, attr){
		var row = {};
		var backstop = {};
		var src = this.getItem(idx);
		return this.store.getValue(src, attr);
	},

	doStartEdit: function(inCell, inRowIndex){
		if(!this._cache[inRowIndex]){
			this._cache[inRowIndex] = this._copyAttr(inRowIndex, inCell.field);
		}
		this.onStartEdit(inCell, inRowIndex);
	},

	doApplyCellEdit: function(inValue, inRowIndex, inAttrName){
		this.store.fetchItemByIdentity({
			identity: this._by_idx[inRowIndex].idty,
			onItem: lang.hitch(this, function(item){
				var oldValue = this.store.getValue(item, inAttrName);
				if(typeof oldValue == 'number'){
					inValue = isNaN(inValue) ? inValue : parseFloat(inValue);
				}else if(typeof oldValue == 'boolean'){
					inValue = inValue == 'true' ? true : inValue == 'false' ? false : inValue;
				}else if(oldValue instanceof Date){
					var asDate = new Date(inValue);
					inValue = isNaN(asDate.getTime()) ? inValue : asDate;
				}
				this.store.setValue(item, inAttrName, inValue);
				this.onApplyCellEdit(inValue, inRowIndex, inAttrName);
			})
		});
	},

	doCancelEdit: function(inRowIndex){
		var cache = this._cache[inRowIndex];
		if(cache){
			this.updateRow(inRowIndex);
			delete this._cache[inRowIndex];
		}
		this.onCancelEdit.apply(this, arguments);
	},

	doApplyEdit: function(inRowIndex, inDataAttr){
		var cache = this._cache[inRowIndex];
		/*if(cache){
			var data = this.getItem(inRowIndex);
			if(this.store.getValue(data, inDataAttr) != cache){
				this.update(cache, data, inRowIndex);
			}
			delete this._cache[inRowIndex];
		}*/
		this.onApplyEdit(inRowIndex);
	},

	removeSelectedRows: function(){
		// summary:
		//		Remove the selected rows from the grid.
		if(this._canEdit){
			this.edit.apply();
			var fx = lang.hitch(this, function(items){
				if(items.length){
					array.forEach(items, this.store.deleteItem, this.store);
					this.selection.clear();
				}
			});
			if(this.allItemsSelected){
				this.store.fetch({
							query: this.query,
							queryOptions: this.queryOptions,
							onComplete: fx});
			}else{
				fx(this.selection.getSelected());
			}
		}
	}
});

DataGrid.cell_markupFactory = function(cellFunc, node, cellDef){
	var field = lang.trim(html.attr(node, "field")||"");
	if(field){
		cellDef.field = field;
	}
	cellDef.field = cellDef.field||cellDef.name;
	var fields = lang.trim(html.attr(node, "fields")||"");
	if(fields){
		cellDef.fields = fields.split(",");
	}
	if(cellFunc){
		cellFunc(node, cellDef);
	}
};

DataGrid.markupFactory = function(props, node, ctor, cellFunc){
	return _Grid.markupFactory(props, node, ctor,
					lang.partial(DataGrid.cell_markupFactory, cellFunc));
};

return DataGrid;

});
},
'dijit/_TemplatedMixin':function(){
define("dijit/_TemplatedMixin", [
	"dojo/_base/lang", // lang.getObject
	"dojo/touch",
	"./_WidgetBase",
	"dojo/string", // string.substitute string.trim
	"dojo/cache",	// dojo.cache
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.destroy, domConstruct.toDom
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window" // win.doc
], function(lang, touch, _WidgetBase, string, cache, array, declare, domConstruct, has, unload, win) {

/*=====
	var _WidgetBase = dijit._WidgetBase;
=====*/

	// module:
	//		dijit/_TemplatedMixin
	// summary:
	//		Mixin for widgets that are instantiated from a template

	var _TemplatedMixin = declare("dijit._TemplatedMixin", null, {
		// summary:
		//		Mixin for widgets that are instantiated from a template

		// templateString: [protected] String
		//		A string that represents the widget template.
		//		Use in conjunction with dojo.cache() to load from a file.
		templateString: null,

		// templatePath: [protected deprecated] String
		//		Path to template (HTML file) for this widget relative to dojo.baseUrl.
		//		Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
		templatePath: null,

		// skipNodeCache: [protected] Boolean
		//		If using a cached widget template nodes poses issues for a
		//		particular widget class, it can set this property to ensure
		//		that its template is always re-built from a string
		_skipNodeCache: false,

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

/*=====
		// _attachPoints: [private] String[]
		//		List of widget attribute names associated with data-dojo-attach-point=... in the
		//		template, ex: ["containerNode", "labelNode"]
 		_attachPoints: [],
 =====*/

/*=====
		// _attachEvents: [private] Handle[]
		//		List of connections associated with data-dojo-attach-event=... in the
		//		template
 		_attachEvents: [],
 =====*/

		constructor: function(){
			this._attachPoints = [];
			this._attachEvents = [];
		},

		_stringRepl: function(tmpl){
			// summary:
			//		Does substitution of ${foo} type properties in template string
			// tags:
			//		private
			var className = this.declaredClass, _this = this;
			// Cache contains a string because we need to do property replacement
			// do the property replacement
			return string.substitute(tmpl, this, function(value, key){
				if(key.charAt(0) == '!'){ value = lang.getObject(key.substr(1), false, _this); }
				if(typeof value == "undefined"){ throw new Error(className+" template:"+key); } // a debugging aide
				if(value == null){ return ""; }

				// Substitution keys beginning with ! will skip the transform step,
				// in case a user wishes to insert unescaped markup, e.g. ${!foo}
				return key.charAt(0) == "!" ? value :
					// Safer substitution, see heading "Attribute values" in
					// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
					value.toString().replace(/"/g,"&quot;"); //TODO: add &amp? use encodeXML method?
			}, this);
		},

		buildRendering: function(){
			// summary:
			//		Construct the UI for this widget from a template, setting this.domNode.
			// tags:
			//		protected

			if(!this.templateString){
				this.templateString = cache(this.templatePath, {sanitize: true});
			}

			// Lookup cached version of template, and download to cache if it
			// isn't there already.  Returns either a DomNode or a string, depending on
			// whether or not the template contains ${foo} replacement parameters.
			var cached = _TemplatedMixin.getCachedTemplate(this.templateString, this._skipNodeCache);

			var node;
			if(lang.isString(cached)){
				node = domConstruct.toDom(this._stringRepl(cached));
				if(node.nodeType != 1){
					// Flag common problems such as templates with multiple top level nodes (nodeType == 11)
					throw new Error("Invalid template: " + cached);
				}
			}else{
				// if it's a node, all we have to do is clone it
				node = cached.cloneNode(true);
			}

			this.domNode = node;

			// Call down to _Widget.buildRendering() to get base classes assigned
			// TODO: change the baseClass assignment to _setBaseClassAttr
			this.inherited(arguments);

			// recurse through the node, looking for, and attaching to, our
			// attachment points and events, which should be defined on the template node.
			this._attachTemplateNodes(node, function(n,p){ return n.getAttribute(p); });

			this._beforeFillContent();		// hook for _WidgetsInTemplateMixin

			this._fillContent(this.srcNodeRef);
		},

		_beforeFillContent: function(){
		},

		_fillContent: function(/*DomNode*/ source){
			// summary:
			//		Relocate source contents to templated container node.
			//		this.containerNode must be able to receive children, or exceptions will be thrown.
			// tags:
			//		protected
			var dest = this.containerNode;
			if(source && dest){
				while(source.hasChildNodes()){
					dest.appendChild(source.firstChild);
				}
			}
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){
			// summary:
			//		Iterate through the template and attach functions and nodes accordingly.
			//		Alternately, if rootNode is an array of widgets, then will process data-dojo-attach-point
			//		etc. for those widgets.
			// description:
			//		Map widget properties and functions to the handlers specified in
			//		the dom node and it's descendants. This function iterates over all
			//		nodes and looks for these properties:
			//			* dojoAttachPoint/data-dojo-attach-point
			//			* dojoAttachEvent/data-dojo-attach-event
			// rootNode: DomNode|Widget[]
			//		the node to search for properties. All children will be searched.
			// getAttrFunc: Function
			//		a function which will be used to obtain property for a given
			//		DomNode/Widget
			// tags:
			//		private

			var nodes = lang.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = lang.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];
				if(this.widgetsInTemplate && (getAttrFunc(baseNode, "dojoType") || getAttrFunc(baseNode, "data-dojo-type"))){
					continue;
				}
				// Process data-dojo-attach-point
				var attachPoint = getAttrFunc(baseNode, "dojoAttachPoint") || getAttrFunc(baseNode, "data-dojo-attach-point");
				if(attachPoint){
					var point, points = attachPoint.split(/\s*,\s*/);
					while((point = points.shift())){
						if(lang.isArray(this[point])){
							this[point].push(baseNode);
						}else{
							this[point]=baseNode;
						}
						this._attachPoints.push(point);
					}
				}

				// Process data-dojo-attach-event
				var attachEvent = getAttrFunc(baseNode, "dojoAttachEvent") || getAttrFunc(baseNode, "data-dojo-attach-event");
				if(attachEvent){
					// NOTE: we want to support attributes that have the form
					// "domEvent: nativeEvent; ..."
					var event, events = attachEvent.split(/\s*,\s*/);
					var trim = lang.trim;
					while((event = events.shift())){
						if(event){
							var thisFunc = null;
							if(event.indexOf(":") != -1){
								// oh, if only JS had tuple assignment
								var funcNameArr = event.split(":");
								event = trim(funcNameArr[0]);
								thisFunc = trim(funcNameArr[1]);
							}else{
								event = trim(event);
							}
							if(!thisFunc){
								thisFunc = event;
							}
							// Map "press", "move" and "release" to keys.touch, keys.move, keys.release
							this._attachEvents.push(this.connect(baseNode, touch[event] || event, thisFunc));
						}
					}
				}
			}
		},

		destroyRendering: function(){
			// Delete all attach points to prevent IE6 memory leaks.
			array.forEach(this._attachPoints, function(point){
				delete this[point];
			}, this);
			this._attachPoints = [];

			// And same for event handlers
			array.forEach(this._attachEvents, this.disconnect, this);
			this._attachEvents = [];

			this.inherited(arguments);
		}
	});

	// key is templateString; object is either string or DOM tree
	_TemplatedMixin._templateCache = {};

	_TemplatedMixin.getCachedTemplate = function(templateString, alwaysUseString){
		// summary:
		//		Static method to get a template based on the templatePath or
		//		templateString key
		// templateString: String
		//		The template
		// alwaysUseString: Boolean
		//		Don't cache the DOM tree for this template, even if it doesn't have any variables
		// returns: Mixed
		//		Either string (if there are ${} variables that need to be replaced) or just
		//		a DOM tree (if the node can be cloned directly)

		// is it already cached?
		var tmplts = _TemplatedMixin._templateCache;
		var key = templateString;
		var cached = tmplts[key];
		if(cached){
			try{
				// if the cached value is an innerHTML string (no ownerDocument) or a DOM tree created within the current document, then use the current cached value
				if(!cached.ownerDocument || cached.ownerDocument == win.doc){
					// string or node of the same document
					return cached;
				}
			}catch(e){ /* squelch */ } // IE can throw an exception if cached.ownerDocument was reloaded
			domConstruct.destroy(cached);
		}

		templateString = string.trim(templateString);

		if(alwaysUseString || templateString.match(/\$\{([^\}]+)\}/g)){
			// there are variables in the template so all we can do is cache the string
			return (tmplts[key] = templateString); //String
		}else{
			// there are no variables in the template so we can cache the DOM tree
			var node = domConstruct.toDom(templateString);
			if(node.nodeType != 1){
				throw new Error("Invalid template: " + templateString);
			}
			return (tmplts[key] = node); //Node
		}
	};

	if(has("ie")){
		unload.addOnWindowUnload(function(){
			var cache = _TemplatedMixin._templateCache;
			for(var key in cache){
				var value = cache[key];
				if(typeof value == "object"){ // value is either a string or a DOM node template
					domConstruct.destroy(value);
				}
				delete cache[key];
			}
		});
	}

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	lang.extend(_WidgetBase,{
		dojoAttachEvent: "",
		dojoAttachPoint: ""
	});

	return _TemplatedMixin;
});

},
'ibm/tivoli/simplesrm/srm/dijit/MyRecordsGrid':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dojo/parser,dijit/form/Button,dijit/form/CheckBox,dojox/grid/DataGrid,dojo/date/locale,dojo/date/stamp,dojo/currency,dojox/color,ibm/tivoli/simplesrm/srm/dijit/WidgetBase,ibm/tivoli/simplesrm/srm/dijit/ProgressSpinner,ibm/tivoli/simplesrm/srm/dijit/BaguetteChart,ibm/tivoli/simplesrm/srm/dijit/ToolbarButton,ibm/tivoli/simplesrm/srm/dijit/MessageDialog,ibm/tivoli/simplesrm/srm/dojo/data/FormattedDataReadStore,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dojo/Formatter,ibm/tivoli/simplesrm/srm/dijit/ContextButton,ibm/tivoli/tip/dijit/TIPTableToolbar,ibm/tivoli/tip/dijit/TIPTableRefreshButton"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid");

// include modules
dojo.require("dijit._Widget");
dojo.require("dojo.parser");
dojo.require("dijit.form.Button");
dojo.require("dijit.form.CheckBox");
dojo.require("dojox.grid.DataGrid");
//dojo.require("dijit.Tooltip");
dojo.require("dojo.date.locale");
dojo.require("dojo.date.stamp");
dojo.require("dojo.currency");
dojo.require("dojox.color");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.WidgetBase");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.BaguetteChart");
//dojo.require("ibm.tivoli.simplesrm.srm.dojo.Hoverer");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ToolbarButton");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MessageDialog");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Formatter");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ContextButton");

dojo.require("ibm.tivoli.tip.dijit.TIPTableToolbar");
dojo.require("ibm.tivoli.tip.dijit.TIPTableRefreshButton");

// the MyRecordsGrid class is a widget that makes an
// XMLHttpRequest to a proxy servlet to reach an SRM object structure
// web service that provides information about service catalog requests.
// the widget displays the service catalog request information
// using a dojo grid
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid",
	[dijit._Widget,
	 ibm.tivoli.simplesrm.srm.dijit.WidgetBase,
	 ibm.tivoli.simplesrm.srm.dojo.Formatter],
{		
	headingText: 'My Records',
	requestTimeout: 60000,			// timeout waiting for ajax requests, millisecs.
//	_showGridTooltipHandler: null,	// closure for showing the tooltip
//	_conn_onHover: null,			// connection handle for the hoverer
//	_hoverer: null,					// monitors grid cells for a hovering mouse
	sripeGraph: null,				// the stripe graph showing summary data from the query
	_outstandingDataQuery: null,	// deferred object for the async catalog request query
	simpleGrid: undefined,			// the grid showing the queried catalog requests
	showDetailsBtn: null,		// the show details button on the toolbar
	approveBtn: null,
	rejectBtn: null,
	contextBtns: null,				// context specific buttons
	imagespath: "",					// where my images are found
	header: null,					// DOM node of the header div, if you need to stick stuff in there.
	_initialization_complete: false,
	_column_defs: null,
	_data_key_field: -1,	// index into _column_defs of the key field
	_initial_view_cols: null,		// array of inceces into _column_defs
	_initial_sort_index: -1,
	_initial_sort_asc: false,
	_status_stats: null, 			// cache stats for the stripe graph
	_contextName: "",				// Synonym domain with this grid's context specific requests
	_viewDialog: "srmssviewsr",
	_fd: null, //"SRM_SRUSRLIST"
	_os: "SRM_SR",
	_ticket_object: "SR",
	
 	_outstandingStatusDomainRequest: null, // deferred object for the status domain query
 	
 	_isApproval: "false",
 	
 	_requestNumbers: null,
 	
	constructor: function()
	{
		console.log("MyRecordsGrid.ctor");
		
//		this._hoverer = new  ibm.tivoli.simplesrm.srm.dojo.Hoverer();
//		this._conn_onHover = dojo.connect(this._hoverer, "OnHover", this, "_showGridTooltip");

		this.imagesPath = this.getRelativePath("images/");	
	},
	buildRendering: function()
	{
		console.log("MyRecordsGrid.buildRendering");
    
      //Retrieve number of rows in My Records grid
      var grid_rows = ibm.tivoli.tpae.dojo.data.getConfigProperty("MyRequestsGridRows");   
      if (grid_rows==null || isNaN(grid_rows) ) {
         grid_rows = 20;
      }
      console.log("MyRecordsGrid.buildRendering, number of rows = " + grid_rows);

		this.inherited(arguments);
		
		// for whatever reason, when I try to create this as a templated widget, the grid won't show
		// its data.  Maybe it's because this code fills out the DOM node in the html page, and a 
		// templated widget replaces it.
		// For now, this is good enough.
		
		if(!this.domNode) {	// should never happen
			this.domNode = document.createElement("div");
			this.domNode.id = this.id;
			this.domNode.className = "my_records_grid_main_div";
		}
		console.log("domNode: ", this.domNode);
		dojo.addClass(this.domNode, "my_records_grid_main_div");
		
//		this.header = document.createElement("div");
//		this.header.className = "my_records_grid_header";
//		dojo.place(this.header, this.domNode, "first");
//		
//		// the grid's title
//		var gridHeading = document.createElement("h2");
//		gridHeading.id = this.id+"_grid_heading";
//		gridHeading.className = "grid_heading";
//		gridHeading.innerHTML = this.headingText;
//		dojo.place(gridHeading, this.header, "first");
		
		
			// the toolbar        
		    var div = dojo.doc.createElement( 'div' );
		    dojo.place(  div, this.domNode, "last"  );
	        
		    this.toolBar = new ibm.tivoli.tip.dijit.TIPTableToolbar( {}, div );
		    dojo.addClass(this.toolBar.domNode, "srmtoolbar");
	        
		    var button = new ibm.tivoli.tip.dijit.TIPTableRefreshButton({
		    	title:this._uiStringTable.RefreshTable,
    			label: this._uiStringTable.Refresh,	
    			showLabel: false,
		    	onClick: dojo.hitch( this, "refresh" ) 
		    });    
		    
		    button._scroll = false;	// prevents the page from jumping when the the user clicks anywhere in the toolbar.
		    						// I made this change in the TIPTableRefreshButton code too, but it took so long to find
		    						// this bug, that I didn't want an update of the TIP widgets to break it.
		    this.toolBar.toolbar.addChild( button );

		    if("function" == typeof this.showRecordDetails) {
		    			    	
		    	this.showDetailsBtn = new dijit.form.Button({		    		
		    			id: this.id+"_show_details_btn", 
		    			disabled: true,
		    			baseClass: "srm_button",
		    			iconClass:"show_details_btn", 
		    			title:this._uiStringTable.ShowSelectedDetails,
		    			label: this._uiStringTable.Details,	
		    			showLabel: false,
		    			onClick: dojo.hitch( this, "_showDetails" )		    		
		    	});
		    			    	
		    }
		    this.showDetailsBtn._scroll = false;
		    this.toolBar.getToolbar().addChild( this.showDetailsBtn );
		    
		    // get context specific buttons
		    if(this._contextName && this._contextName.length > 0) {
		    	this.contextBtns = new ibm.tivoli.simplesrm.srm.dijit.ContextButtonSet({contextName: this._contextName, toolbar: this.toolBar.getToolbar()});
		    	this.contextBtns.attr("disabled", true);
		    }	
		
		// insert the html tag for dojo to use to insert the grid
		var gridContainer = document.createElement("div");
		gridContainer.id = this.id+"_grid_container";
		gridContainer.className = "my_records_grid_container";
		dojo.place(gridContainer, this.domNode, "last");
		
		// the stripe graph
		var footerDiv = document.createElement("div");
		footerDiv.className = "footer";
		dojo.place(footerDiv, this.domNode, "last");
		
		if (this._isApproval == "false"){
			var graphDiv = document.createElement("div");
			graphDiv.id = this.id+"_stripe_graph";
			//graphDiv.className = "footer";
			dojo.place(graphDiv, footerDiv, "first");
			var bgcolor = dojo.style(this.domNode, "backgroundColor");
			try {
				var total = this._uiStringTable.Total;
				console.log("MyRecordsGrid.buildRendering  - createBaguette");
				this.baguetteChart = new ibm.tivoli.simplesrm.srm.dijit.BaguetteChart({
					barHeight:15, 
					captionHeight:13, captionFontSize:10, 
					showLegend: true, 
					showTotal: true,
					totalLegend: total}, graphDiv);
				// TODO: why does backgroundColor: transparent or inherited wind up white, when the table cell it's in has a background color?
				dojo.connect(this.baguetteChart, "onDatumClick", this, "_stripeClick");				
			}
			catch(ex) {
				// the baguette chart sometimes fails in ie.
				// don't let it take down the whole UI
				ibm.tivoli.logger.error("Failed creating the BaguetteChart: " + ex,ex);
				console.error("Failed creating the BaguetteChart: " + ex);
				this.baguetteChart = null;
				dojo.style(graphDiv, "display", "none");
			}						
		}else {
			var totalDiv = document.createElement("div");
			totalDiv.id = "totalNumber";
			
			//totalDiv.className = "status_table";
			dojo.style(totalDiv, "textAlign", "right");
			
			var s = document.createElement("span");
			s.className = "requestnumber";
			//dojo.style(s, "textAlign": "right");
			//s.className = "status";
			
			dojo.place(s, totalDiv, "first");
			dojo.place(totalDiv, footerDiv, "first");
		}
		
		// now fill in the grid
		// html element to hang the grid
		var gridElement = document.createElement("span");
		gridElement.id = this.id+"_simple_grid";
		gridElement.className = "my_records_grid_simple_grid";
		dojo.place(gridElement, gridContainer, "first");
	
		// define the grid's initial view and data
		var cols = [];
		for(var c in this._initial_view_cols) {
			if(this._initial_view_cols.hasOwnProperty(c)){
				cols.push(this._column_defs[this._initial_view_cols[c]]);
			}
		}
		cols[cols.length-1].width = "auto";
		
		// insert simple (non-subgrid) version of the grid showing service catalog request info
		this.simpleGrid = new dojox.grid.DataGrid(
			{
				structure: cols,
				autoHeight: grid_rows,
            //autoHeight: false,
				autoWidth: false,
				selectionMode: "single",
				rowSelector: "1em"
			},
			gridElement);
		
		dojo.style(this.simpleGrid, "width", "100%");
		this.simpleGrid.startup();
		
		if(this._initial_sort_index >= 0){
			this.simpleGrid.setSortIndex(this._initial_sort_index, this._initial_sort_asc);
		}
		//this._rowclickhandler = dojo.connect(this.simpleGrid, "onRowClick", this, "_onRowClick");
		this.connect(this.simpleGrid, "onSelected", "_onRowSelect");
		this.connect(this.simpleGrid, "onDeselected", "_onRowDeselect");
		this.connect(this.simpleGrid, "onDblClick", "_showDetails");
		 
		//This fixes an initial  rendering problem with grid scroll bars       
		//this.simpleGrid.update();  //D42469 
		this.refresh(false);   //D40632 
		
		console.log("MyRecordsGrid.buildRendering - exit");
//		// add tooltip support
//		dojo.connect(this.simpleGrid,
//			"onCellMouseOver",
//			dojo.hitch(this, function(e)
//			{
//				if(e.cellIndex === 0 && e.cellNode.tagName !== "TH")
//				 {
//					//var msg = this.getGridToolTip(e);
//					//if (msg != null)
//					//{
//						this._hoverer.setDOMNode(e.cellNode);
//						this._hoverer.connect(e);
//						this._hoverer.setData("rowIndex", e.rowIndex);
//						//this._hoverer.setData("text", msg);
//					//}
//				}
//			}));
//		
//		dojo.connect(this.simpleGrid,
//			"onCellMouseOut", 
//			dojo.hitch(this, function(e)
//			{
////				console.log("onCellMouseOut");
//				dijit.hideTooltip(e.cellNode);
//				dijit._masterTT._onDeck=null;
//			}));
//			
//		dojo.connect(this.simpleGrid,
//			"onCellClick",
//			function(e)
//			{
//				console.log("onCellClick");
//				dijit.hideTooltip(e.cellNode);
//				dijit._masterTT._onDeck=null;
//			});				
//		// FYI: we don't get an onCellMouseOut when the mouse leaves a cell by leaving the 
//		// right-hand side of the last cell in a row
//		// I tried and we don't get an onMouseOut eiher.


	},
	postCreate: function()
	{
		this.toolBar.searchField.setTable( this.simpleGrid );  
		  
	},
	startup: function()
	{
		console.log("MyRecordsGrid - startup");
		this.inherited(arguments);
		if(this.baguetteChart){
			this.baguetteChart.startup();
		}
		this._initialization_complete = true;
		
		dojo.connect(this.toolBar.toolbar, "onblur", null, function(evt) {
			console.log("### toolbar blur");
			evt.stopPropagation();
		});
		dojo.connect(this.toolBar.toolbar, "onfocus", null, function(evt) {
			console.log("### toolbar focus");
			evt.stopPropagation();
		});
		dojo.connect(this.toolBar.toolbar, "onfocus", null, function(evt) {
			console.log("### toolbar focus");
			evt.stopPropagation();
		});
		dojo.connect(this.toolBar.toolbar, "onmousedown", null, function(evt) {
			console.log("### toolbar mousenown");
			evt.stopPropagation();
		});
	},
	destroy: function()
	{
		if(this.progressSpinner) {
			this.progressSpinner.destroy();
			this.progressSpinner = null;
		}
		if(this.simpleGrid) {
			try {
				this.simpleGrid.destroy();
			}
			catch(ex){
				ibm.tivoli.logger.error("",ex);
				// quietly fail
			}
			this.simpleGrid = null;
		}
		if(this._conn_onHover) {
			dojo.disconnect(this._conn_onHover);
			this._conn_onHover = null;
		}
//		if(this._hoverer) {
//			this._hoverer.destroy();
//			this._hoverer = null;
//		}
	},

	
	/*
	*********** status domain lookup ***************
	*/
	_ajaxRequestStatusDomain: function(domain_id)
	{
		console.log("CatalogRequestsGrid._ajaxRequestStatusDomain");
		var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomain({DOMAINID: domain_id});
		deferred.addCallbacks(dojo.hitch(this, "_processStatusDomain"), dojo.hitch(this, "_onQueryError"));
		deferred.addBoth(dojo.hitch(this, "_cleanupQuery"));
		return deferred;
	},
	_processStatusDomain: function(response)
	{	
		console.log("CatalogRequestsGrid._processStatusDomain");

		this._statusDomainValues = [];
		var synonym_domain = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('MRSTATUS');
		for (var i = 0; i < synonym_domain.length; ++i)
		{
			this._statusDomainValues[synonym_domain.synonyms[i].VALUE] = synonym_domain.synonyms[i].DESCRIPTION;
		}
		return response;
	},
	/*
	********* the data query ************
	*/
	/*
	 * This is the method that does the ajax query for the grid's data.
	 * Override in derived classes
	 */
	ajaxQueryData: function()
	{
		return null;
	},

	// invoke an xmlHttpRequest to get service catalog requests
	_ajaxDoQuery: function()
	{
		console.log("MyRecordsGrid._ajaxDoQuery");
		if(this._outstandingDataQuery) {
			this._outstandingDataQuery.cancel();
			this._outstandingDataQuery = null;
		}

		// clear the baguette chart
		if(this.baguetteChart){
			this.baguetteChart.setData([]);
		}
		// clear the grid
		this.clearGrid();

		this.showProgressSpinner();
		
		this._outstandingDataQuery = this.ajaxQueryData();
		if(this._outstandingDataQuery) {
			this._outstandingDataQuery.addCallbacks(dojo.hitch(this, "_processQueryResult"), dojo.hitch(this, "_onQueryError"));
			this._outstandingDataQuery.addBoth(dojo.hitch(this, "_cleanupQuery"));
		}
		return this._outstandingDataQuery;
	},
	_processQueryResult: function(response)
	{
		this._fireOnRefresh(response);	// let the world know we're finished
		return response;
	},	
	_loadGrid: function(newdata)
	{	
		// keep count of status types
		this._requestNumbers = newdata.length;

		this._status_stats = {srm_status_count: [], srm_unique_stati: 0};
		try {
			var pmscmr_count = newdata.length;
			for(var i = 0; i < pmscmr_count; ++i) {
				var p = newdata[i];
				if(p["StatusString"]) {
					var status = p["StatusString"];
					if(typeof this._status_stats.srm_status_count[status] == 'number') {
						++this._status_stats.srm_status_count[status];
					}
					else {
						this._status_stats.srm_status_count[status] = 1;
						++this._status_stats.srm_unique_stati;
					}
				}				
			}
			var newstore = new ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore({data: {items: dojo.clone(newdata)}});
			newstore.setStructure(this.simpleGrid.structure);
			newstore.comparatorMap = {};
			var gl = this.simpleGrid.structure;
			for(var i in gl) {
				if(gl.hasOwnProperty(i)){
					if(undefined !== gl[i].compare) {
						newstore.comparatorMap[gl[i].field] = gl[i].compare;
					}
				}
			} 
			this.simpleGrid.setStore(newstore, null, {ignoreCase: true});
			
			// refresh the grid's data
			if(this.simpleGrid.getSortIndex() > 0){
				this.simpleGrid.sort();			
			}
			try {
			   this.simpleGrid.resize();
			}  catch(ex) {					
					console.error("MyRecordsGrid.resize failed: ", ex);					
			}	

			this.simpleGrid.selection.setSelected(0, true);  //select inital record on entry //fpb
			
			//this.simpleGrid.focus.setFocusIndex(0,0);
			//this.simpleGrid.domNode.focus();
			
			// refresh the graph's data
			if (this._isApproval == "false"){
				this._refreshBaguetteChart();
			}
			else{ 
				this._refreshTotal();
			}
			this._enableFilter();
		}
		catch(ex) {
			ibm.tivoli.logger.error("",ex);
			console.error("Failed processing catalog request data: ", ex);
			throw ex;
		}	
	},	
	_onQueryError: function(response) 
	{
		if(response && (response.message.indexOf("cancelled")>0  || response.message.indexOf("Cancelled")>0))   {
			console.log("Catalog request canceled");
		}
		else {
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: this._queryErrorMessage})).show();
			ibm.tivoli.logger.error("MyRecordsGrid._onQueryError: " + response,new Error());
			console.log("Failed retrieving grid data.");
			console.log(response);
		}
		return response;
	},
	_onProcessError: function(response) 
	{

      if(response && (response.message.indexOf("cancelled")>0  || response.message.indexOf("Cancelled")>0))   {
			console.log("Process request canceled");
		}
		else {
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: this._processErrorMessage})).show();
			ibm.tivoli.logger.error("MyRecordsGrid._onProcessError: " + response);
			console.log("Failed processing selected request.");
			console.log(response);
		}
		return response;
	},
	_cleanupQuery: function(response) 
	{
		this._outstandingDataQuery = null;
		this.hideProgressSpinner();
		
		return response;
	},
	_refreshBaguetteChart: function()
	{
//		if( !this.isDisplayed() ) {	// defer until later
//			return;
//		}
		if(!this._status_stats) {	// nothing to do
			return;
		}
		console.log("MyRecordsGrid._refreshBaguetteChart: refreshing");

		
		var counts = this._status_stats.srm_status_count;
		counts.sort();
		// set stripe graph data using colors generated by walking around the color wheel
		var stripeData = [];
		for(var s in counts) {
			if(counts.hasOwnProperty(s)){
				stripeData.push({name: s, value: counts[s], color: ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.getDefaultColor(s)});
			}
		}
		if(this.baguetteChart){
			this.baguetteChart.setData(stripeData);
		}
	},	
	_refreshTotal: function()
	{
		dojo.query(".requestnumber")[0].innerHTML = "Total: " + this._requestNumbers;
	},

	/*
	*************** flyover popup  support
	*/
	// the function for getting the grid's rollover tooltip text
//	getGridToolTip: function(cellDOMNode, rowIndex)
//	{
//		// if the cell is too low in the grid, so it's mostly 
//		// off the bottom, then don't show the tooltip.
//		// this isn't as straight forward as it should be, since
//		// the contents div has scrollbars, and there's no (easy) way
//		// to get their size
//		var gridcoords = dojo.coords(this.simpleGrid.domNode);
//		var cellcoords = dojo.coords(cellDOMNode);
//		if((gridcoords.y + gridcoords.h - cellcoords.y) < 30) {
//			return null;
//		}
//	
//		var row_data = this.simpleGrid.getItem(rowIndex);
//		var icon = null;
//	
//		tooltip2 = '<table border="0" cellspacing="1" cellpadding="2"><tbody>';
//		for(var i in this._column_defs) {
//			var coldef = this._column_defs[i];
//			if(coldef.showInTooltip == false) {
//				continue;
//			}
//
//			var field = coldef.field;
//			var datum = this.simpleGrid.store.getValue(row_data, field)
//			if(undefined == datum) {
//				continue;
//			}
//			if(field === "ImageName") {
//				icon = this._formatIconSz(datum, rowIndex, 50);
//			}
//			else {
//				tooltip2 += '<tr><td><b>';
//				tooltip2 += coldef.name;
//				tooltip2 += ': </b></td><td>';
//				tooltip2 += coldef.formatter ? coldef.formatter(datum) : datum;
//				tooltip2 += '</td></tr>';
//			}
//		}
//		tooltip2 += '</tbody></table>';
//		
//		if(icon) {
//			tooltip2  = '<table border=0 cellspacing=1 cellpadding=0><tbody><tr><td style="vertical-align:middle;"><td>'
//						+ icon
//						+ '</td><td>'
//						+ tooltip2
//						+ '</td></tr></tbody></table>';
//		}
//		
//		return '<div>' + tooltip2 + '</div>';
//				
//	},
//	_showGridTooltip: function(/*Hoverer*/hvr)
//	{
//		console.log("MyRecordsGrid._showGridTooltip");
//		var node = hvr.getDOMNode();
//		var msg = this.getGridToolTip(node, hvr.getData("rowIndex"));
//		dijit.showTooltip(msg, node);
//	},
	
	showProgressSpinner: function() 
	{
		console.log("MyRecordsGrid.showProgressSpinner");
		try {
			if(!this.progressSpinner) {
				this.progressSpinner = new ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner({text: this._uiStringTable.Loading + "&nbsp;"});
				var box = dojo.coords(this.simpleGrid.domNode);
				dojo.style(this.progressSpinner.domNode, {
					height: "1em",
					width: "100%",
					zIndex: "10",
					position: "absolute",
					top: "40%",
					left: "0px",
					display: "block",
					textAlign: "center"
				});
				dojo.place(this.progressSpinner.domNode, this.simpleGrid.domNode, "before");  //first didn't look right
			}	
			
			this.progressSpinner.show();
		}
		catch(ex) {
			ibm.tivoli.logger.error("Failed rendering MyRecordsGrid's progress spinner: ", ex);
			console.error("Failed rendering MyRecordsGrid's progress spinner: ", ex);
			if(this.progressSpinner) {
				this.progressSpinner.destroyRecursive();
				this.progressSpinner = null;
			}
			window.status = "Retrieving...";
		}
	},
	hideProgressSpinner: function() {
		console.log("MyRecordsGrid.hideProgressSpinner");
		if(this.progressSpinner){
			this.progressSpinner.hide();
		}
		else{
			window.status = "Done.";
		}
	},
	clearGrid: function() 
	{
		console.log("MyRecordsGrid.clearGrid");
		
		if(this.showDetailsBtn){
			this.showDetailsBtn.attr("disabled", true);
		}

		if(this.approveBtn){
			this.approveBtn.attr("disabled", true);
		}

		if(this.rejectBtn){
			this.rejectBtn.attr("disabled", true);
		}

		if(this.simpleGrid) {
			this.simpleGrid.selection.clear();
			this.simpleGrid.setStore(new ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore({data: {items:[]}}));
		}
//		if(this._hoverer) {
//			this._hoverer.setDOMNode(null);
//		}
		
	},
	isDisplayed: function()
	{
		//console.group("MyRecordsGrid.isDisplayed");
		var d = true;
		for(var n = this.domNode; n && 'body' != n.tagName.toLowerCase(); n = n.parentNode) {
			//console.log(n);
			if("none" == dojo.style(n, "display")) {
				d = false;
				break;
			}
		}
		//console.log("isDisplayed = ", d);
		//console.groupEnd();
		return d;
	},
	/* refresh button handling */
	refresh: function(forceRequery) {
		console.log("MyRecordsGrid.refresh(%s)", forceRequery);
		
		if(!this._initialization_complete) {
			window.setTimeout(dojo.hitch(this, 'refresh'), 1000); 
		}

		//reload of data should only occur if refresh button pressed or explicitly passed.
		if(typeof forceRequery  =='object' || forceRequery === true) {
		//if("boolean" != typeof forceRequery || forceRequery === true) {			
			if (this.toolBar.searchField  && this.toolBar.searchField.getSelectedColumns()) {  
			   this._savedFilterCols = this.toolBar.searchField.getSelectedColumns();
			}
 			this._disableFilter();
			this._ajaxDoQuery();
		}
		else {
			this.simpleGrid.update();
			
			if (this._isApproval == "false"){
				this._refreshBaguetteChart();
			}
			else{
				this._refreshTotal();
			}
			this.simpleGrid.resize();		// TODO: part of the realignment hack
		}
	},
	_fireOnRefresh: function(raw_data)
	{
		try {
			this.onRefresh(raw_data);
		}
		catch(ex) {
			ibm.tivoli.logger.warn("MyRecordsGrid.onRefresh handler failed: " + ex,ex);
			console.warn("MyRecordsGrid.onRefresh handler failed: " + ex,ex);
		}
	},
	onRefresh: function()
	{
		// override this puppy
	},
	 
	/* show details button handling */
	_activeRow: -1,
	_onRowSelect: function(rowIndex)
	{
		console.log("MyRecordsGrid._onRowSelect ", rowIndex);
		
		this._activeRow = rowIndex;
		if (this.showDetailsBtn) {
			this.showDetailsBtn.attr("disabled", false);
			
			if (this.contextBtns) {
				// the row's data to the context buttons
				var context = {};
				try {
					context = this.getContext();
				}
				catch(ex) {
					ibm.tivoli.logger.warn("",ex);
				}
								
				var wcaCase = (context.TYPE!==undefined && context.TYPE==="WCA");				
//				console.log(wcaCase);
				if(wcaCase){
					this.contextBtns.attr("disabled", true); //TODO: exclude some buttons if necessary 
				}
				else{
					this.contextBtns.attr("disabled", false);	
				}
				this.contextBtns.setContext(context);
			}
		}
		
		if (this.approveBtn){
			this.approveBtn.attr("disabled", false);	
		}
		if (this.rejectBtn){
			this.rejectBtn.attr("disabled", false);	
		}
	},
	_onRowDeselect: function(rowIndex)
	{
		console.log("MyRecordsGrid._onRowDeselect ", rowIndex);
		if (this.showDetailsBtn) {
			this.showDetailsBtn.attr("disabled", true);
			if (this.contextBtns) {
				this.contextBtns.attr("disabled", true);
			}
		}
		
		if (this.approveBtn) {
			this.approveBtn.attr("disabled", true);
		}
		
		if (this.rejectBtn) {
			this.rejectBtn.attr("disabled", true);
		}
	},
	
	//display dialog for row selected
	_showDetails: function()
	{
		console.log("MyRecordsGrid._showDetails(row: %d)", this._activeRow);

		if(this._activeRow >= 0) {	
			var selected_record = this.simpleGrid.getItem(this._activeRow);
			selected_record = this._gridItemToObject(selected_record);
		    console.log("MyRecordsGrid._showDetails---selected_record = ", selected_record);
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			if (product!=null && product.indexOf("srm") >= 0 && selected_record.type == "SR")
				this._viewSR(selected_record.id);
			else if (product!=null && product.indexOf("srm") >= 0 && selected_record.type == "BULLETBOARD")
				this._viewNews(selected_record.id);
			//TODO asset support
			else if (product!=null && product.indexOf("srm") >= 0 && selected_record.type == "ASSET")
				this._viewSR(selected_record.id);
			else 
				this.showRecordDetails(selected_record);
		}
	},
	_openSRDialogHandle:null,
	//launch View SR dialog 
	_viewSR: function(ticketUID)  
	{
		console.log("MyRecordsGrid._viewSR - launch dialog - " + this._viewDialog + " ticketUID = ",ticketUID);
		//var node = dojo.byId(this.id);
		arguments.caller=null; //running into a IE bug in stacktrace()
		if(dojo.isIE) {
			this._openSRDialogHandle = dojo.connect(null,"removeModalWaitLayer",this,"_showMyRequest");
			dojo.publish("hideMyRequest");
		}	
		
		var navid = "mx107";
	    var nav = dojo.query("div.srmnavigator");  //use id of navigator
	    if (nav.length>0)
		    navid = nav[0].id;
	    sendEvent(this._viewDialog,  navid,  ticketUID);
	},
	
	//view dialog to launch
	_setViewDialog: function(dialog) {
		this._viewDialog = dialog;
	},
	_setFD: function(fd) {
		this._fd = fd;
	}, 
	_setOS: function(os) {
		this._os = os;
	}, 
	_setTicketObject: function(to) {
		this._ticket_object = to;
	}, 
	
	_showMyRequest:function(){
		if(modalWaitLayers && modalWaitLayers.length<=0) {
		   dojo.disconnect(this._openSRDialogHandle);
		   dojo.publish("showMyRequest");
		}
	},
	//launch My News dialog 
	_openNewsDialogHandle:null,
	_viewNews: function(bbUID)  
	{ 
		console.log("MyRecordsGrid._viewNews - launch dialog  bbUID = ",bbUID);
		var node = dojo.byId(this.id);
		arguments.caller=null; //running into a IE bug in stacktrace()
		if(dojo.isIE) {
			this._openNewsDialogHandle = dojo.connect(null,"removeModalWaitLayer",this,"_showMyRequest");
			dojo.publish("hideMyRequest");
		}		
		
		var navid = "mx107";
	    var nav = dojo.query("div.srmnavigator");  //use id of navigator
	    if (nav.length>0)
		    navid = nav[0].id;	    
	    sendEvent("srmssviewmynews",  navid,  bbUID);
		
	}, 
	// returns an object with data from the selected row pertinant to the grid's datatype
	// derived grids should override if you have any context specific actions
	getContext: function()
	{
		return {};
	},
	// there ought to be a better way
	_gridItemToObject: function(item)
	{
		var attribs = this.simpleGrid.store.getAttributes(item);
		var obj = {};
		for(var i = 0; i < attribs.length; ++i) {
			obj[attribs[i]] = this.simpleGrid.store.getValue(item, attribs[i]);
		}
		return obj;
	},
	// ------------- event handlers -----------------------
	// TODO: I added code to save the current list of filtered columns and set it to just "Status"
	// when responding to a baguette chart click, then put things back if the user clicks on "total"
	// I'm not sure this is a good idea.  Talk to BJ
	_savedFilterCols: null,
	_stripeClick: function(evt, datum_name)
	{
		console.log("MyRecordsGrid._stripeClick ", datum_name);
		if(datum_name == "Total") {
			this.toolBar.searchField.searchField.value = "";
			this.clearFilter();
			if(dojo.isArray(this._savedFilterCols)) {
				this.toolBar.searchField.setSelectedColumns(this._savedFilterCols);
				this._savedFilterCols = null;
			}
			return;
		}
		
		this.toolBar.searchField.searchField.value = datum_name;
		if(!this._savedFilterCols){
			this._savedFilterCols = this.toolBar.searchField.getSelectedColumns();
		}
		this.toolBar.searchField.setSelectedColumns(["StatusString"]);
		this.filter( ['StatusString'], datum_name);
		this.toolBar.searchField.searchField.focus();
	},

	/*
	*********** FILERING SUPPORT *********************
	*/
	_onFilterSubscription: null,
	_onFilterKeypressHandle: null,
	_onFilterDelay: 700,		// msecs from time user starts typing, until we automagically filter the data
	_filterTimerID: -1,			// timer for delayed auto-filtering

	_disableFilter: function()
	{
		dojo.unsubscribe ( this._onFilterSubscription );  
		dojo.disconnect(this._onFilterKeypressHandle); 
		this._onFilterSubscription = this._onFilterKeypressHandle = null;
		this.toolBar.searchField.clear();
		//this.toolBar.searchField.searchField.value = "";	// you'd think clear() would take care of this.
	},
	_enableFilter: function()
	{
		this.toolBar.searchField.setTable(this.simpleGrid);
		if(!this._onFilterSubscription) {	// wire it up
			// published on hitting enter
			this._onFilterSubscription = dojo.subscribe ( this.toolBar.searchField.id + "searchInvoked", this, "_onFilter" );    
			// we also want to automatically filter as the user types
			this._onFilterKeypressHandle = dojo.connect(this.toolBar.searchField.searchField, "onkeypress", this, "_onSearchKeyPress");
		}
		// if the table was filtered, re-filter with new data
		if(this.toolBar.searchField.searchField.value.length > 0) {
			this._onFilter();
		}
	},
	_onSearchKeyPress: function(evt)
	{
		if(evt.keyCode == dojo.keys.ENTER || evt.keyCode == dojo.keys.TAB)  {
			// ENTER is already handled, and TAB just causes field to loose focus
			return;
		}
		//console.log("MyRecordsGrid._onSearchKeyPress");
		if(this._filterTimerID < 0) {
			this._filterTimerID = window.setTimeout(dojo.hitch(this, "_onFilter"), this._onFilterDelay);
		}
	},
	_onFilter: function()
	{
		console.log("CatalogRequestQery._onFilter");
		if(this._filterTimerID >= 0) {
			window.clearTimeout(this._filterTimerID);
			this._filterTimerID = -1;
		}

		// I'm here becuase the user is typing in the filter box
		// if there are saved filter cols (because of a baguetteChart click)
		// put the previous cols back
		if(dojo.isArray(this._savedFilterCols)) {
			this.toolBar.searchField.setSelectedColumns(this._savedFilterCols);
			this._savedFilterCols = null;
		}
	     // now that I'm automatically filtering on key presses, can't trim whitespace,
	     // or spaces disappear from between words as the user types
	     //this.toolBar.searchField.searchField.value = this.toolBar.searchField.searchField.value.replace(/^\s+|\s+$/g, '');
	     var filterString = this.toolBar.searchField.searchField.value;
	     
	     filterString = filterString.replace(/"/gm, "*");
	     
	     if ( filterString.length < 1 )
	     {
	       this.clearFilter();
	     }
	     else
	     {
	       var searchfields = this.toolBar.searchField.getSelectedColumns(); //fpb
	       if (searchfields.length==0) {
	    	   var cols = [];
	    	   for (var y in this.toolBar.searchField.childrenWidgets) {
	    		   if (y) {	   	  			 
	   		  			if (this.toolBar.searchField.childrenWidgets[y].columnID !== undefined ) {
	   		  				cols.push(this.toolBar.searchField.childrenWidgets[y].columnID);
	   		  			}

	    		   }
	    	   }
	    	   this.toolBar.searchField.setSelectedColumns(cols);
	       }
	       this.filter( this.toolBar.searchField.getSelectedColumns(), filterString );
	     }
	     
    	 this.toolBar.searchField.searchField.focus();
	    	 
	},
	//************** client-side data filtering	 *********************
	filter: function( fields,        /* array of field names to filter on */
	                  filterString ) /* user entered string */
	{
		// surround the filter string with '*'s so we match substrings
		var t = "*" + filterString + "*";
		// create the query by ORing together a query on each of the fields
		var q = "";
		dojo.forEach(fields, function(f) {
			q += f + ":\"" + t + "\" OR ";
		});
		q = q.substring(0, q.lastIndexOf(" OR "));
		this.simpleGrid.setQuery({complexQuery: q});
		
		// because we use auto-width cols, needed to guarantee the column headings are aligned with the data
		this.simpleGrid.resize();
	 
		// I realize that this may be an unexpected side-effect, but it also works around some
		// unusual behaviors exhibited by the grid when the selected row is filtered out, or scrolled
		// out of view
		// TODO: is this still an issue with dojo1.3.1's DataGrid?
		this.clearGridSelection();
	 },
	 clearFilter: function()
	 {
	 	// you can't clear the query with DataGrid.setQuery
	 	this.simpleGrid.query = null;
		this.simpleGrid._refresh();
		this.simpleGrid.resize();	// get columns aligned
		this.clearGridSelection();
	 },
	 clearGridSelection: function()
	 {
		if(this.simpleGrid.selection.getSelectedCount() > 0) {
			this.simpleGrid.selection.clear();
		}
		this.simpleGrid.focus.setFocusIndex(0,0);	// move focus to first cell. Has the side-effect of scrolling there   
	 }
});


});

},
'dojox/grid/_FocusManager':function(){
define("dojox/grid/_FocusManager", [
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/query",
	"./util",
	"dojo/_base/html"
], function(array, lang, declare, connect, event, has, query, util, html){

// focus management
return declare("dojox.grid._FocusManager", null, {
	// summary:
	//	Controls grid cell focus. Owned by grid and used internally for focusing.
	//	Note: grid cell actually receives keyboard input only when cell is being edited.
	constructor: function(inGrid){
		this.grid = inGrid;
		this.cell = null;
		this.rowIndex = -1;
		this._connects = [];
		this._headerConnects = [];
		this.headerMenu = this.grid.headerMenu;
		this._connects.push(connect.connect(this.grid.domNode, "onfocus", this, "doFocus"));
		this._connects.push(connect.connect(this.grid.domNode, "onblur", this, "doBlur"));
		this._connects.push(connect.connect(this.grid.domNode, "mousedown", this, "_mouseDown"));
		this._connects.push(connect.connect(this.grid.domNode, "mouseup", this, "_mouseUp"));
		this._connects.push(connect.connect(this.grid.domNode, "oncontextmenu", this, "doContextMenu"));
		this._connects.push(connect.connect(this.grid.lastFocusNode, "onfocus", this, "doLastNodeFocus"));
		this._connects.push(connect.connect(this.grid.lastFocusNode, "onblur", this, "doLastNodeBlur"));
		this._connects.push(connect.connect(this.grid,"_onFetchComplete", this, "_delayedCellFocus"));
		this._connects.push(connect.connect(this.grid,"postrender", this, "_delayedHeaderFocus"));
	},
	destroy: function(){
		array.forEach(this._connects, connect.disconnect);
		array.forEach(this._headerConnects, connect.disconnect);
		delete this.grid;
		delete this.cell;
	},
	_colHeadNode: null,
	_colHeadFocusIdx: null,
	_contextMenuBindNode: null,
	tabbingOut: false,
	focusClass: "dojoxGridCellFocus",
	focusView: null,
	initFocusView: function(){
		this.focusView = this.grid.views.getFirstScrollingView() || this.focusView || this.grid.views.views[0];
		this._initColumnHeaders();
	},
	isFocusCell: function(inCell, inRowIndex){
		// summary:
		//	states if the given cell is focused
		// inCell: object
		//	grid cell object
		// inRowIndex: int
		//	grid row index
		// returns:
		//	true of the given grid cell is focused
		return (this.cell == inCell) && (this.rowIndex == inRowIndex);
	},
	isLastFocusCell: function(){
		if(this.cell){
			return (this.rowIndex == this.grid.rowCount-1) && (this.cell.index == this.grid.layout.cellCount-1);
		}
		return false;
	},
	isFirstFocusCell: function(){
		if(this.cell){
			return (this.rowIndex === 0) && (this.cell.index === 0);
		}
		return false;
	},
	isNoFocusCell: function(){
		return (this.rowIndex < 0) || !this.cell;
	},
	isNavHeader: function(){
		// summary:
		//	states whether currently navigating among column headers.
		// returns:
		//	true if focus is on a column header; false otherwise.
		return (!!this._colHeadNode);
	},
	getHeaderIndex: function(){
		// summary:
		//	if one of the column headers currently has focus, return its index.
		// returns:
		//	index of the focused column header, or -1 if none have focus.
		if(this._colHeadNode){
			return array.indexOf(this._findHeaderCells(), this._colHeadNode);
		}else{
			return -1;
		}
	},
	_focusifyCellNode: function(inBork){
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			html.toggleClass(n, this.focusClass, inBork);
			if(inBork){
				var sl = this.scrollIntoView();
				try{
					if(!this.grid.edit.isEditing()){
						util.fire(n, "focus");
						if(sl){ this.cell.view.scrollboxNode.scrollLeft = sl; }
					}
				}catch(e){}
			}
		}
	},
	_delayedCellFocus: function(){
		if(this.isNavHeader()||!this.grid.focused){
				return;
		}
		var n = this.cell && this.cell.getNode(this.rowIndex);
		if(n){
			try{
				if(!this.grid.edit.isEditing()){
					html.toggleClass(n, this.focusClass, true);
					if(this._colHeadNode){
						this.blurHeader();
					}
					util.fire(n, "focus");
				}
			}
			catch(e){}
		}
	},
	_delayedHeaderFocus: function(){
		if(this.isNavHeader()){
			this.focusHeader();
			this.grid.domNode.focus();
		}
	},
	_initColumnHeaders: function(){
		array.forEach(this._headerConnects, connect.disconnect);
		this._headerConnects = [];
		var headers = this._findHeaderCells();
		for(var i = 0; i < headers.length; i++){
			this._headerConnects.push(connect.connect(headers[i], "onfocus", this, "doColHeaderFocus"));
			this._headerConnects.push(connect.connect(headers[i], "onblur", this, "doColHeaderBlur"));
		}
	},
	_findHeaderCells: function(){
		// This should be a one liner:
		//	query("th[tabindex=-1]", this.grid.viewsHeaderNode);
		// But there is a bug in query() for IE -- see trac #7037.
		var allHeads = query("th", this.grid.viewsHeaderNode);
		var headers = [];
		for (var i = 0; i < allHeads.length; i++){
			var aHead = allHeads[i];
			var hasTabIdx = html.hasAttr(aHead, "tabIndex");
			var tabindex = html.attr(aHead, "tabIndex");
			if (hasTabIdx && tabindex < 0) {
				headers.push(aHead);
			}
		}
		return headers;
	},
	_setActiveColHeader: function(/*Node*/colHeaderNode, /*Integer*/colFocusIdx, /*Integer*/ prevColFocusIdx){
		//console.log("setActiveColHeader() - colHeaderNode:colFocusIdx:prevColFocusIdx = " + colHeaderNode + ":" + colFocusIdx + ":" + prevColFocusIdx);
		this.grid.domNode.setAttribute("aria-activedescendant",colHeaderNode.id);
		if (prevColFocusIdx != null && prevColFocusIdx >= 0 && prevColFocusIdx != colFocusIdx){
			html.toggleClass(this._findHeaderCells()[prevColFocusIdx],this.focusClass,false);
		}
		html.toggleClass(colHeaderNode,this.focusClass, true);
		this._colHeadNode = colHeaderNode;
		this._colHeadFocusIdx = colFocusIdx;
		this._scrollHeader(this._colHeadFocusIdx);
	},
	scrollIntoView: function(){
		var info = (this.cell ? this._scrollInfo(this.cell) : null);
		if(!info || !info.s){
			return null;
		}
		var rt = this.grid.scroller.findScrollTop(this.rowIndex);
		// place cell within horizontal view
		if(info.n && info.sr){
			if(info.n.offsetLeft + info.n.offsetWidth > info.sr.l + info.sr.w){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}
		}
		// place cell within vertical view
		if(info.r && info.sr){
			if(rt + info.r.offsetHeight > info.sr.t + info.sr.h){
				this.grid.setScrollTop(rt + info.r.offsetHeight - info.sr.h);
			}else if(rt < info.sr.t){
				this.grid.setScrollTop(rt);
			}
		}

		return info.s.scrollLeft;
	},
	_scrollInfo: function(cell, domNode){
		if(cell){
			var cl = cell,
				sbn = cl.view.scrollboxNode,
				sbnr = {
					w: sbn.clientWidth,
					l: sbn.scrollLeft,
					t: sbn.scrollTop,
					h: sbn.clientHeight
				},
				rn = cl.view.getRowNode(this.rowIndex);
			return {
				c: cl,
				s: sbn,
				sr: sbnr,
				n: (domNode ? domNode : cell.getNode(this.rowIndex)),
				r: rn
			};
		}
		return null;
	},
	_scrollHeader: function(currentIdx){
		var info = null;
		if(this._colHeadNode){
			var cell = this.grid.getCell(currentIdx);
			if(!cell){ return; }
			info = this._scrollInfo(cell, cell.getNode(0));
		}
		if(info && info.s && info.sr && info.n){
			// scroll horizontally as needed.
			var scroll = info.sr.l + info.sr.w;
			if(info.n.offsetLeft + info.n.offsetWidth > scroll){
				info.s.scrollLeft = info.n.offsetLeft + info.n.offsetWidth - info.sr.w;
			}else if(info.n.offsetLeft < info.sr.l){
				info.s.scrollLeft = info.n.offsetLeft;
			}else if(has("ie") <= 7 && cell && cell.view.headerNode){
				// Trac 7158: scroll dojoxGridHeader for IE7 and lower
				cell.view.headerNode.scrollLeft = info.s.scrollLeft;
			}
		}
	},
	_isHeaderHidden: function(){
		// summary:
		//		determine if the grid headers are hidden
		//		relies on documented technique of setting .dojoxGridHeader { display:none; }
		// returns: Boolean
		//		true if headers are hidden
		//		false if headers are not hidden
		
		var curView = this.focusView;
		if (!curView){
			// find one so we can determine if headers are hidden
			// there is no focusView after adding items to empty grid (test_data_grid_empty.html)
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				if(cView.headerNode ){
					curView=cView;
					break;
				}
			}
		}
		return (curView && html.getComputedStyle(curView.headerNode).display == "none");
	},
	colSizeAdjust: function (e, colIdx, delta){ // adjust the column specified by colIdx by the specified delta px
		var headers = this._findHeaderCells();
		var view = this.focusView;
		if (!view) {
			for (var i = 0, cView; (cView = this.grid.views.views[i]); i++) {
				// find first view with a tableMap in order to work with empty grid
				if(cView.header.tableMap.map ){
					view=cView;
					break;
				}
			}
		}
		var curHeader = headers[colIdx];
		if (!view || (colIdx == headers.length-1 && colIdx === 0)){
			return; // can't adjust single col. grid
		}
		view.content.baseDecorateEvent(e);
		// need to adjust event with header cell info since focus is no longer on header cell
		e.cellNode = curHeader; //this.findCellTarget(e.target, e.rowNode);
		e.cellIndex = view.content.getCellNodeIndex(e.cellNode);
		e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		if (view.header.canResize(e)){
			var deltaObj = {
				l: delta
			};
			var drag = view.header.colResizeSetup(e,false);
			view.header.doResizeColumn(drag, null, deltaObj);
			view.update();
		}
	},
	styleRow: function(inRow){
		return;
	},
	setFocusIndex: function(inRowIndex, inCellIndex){
		// summary:
		//	focuses the given grid cell
		// inRowIndex: int
		//	grid row index
		// inCellIndex: int
		//	grid cell index
		this.setFocusCell(this.grid.getCell(inCellIndex), inRowIndex);
	},
	setFocusCell: function(inCell, inRowIndex){
		// summary:
		//	focuses the given grid cell
		// inCell: object
		//	grid cell object
		// inRowIndex: int
		//	grid row index
		if(inCell && !this.isFocusCell(inCell, inRowIndex)){
			this.tabbingOut = false;
			if (this._colHeadNode){
				this.blurHeader();
			}
			this._colHeadNode = this._colHeadFocusIdx = null;
			this.focusGridView();
			this._focusifyCellNode(false);
			this.cell = inCell;
			this.rowIndex = inRowIndex;
			this._focusifyCellNode(true);
		}
		// even if this cell isFocusCell, the document focus may need to be rejiggered
		// call opera on delay to prevent keypress from altering focus
		if(has("opera")){
			setTimeout(lang.hitch(this.grid, 'onCellFocus', this.cell, this.rowIndex), 1);
		}else{
			this.grid.onCellFocus(this.cell, this.rowIndex);
		}
	},
	next: function(){
		// summary:
		//	focus next grid cell
		if(this.cell){
			var row=this.rowIndex, col=this.cell.index+1, cc=this.grid.layout.cellCount-1, rc=this.grid.rowCount-1;
			if(col > cc){
				col = 0;
				row++;
			}
			if(row > rc){
				col = cc;
				row = rc;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var nextCell = this.grid.getCell(col);
				if (!this.isLastFocusCell() && (!nextCell.editable ||
					this.grid.canEdit && !this.grid.canEdit(nextCell, row))){
					this.cell=nextCell;
					this.rowIndex=row;
					this.next();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	previous: function(){
		// summary:
		//	focus previous grid cell
		if(this.cell){
			var row=(this.rowIndex || 0), col=(this.cell.index || 0) - 1;
			if(col < 0){
				col = this.grid.layout.cellCount-1;
				row--;
			}
			if(row < 0){
				row = 0;
				col = 0;
			}
			if(this.grid.edit.isEditing()){ //when editing, only navigate to editable cells
				var prevCell = this.grid.getCell(col);
				if (!this.isFirstFocusCell() && !prevCell.editable){
					this.cell=prevCell;
					this.rowIndex=row;
					this.previous();
					return;
				}
			}
			this.setFocusIndex(row, col);
		}
	},
	move: function(inRowDelta, inColDelta) {
		// summary:
		//	focus grid cell or  simulate focus to column header based on position relative to current focus
		// inRowDelta: int
		// vertical distance from current focus
		// inColDelta: int
		// horizontal distance from current focus

		var colDir = inColDelta < 0 ? -1 : 1;
		// Handle column headers.
		if(this.isNavHeader()){
			var headers = this._findHeaderCells();
			var savedIdx = currentIdx = array.indexOf(headers, this._colHeadNode);
			currentIdx += inColDelta;
			while(currentIdx >=0 && currentIdx < headers.length && headers[currentIdx].style.display == "none"){
				// skip over hidden column headers
				currentIdx += colDir;
			}
			if((currentIdx >= 0) && (currentIdx < headers.length)){
				this._setActiveColHeader(headers[currentIdx],currentIdx, savedIdx);
			}
		}else{
			if(this.cell){
				// Handle grid proper.
				var sc = this.grid.scroller,
					r = this.rowIndex,
					rc = this.grid.rowCount-1,
					row = Math.min(rc, Math.max(0, r+inRowDelta));
				if(inRowDelta){
					if(inRowDelta>0){
						if(row > sc.getLastPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop+sc.findScrollTop(row)-sc.findScrollTop(r));
						}
					}else if(inRowDelta<0){
						if(row <= sc.getPageRow(sc.page)){
							//need to load additional data, let scroller do that
							this.grid.setScrollTop(this.grid.scrollTop-sc.findScrollTop(r)-sc.findScrollTop(row));
						}
					}
				}
				var cc = this.grid.layout.cellCount-1,
				i = this.cell.index,
				col = Math.min(cc, Math.max(0, i+inColDelta));
				var cell = this.grid.getCell(col);
				while(col>=0 && col < cc && cell && cell.hidden === true){
					// skip hidden cells
					col += colDir;
					cell = this.grid.getCell(col);
				}
				if (!cell || cell.hidden === true){
					// don't change col if would move to hidden
					col = i;
				}
				//skip hidden row|cell
				var n = cell.getNode(row);
				if(!n && inRowDelta){
					if((row + inRowDelta) >= 0 && (row + inRowDelta) <= rc){
						this.move(inRowDelta > 0 ? ++inRowDelta : --inRowDelta, inColDelta);
					}
					return;
				}else if((!n || html.style(n, "display") === "none") && inColDelta){
					if((col + inRowDelta) >= 0 && (col + inRowDelta) <= cc){
						this.move(inRowDelta, inColDelta > 0 ? ++inColDelta : --inColDelta);
					}
					return;
				}
				this.setFocusIndex(row, col);
				if(inRowDelta){
					this.grid.updateRow(r);
				}
			}
		}
	},
	previousKey: function(e){
		if(this.grid.edit.isEditing()){
			event.stop(e);
			this.previous();
		}else if(!this.isNavHeader() && !this._isHeaderHidden()) {
			this.grid.domNode.focus(); // will call doFocus and set focus into header.
			event.stop(e);
		}else{
			this.tabOut(this.grid.domNode);
			if (this._colHeadFocusIdx != null) { // clear grid header focus
				html.toggleClass(this._findHeaderCells()[this._colHeadFocusIdx], this.focusClass, false);
				this._colHeadFocusIdx = null;
			}
			this._focusifyCellNode(false);
		}
	},
	nextKey: function(e) {
		var isEmpty = (this.grid.rowCount === 0);
		if(e.target === this.grid.domNode && this._colHeadFocusIdx == null){
			this.focusHeader();
			event.stop(e);
		}else if(this.isNavHeader()){
			// if tabbing from col header, then go to grid proper.
			this.blurHeader();
			if(!this.findAndFocusGridCell()){
				this.tabOut(this.grid.lastFocusNode);
			}
			this._colHeadNode = this._colHeadFocusIdx= null;
		}else if(this.grid.edit.isEditing()){
			event.stop(e);
			this.next();
		}else{
			this.tabOut(this.grid.lastFocusNode);
		}
	},
	tabOut: function(inFocusNode){
		this.tabbingOut = true;
		inFocusNode.focus();
	},
	focusGridView: function(){
		util.fire(this.focusView, "focus");
	},
	focusGrid: function(inSkipFocusCell){
		this.focusGridView();
		this._focusifyCellNode(true);
	},
	findAndFocusGridCell: function(){
		// summary:
		//		find the first focusable grid cell
		// returns: Boolean
		//		true if focus was set to a cell
		//		false if no cell found to set focus onto
		
		var didFocus = true;
		var isEmpty = (this.grid.rowCount === 0); // If grid is empty this.grid.rowCount == 0
		if (this.isNoFocusCell() && !isEmpty){
			var cellIdx = 0;
			var cell = this.grid.getCell(cellIdx);
			if (cell.hidden) {
				// if first cell isn't visible, use _colHeadFocusIdx
				// could also use a while loop to find first visible cell - not sure that is worth it
				cellIdx = this.isNavHeader() ? this._colHeadFocusIdx : 0;
			}
			this.setFocusIndex(0, cellIdx);
		}
		else if (this.cell && !isEmpty){
			if (this.focusView && !this.focusView.rowNodes[this.rowIndex]){
				// if rowNode for current index is undefined (likely as a result of a sort and because of #7304)
				// scroll to that row
				this.grid.scrollToRow(this.rowIndex);
			}
			this.focusGrid();
		}else {
			didFocus = false;
		}
		this._colHeadNode = this._colHeadFocusIdx= null;
		return didFocus;
	},
	focusHeader: function(){
		var headerNodes = this._findHeaderCells();
		var saveColHeadFocusIdx = this._colHeadFocusIdx;
		if (this._isHeaderHidden()){
			// grid header is hidden, focus a cell
			this.findAndFocusGridCell();
		}
		else if (!this._colHeadFocusIdx) {
			if (this.isNoFocusCell()) {
				this._colHeadFocusIdx = 0;
			}
			else {
				this._colHeadFocusIdx = this.cell.index;
			}
		}
		this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		while(this._colHeadNode && this._colHeadFocusIdx >=0 && this._colHeadFocusIdx < headerNodes.length &&
				this._colHeadNode.style.display == "none"){
			// skip over hidden column headers
			this._colHeadFocusIdx++;
			this._colHeadNode = headerNodes[this._colHeadFocusIdx];
		}
		if(this._colHeadNode && this._colHeadNode.style.display != "none"){
			// Column header cells know longer receive actual focus.  So, for keyboard invocation of
			// contextMenu to work, the contextMenu must be bound to the grid.domNode rather than the viewsHeaderNode.
			// unbind the contextmenu from the viewsHeaderNode and to the grid when header cells are active.  Reset
			// the binding back to the viewsHeaderNode when header cells are no longer acive (in blurHeader) #10483
			if (this.headerMenu && this._contextMenuBindNode != this.grid.domNode){
				this.headerMenu.unBindDomNode(this.grid.viewsHeaderNode);
				this.headerMenu.bindDomNode(this.grid.domNode);
				this._contextMenuBindNode = this.grid.domNode;
			}
			this._setActiveColHeader(this._colHeadNode, this._colHeadFocusIdx, saveColHeadFocusIdx);
			this._scrollHeader(this._colHeadFocusIdx);
			this._focusifyCellNode(false);
		}else {
			// all col head nodes are hidden - focus the grid
			this.findAndFocusGridCell();
		}
	},
	blurHeader: function(){
		html.removeClass(this._colHeadNode, this.focusClass);
		html.removeAttr(this.grid.domNode,"aria-activedescendant");
		// reset contextMenu onto viewsHeaderNode so right mouse on header will invoke (see focusHeader)
		if (this.headerMenu && this._contextMenuBindNode == this.grid.domNode) {
			var viewsHeader = this.grid.viewsHeaderNode;
			this.headerMenu.unBindDomNode(this.grid.domNode);
			this.headerMenu.bindDomNode(viewsHeader);
			this._contextMenuBindNode = viewsHeader;
		}
	},
	doFocus: function(e){
		// trap focus only for grid dom node
		if(e && e.target != e.currentTarget){
			event.stop(e);
			return;
		}
		// don't change focus if clicking on scroller bar
		if(this._clickFocus){
			return;
		}
		// do not focus for scrolling if grid is about to blur
		if(!this.tabbingOut){
			this.focusHeader();
		}
		this.tabbingOut = false;
		event.stop(e);
	},
	doBlur: function(e){
		event.stop(e);	// FF2
	},
	doContextMenu: function(e){
	//stop contextMenu event if no header Menu to prevent default/browser contextMenu
		if (!this.headerMenu){
			event.stop(e);
		}
	},
	doLastNodeFocus: function(e){
		if (this.tabbingOut){
			this._focusifyCellNode(false);
		}else if(this.grid.rowCount >0){
			if (this.isNoFocusCell()){
				this.setFocusIndex(0,0);
			}
			this._focusifyCellNode(true);
		}else {
			this.focusHeader();
		}
		this.tabbingOut = false;
		event.stop(e);	 // FF2
	},
	doLastNodeBlur: function(e){
		event.stop(e);	 // FF2
	},
	doColHeaderFocus: function(e){
		this._setActiveColHeader(e.target,html.attr(e.target, "idx"),this._colHeadFocusIdx);
		this._scrollHeader(this.getHeaderIndex());
		event.stop(e);
	},
	doColHeaderBlur: function(e){
		html.toggleClass(e.target, this.focusClass, false);
	},
	_mouseDown: function(e){
		// a flag indicating grid is being focused by clicking
		this._clickFocus = dojo.some(this.grid.views.views, function(v){
			return v.scrollboxNode === e.target;
		});
	},
	_mouseUp: function(e){
		this._clickFocus = false;
	}
});
});
},
'dijit/_Templated':function(){
define("dijit/_Templated", [
	"./_WidgetBase",
	"./_TemplatedMixin",
	"./_WidgetsInTemplateMixin",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.extend lang.isArray
	"dojo/_base/kernel" // kernel.deprecated
], function(_WidgetBase, _TemplatedMixin, _WidgetsInTemplateMixin, array, declare, lang, kernel){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _WidgetsInTemplateMixin = dijit._WidgetsInTemplateMixin;
=====*/

	// module:
	//		dijit/_Templated
	// summary:
	//		Deprecated mixin for widgets that are instantiated from a template.

	// These arguments can be specified for widgets which are used in templates.
	// Since any widget can be specified as sub widgets in template, mix it
	// into the base widget class.  (This is a hack, but it's effective.)
	lang.extend(_WidgetBase, {
		waiRole: "",
		waiState:""
	});

	return declare("dijit._Templated", [_TemplatedMixin, _WidgetsInTemplateMixin], {
		// summary:
		//		Deprecated mixin for widgets that are instantiated from a template.
		//		Widgets should use _TemplatedMixin plus if necessary _WidgetsInTemplateMixin instead.

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  False by default.
		widgetsInTemplate: false,

		constructor: function(){
			kernel.deprecated(this.declaredClass + ": dijit._Templated deprecated, use dijit._TemplatedMixin and if necessary dijit._WidgetsInTemplateMixin", "", "2.0");
		},

		_attachTemplateNodes: function(rootNode, getAttrFunc){

			this.inherited(arguments);

			// Do deprecated waiRole and waiState
			var nodes = lang.isArray(rootNode) ? rootNode : (rootNode.all || rootNode.getElementsByTagName("*"));
			var x = lang.isArray(rootNode) ? 0 : -1;
			for(; x<nodes.length; x++){
				var baseNode = (x == -1) ? rootNode : nodes[x];

				// waiRole, waiState
				var role = getAttrFunc(baseNode, "waiRole");
				if(role){
					baseNode.setAttribute("role", role);
				}
				var values = getAttrFunc(baseNode, "waiState");
				if(values){
					array.forEach(values.split(/\s*,\s*/), function(stateValue){
						if(stateValue.indexOf('-') != -1){
							var pair = stateValue.split('-');
							baseNode.setAttribute("aria-"+pair[0], pair[1]);
						}
					});
				}
			}
		}
	});
});

},
'ibm/tivoli/tip/dijit/Caret':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/form/ComboBox"], function(dijit,dojo,dojox){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * (C) Copyright IBM Corp. 2008 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/

 dojo.provide("ibm.tivoli.tip.dijit.Caret"); 

dojo.require("dijit.form.ComboBox");

/**
 * Caret. 
 *
 * @author: Marco Lerro (marco.lerro@it.ibm.com)   
 */
dojo.declare(
    "ibm.tivoli.tip.dijit.Caret",
	[dijit.form.ComboBoxMixin],
	{
	    /** the DOM node to manage */
	    _node: null,
	    
	    /**
	     * Constructor.
	     */
	    constructor: function(node)
	    {
	        this._node = node;
	    },
	    
        /**
         * Returns the caret position.
         */
        getPosition: function()
		{
			return this._getCaretPos(this._node);
		},
		
		/**
         * Sets the caret position.
         */
		setPosition: function(index)
		{
		    this._setCaretPos(this._node, index);
		}
	}
);

});

},
'ibm/tivoli/simplesrm/srm/dijit/Overview/RequestsPod':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!ibm/tivoli/simplesrm/srm/dijit/Overview/Pod,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,dojo/DeferredList,ibm/tivoli/simplesrm/srm/dijit/BaguetteChart,ibm/tivoli/simplesrm/srm/dijit/MyCatalogRequestsGrid"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsPod");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsView");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestDetails");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestRefresh");

dojo.require("ibm.tivoli.simplesrm.srm.dijit.Overview.Pod");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("dojo.DeferredList");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.BaguetteChart");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyCatalogRequestsGrid");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsPod", ibm.tivoli.simplesrm.srm.dijit.Overview.Pod,
{
	viewType: "ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsView",
	detailsType: "ibm.tivoli.simplesrm.srm.dijit.Overview.RequestDetails",
	autoRefreshProperty: "RequestsAutoRefresh",
	//configurable Pod parms
	os: 'SRM_SR',   
    sr_object: 'SR',   
	fd: '', //'SRM_SRUSRLIST'
	view_dialog: 'srmssviewsr',	
	label: "",
	cols: '',
	
	postMixInProperties: function()
	{		
		console.log("Overview.RequestsPod.postMixInProperties os = " + this.os + " fd = "+ this.fd + " view_dialog = " + this.view_dialog + " ticket_object = " + this.sr_object );
		try {
		   //Get Pod headings from bundle
		   var key = this.sr_object +  'RequestPodHeading'; //default bundle key = SRRequestPodHeading
		   this.heading = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable")[key];
		   
		   var key = this.sr_object + 'ShowMyRequestsLink';  
		   this.detailsLinkLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable")[key];
		   this.detailsUrl = "#requests";
		} catch(ex) {
			 console.log("Overview.RequestsPod.postMixInProperties - " + ex);
			 //Use control label as heading as last resort 
			 if ((this.heading==null || this.heading=="") && this.label!=null && this.label.length>0)
			     this.heading = this.label;
			 else
				 this.heading = "My Requests";
			 this.detailsLinkLabel = "Show All My Requests...";
		}
		
		this.inherited(arguments);
	},

	constructor: function()
	{
		console.log("Overview.RequestsPod.constructor ");
		if(invalidRequestGridColumnName != "")
		{
			//alert("Columns : "+invalidRequestGridColumnName+", configured for the 'Show All My Requests' dialog in the My Requests Pod do not exist. Edit the Self Service Center application and correct the columns property.");
			var invalidCol1 = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").InvalidColumn1;
			var invalidCol2 = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").InvalidColumn2;
			alert(invalidCol1 +" "+invalidRequestGridColumnName +", "+invalidCol2);
		}
		//dojo.subscribe("refreshpod", this, "_poll");  //not used now that  RequestRefresh is called when create SR dialog button is clicked 				
	},

	postCreate: function()
	{
		//ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsPodID = this.id;
		var params = [];
		params._maxItems=10; //Get 10 at startup		
		this.refresh(params);
		this.inherited(arguments);
	},
	/**
	 * Requery my data and update my UI
	 */
	refresh: function(params) {
		console.log("RequestsPod.refresh()");
		this._cancelPoll();
		if (params==undefined) 
		   params = [];
		if (this.fd && this.fd!='')
		   params._fd = this.fd;  //filtering domain
		params.os = this.os;   //OS name
		params.sr_object = this.sr_object;  //Main object
		
		if (!params._maxItems)  //Get 500 max if amount not passed in
		   params._maxItems=500;  
		
		var amt = parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty("MaxRequestsPodRecords"),10);
		if (!isNaN(amt) && amt > 0) {
         params._maxItems=amt;  
		}
		params._orderbydesc="changedate";	

		var dq = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getServiceRequests(params);
		dq.addCallbacks(dojo.hitch(this, this._updateData), dojo.hitch(this, this._refreshError));
	},

	/**
	 * Update the UI, given a new data set
	 */
	_lastRequestId : null,	 
	_updateData: function(response)
	{
		try {
			this._cancelPoll();
			this._refreshErrorCount = 0;
			var requests = response.Requests;
			if(this._detailsData === requests){
				return;
			}
			requests.sort(function(a, b) 
			{
				// sort descending
				return a.CHANGEDATE < b.CHANGEDATE ? 1 : a.CHANGEDATE > b.CHANGEDATE ? -1 : 0;
			});
			if (requests.length>0) {
				var dt = dojo.date.stamp.fromISOString(requests[0].CHANGEDATE);
				//shouldn't have to do this. However rest is ignoring seconds so it is returning the latest when it shouldn"t. That's a tpae bug.
				dt = dojo.date.add(dt, "minute", 1);  
				if(dt) {
					this._mostRecent = dt.getTime();
					this._lastRequestId = requests[0].TICKETUID;					 
				}
			}
			this._detailsData = requests;
			this._view.setData(requests);
			this._onDataReady();
		}
		catch(ex) {
			ibm.tivoli.logger.error("RequestsPod._updateData failure",ex);
		}
		finally {
			this._resetPoll();
		}
	},
	_poll: function()
	{
		console.log("RequestsPod._poll");
		var params = [];
		if (this.fd && this.fd!='')
		   params._fd = this.fd;  
		params.os = this.os;
		params.sr_object = this.sr_object;

		//Poll for new SRs or SRs that have changed
		//Get any SRs with a CHANGEDATE newer than most recent or ticketud > last one
		if(this._lastRequestId != null) {		 
			var lastChangeDate = dojo.date.stamp.toISOString(new Date(this._mostRecent));  	
			params.changedate= "~gt~" + lastChangeDate;			 
			params.ticketuid= "~gt~" + this._lastRequestId;
			params._opmodeor="1";
		}
 		
		var dq = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getServiceRequests(params);
		dq.addCallbacks(dojo.hitch(this, this._checkUpdateSR), dojo.hitch(this, this.__refreshError));
	},
	
	_checkUpdateSR: function(response)
	{
		this._cancelPoll();
		var requests = response.Requests;
		//Any new or modified SRs? 	 
		if(requests.length > 0 )		 
		//if(requests.length > 1 || (requests.length > 0  && this._lastRequestId == null) || (requests.length == 0  && this._lastRequestId != null))   	
			this.refresh();
		else
			this._resetPoll();
		
	},
	_onDataReady: function()
	{
		this.inherited(arguments);
	},	
		
	//Show All My Requests clicked
	onShowDetails: function()
	{
		var bNeedsConnect = undefined == this._details;

		// temporary 
		var col = dojo.fromJson(unescape(this.cols));
		colAttrNameArray = [];
		colAttrNameArray = new Array(col.cols.length);
		for (var colIter = 0; colIter < col.cols.length; colIter++) {
		    colAttrNameArray[col.cols[colIter].name.toUpperCase()] = col.cols[colIter].description;
		}
		
		//this.inherited(arguments);
		
		// lazy create
		if(!this._details) {
			dojo["require"](this.detailsType);
			//dojo.require(this.detailsType);		
			//dojo._loadModule(this.detailsType);
			
			var cls = dojo.getObject(this.detailsType);
			this._details = new cls({headingText: this.detailsLinkLabel});
		} else {
			if (this._details.detailsWidget.toolBar) //clear search field 
				this._details.detailsWidget.toolBar.searchField.searchField.value = "";
		}
		
		this._details.refresh(this._detailsData);
		this._details.show();			
		
		if(bNeedsConnect && this._details) {	// only connect once
			this.connect(this._details.detailsWidget, "onRefresh", this._updateData);
		}
		//pass view dialog and ObjectStructure parms to Grid 
		if (this._details && this._details.detailsWidget._setViewDialog) { 
			this._details.detailsWidget._setViewDialog(this.view_dialog);
			this._details.detailsWidget._setFD(this.fd);
			this._details.detailsWidget._setOS(this.os);
			this._details.detailsWidget._setTicketObject(this.sr_object);						 
		}
		
		this._details.detailsWidget.refresh(true); //Get to get all SRs for user
	}
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsView", 
		[ibm.tivoli.simplesrm.srm.dijit.Overview.View, ibm.tivoli.simplesrm.srm.dijit.ShowRequestDetails],
{
	widgetsInTemplate: true,
	templateString: '<div>\n' +
					'	<div dojoType="ibm.tivoli.simplesrm.srm.dijit.BaguetteChart" barHeight="15" captionHeight="13" captionFontSize="10"\n' + 
					'			showTotal="true" totalLegend="${totalStr}"\n' + 
					'		dojoAttachPoint="baguetteChart" style="overflow:hidden; margin-bottom: 10px;"></div>\n' +
					'	<div dojoType="ibm.tivoli.simplesrm.srm.dijit.Overview.DataTable" dojoAttachPoint="dataTable" heading="${tableCaption}"></div>\n' +
					'</div>\n',
	tableCaption: "",
	totalStr: "Total",
	showDetais: "Show details",
	view_dialog: "srmssviewsr",
	constructor: function()
	{
		console.log("Overview.RequestsView.ctor");
	},
	postMixInProperties: function()
	{
		console.log("Overview.RequestsView.postMixInProperties");
		this.tableCaption = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").RecentActivity;
		this.totalStr =     dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Total;
		this.showDetails =	dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").ShowDetails;
		this.inherited(arguments);
	},
	
	//Store data in Pod view
	setData: function(requests)
	{
		this.clear();

		//get sr/incident status count
		if ( requests && requests.length>0) {
			sendXHREvent("pmsc_getTicketStatusCount", "my_requests_pod", this.getParent().sr_object, REQUESTTYPE_HIGHASYNC, "json", "application/json",  //hardcoding pod id is not good
				dojo.hitch(this,this._getTicketStatusCount),				
			   	function(response) {
			           console.error("RequstsPod.setData() - sendXHREvent error - " + response);
		        }
		    );
	    }							
		
		this._detailsData = requests;
		//var status_stats = {srm_status_count: [], srm_unique_stati: 0};
		var l = requests.length;
		var maxoverview =  Math.min(5, l);  //only show most recent 5
		for(var i = 0; i < l; ++i) {
			var cmr = requests[i];
			var status = cmr.StatusString;
			if(i < maxoverview) {
				var desc = cmr.DESCRIPTION;
				if (desc) {
					desc = dojo.trim(desc);
					if (desc.length > 100)  //truncate at 100 even though field len is 100
					   desc = desc.substring(0,100) + "...";
				}
				var newdesc = desc; 
					//If no spaces, then we add one so html will wrap
				if (desc && desc.length> 50 && (desc.indexOf(" ")<0 || desc.indexOf(" ")>50 ) ) {		   
					   newdesc = desc.substring(0,50) + " " + desc.substring(50);				   	
				}
				var link = "<a href='#req_"+ cmr.id +"' title='"+this.showDetails.htmlencode()+"'>" +(newdesc ? newdesc.htmlencode() : '...')+ "</a>";
				this.dataTable.addRow(link, status);  //add SR row to table
			}
			/*if('number' == typeof status_stats.srm_status_count[status]) {
				++status_stats.srm_status_count[status];
			}
			else {
				status_stats.srm_status_count[status] = 1;
				++status_stats.srm_unique_stati;
			}*/
		}
		if(l > 0) {
			var links = dojo.query("a", this.dataTable.domNode);
			for(var i = 0; i < links.length; ++i) {
				this.connect(links[i], "onclick", this._showRequestDetails);
			}
		}
		if(l > 0){
			//this._refreshBaguetteChart(status_stats);
		}
		else{ 
			this.dataTable.addRow(dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").NoRecentActivity, "");
		}
	},
	
	//Process server async call to get count of SR/incident status for baguette 
	_getTicketStatusCount: function(response) {
		console.log("Navigator._getSRStatusCount_resp:" + response);
		var domain = this.getParent().sr_object + "STATUS";  //SRSTATUS or INCIDENTSTATUS 
		var statusMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable(domain);
		var status_stats = {srm_status_count: [], srm_unique_stati: 0};
		for (var status in response) {			
			status_stats.srm_status_count[statusMap.descriptionByValue(status)] = response[status];
		}
		status_stats.srm_unique_stati = status_stats.srm_status_count.length;
		this._refreshBaguetteChart(status_stats);
	},
	

	//launch View SR dialog 
	_viewSR: function(ticketUID)  
	{ 
		console.log("RequestsPod._viewSR: launch dialog - " + this.view_dialog + " ticketUID = ",ticketUID);
		//var node = dojo.byId(this.id);
		arguments.caller=null; //running into a IE bug in stacktrace()		
		var navid = "mx107";
	    var nav = dojo.query("div.srmnavigator");  //use id of navigator
	    if (nav.length>0)
		    navid = nav[0].id;	    
		sendEvent(this.view_dialog,  navid,  ticketUID);
	},
	clear: function()
	{
		this.dataTable.clear();
		if(this.baguetteChart){
			this.baguetteChart.setData([]);
		}
	},	
	_refreshBaguetteChart: function(status_stats)
	{
		if(!this.baguetteChart){
			return;
		}

		console.log("Overview.RequestsView._refreshBaguetteChart: refreshing");

		var counts = status_stats.srm_status_count;
		counts.sort();
		// set stripe graph data using colors generated by walking around the color wheel
		var stripeData = [];
		for(var s in counts) {
			stripeData.push({name: s, value: counts[s], color: ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.getDefaultColor(s)});
		}
		this.baguetteChart.setData(stripeData);
	},
	_showRequestDetails: function(evt)
	{
		console.log(evt);
		try {
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			var href = evt.target.href;
			var reqid = href.substring(href.lastIndexOf("_")+1);
			console.log("RequestsPod._showRequestDetails(%s)", reqid);
			for(var i = 0; i < this._detailsData.length; ++i) {
				var req = this._detailsData[i];
				if(reqid == req.id) {
					console.log("RequestsPod._showRequestDetails reqid = ", req.id);
					if (product!=null && product.indexOf("srm")>=0)
						this._viewSR(reqid);
					else
						this.showRecordDetails(req);
					break;
				}
			}
		}
		catch(ex){
			console.warn(ex);
		}
	}
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestDetails", ibm.tivoli.simplesrm.srm.dijit.Overview.Details,
{
	headingText: "Manage Requests",
	detailsType: "ibm.tivoli.simplesrm.srm.dijit.MyCatalogRequestsGrid",
	
	_cshKey: "",
	
	constructor: function()
	{
		//var key = "SR" + "MyRequests";
		/*
		var key = this.sr_object +  'RequestPodHeading';
		try {			  
		    this.headingText = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable")[key];
		} catch(ex) {
			console.log("Overview.RequestDetails.constructor - " + ex);
			this.headingText = "My Requests";
		}
		if (this.headingText==undefined) {
			console.log("Overview.RequestDetails.constructor:  undefined key - " + key);
			this.headingText = "My Requests";
		}
		*/

		var localText = dojo.locale;
		var localMatch = localText.match(/-/gi);
		if(localMatch != null)
		{
			localText = localText.split('-')[0];
		}
		
      this._cshKey = "/help/index.jsp?topic=/com.ibm.sccd.doc/selfserv/c_my_requests_pod.html";
		//this._cshKey = "/maximohelp/"+localText+"/mergedProjects/srmssctr/helpmyrequestpodgrid.htm";
	},
	refresh: function(data_set)
	{
	     //startup not called in dojo 1.4!  added this code 		
		if (this.detailsWidget && this.detailsWidget._initialization_complete!=undefined && this.detailsWidget._initialization_complete!= true) {
			console.log("RequestsPod.Overview.RequestDetails - start MyRecordsGrid");
			this.detailsWidget.startup();
		}
		
		if(data_set) {
			this._detailsData = data_set;
			this.detailsWidget.clearGrid();
			this.detailsWidget._loadGrid(this._detailsData);
		}
		else {
			this.inherited(arguments);	// will refresh detailsWidget
		}
	},
	resize: function()
	{
		this.inherited(arguments);
		//var containerSz = dojo.contentBox(this.containerNode)
		//dojo.style(this.detailsWidget.id + "_grid_container", "height", containerSz.h + "px");
		this.detailsWidget.simpleGrid.resize();
		this.detailsWidget.baguetteChart.resize();
	}
});

//ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsPodID = null;  //Is there an easier way to get pointer to Pod?

//This is used to refresh the My Requests Pod
//Called from mxeventjshandler srmbutton property (when button is clicked)
ibm.tivoli.simplesrm.srm.dijit.Overview.RequestRefresh = function(comp, eventType, eventValue, requesttype, piggyBack) {
    console.log('ibm.tivoli.simplesrm.srm.dijit.Overview.RequestRefresh: comp.id=' + comp.id + ', eventType=' + eventType + ', eventValue=' + eventValue + ', requesttype=' + requesttype + ', piggyBack=' + piggyBack);
    var ws = dijit.registry.byClass("ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsPod");  //returns WidgetSet
    ws.forEach(function(pod, index, hash){    	
    	//var pod = dijit.byId(ibm.tivoli.simplesrm.srm.dijit.Overview.RequestsPodID);
        if (pod.sr_object=='SR') {  //not ideal
        	pod._cancelPoll();  	 
        	window.setTimeout( function(){ pod._poll(); return null; }, 1000 );  //wait until server does it's work    	
        }
    	  
   	});    
    
	return REQUESTTYPE_SYNC;
};
});

},
'ibm/tivoli/simplesrm/srm/dijit/ListTree':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dijit/_Widget,dijit/_Templated,dijit/_Container,dojo/fx,dijit/_base/place,ibm/tivoli/simplesrm/srm/dojo/Hoverer,ibm/tivoli/simplesrm/srm/dojo/Utilities"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ListTree");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ListItem");

dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit._Container");
dojo.require("dojo.fx");
dojo.require("dijit._base.place");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Hoverer");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Utilities");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

/**
it's html representation of ListTree node. this code was removed from ListTree
to simplify the creation of DOM nodes. after creation instance of
this widget is stored as a field in ListTree object.
note that for legacy issues ListTree.domNode==ListItem.domNode
*/
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ListItem", 
		[dijit._Widget,dijit._Templated], 
{	
	_uiStringTable: null,
	templateString:"<div class=\"ListItem ${itemStyle}\" tabindex=\"0\">\n<!--\n @HTML_LONG_COPYRIGHT_BEGIN@\n @HTML_LONG_COPYRIGHT_END@\n-->\n<table><tr>\n\t<td class='icon' style='width: ${iconWrapperSize}px;'>\n\t\t<img  src=\"${icon}\" alt=\"\" class=\"${iconClass}\" style='width: ${iconSize}px;'></img>\n\t</td>\n\t<td class='content'>\n\t\t<p class='label'>${label}</p>\n\t\t<div class='description'>${description}</div>\n\t\t<img src=\"${icon2}\" alt=\"\" />\n\t</td>\n\t<td class='sprite'>\n\t\t<div dojoattachpoint=\"iconNode\" class='sprite' title=\"${iconTitle}\" >\n\t\t\t<span dojoattachpoint=\"iconTextNode\" class='alternativeText' title=\"${iconTitle}\">${iconText}</span>\n\t\t</div>\n\t</td>\n</tr></table>\n</div>\n",
	label: null,
	description: null,
	icon: null,
	icon2: null,
	iconSize:0,	
	iconClass: "",
	iconWrapperSize: 0,
	
	iconTextBranch: ">",
	iconTextLeaf: "*",
	iconText: null ,
		
	iconTitle:null,	
	iconTitleBranch:null,
	iconTitleLeaf:null,
	
	itemStyle: null,
	itemStyleBranch: "branch",
	itemStyleLeaf: "leaf",
	
	isBranch: false,
	ClassStructureID:null,  //D29365
	
	constructor: function(){
		this._uiStringTable= dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
		this.iconTitleLeaf= this._uiStringTable["Panel"];
		this.iconTitleBranch= this._uiStringTable["Directory"];
		this.iconText = this.iconTextLeaf;
		this.iconTitle = this.iconTitleLeaf;
		this.itemStyle = this.itemStyleLeaf;
	},
	toBranch: function(){
		if(!this.isBranch){
			this.iconText = this.iconTextBranch;
			this.iconTitle = this.iconTitleBranch;
			this.itemStyle = this.itemStyleBranch;
			this.isBranch = true;
			this.refresh();
		}
	},
	toLeaf: function(){
		if(this.isBranch){
			this.iconText = this.iconTextLeaf;
			this.iconTitle = this.iconTitleLeaf;
			this.itemStyle = this.itemStyleLeaf;
			this.isBranch = false;
			this.refresh();
		}
	},
	noIcon: function(){
			this.iconText = "";
			this.iconTitle = "";
			this.itemStyle = "";
			this.isBranch = "";
			this.refresh();
	},
	refresh: function(){
		dojo.attr(this.iconNode,"title", this.iconTitle);
		dojo.attr(this.iconTextNode,"title", this.iconTitle);
		this.iconTextNode.firstChild.nodeValue = this.iconText;
		dojo.removeClass(this.domNode, this.itemStyleBranch);
		dojo.removeClass(this.domNode, this.itemStyleLeaf);
		dojo.addClass(this.domNode, this.itemStyle);
	}
});


// TODO: ListTree is too tied to the data structure we return from maximo
// need to define ListTree's data and decouple the two

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ListTree", 
	[dijit._Widget], 
{	
	label: "",					// the label shown in the tre
	description: "",			// the optional description, shown below the label
	fullDescription: "",
	icon: "",					// the icon filename
	icon2: "",
	data: null,					// the whole object passed in.  Kept for reference
	_loaded:false,              // Used in Browse Solutions link to load list item which folder clicked on  
	iconPath: "",				// path to the icon files
	iconSize: "",				// icon size, in pixels
	iconClass: "",				// icon class
	defaultIconSize: 48,		// default icon size, in pixels
	fillOrder: "ColMajor",		// RowMajor, ColMajor, or any other class you want to write CSS for
	colCount: 1,				// how many columns of data
	_crossFader: null,			// dojo._Animation object that handles the cross fade
	_xfadeend_handle: null,		// event connection handle for cross fade animation onEnd
	_connHandles: null,			// my event connection handles
	_flymgr: null,				// handles the popup long description
	_scrollbarWidth: 0,			// width of the browser's scrollbars
	
	listItemWidget: null,		//read only, filled in _buildItemDomNodes
	
	// teach this ListTree how to parse its data
	keyField: '',				// the data field that is the unique key/index
	labelField: '', 			// the data field holding the label
	descField: '',			// the data field holding the description
	iconField: '',			// the data field holding the path to the icon file
	iconSizeField: '',		// the data field holding the icon size
	iconClassField: '',
	childField: '',			// the data field holding the children sub-trees of the current node
	leafField: '',			// the data field holding the chilren leaf-nodes of the current node	
	toolTip: false,         //if true,  use Dojo tooltip 
	hideDescription: false, //Hide the description
	type: '',               //type of link item (7.5)
	target: '',             //target of type (7.5)
	
	// ******** lifecycle methods ********
	constructor: function(/*object*/params, /*domnode?*/domNode) 
	{
		//console.log("ListTree.ctor");
		this.containerNode = null;	// the div containing the rendered list
		this.listNode = null;		// the ul implementing the rendered list
		this.subitems = [];			// the sub-ListTrees that are my list items
		this.parentList = null;		// my parent list in the tree
		this.activeList = null;		// the currently active list.  only populated in the root node of the tree
		this._xfadeDuration = 300;
		this._connHandles = [];
	},
	startup: function() 
	{
		//console.log("ListTree.startup");
		this.inherited(arguments);
		this._crossFade(null, this);
	},
	buildRendering: function()
	{
		this.inherited(arguments);	
		this._buildListDomNodes();
	},
	// dojo 1.2 book I have says to override uninitialize, but
	// the dojo version we have here calls destroy
	destroy: function()
	{
		console.log("ListTree.destroy");
		if(this._flymgr) {
			this._flymgr.destroy();
		}
		var h;
		while(h = this._connHandles.pop()) {
			dojo.disconnect(h);
		}
		this.inherited(arguments);
	},
	setIconPath: function(/*string*/path)
	{
		this.iconPath = path;
		if(path.charAt(path.length-1) != '/') {
			this.iconPath += '/';
		}
	},
	getIconPath: function()
	{
		return this.getTreeRoot().iconPath;
	},
	// ******  tree building methods *********
	// add the children of the given object to this tree node
	addChildren: function(/*obj*/ofThisObj, /*string?*/ fillOrder, /*integer?*/ colCount)  {
		// walk the incoming data array, creating the sub-tree of ListTree objects
		
		//console.group(this.label, ": add Children");
		if((ofThisObj[this.childField] && ofThisObj[this.childField].length > 0) ||
			(ofThisObj[this.leafField] && ofThisObj[this.leafField].length > 0)	) {
			// adding children may change this node from a leaf to a branch node
			
			if(this.listItemWidget) {
				this.listItemWidget.toBranch();
			}
			if(!fillOrder || !dojo.isString(fillOrder)) {
				fillOrder = this.fillOrder;
			}
			else {
				this.fillOrder = fillOrder;
			}
			colCount = parseInt(colCount,10);
			if(isNaN(colCount)) {
				colCount = this.colCount;
			}
			else {
				this.colCount = colCount;
			}
			var subarrays = [ofThisObj[this.childField], ofThisObj[this.leafField]];
			for(var k in subarrays) {
				var childArray = subarrays[k];
				if(!childArray){
					continue;
				}
				dojo.forEach(childArray, dojo.hitch(this, function(child) { 
					childitem = new ibm.tivoli.simplesrm.srm.dijit.ListTree({
							fillOrder: fillOrder, colCount: colCount,
							keyField: this.keyField, labelField: this.labelField, descField: this.descField, iconField: 
							this.iconField, childField: this.childField, leafField: this.leafField, toolTip: this.toolTip});
					childitem.data = child;
					
					var label = child[this.labelField].htmlencode(); 
					
					if(child.spaces){
						label+=" ";
						for(i=0;i<child.spaces;i++){
							label+="&nbsp;&nbsp;&nbsp;";
						}
					}
															
					childitem.label = label;		
					childitem.hideDescription = child.hideDescription;
					
					if(child[this.descField]) {						
						var d = child[this.descField];
						
						d = d.replace("$protocol$:",window.location.protocol);
						d = d.replace("$hostname$",window.location.hostname);
						d = d.replace("$port$",window.location.port);
						childitem.fullDescription = d;
						
						d =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().truncate(d);  //truncate description						
						childitem.description = d;
					}
					else {
						childitem.description = "&nbsp;";
					}
					
					// if no icon is given, use the parent's
					childitem.icon = child[this.iconField] ? child[this.iconField] : this.icon;
					if (childitem.icon.indexOf("undefined")>=0)  //fix this for IE
						childitem.icon="";
					childitem.iconSize = (undefined !== this.iconSizeField && typeof child[this.iconSizeField] == "number") ? child[this.iconSizeField] : this.defaultIconSize;
					
					childitem.iconClass = (undefined !== this.iconClassField && this.iconClassField!="") ? child[this.iconClassField] : "";
					
					if (child["ClassStructureID"])  //D29365
						childitem.ClassStructureID = child["ClassStructureID"];

					if(child["ImagePath2"])
						childitem.icon2 = child["ImagePath2"] ;
					
					//new 7.5 config parms
					if(child["type"])
						childitem.type = child["type"] ;
					if(child["target"])
						childitem.target= child["target"] ;
					
					//console.log("child.icon = ", childitem.icon);
					this.subitems.push(childitem);			// add the new ListTree node to my sublist
					childitem.parentList = this;			// back-pointer to the new node's parent ListTree
					// TODO: eventyally handle boh sub-trees and leaf-nodes
					if(child[this.childField] || child[this.leafField]) {
						childitem.addChildren(child);	// down another level
					}
				}));
			}
		}
		//console.groupEnd();
	},
	
	
	
	removeChildren: function()
	{
//		if(this.getActiveList() == this) {
//			this.popList();
//		}
		var item;
		while(item = this.subitems.pop()) {
			console.group("removing ", item.label);
			item.removeChildren();
			if(item.containerNode) {
				item.containerNode.parentNode.removeChild(this.containerNode);
				item.containerNode = null;
			}
			item.destroy();
			console.groupEnd();
		}
		if(this.containerNode) {
			this.containerNode.parentNode.removeChild(this.containerNode);
			this.containerNode = null;
		}
	},
	
	
	_buildItemDomNodes: function()
	{
		//console.log("Treelist._buildItemDomNodes(%s)[%s]", this.label, this.icon);
		// the list item
		var cell = document.createElement('td');
	
		var description = this.hideDescription && this.toolTip ? "" : this.description;
		var itemNode = new ibm.tivoli.simplesrm.srm.dijit.ListItem({
				label: this.label,		
				description: description,
				icon: this.icon,
				icon2: this.icon2,
				iconSize: this.iconSize,
				iconClass: this.iconClass,
				iconWrapperSize: this.iconSize + 2
				});
		this.listItemWidget = itemNode;
		this.domNode = itemNode.domNode;//there's code that depends on it
		var node = itemNode.domNode;
		cell.appendChild(node);
		
		if(this.hideDescription) {
			dojo.addClass(node, "");
			itemNode.noIcon();
		}
		else 
		{	
			if(this.subitems.length === 0) {
				dojo.addClass(node, "leaf");
				itemNode.toLeaf();
			}
			else {
				dojo.addClass(node, "branch");
				itemNode.toBranch();
			}
		}
		
		this._connHandles.push(dojo.connect(node, 'onkeypress', dojo.hitch(this, '_onEnterKeyPressed')));
		this._connHandles.push(dojo.connect(node, 'onclick', dojo.hitch(this, '_onclick')));
		this._connHandles.push(dojo.connect(node, 'onmouseover', dojo.hitch(this, '_onmouseover')));
		this._connHandles.push(dojo.connect(node, 'onmouseout', dojo.hitch(this, '_onmouseout')));
			
		return cell;
		
		/*
		//TODO: remove previous version of this method
		// the list item
		var cell = document.createElement('td');
		var itemnode = this.domNode = document.createElement("div");  
		cell.appendChild(itemnode);
		if(this.subitems.length == 0) {
			dojo.addClass(itemnode, "leaf");
		}
		else {
			dojo.addClass(itemnode, "branch");
		}
		dojo.addClass(itemnode, "ListItem");

		s = "<table><tr>"
			+ "<td class='icon' style='width:"+(this.iconSize+2)+"px;'><img src='" + this.icon +"' style='width:"+this.iconSize+"px;'></td>"
			+  "<td class='content'>\n"
			+  "<p class='label'>" + this.label + "</p>\n"
			+  "<div class='description'>" + this.description + "</div>\n"
			+  "</td>\n"
			+  "<td class='sprite'><div class='sprite'></div></td>\n"
			+ "</tr></table>";
		itemnode.innerHTML = s;
		//console.log(li.innerHTML);
		
		dojo.attr(itemnode,"tabindex", 0);
	
		// wire it up
		this._connHandles.push(dojo.connect(itemnode, 'onkeypress', dojo.hitch(this, '_onEnterKeyPressed')));
		this._connHandles.push(dojo.connect(itemnode, 'onclick', dojo.hitch(this, '_onclick')));
		this._connHandles.push(dojo.connect(itemnode, 'onmouseover', dojo.hitch(this, '_onmouseover')));
		this._connHandles.push(dojo.connect(itemnode, 'onmouseout', dojo.hitch(this, '_onmouseout')));
			
		return cell;
		*/
	},
	
	//build the DOM node for the tree item
	_buildListDomNodes: function() 	{
		//console.log("ListTree._buildListDomNodes(%s)", this.label);
		if(this.subitems.length > 0 && !this.containerNode) {	// this list hasn't been rendered in the DOM yet
			
			//get Long Descriptions from server for items in folder that don't have any  
			var itemids = [];
			//get array of itemids (LD keys)
			dojo.forEach(this.subitems, dojo.hitch(this, function(item) {  
			      if (item.fullDescription=="" ) {  //No  Long Description
			          //skip top level nodes or folders
	                  if (!(item.parentList==null || item.parentList.parentList==null || item.subitems.length>0)) {
	                	  var key = item.data.ItemID;   //Offering id
	                	  if (key!=undefined) {
	                		  itemids.push(key);
	                	  }
	                  }
			      }
			}));
						
			if (itemids.length>0) {
				//sort ids
				itemids.sort(function(a, b) {
							if(a<b) {return -1;}
							if(a>b) {return 1;}
							return 0;
				});	
				
				var count = 0;
				
			    //get 50 LDs at a time from server
				while (count < itemids.length) {
					var params = {};
					var itemidsgrp = [];
					if (count+50 < itemids.length) {
						//get next 50
						itemidsgrp = itemids.slice(count, count+50);
                        count = count+50;   					
					} else {
						//get last few
						itemidsgrp = itemids.slice(count);
						count= count+50;
					}
					params.ldkey=itemidsgrp;
	                params["ldkey.ormode"]=1;
	                params._exactmatch=0;

	                params.ldownertable = "ITEM";
	                params.ldownercol = "DESCRIPTION";
					params._compact=1;
					params.sync = true;				
					params._includecols="ldkey,ldtext";
					if (ibm.tivoli.tpae.dojo.data._langcode!=null &&  ibm.tivoli.tpae.dojo.data._langcode.length>0) {
						params.langcode = ibm.tivoli.tpae.dojo.data._langcode;
			        } else {
			        	params.langcode = dojo.locale.toUpperCase();
			        }
					
					//Get LongDescriptions
				    var deferred  =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMbo("LongDescription",params);
		            if (deferred) {
			            deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
			    	       if (response.LONGDESCRIPTIONMboSet.rsCount>0) {
				    
				                 //Add LD to Offering
				                 dojo.forEach(this.subitems, dojo.hitch(this, function(subitem) {  
	                             var subitem_id = subitem.data.ItemID;   //Offering id 
	                            //Do we have a LD for this subitem?
				   			       if (subitem_id !=undefined && dojo.indexOf(itemidsgrp,subitem_id)>=0) { 
	                                  for (var i=0;i<response.LONGDESCRIPTIONMboSet.rsCount;i++) { 
	                                     var itemid =  response.LONGDESCRIPTIONMboSet.LONGDESCRIPTION[i].LDKEY;
	                                     var ld = response.LONGDESCRIPTIONMboSet.LONGDESCRIPTION[i].LDTEXT;			   	                	     
				   	                	 if (subitem_id==itemid && ld) {	 	  
				   	    			    	     subitem.fullDescription = ld;			   	    					  
				   	    					     subitem.description =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().truncate(ld);
				   	    					     break;
				   	                     }
	                                  }
				   			       }			   			       
				   			     }));
			    	       }	    					         
			            }));
		            }	                	  	            			 
				   }  //end LD while loop
				} //end itemids if
                

			//get image names from server (imglib table) for items in folder that don't have any  
			itemids = [];
            var static_iconpath = dojo.moduleUrl(this.declaredClass.substring(0, this.declaredClass.lastIndexOf('.')), "images/icons/").toString();

			//get array of itemids (LD keys)
			dojo.forEach(this.subitems, dojo.hitch(this, function(subitem) {  
				  //if item imagename = 'getonserver' or item is a folder then get icon image from server  
			      if (subitem.icon.indexOf("getonserver")>=0  || subitem.subitems.length>0) { 
			          //skip top level nodes 
	                if (!(subitem.parentList==null || subitem.parentList.parentList==null )) { 	                	 
                      //Set default icon if not found on server
                      subitem.icon2 = static_iconpath + "transp.gif";
                      if (subitem.data.Category || subitem.data.Offering) {
                         imagename = "request_folder.png";
                      } else {
                         if (subitem.data.ItemNum)
                             imagename = "default_offering.png";
                         else if (subitem.data.Template)
                             imagename = "default_template.png";
                         else if (subitem.data.Solution)
                             imagename = "default_solution.png";
                         else
                             imagename = "default_offering.png";
                      }
                      subitem.icon = static_iconpath + imagename;                

	                	  var subitem_id = subitem.data.ItemID;   //Offering or classstructure id to retrieve  
	                	  if (subitem_id==undefined) {
	                		  subitem_id = subitem.data.ID;
	                	  }
	                	  if (subitem_id!=undefined && !isNaN(subitem_id)) {
	                		  itemids.push(subitem_id);
	                	  }
	                  }
			      }
			}));
						
			if (itemids.length>0) { //any images?
				//sort ids
				itemids.sort(function(a, b) {
							if(a<b) {return -1;}
							if(a>b) {return 1;}
							return 0;
				});	
				
				var count = 0;
								
				//get 50 images at a time 
				while (count < itemids.length) {
					var params = {};
					var itemidsgrp = [];
					if (count+50 < itemids.length) {
						//get next 50
						itemidsgrp = itemids.slice(count, count+50);
                        count = count+50;   					
					} else {
						//get last few
						itemidsgrp = itemids.slice(count);
						count= count+50;
					}
					params.refobjectid=itemidsgrp;
	                params["refobjectid.ormode"]=1; 

                    params._exactmatch=0;
                    params.refobject = "ITEM,PMSCOFFERING,CLASSSTRUCTURE";  //default sample offerings use ITEM but new offerings use PMSCOFERING. 
                    params._compact=1;
                    params.sync = true;				
                    params._includecols="refobjectid,imagename";

                    //Get imagenames
                    var deferred  =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMbo("IMGLIB",params);

                    if (deferred) {
                       deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
                          if (response.IMGLIBMboSet.rsCount>0) {
                             //Add image to Offering	   
                             dojo.forEach(this.subitems, dojo.hitch(this, function(subitem) {  //for each offering 
                                var subitem_id =  subitem.data.ItemID;   //Offering id
                                if (subitem_id==undefined) {
                                   subitem_id =  subitem.data.ID;  //Classstructure id   
                                }
                                if (subitem_id!=undefined && dojo.indexOf(itemidsgrp,subitem_id)>=0 ) {  //subitem without image			   	    	
                                   for (var i=0;i<response.IMGLIBMboSet.rsCount;i++) {   //find image for subitem
                                      var itemid =  response.IMGLIBMboSet.IMGLIB[i].REFOBJECTID;
                                      var imagename = response.IMGLIBMboSet.IMGLIB[i].IMAGENAME;                           

                                      if (imagename!=null && itemid==subitem_id) {  //Got an image and found the matching item
                                         imagename = imagename.replace(/\+/g, "%2B");  //encode +

                                         //we cache images and reuse itemid(refobjectid). This assumes that duplicate image names are the same image.
                                         var dontCacheImageNames = ibm.tivoli.tpae.dojo.data.getConfigProperty("DontCacheImageNames");  //if DontCachImageNames = true, we don't reuse image name
                                         if (dontCacheImageNames==null || dontCacheImageNames!='true' ) {                            	 
                                             if (!ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[imagename]) {  //cache image url data                            	
                                                ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[imagename] = {itemid: itemid};                            	
                                             } else {
                                                itemid =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[imagename].itemid;
                                             }   
                                         }

                                         //rest url to retrieve image                                        
                                         subitem.icon = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().baseRestUrl +   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().rest_context_root + "/rest/mbo/imglib/" + "?REFOBJECTID=" + itemid + "&imagename=" + imagename + "&_compact=true";
                                         break;
                                     }                        
                                 }	
                              }
                          }));
                       }	    					         
                    }));
                   } //end if deferred	                	  	            			 
						
				}  //end of image loop
		   }  //end of getting images
			
			var treeDomNode = this.getTreeRoot().domNode;

			// holds the list at this level of the tree
			this.containerNode = document.createElement('div');
			this.containerNode.id = this.id + "_cn_box";
			dojo.addClass(this.containerNode, "ListTree");
			dojo.style(this.containerNode, "position", "relative");
			dojo.style(this.containerNode, "display", "none");
			dojo.place(this.containerNode, treeDomNode, "last");

			this.listNode = document.createElement('div');
			this.listNode.id = this.id + "_listnode";
			dojo.addClass(this.listNode, "ListTree");
			dojo.addClass(this.listNode, this.fillOrder);
		
			var thelist = this.listNode;
/*
 * TODO: when i changed from a ul to a table implementation, I didn't have time to fix the colmajor code
 * so it won't render right
 */
			if("ColMajor" == this.fillOrder)
			{
//				// 2 columns filled column-major order
//				var itemCount = 0;
//				var itemsPerCol = this.subitems.length / 2;
//				dojo.forEach(this.subitems, dojo.hitch(this, function(item) {
//					var li = item._buildItemDomNodes();
//					dojo.place(li, thelist, "last");
//					if(++itemCount >= itemsPerCol) {
//						itemCount = 0;
//						dojo.place(thelist, this.containerNode, "last");
//						thelist = document.createElement('thelist');
//						dojo.addClass(thelist, "ListTree");
//						dojo.addClass(thelist, "ColMajor");
//					}	
//				}));
//				dojo.place(thelist, this.containerNode, "last");
//
//				var clearer = document.createElement("div");
//				dojo.style(clearer, "clear", "both");
//				dojo.style(clearer, "height", "0");
//				dojo.place(clearer, this.containerNode, "last");
			}
			else {
				// Fill in RowMajor
				//console.log("filling ", this.fillOrder);
				this.containerNode.appendChild(thelist);
				var tbl = document.createElement("table");
				dojo.addClass(tbl, "ListTree");
				dojo.addClass(tbl, this.fillOrder);
				thelist.appendChild(tbl);
				var tb = document.createElement("tbody");
				tbl.appendChild(tb);
				thelist = tb;
				// columns filled row-major order
				var itemCount = 0;
				var curr_row = null;
				dojo.forEach(this.subitems, dojo.hitch(this, function(item) {
					if(itemCount++ % this.colCount === 0) {
						curr_row = document.createElement("tr");
						thelist.appendChild(curr_row);
					}
					var one_item = item._buildItemDomNodes();
					curr_row.appendChild(one_item);
				}));
				if(itemCount % this.colCount !== 0 ) {
					var cell = document.createElement("td");
					cell.innerHTML = "&nbsp;";
					curr_row.appendChild(cell);
				}
				
			}
			// the tree's DOM nodes are in place, now wire up the flyover manager to the descriptions
			if (!this.toolTip) {  //no tooltip!
			    //this._flymgr = new ibm.tivoli.simplesrm.srm.dijit.ListTreeFlyManager();
   				//var d_list = dojo.query(".description", this.containerNode);
				//this._flymgr.connect(d_list);
				
			//Use Dojo tooltip
			} else {			
			    
			   dojo.forEach(this.subitems, dojo.hitch(this, function(item) {
			      if (item.fullDescription!="" ) {
			          //skip top level nodes
	                  if (!(item.parentList==null || item.parentList.parentList==null)) {
	                	  var tip = "<span style='font-size:x-small;'>" + item.fullDescription + "</span>";
	                	  //replace encode of & 
	                	  tip = tip.replace(/&amp;/g, "&");
			              var tt=new dijit.Tooltip({connectId: [item.domNode],label: tip, showDelay:2000});			              
	                  }			             
			      }		 
			   }));
			}			
		}
		
	},
	 
	_getScrollbarWidth: function()
	{
		if(this._scrollbarWidth === 0) {
			var sbszr = document.createElement("div");
			dojo.style(sbszr, "width", "30px");
			dojo.style(sbszr, "position", "absolute");
			dojo.style(sbszr, "left", "-40px");
			dojo.style(sbszr, "top", "0px");
			dojo.style(sbszr, "overflowY", "auto");
			dojo.style(sbszr, "backgroundColor", "blue");
			document.body.appendChild(sbszr);
			var w_auto = sbszr.clientWidth;
			dojo.style(sbszr, "overflowY", "scroll");
			var w_scroll = sbszr.clientWidth;
			document.body.removeChild(sbszr);
			this._scrollbarWidth = w_auto - w_scroll;
		}
		return this._scrollbarWidth;
	},	
	getTreeRoot: function()
	{
		var treeNode = this; 
		while(treeNode.parentList) {
			treeNode = treeNode.parentList;
		}
		return treeNode;
	},
	
	//Get List type: Catalog, Favorites, Issues, etc..
	getListType: function() {
		var treeNode = this;
		var linktype = this.type;
		while(treeNode.parentList) {
			if (treeNode.type!=null && treeNode.type!="") {
				linktype = treeNode.type;
				break;
			}
			treeNode = treeNode.parentList;
		}
		return linktype;
	},
	
	getActiveList: function()
	{
		return this.getTreeRoot().activeList;
	},

	// ********* state management methods ***********
	// shows this list's sublist
	// fires onPushList and onChangeList
	showSubList: function() {
		//console.log("ListTree.showSubList");
		this._stopCrossFade();
		
		this._setActiveList(this);
		this._crossFade(this.parentList, this);
		this._onpushlist(this.parentList, this);
	},
	// shows this list's parent list
	// fires onPopList. and onChangeList
	popList: function() {
		this._stopCrossFade();
		
		// hide me
		if(this.containerNode) {
			if(this.parentList) {	// this is a sublist
				this._setActiveList(this.parentList);
				this._crossFade(this, this.parentList);
				this._onpoplist(this, this.parentList);
			}
			else {		// this is the root list
				this._onactivatelist(this);
			}
		}
	},
	// shows this list
	// fires onChangeList
	show: function() {
		this._stopCrossFade();
		
		this._show();
		//this._onchangelist(this.getActiveList(), this);
	},
	reset: function() {
		this._stopCrossFade();
		
		this.getTreeRoot()._show();
		this._onactivatelist(this);
	},
	_show: function()
	{
		//console.log("ListTree._show(%s)", this.label);
		var active = this.getActiveList();
		this._setActiveList(this);
		this._crossFade(active, this);
		this._onactivatelist(this);
	},
	_setActiveList: function(list)
	{
		this.getTreeRoot().activeList = list;
	},

	// ****** events **********
	_onEnterKeyPressed: function(evt) {
		//console.log("ListTree._onEnterKeyPressed");
		if (evt.keyCode == dojo.keys.ENTER) {
			dojo.stopEvent(evt);
			this._onclick(evt);
			return false;
		}
		return true;
	},
	_onmouseover: function(evt) {
//		console.log("ListTree._onmouseover, domNode:", this.domNode);
		dojo.addClass(this.domNode, 'highlight');
	},

	_onmouseout: function(evt) {
		var current_target = null;
		if(dojo.isIE) {
			if( evt.toElement && evt.toElement.className !== "popupmore") {
//				console.log("ListTree._onmouseout: ie out, domNode:", this.domNode);
				dojo.removeClass(this.domNode, "highlight");
			}
			else {
				current_target = evt.toElement;
			}
		}
		else {
			current_target = evt.relatedTarget;
		}
//		console.log("ListTree._onmouseout: current_target: ", current_target);
		for(var e = current_target; e && e != document.body; e = e.parentNode) {
			if(e == this.domNode) {
				// still w/in the dom node
//				console.log("ListTree._onmouseout: still w/in domNode");
				return;
			}
		}
		// 
		//console.log("ListTree._onmouseout: out, domNode:", this.domNode);
		dojo.removeClass(this.domNode, "highlight");
	},
	_onclick: function(evt) {
		//console.log("ListTree._onclick");
		this._stopCrossFade();
		
		//Special case to load solutions in a folder which clicked on
		var loadSolutionFolder = false;  
		if (this.getListType()=='BrowseSolution' && this.listItemWidget && this.listItemWidget.isBranch == true && this._loaded==false) {
			loadSolutionFolder = true;
	    }		
		
		//Show list of items in folder
		if(this.subitems.length > 0 && loadSolutionFolder==false) { 
			this.showSubList();
		}
		else {
			//Will cause  Navigator _onlistclick to be invoked to load  list items
			if(this.onClick(this)) {
				this.getTreeRoot().onClick(this);
			}
		}
	},
	_onpushlist: function(prevList, newList) {
		//console.log("ListTree._onpushlist");
		this.getTreeRoot().onPushList(prevList, newList);
		this._onchangelist(prevList, newList);
		this._onactivatelist(newList);
	},
	_onpoplist: function(prevList, newList) {
		//console.log("ListTree._onpoplist");
		this.getTreeRoot().onPopList(prevList, newList);
		this._onchangelist(prevList, newList);
	},
	_onactivatelist: function(newList) {
		this.getTreeRoot().onActivateList(newList);
	},
	_onchangelist: function(prevList, newList) {
		this.getTreeRoot().onChangeList(prevList, newList);
	},
	onClick: function(listNode) {
		return true;
	},
	onPushList: function(prevList, newList) {
		return true;
	},
	onPopList: function(prevList, newList) {
		return true;
	},
	onChangeList: function(prevList, newList) {
		return true;
	},
	onActivateList: function(newList) {
		return true;
	},

	// ********* helpers ***********
	_gethider: function(list) {
		if(!list) {
			list = this;
		}
		return dojo.fadeOut({
			node: list.containerNode, 
			duration: this._xfadeDuration,
			onEnd:function(){
				dojo.style(list.containerNode,"display", "none"); 
			}});
	},
	_getshower: function(list) {
		if(!list) {
			list = this;
		}
		return dojo.fadeIn({
			node: list.containerNode,
			duration: this._xfadeDuration,
			onPlay: function() {
				dojo.style(list.containerNode, "display", "block");
			},
			onEnd: dojo.hitch(this,"putFocus",list)
			});
	},
	_crossFade: function(outlist, inlist)
	{
		console.group("ListTree._crossFade");
		if(inlist) {
			inlist._buildListDomNodes();
		}
				
		
			if(this._xfadeend_handle) {
				dojo.disconnect(this._xfadeend_handle);
				this._xfadeend_handle = null;
			}
			this._crossFader = null;
			
			var xfadechain = [];
			if(outlist && outlist.containerNode) {
				console.log("out: %s (%s)", outlist.containerNode.id, outlist.label);
				h = this._gethider(outlist);
				xfadechain.push(h);
			}
			if(inlist && inlist.containerNode) {
				console.log("in: %s (%s)", inlist.containerNode.id, inlist.label);
				s = this._getshower(inlist);
				xfadechain.push(s);
			}
			if(xfadechain.length > 0) {
				this._crossFader = dojo.fx.chain(xfadechain);				
				this._crossFader.play();
			}
		
		console.groupEnd();
	},
	putFocus: function(inlist){
		//console.log("ListTree.putFocus");		
		var isVisible = function(x){
			if(dojo.style(x,"display")!="block")	{
				return false;
			} 
			return true;
		};
		
		var allItems = dojo.query("div.ListItem",inlist.containerNode);
		//console.log("allItems: " + (allItems ?  allItems.length : "not array" ));
		var visibleItems = dojo.filter(	allItems , isVisible	);		
		//console.log("visisbleItems: " + (visibleItems ?  visibleItems.length : "not array" ));
		if(visibleItems && visibleItems.length>0){
			visibleItems[0].focus();
		}
	},
	_stopCrossFade: function()
	{
		if(this._crossFader && this._crossFader.status() == "playing") {
			this._crossFader.stop(true);
		}	
	},
	/*
	** Search the list tree rooted at this list for the given text (which can be a regular expression)
	** Return the results as an array of he data objects originally cached in the ListTree objects
	** If return_object=true then return the ListTree object instead of the data.
	*/
	Search: function(/*string*/search_text, return_object)   
	{
		var found_items = {};
		var regexp = search_text;
		if (isNaN(search_text)) {
		   regexp = new RegExp(search_text, "i");
		}
		
		this._doSearch(regexp, found_items, return_object);
		
		var found_items_array = [];
		for(var i in found_items) {
			found_items_array.push(found_items[i]);
			//console.log(i, ": ", found_items[i].Description);
		}
		console.groupEnd();
		console.group("ListTree.Search found - " + found_items_array);
		return found_items_array;
	},
	_doSearch: function(/*regexp*/search_exp, /*Array*/found_items, /* String */ return_object)
	{
		//console.group("ListTree._doSearch(%s): %s", search_exp, this.label);
		if(isNaN(search_exp) && this.label.match(search_exp)) {
			//console.log("found label for", this.label);
			if(this.data && this.data[this.keyField]) {
				found_items[this.data[this.keyField]] = this.data;
			}

		} else if(isNaN(search_exp) &&  this.description.match(search_exp)) {
			//console.log("found description for ", this.label);
			if(this.data && this.data[this.keyField]) {
				found_items[this.data[this.keyField]] = this.data;
			}
		} else if(this.data && this.descField) {
			if(isNaN(search_exp) && this.data[this.descField] && this.data[this.descField].match(search_exp)) {
				//console.log("found long description for ", this.label);
				if(this.data && this.data[this.keyField]) {
					found_items[this.data[this.keyField]] = this.data;
				}
			
		    } else if(isNaN(search_exp) &&  this.data[this.keyField] && this.data[this.keyField].match(search_exp)) {
				found_items[this.data[this.keyField]] = this.data;	
			
		    } else if(!isNaN(search_exp) &&  this.data[this.keyField] && this.data[this.keyField] == search_exp) {  //compare if numeric id
		    	if (return_object && return_object==true) {
		    		 found_items[this.data[this.keyField]] = this;
		    	} else {
		    		 found_items[this.data[this.keyField]] = this.data;	
		    	}
			  
		    }
	    }
		
		for(var i in this.subitems) {
			this.subitems[i]._doSearch(search_exp, found_items, return_object);			
		}
		//console.groupEnd();
	},	
	
	dump: function()
	{
		console.group(this.label);
		if(this.subitems) {
			dojo.forEach(this.subitems, function(item) {	// don't need hitch, because never using 'this'
				item.dump();
			});
		}
		console.groupEnd();
	}
});
/*
** class ListTreeFlyManager
** Manages the flyover popup of list item's long description
*/
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ListTreeFlyManager", null,
{
	activeDesc: null,
	activeMore: null,
	overHandler: null,
	outHandler: null,
	hideHandler: null,
	showHandler: null,
	connHandles: null,
	outConnHandles: null,		// array of event handler connections
	_hoverers: null,			// one for each node we're watching
	_popupDiv: document.createElement("div"),
	
	
	constructor: function()
	{
		//console.log("FlyManager.ctor");
		this.connHandles = [];
		this.outConnHandles = [];
		this._hoverers = [];
		this._highlighter = dojo.hitch(this, "_highlightListNode");
		
		// some basic initialization of the popup
		this._popupDiv.className = "popupmore";
		document.body.appendChild(this._popupDiv);
	},
	destroy: function()
	{
		//console.log("FlyManager.destroy");
		this.disconnect();
		var hvr;
		while(hvr = this._hoverers.pop()) {	
			hvr.destroy();
		}
	},
	connect: function(/*Array of DOM nodes*/elem_array)
	{
		//console.log("FlyManager.connect");

		if(elem_array && elem_array.length > 0) {
			// cache event handlers
			this.overHandler = dojo.hitch(this, "_over");
			this.outHandler = dojo.hitch(this, "_out");
			this.showHandler = dojo.hitch(this, "_showFly");
			this.hideHandler = dojo.hitch(this, "_hideFly");
		}

		elem_array.forEach(dojo.hitch(this, dojo.hitch(this, function(d) 
		{
			if(dojo.query("div.more", d).length == 1) {
				//console.log("connecting", d);
				this.connHandles.push(dojo.connect(d, 'onmouseover', null, this.overHandler));
				this.connHandles.push(dojo.connect(d, 'onmouseout', null, this.outHandler));
				var hvr = new ibm.tivoli.simplesrm.srm.dojo.Hoverer();
				hvr.setDOMNode(d);
				this.connHandles.push(dojo.connect(hvr, "OnHover", null, this.showHandler));
				this._hoverers.push(hvr);
			}
		})));
	},
	disconnect: function()
	{
		dojo.forEach(this.connHandles, function(x) 
		{
			dojo.disconnect(x);
		});
		this.connHandles = null;
	},
	_over: function(evt)
	{
		//console.log("FlyManager._over");
		if(dojo.hasClass(evt.target,'more')) {return;}
		//console.log("over target: %s activeDesc: %o this.activeMore: %o", evt.target.id, this.activeDesc, this.activeMore);
		this.activeDesc = evt.target;
	},
	_out: function(evt)
	{
		//console.log("FlyManager._out");
		if(this.outConnHandles.length > 0 || !this.activeMore) {return;}
		//console.log("out  target: %s this.activeDesc: %o this.activeMore: %o", evt.target.id, this.activeDesc, this.activeMore);
		if(undefined != this.activeMore) {
			//dojo.style(this.activeMore, 'display', 'none');
			this.activeMore = null;
		}
	},
	_findMore: function()
	{
		//console.log("LisTree._findMore: activeDesc=", this.activeDesc);
		if(this.activeDesc) {
			var more = dojo.query(".more", this.activeDesc);
			if(more.length > 0) {
				//console.log("ListTree._findMore found: ", more[0]);
				return more[0];
			}
		}
		return null;
	},
	_showFly: function()
	{
		if(this.activeMore){
			return;
		}
		this.activeMore = this._findMore();
		//console.log("More = ", this.activeMore);
		if(this.activeMore) {
			//console.log("FlyManager._showFly", this.activeMore);
			var sz = dojo.boxModel == "content-box" ? dojo.contentBox(this.activeDesc) : dojo.marginBox(this.activeDesc);
			var borderLeft = dojo.style(this.activeMore, "borderLeftWidth");
			var borderTop = dojo.style(this.activeMore, "borderTopWidth");
			var padLeft = dojo.style(this.activeDesc, "paddingLeft");
			var padRight = padLeft > 0 ? padLeft : 5;
			var padTopBottom = 5;
			var bodyScrollX = document.documentElement.scrollLeft; 
			var bodyScrollY = document.documentElement.scrollTop;
			var loc = dojo.coords(this.activeDesc);
			var fontSize = dojo.style(this.activeDesc, "fontSize"); 
			if(fontSize.indexOf("em") > 0) {
				fontSize = (parseFloat(fontSize) / 0.0625);
				if(dojo.isIE) {
					fontSize *= 0.8;	// go figure
				}
				fontSize += "px";
			}
			var lineHeight = dojo.style(this.activeDesc, "lineHeight");
			if(dojo.isIE) {
				loc.y += document.body.scrollTop;
				loc.x += document.body.scrollLeft;
			}

			this._popupDiv.innerHTML = this.activeMore.innerHTML;
			dojo.style(this._popupDiv, "padding", padTopBottom + "px " + padRight + "px " + padTopBottom + "px " + padLeft + "px");
			dojo.style(this._popupDiv, 'left', (loc.x - borderLeft + bodyScrollX) + "px");
			dojo.style(this._popupDiv, 'top',  (loc.y - borderTop - padTopBottom + bodyScrollY)  + "px");
			dojo.style(this._popupDiv, 'width', (sz.w) + "px");
			//dojo.style(this._popupDiv, 'height', "auto");
			dojo.style(this._popupDiv, 'fontSize', fontSize);
			dojo.style(this._popupDiv, 'fontFamily', dojo.style(this.activeDesc, "fontFamily"));
			if(lineHeight) {
				dojo.style(this._popupDiv, 'lineHeight', dojo.style(this.activeDesc, "lineHeight")+"px");
			}
			dojo.style(this._popupDiv, "color", dojo.style(this.activeDesc, "color"));
			dojo.style(this._popupDiv, 'display', 'block');
			//console.log("FlyManager _popupDiv: ", this._popupDiv);
			window.setTimeout(this._highlighter, 10);		
			this.outConnHandles.push(dojo.connect(this._popupDiv, "onmouseout", this.hideHandler));
			this.outConnHandles.push(dojo.connect(this._popupDiv, "onclick", this.hideHandler));
		}
	},
	_highlightListNode: function()
	{
		//console.log("FlyManager._highlightListNode");
		// when the popup displays, the list item gets an onmouseout and looses its highlight.
		// keep that from happening
		for(var n = this.activeDesc; n.tagName; n = n.parentNode) {
			if(n.tagName.toLowerCase() == 'div') {
				if(dojo.hasClass(n, "ListItem")) {
					dojo.addClass(n, 'highlight');
					break;
				}
			}
		}
	},
	
	_hideFly: function(evt)
	{
		//console.log("hide", this.activeMore, evt);
		if(evt.type == "click") {
			// clicking in the "more" popup hides it, but won't click on the underlying list item
			evt.stopPropagation();
		}
		while(c = this.outConnHandles.pop()) {
			dojo.disconnect(c);
		}
//		dojo.style(this.activeMore, 'display', 'none');
		dojo.style(this._popupDiv, "display", "none");
		this.activeMore = this.activeDesc = null;
	},
	_dummy:null
});

});

},
'dijit/_CssStateMixin':function(){
define("dijit/_CssStateMixin", [
	"dojo/touch",
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare",	// declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/window" // win.body
], function(touch, array, declare, domClass, lang, win){

// module:
//		dijit/_CssStateMixin
// summary:
//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
//		state changes, and also higher-level state changes such becoming disabled or selected.

return declare("dijit._CssStateMixin", [], {
	// summary:
	//		Mixin for widgets to set CSS classes on the widget DOM nodes depending on hover/mouse press/focus
	//		state changes, and also higher-level state changes such becoming disabled or selected.
	//
	// description:
	//		By mixing this class into your widget, and setting the this.baseClass attribute, it will automatically
	//		maintain CSS classes on the widget root node (this.domNode) depending on hover,
	//		active, focus, etc. state.   Ex: with a baseClass of dijitButton, it will apply the classes
	//		dijitButtonHovered and dijitButtonActive, as the user moves the mouse over the widget and clicks it.
	//
	//		It also sets CSS like dijitButtonDisabled based on widget semantic state.
	//
	//		By setting the cssStateNodes attribute, a widget can also track events on subnodes (like buttons
	//		within the widget).

	// cssStateNodes: [protected] Object
	//		List of sub-nodes within the widget that need CSS classes applied on mouse hover/press and focus
	//.
	//		Each entry in the hash is a an attachpoint names (like "upArrowButton") mapped to a CSS class names
	//		(like "dijitUpArrowButton"). Example:
	//	|		{
	//	|			"upArrowButton": "dijitUpArrowButton",
	//	|			"downArrowButton": "dijitDownArrowButton"
	//	|		}
	//		The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
	//		is hovered, etc.
	cssStateNodes: {},

	// hovering: [readonly] Boolean
	//		True if cursor is over this widget
	hovering: false,

	// active: [readonly] Boolean
	//		True if mouse was pressed while over this widget, and hasn't been released yet
	active: false,

	_applyAttributes: function(){
		// This code would typically be in postCreate(), but putting in _applyAttributes() for
		// performance: so the class changes happen before DOM is inserted into the document.
		// Change back to postCreate() in 2.0.  See #11635.

		this.inherited(arguments);

		// Automatically monitor mouse events (essentially :hover and :active) on this.domNode
		array.forEach(["onmouseenter", "onmouseleave", touch.press], function(e){
			this.connect(this.domNode, e, "_cssMouseEvent");
		}, this);

		// Monitoring changes to disabled, readonly, etc. state, and update CSS class of root node
		array.forEach(["disabled", "readOnly", "checked", "selected", "focused", "state", "hovering", "active"], function(attr){
			this.watch(attr, lang.hitch(this, "_setStateClass"));
		}, this);

		// Events on sub nodes within the widget
		for(var ap in this.cssStateNodes){
			this._trackMouseState(this[ap], this.cssStateNodes[ap]);
		}
		// Set state initially; there's probably no hover/active/focus state but widget might be
		// disabled/readonly/checked/selected so we want to set CSS classes for those conditions.
		this._setStateClass();
	},

	_cssMouseEvent: function(/*Event*/ event){
		// summary:
		//	Sets hovering and active properties depending on mouse state,
		//	which triggers _setStateClass() to set appropriate CSS classes for this.domNode.

		if(!this.disabled){
			switch(event.type){
				case "mouseenter":
				case "mouseover":	// generated on non-IE browsers even though we connected to mouseenter
					this._set("hovering", true);
					this._set("active", this._mouseDown);
					break;

				case "mouseleave":
				case "mouseout":	// generated on non-IE browsers even though we connected to mouseleave
					this._set("hovering", false);
					this._set("active", false);
					break;

				case "mousedown":
				case "touchpress":
					this._set("active", true);
					this._mouseDown = true;
					// Set a global event to handle mouseup, so it fires properly
					// even if the cursor leaves this.domNode before the mouse up event.
					// Alternately could set active=false on mouseout.
					var mouseUpConnector = this.connect(win.body(), touch.release, function(){
						this._mouseDown = false;
						this._set("active", false);
						this.disconnect(mouseUpConnector);
					});
					break;
			}
		}
	},

	_setStateClass: function(){
		// summary:
		//		Update the visual state of the widget by setting the css classes on this.domNode
		//		(or this.stateNode if defined) by combining this.baseClass with
		//		various suffixes that represent the current widget state(s).
		//
		// description:
		//		In the case where a widget has multiple
		//		states, it sets the class based on all possible
		//	 	combinations.  For example, an invalid form widget that is being hovered
		//		will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
		//
		//		The widget may have one or more of the following states, determined
		//		by this.state, this.checked, this.valid, and this.selected:
		//			- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
		//			- Incomplete - ValidationTextBox sets this.state to "Incomplete" if the current input value is not finished yet
		//			- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
		//			- Selected - ex: currently selected tab will have this.selected==true
		//
		//		In addition, it may have one or more of the following states,
		//		based on this.disabled and flags set in _onMouse (this.active, this.hovering) and from focus manager (this.focused):
		//			- Disabled	- if the widget is disabled
		//			- Active		- if the mouse (or space/enter key?) is being pressed down
		//			- Focused		- if the widget has focus
		//			- Hover		- if the mouse is over the widget

		// Compute new set of classes
		var newStateClasses = this.baseClass.split(" ");

		function multiply(modifier){
			newStateClasses = newStateClasses.concat(array.map(newStateClasses, function(c){ return c+modifier; }), "dijit"+modifier);
		}

		if(!this.isLeftToRight()){
			// For RTL mode we need to set an addition class like dijitTextBoxRtl.
			multiply("Rtl");
		}

		var checkedState = this.checked == "mixed" ? "Mixed" : (this.checked ? "Checked" : "");
		if(this.checked){
			multiply(checkedState);
		}
		if(this.state){
			multiply(this.state);
		}
		if(this.selected){
			multiply("Selected");
		}

		if(this.disabled){
			multiply("Disabled");
		}else if(this.readOnly){
			multiply("ReadOnly");
		}else{
			if(this.active){
				multiply("Active");
			}else if(this.hovering){
				multiply("Hover");
			}
		}

		if(this.focused){
			multiply("Focused");
		}

		// Remove old state classes and add new ones.
		// For performance concerns we only write into domNode.className once.
		var tn = this.stateNode || this.domNode,
			classHash = {};	// set of all classes (state and otherwise) for node

		array.forEach(tn.className.split(" "), function(c){ classHash[c] = true; });

		if("_stateClasses" in this){
			array.forEach(this._stateClasses, function(c){ delete classHash[c]; });
		}

		array.forEach(newStateClasses, function(c){ classHash[c] = true; });

		var newClasses = [];
		for(var c in classHash){
			newClasses.push(c);
		}
		tn.className = newClasses.join(" ");

		this._stateClasses = newStateClasses;
	},

	_trackMouseState: function(/*DomNode*/ node, /*String*/ clazz){
		// summary:
		//		Track mouse/focus events on specified node and set CSS class on that node to indicate
		//		current state.   Usually not called directly, but via cssStateNodes attribute.
		// description:
		//		Given class=foo, will set the following CSS class on the node
		//			- fooActive: if the user is currently pressing down the mouse button while over the node
		//			- fooHover: if the user is hovering the mouse over the node, but not pressing down a button
		//			- fooFocus: if the node is focused
		//
		//		Note that it won't set any classes if the widget is disabled.
		// node: DomNode
		//		Should be a sub-node of the widget, not the top node (this.domNode), since the top node
		//		is handled specially and automatically just by mixing in this class.
		// clazz: String
		//		CSS class name (ex: dijitSliderUpArrow).

		// Current state of node (initially false)
		// NB: setting specifically to false because domClass.toggle() needs true boolean as third arg
		var hovering=false, active=false, focused=false;

		var self = this,
			cn = lang.hitch(this, "connect", node);

		function setClass(){
			var disabled = ("disabled" in self && self.disabled) || ("readonly" in self && self.readonly);
			domClass.toggle(node, clazz+"Hover", hovering && !active && !disabled);
			domClass.toggle(node, clazz+"Active", active && !disabled);
			domClass.toggle(node, clazz+"Focused", focused && !disabled);
		}

		// Mouse
		cn("onmouseenter", function(){
			hovering = true;
			setClass();
		});
		cn("onmouseleave", function(){
			hovering = false;
			active = false;
			setClass();
		});
		cn(touch.press, function(){
			active = true;
			setClass();
		});
		cn(touch.release, function(){
			active = false;
			setClass();
		});

		// Focus
		cn("onfocus", function(){
			focused = true;
			setClass();
		});
		cn("onblur", function(){
			focused = false;
			setClass();
		});

		// Just in case widget is enabled/disabled while it has focus/hover/active state.
		// Maybe this is overkill.
		this.watch("disabled", setClass);
		this.watch("readOnly", setClass);
	}
});
});

},
'dojo/currency':function(){
define("dojo/currency", ["./_base/kernel", "./_base/lang", "./_base/array", "./number", "./i18n", "./i18n!./cldr/nls/currency", "./cldr/monetary"], function(dojo, lang, darray, dnumber, i18n, nlsCurrency, cldrMonetary) {
	// module:
	//		dojo/currency
	// summary:
	//		TODOC

lang.getObject("currency", true, dojo);

/*=====
dojo.currency = {
	// summary: localized formatting and parsing routines for currencies
	//
	// description: extends dojo.number to provide culturally-appropriate formatting of values
	//	in various world currencies, including use of a currency symbol.  The currencies are specified
	//	by a three-letter international symbol in all uppercase, and support for the currencies is
	//	provided by the data in `dojo.cldr`.  The scripts generating dojo.cldr specify which
	//	currency support is included.  A fixed number of decimal places is determined based
	//	on the currency type and is not determined by the 'pattern' argument.  The fractional
	//	portion is optional, by default, and variable length decimals are not supported.
}
=====*/

dojo.currency._mixInDefaults = function(options){
	options = options || {};
	options.type = "currency";

	// Get locale-dependent currency data, like the symbol
	var bundle = i18n.getLocalization("dojo.cldr", "currency", options.locale) || {};

	// Mixin locale-independent currency data, like # of places
	var iso = options.currency;
	var data = cldrMonetary.getData(iso);

	darray.forEach(["displayName","symbol","group","decimal"], function(prop){
		data[prop] = bundle[iso+"_"+prop];
	});

	data.fractional = [true, false];

	// Mixin with provided options
	return lang.mixin(data, options);
};

/*=====
dojo.declare("dojo.currency.__FormatOptions", [dojo.number.__FormatOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be "currency".
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	places: Number?
	//		number of decimal places to show.  Default is defined based on which currency is used.
	type: "",
	symbol: "",
	currency: "",
	places: ""
});
=====*/

dojo.currency.format = function(/*Number*/value, /*dojo.currency.__FormatOptions?*/options){
// summary:
//		Format a Number as a currency, using locale-specific settings
//
// description:
//		Create a string from a Number using a known, localized pattern.
//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements)
//		appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
//		as well as the appropriate symbols and delimiters and number of decimal places.
//
// value:
//		the number to be formatted.

	return dnumber.format(value, dojo.currency._mixInDefaults(options));
};

dojo.currency.regexp = function(/*dojo.number.__RegexpOptions?*/options){
//
// summary:
//		Builds the regular needed to parse a currency value
//
// description:
//		Returns regular expression with positive and negative match, group and decimal separators
//		Note: the options.places default, the number of decimal places to accept, is defined by the currency type.
	return dnumber.regexp(dojo.currency._mixInDefaults(options)); // String
};

/*=====
dojo.declare("dojo.currency.__ParseOptions", [dojo.number.__ParseOptions], {
	//	type: String?
	//		Should not be set.  Value is assumed to be currency.
	//	currency: String?
	//		an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like "USD".
	//		For use with dojo.currency only.
	//	symbol: String?
	//		localized currency symbol. The default will be looked up in table of supported currencies in `dojo.cldr`
	//		A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.
	//	places: Number?
	//		fixed number of decimal places to accept.  The default is determined based on which currency is used.
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by the currency
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	//		By default for currencies, it the fractional portion is optional.
	type: "",
	currency: "",
	symbol: "",
	places: "",
	fractional: ""
});
=====*/

dojo.currency.parse = function(/*String*/expression, /*dojo.currency.__ParseOptions?*/options){
	//
	// summary:
	//		Convert a properly formatted currency string to a primitive Number,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Number from a string using a known, localized pattern.
	//		[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		are chosen appropriate to the locale, as well as the appropriate symbols and delimiters
	//		and number of decimal places.
	//
	// expression: A string representation of a currency value

	return dnumber.parse(expression, dojo.currency._mixInDefaults(options));
};

return dojo.currency;
});

},
'dojox/color':function(){
define("dojox/color", ["./color/_base"], function(dxcolor){
	return dxcolor;
});

},
'dijit/DialogUnderlay':function(){
define("dijit/DialogUnderlay", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.getBox
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe"
], function(declare, domAttr, win, winUtils, _Widget, _TemplatedMixin, BackgroundIframe){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/DialogUnderlay
	// summary:
	//		The component that blocks the screen behind a `dijit.Dialog`

	return declare("dijit.DialogUnderlay", [_Widget, _TemplatedMixin], {
		// summary:
		//		The component that blocks the screen behind a `dijit.Dialog`
		//
		// description:
		// 		A component used to block input behind a `dijit.Dialog`. Only a single
		//		instance of this widget is created by `dijit.Dialog`, and saved as
		//		a reference to be shared between all Dialogs as `dijit._underlay`
		//
		//		The underlay itself can be styled based on and id:
		//	|	#myDialog_underlay { background-color:red; }
		//
		//		In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
		//		suffixed with _underlay.

		// Template has two divs; outer div is used for fade-in/fade-out, and also to hold background iframe.
		// Inner div has opacity specified in CSS file.
		templateString: "<div class='dijitDialogUnderlayWrapper'><div class='dijitDialogUnderlay' data-dojo-attach-point='node'></div></div>",

		// Parameters on creation or updatable later

		// dialogId: String
		//		Id of the dialog.... DialogUnderlay's id is based on this id
		dialogId: "",

		// class: String
		//		This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay
		"class": "",

		_setDialogIdAttr: function(id){
			domAttr.set(this.node, "id", id + "_underlay");
			this._set("dialogId", id);
		},

		_setClassAttr: function(clazz){
			this.node.className = "dijitDialogUnderlay " + clazz;
			this._set("class", clazz);
		},

		postCreate: function(){
			// summary:
			//		Append the underlay to the body
			win.body().appendChild(this.domNode);
		},

		layout: function(){
			// summary:
			//		Sets the background to the size of the viewport
			//
			// description:
			//		Sets the background to the size of the viewport (rather than the size
			//		of the document) since we need to cover the whole browser window, even
			//		if the document is only a few lines long.
			// tags:
			//		private

			var is = this.node.style,
				os = this.domNode.style;

			// hide the background temporarily, so that the background itself isn't
			// causing scrollbars to appear (might happen when user shrinks browser
			// window and then we are called to resize)
			os.display = "none";

			// then resize and show
			var viewport = winUtils.getBox();
			os.top = viewport.t + "px";
			os.left = viewport.l + "px";
			is.width = viewport.w + "px";
			is.height = viewport.h + "px";
			os.display = "block";
		},

		show: function(){
			// summary:
			//		Show the dialog underlay
			this.domNode.style.display = "block";
			this.layout();
			this.bgIframe = new BackgroundIframe(this.domNode);
		},

		hide: function(){
			// summary:
			//		Hides the dialog underlay
			this.bgIframe.destroy();
			delete this.bgIframe;
			this.domNode.style.display = "none";
		}
	});
});

},
'dijit/layout/ScrollingTabController':function(){
require({cache:{
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_menuBtn\"\n\t\t\tdata-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t\tdata-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_leftBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_rightBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeypress:onkeypress'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>",
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"onclick:_onClick\">\n\t<div role=\"presentation\" class=\"dijitTabInnerDiv\" data-dojo-attach-point=\"innerDiv,focusNode\">\n\t\t<div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\" data-dojo-attach-point=\"tabContent\">\n\t\t\t<img role=\"presentation\" alt=\"\" src=\"${_blankGif}\" class=\"dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n\t\t</div>\n\t</div>\n</div>"}});
define("dijit/layout/ScrollingTabController", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/fx", // Animation
	"dojo/_base/lang", // lang.hitch
	"dojo/query", // query
	"dojo/_base/sniff", // has("ie"), has("webkit"), has("quirks")
	"../registry",	// registry.byId()
	"dojo/text!./templates/ScrollingTabController.html",
	"dojo/text!./templates/_ScrollingTabControllerButton.html",
	"./TabController",
	"./utils",	// marginBox2contextBox, layoutChildren
	"../_WidgetsInTemplateMixin",
	"../Menu",
	"../MenuItem",
	"../form/Button",
	"../_HasDropDown",
	"dojo/NodeList-dom" // NodeList.style
], function(array, declare, domClass, domGeometry, domStyle, fx, lang, query, has,
	registry, tabControllerTemplate, buttonTemplate, TabController, layoutUtils, _WidgetsInTemplateMixin,
	Menu, MenuItem, Button, _HasDropDown){

/*=====
var _WidgetsInTemplateMixin = dijit._WidgetsInTemplateMixin;
var Menu = dijit.Menu;
var _HasDropDown = dijit._HasDropDown;
var TabController = dijit.layout.TabController;
=====*/


// module:
//		dijit/layout/ScrollingTabController
// summary:
//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
//		all fitting on a single row.


var ScrollingTabController = declare("dijit.layout.ScrollingTabController", [TabController, _WidgetsInTemplateMixin], {
	// summary:
	//		Set of tabs with left/right arrow keys and a menu to switch between tabs not
	//		all fitting on a single row.
	//		Works only for horizontal tabs (either above or below the content, not to the left
	//		or right).
	// tags:
	//		private

	baseClass: "dijitTabController dijitScrollingTabController",

	templateString: tabControllerTemplate,

	// useMenu: [const] Boolean
	//		True if a menu should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useMenu: true,

	// useSlider: [const] Boolean
	//		True if a slider should be used to select tabs when they are too
	//		wide to fit the TabContainer, false otherwise.
	useSlider: true,

	// tabStripClass: [const] String
	//		The css class to apply to the tab strip, if it is visible.
	tabStripClass: "",

	widgetsInTemplate: true,

	// _minScroll: Number
	//		The distance in pixels from the edge of the tab strip which,
	//		if a scroll animation is less than, forces the scroll to
	//		go all the way to the left/right.
	_minScroll: 5,

	// Override default behavior mapping class to DOMNode
	_setClassAttr: { node: "containerNode", type: "class" },

	buildRendering: function(){
		this.inherited(arguments);
		var n = this.domNode;

		this.scrollNode = this.tablistWrapper;
		this._initButtons();

		if(!this.tabStripClass){
			this.tabStripClass = "dijitTabContainer" +
				this.tabPosition.charAt(0).toUpperCase() +
				this.tabPosition.substr(1).replace(/-.*/, "") +
				"None";
			domClass.add(n, "tabStrip-disabled")
		}

		domClass.add(this.tablistWrapper, this.tabStripClass);
	},

	onStartup: function(){
		this.inherited(arguments);

		// TabController is hidden until it finishes drawing, to give
		// a less visually jumpy instantiation.   When it's finished, set visibility to ""
		// to that the tabs are hidden/shown depending on the container's visibility setting.
		domStyle.set(this.domNode, "visibility", "");
		this._postStartup = true;
	},

	onAddChild: function(page, insertIndex){
		this.inherited(arguments);

		// changes to the tab button label or iconClass will have changed the width of the
		// buttons, so do a resize
		array.forEach(["label", "iconClass"], function(attr){
			this.pane2watches[page.id].push(
				this.pane2button[page.id].watch(attr, lang.hitch(this, function(){
					if(this._postStartup && this._dim){
						this.resize(this._dim);
					}
				}))
			);
		}, this);

		// Increment the width of the wrapper when a tab is added
		// This makes sure that the buttons never wrap.
		// The value 200 is chosen as it should be bigger than most
		// Tab button widths.
		domStyle.set(this.containerNode, "width",
			(domStyle.get(this.containerNode, "width") + 200) + "px");
	},

	onRemoveChild: function(page, insertIndex){
		// null out _selectedTab because we are about to delete that dom node
		var button = this.pane2button[page.id];
		if(this._selectedTab === button.domNode){
			this._selectedTab = null;
		}

		this.inherited(arguments);
	},

	_initButtons: function(){
		// summary:
		//		Creates the buttons used to scroll to view tabs that
		//		may not be visible if the TabContainer is too narrow.

		// Make a list of the buttons to display when the tab labels become
		// wider than the TabContainer, and hide the other buttons.
		// Also gets the total width of the displayed buttons.
		this._btnWidth = 0;
		this._buttons = query("> .tabStripButton", this.domNode).filter(function(btn){
			if((this.useMenu && btn == this._menuBtn.domNode) ||
				(this.useSlider && (btn == this._rightBtn.domNode || btn == this._leftBtn.domNode))){
				this._btnWidth += domGeometry.getMarginSize(btn).w;
				return true;
			}else{
				domStyle.set(btn, "display", "none");
				return false;
			}
		}, this);
	},

	_getTabsWidth: function(){
		var children = this.getChildren();
		if(children.length){
			var leftTab = children[this.isLeftToRight() ? 0 : children.length - 1].domNode,
				rightTab = children[this.isLeftToRight() ? children.length - 1 : 0].domNode;
			return rightTab.offsetLeft + domStyle.get(rightTab, "width") - leftTab.offsetLeft;
		}else{
			return 0;
		}
	},

	_enableBtn: function(width){
		// summary:
		//		Determines if the tabs are wider than the width of the TabContainer, and
		//		thus that we need to display left/right/menu navigation buttons.
		var tabsWidth = this._getTabsWidth();
		width = width || domStyle.get(this.scrollNode, "width");
		return tabsWidth > 0 && width < tabsWidth;
	},

	resize: function(dim){
		// summary:
		//		Hides or displays the buttons used to scroll the tab list and launch the menu
		//		that selects tabs.

		// Save the dimensions to be used when a child is renamed.
		this._dim = dim;

		// Set my height to be my natural height (tall enough for one row of tab labels),
		// and my content-box width based on margin-box width specified in dim parameter.
		// But first reset scrollNode.height in case it was set by layoutChildren() call
		// in a previous run of this method.
		this.scrollNode.style.height = "auto";
		var cb = this._contentBox = layoutUtils.marginBox2contentBox(this.domNode, {h: 0, w: dim.w});
		cb.h = this.scrollNode.offsetHeight;
		domGeometry.setContentSize(this.domNode, cb);

		// Show/hide the left/right/menu navigation buttons depending on whether or not they
		// are needed.
		var enable = this._enableBtn(this._contentBox.w);
		this._buttons.style("display", enable ? "" : "none");

		// Position and size the navigation buttons and the tablist
		this._leftBtn.layoutAlign = "left";
		this._rightBtn.layoutAlign = "right";
		this._menuBtn.layoutAlign = this.isLeftToRight() ? "right" : "left";
		layoutUtils.layoutChildren(this.domNode, this._contentBox,
			[this._menuBtn, this._leftBtn, this._rightBtn, {domNode: this.scrollNode, layoutAlign: "client"}]);

		// set proper scroll so that selected tab is visible
		if(this._selectedTab){
			if(this._anim && this._anim.status() == "playing"){
				this._anim.stop();
			}
			this.scrollNode.scrollLeft = this._convertToScrollLeft(this._getScrollForSelectedTab());
		}

		// Enable/disabled left right buttons depending on whether or not user can scroll to left or right
		this._setButtonClass(this._getScroll());

		this._postResize = true;

		// Return my size so layoutChildren() can use it.
		// Also avoids IE9 layout glitch on browser resize when scroll buttons present
		return {h: this._contentBox.h, w: dim.w};
	},

	_getScroll: function(){
		// summary:
		//		Returns the current scroll of the tabs where 0 means
		//		"scrolled all the way to the left" and some positive number, based on #
		//		of pixels of possible scroll (ex: 1000) means "scrolled all the way to the right"
		return (this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")) ? this.scrollNode.scrollLeft :
				domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width")
					 + (has("ie") == 8 ? -1 : 1) * this.scrollNode.scrollLeft;
	},

	_convertToScrollLeft: function(val){
		// summary:
		//		Given a scroll value where 0 means "scrolled all the way to the left"
		//		and some positive number, based on # of pixels of possible scroll (ex: 1000)
		//		means "scrolled all the way to the right", return value to set this.scrollNode.scrollLeft
		//		to achieve that scroll.
		//
		//		This method is to adjust for RTL funniness in various browsers and versions.
		if(this.isLeftToRight() || has("ie") < 8 || (has("ie") && has("quirks")) || has("webkit")){
			return val;
		}else{
			var maxScroll = domStyle.get(this.containerNode, "width") - domStyle.get(this.scrollNode, "width");
			return (has("ie") == 8 ? -1 : 1) * (val - maxScroll);
		}
	},

	onSelectChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Smoothly scrolls to a tab when it is selected.

		var tab = this.pane2button[page.id];
		if(!tab || !page){return;}

		var node = tab.domNode;

		// Save the selection
		if(node != this._selectedTab){
			this._selectedTab = node;

			// Scroll to the selected tab, except on startup, when scrolling is handled in resize()
			if(this._postResize){
				var sl = this._getScroll();

				if(sl > node.offsetLeft ||
						sl + domStyle.get(this.scrollNode, "width") <
						node.offsetLeft + domStyle.get(node, "width")){
					this.createSmoothScroll().play();
				}
			}
		}

		this.inherited(arguments);
	},

	_getScrollBounds: function(){
		// summary:
		//		Returns the minimum and maximum scroll setting to show the leftmost and rightmost
		//		tabs (respectively)
		var children = this.getChildren(),
			scrollNodeWidth = domStyle.get(this.scrollNode, "width"),		// about 500px
			containerWidth = domStyle.get(this.containerNode, "width"),	// 50,000px
			maxPossibleScroll = containerWidth - scrollNodeWidth,	// scrolling until right edge of containerNode visible
			tabsWidth = this._getTabsWidth();

		if(children.length && tabsWidth > scrollNodeWidth){
			// Scrolling should happen
			return {
				min: this.isLeftToRight() ? 0 : children[children.length-1].domNode.offsetLeft,
				max: this.isLeftToRight() ?
					(children[children.length-1].domNode.offsetLeft + domStyle.get(children[children.length-1].domNode, "width")) - scrollNodeWidth :
					maxPossibleScroll
			};
		}else{
			// No scrolling needed, all tabs visible, we stay either scrolled to far left or far right (depending on dir)
			var onlyScrollPosition = this.isLeftToRight() ? 0 : maxPossibleScroll;
			return {
				min: onlyScrollPosition,
				max: onlyScrollPosition
			};
		}
	},

	_getScrollForSelectedTab: function(){
		// summary:
		//		Returns the scroll value setting so that the selected tab
		//		will appear in the center
		var w = this.scrollNode,
			n = this._selectedTab,
			scrollNodeWidth = domStyle.get(this.scrollNode, "width"),
			scrollBounds = this._getScrollBounds();

		// TODO: scroll minimal amount (to either right or left) so that
		// selected tab is fully visible, and just return if it's already visible?
		var pos = (n.offsetLeft + domStyle.get(n, "width")/2) - scrollNodeWidth/2;
		pos = Math.min(Math.max(pos, scrollBounds.min), scrollBounds.max);

		// TODO:
		// If scrolling close to the left side or right side, scroll
		// all the way to the left or right.  See this._minScroll.
		// (But need to make sure that doesn't scroll the tab out of view...)
		return pos;
	},

	createSmoothScroll: function(x){
		// summary:
		//		Creates a dojo._Animation object that smoothly scrolls the tab list
		//		either to a fixed horizontal pixel value, or to the selected tab.
		// description:
		//		If an number argument is passed to the function, that horizontal
		//		pixel position is scrolled to.  Otherwise the currently selected
		//		tab is scrolled to.
		// x: Integer?
		//		An optional pixel value to scroll to, indicating distance from left.

		// Calculate position to scroll to
		if(arguments.length > 0){
			// position specified by caller, just make sure it's within bounds
			var scrollBounds = this._getScrollBounds();
			x = Math.min(Math.max(x, scrollBounds.min), scrollBounds.max);
		}else{
			// scroll to center the current tab
			x = this._getScrollForSelectedTab();
		}

		if(this._anim && this._anim.status() == "playing"){
			this._anim.stop();
		}

		var self = this,
			w = this.scrollNode,
			anim = new fx.Animation({
				beforeBegin: function(){
					if(this.curve){ delete this.curve; }
					var oldS = w.scrollLeft,
						newS = self._convertToScrollLeft(x);
					anim.curve = new fx._Line(oldS, newS);
				},
				onAnimate: function(val){
					w.scrollLeft = val;
				}
			});
		this._anim = anim;

		// Disable/enable left/right buttons according to new scroll position
		this._setButtonClass(x);

		return anim; // dojo._Animation
	},

	_getBtnNode: function(/*Event*/ e){
		// summary:
		//		Gets a button DOM node from a mouse click event.
		// e:
		//		The mouse click event.
		var n = e.target;
		while(n && !domClass.contains(n, "tabStripButton")){
			n = n.parentNode;
		}
		return n;
	},

	doSlideRight: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the right.
		// e:
		//		The mouse click event.
		this.doSlide(1, this._getBtnNode(e));
	},

	doSlideLeft: function(/*Event*/ e){
		// summary:
		//		Scrolls the menu to the left.
		// e:
		//		The mouse click event.
		this.doSlide(-1,this._getBtnNode(e));
	},

	doSlide: function(/*Number*/ direction, /*DomNode*/ node){
		// summary:
		//		Scrolls the tab list to the left or right by 75% of the widget width.
		// direction:
		//		If the direction is 1, the widget scrolls to the right, if it is
		//		-1, it scrolls to the left.

		if(node && domClass.contains(node, "dijitTabDisabled")){return;}

		var sWidth = domStyle.get(this.scrollNode, "width");
		var d = (sWidth * 0.75) * direction;

		var to = this._getScroll() + d;

		this._setButtonClass(to);

		this.createSmoothScroll(to).play();
	},

	_setButtonClass: function(/*Number*/ scroll){
		// summary:
		//		Disables the left scroll button if the tabs are scrolled all the way to the left,
		//		or the right scroll button in the opposite case.
		// scroll: Integer
		//		amount of horizontal scroll

		var scrollBounds = this._getScrollBounds();
		this._leftBtn.set("disabled", scroll <= scrollBounds.min);
		this._rightBtn.set("disabled", scroll >= scrollBounds.max);
	}
});


var ScrollingTabControllerButtonMixin = declare("dijit.layout._ScrollingTabControllerButtonMixin", null, {
	baseClass: "dijitTab tabStripButton",

	templateString: buttonTemplate,

		// Override inherited tabIndex: 0 from dijit.form.Button, because user shouldn't be
		// able to tab to the left/right/menu buttons
	tabIndex: "",

	// Similarly, override FormWidget.isFocusable() because clicking a button shouldn't focus it
	// either (this override avoids focus() call in FormWidget.js)
	isFocusable: function(){ return false; }
});
/*=====
ScrollingTabControllerButtonMixin = dijit.layout._ScrollingTabControllerButtonMixin;
=====*/

// Class used in template
declare("dijit.layout._ScrollingTabControllerButton",
	[Button, ScrollingTabControllerButtonMixin]);

// Class used in template
declare(
	"dijit.layout._ScrollingTabControllerMenuButton",
	[Button, _HasDropDown, ScrollingTabControllerButtonMixin],
{
	// id of the TabContainer itself
	containerId: "",

	// -1 so user can't tab into the button, but so that button can still be focused programatically.
	// Because need to move focus to the button (or somewhere) before the menu is hidden or IE6 will crash.
	tabIndex: "-1",

	isLoaded: function(){
		// recreate menu every time, in case the TabContainer's list of children (or their icons/labels) have changed
		return false;
	},

	loadDropDown: function(callback){
		this.dropDown = new Menu({
			id: this.containerId + "_menu",
			dir: this.dir,
			lang: this.lang,
			textDir: this.textDir
		});
		var container = registry.byId(this.containerId);
		array.forEach(container.getChildren(), function(page){
			var menuItem = new MenuItem({
				id: page.id + "_stcMi",
				label: page.title,
				iconClass: page.iconClass,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir,
				onClick: function(){
					container.selectChild(page);
				}
			});
			this.dropDown.addChild(menuItem);
		}, this);
		callback();
	},

	closeDropDown: function(/*Boolean*/ focus){
		this.inherited(arguments);
		if(this.dropDown){
			this.dropDown.destroyRecursive();
			delete this.dropDown;
		}
	}
});

return ScrollingTabController;
});

},
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:_onClick,onkeypress:_onButtonKeyPress\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeypress:_onArrowKeyPress\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t/></td></tr></tbody\n></table>\n",
'ibm/tivoli/simplesrm/srm/dijit/RequestDetails':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dijit/Dialog,dijit/_Widget,dijit/_Templated,dijit/form/Button,dijit/form/CheckBox,dijit/form/SimpleTextarea,dijit/form/TextBox,ibm/tivoli/tip/dijit/TextInputBox,dijit/form/Form,dijit/layout/BorderContainer,dijit/layout/TabContainer,dijit/layout/ContentPane,ibm/tivoli/simplesrm/srm/dijit/MessageDialog,ibm/tivoli/simplesrm/srm/dijit/OpenHelp,ibm/tivoli/simplesrm/srm/dijit/MultipleModal,ibm/tivoli/simplesrm/srm/dijit/MyRecordsGrid,ibm/tivoli/simplesrm/srm/dijit/ItemChooserGrid,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dojo/Utilities,ibm/tivoli/simplesrm/srm/dojo/Formatter"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.RequestDetails");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.CommLogGrid");

dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

dojo.require("dijit.Dialog");
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit.form.Button");
dojo.require("dijit.form.CheckBox");
dojo.require("dijit.form.SimpleTextarea");
dojo.require("dijit.form.TextBox");
dojo.require("ibm.tivoli.tip.dijit.TextInputBox");
dojo.require("dijit.form.Form");
dojo.require("dijit.layout.BorderContainer");
dojo.require("dijit.layout.TabContainer");
dojo.require("dijit.layout.ContentPane");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MessageDialog");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MultipleModal");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ItemChooserGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Utilities");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Formatter");

/**
 * This panel shows the details from a service request. A dialog is embedded,
 * so per default it will show up as a popup dialog.
 *  
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.RequestDetails",
			 [dijit._Widget,
			  dijit._Templated,
			  ibm.tivoli.simplesrm.srm.dijit.MultipleModal,
			  ibm.tivoli.simplesrm.srm.dijit.OpenHelp],
{
	_uiStringTable: null,
	widgetsInTemplate: true,
	templateString:"<div class=\"templateddialog\">\n<!--\n @HTML_LONG_COPYRIGHT_BEGIN@\n @HTML_LONG_COPYRIGHT_END@\n-->\n\t<div dojoType=\"dijit.Dialog\"\n\t\t dojoAttachPoint=\"_dialog\"\n\t\t title=\"${_uiStringTable.ViewSRTitle}\"\n\t\t class=\"tundra simplesrm templateddialog mydialog\">\n\t\t<div dojoType=\"dijit.layout.BorderContainer\"\n\t\t\tstyle=\"width:${_width};height:430px;background-color:#DCE2E7;padding:0;margin:0;\"> \n\t\t\t<div dojoType=\"dijit.layout.ContentPane\" region=\"center\" style=\"padding:0;margin:0;\">\n\t\t\t\t<div dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t style=\"padding:0;margin:0;font-size:10pt;\">\n\t\t\t\t\t<div dojoType=\"dijit.layout.TabContainer\"\n\t\t\t\t\t\t dojoAttachPoint=\"_tabC\"\n\t\t\t\t\t\t style=\"width:630px;height:630px;padding:0;margin:0;\">\n\t\t\t\t\t\t<div id=\"${id}_general\" dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t\t \t closeable=\"false\" title=\"${_uiStringTable.ViewSRGeneral}\"\n\t\t\t\t\t\t \t dojoAttachPoint=\"_gen\"\n\t\t\t\t\t\t \t style=\"background-color:#DCE2E7;padding:0;margin:0\">\n\t\t\t\t\t\t\t<div class=\"banner\">\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:50px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t<img src=\"../webclient/javascript/simplesrm/srm/dijit/images/icons/default_request.png\" width=\"50\" height=\"50\" alt=\"\"/>\n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:370px;height:50px;margin:10px;\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"_viewSrGenBannerText\">\n\t\t\t\t\t\t\t\t\t${_uiStringTable.ViewSRGenBannerApproval}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"clear\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_gen_table></div>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_attr_table></div>\n\t\t\t\t\t\t</div>\n\t\n\t\t\t\t\t\t<!--div id=\"${id}_work\" dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t\t\t closeable=\"false\" title=\"${_uiStringTable.ViewSRWorkLog}\" \n\t\t\t\t\t\t\t style=\"background-color:#DCE2E7;padding:0;margin:0\">\n\t\t\t\t\t\t\t<div class=\"banner\"\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"_workl_banner\"\n\t\t\t\t\t\t\t\tstyle=\"height:70px;background-color:#C0CEDC;border-color:#B0B5B8;\">\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:50px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t<img src=\"../webclient/javascript/simplesrm/srm/dijit/images/icons/default_request.png\"\n\t\t\t\t\t\t\t\t\t\t width=\"50\" height=\"50\" alt=\"\"/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:370px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t${_uiStringTable.ViewSRWorkBanner}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_workl_table></div>\n\t\t\t\t\t\t</div-->\n\t\t\t\n\t\t\t\t\t\t<div id=\"${id}_comm\" dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t\t\tcloseable=\"false\" title=\"${_uiStringTable.ViewSRCommLog}\"\n\t\t\t\t\t\t\tstyle=\"background-color:#DCE2E7;padding:0;margin:0\">\n\t\t\t\t\t\t\t<div class=\"banner\"\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"_comml_banner\"\n\t\t\t\t\t\t\t\tstyle=\"height:70px;background-color:#C0CEDC;border-color:#B0B5B8;\">\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:50px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t<img src=\"../webclient/javascript/simplesrm/srm/dijit/images/icons/default_request.png\"\n\t\t\t\t\t\t\t\t\t\t width=\"50\" height=\"50\" alt=\"\"/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:370px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t${_uiStringTable.ViewSRCommBanner}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div dojoType=ibm.tivoli.simplesrm.srm.dijit.CommLogGrid\n\t\t\t\t\t\t\t\t dojoAttachPoint=_comml_table name=\"\" \n\t\t\t\t\t\t\t\t class=\"commloggrid\">\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_comml_details>\n\t\t\t\t\t\t\t\t<table width=90% style=\"\"><tr>\n\t\t\t\t\t\t\t\t<td><div dojoAttachPoint=_comml_details_gen></div></td>\n\t\t\t\t\t\t\t\t<td><div dojoAttachPoint=_comml_details_det></div></td>\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t</tr></table>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<!-- Venkyg : Solutions for SRs and Related Records -->\n\t\t\t\t\t\t\n\t\t\t\t\t\t<div id=\"${id}_work\" dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t\t\t closeable=\"false\" title=\"${_uiStringTable.ViewSolutionForSRPR}\" \n\t\t\t\t\t\t\t style=\"background-color:#DCE2E7;padding:0;margin:0\">\n\t\t\t\t\t\t\t<div class=\"banner\"\n\t\t\t\t\t\t\t\tdojoAttachPoint=\"_workl_banner\"\n\t\t\t\t\t\t\t\tstyle=\"height:70px;background-color:#C0CEDC;border-color:#B0B5B8;\">\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:50px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t<img src=\"../webclient/javascript/simplesrm/srm/dijit/images/icons/default_request.png\"\n\t\t\t\t\t\t\t\t\t\t width=\"50\" height=\"50\" alt=\"\"/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:370px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t${_uiStringTable.ViewSolutionForSRPRBanner}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_workl_table></div>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_solRR_table></div>  \n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_apprC\" class=\"approval\"\n\t\t\t\t region=\"right\" style=\"display:${_approvalDisplay}\">\n\t\t\t\t<form id=\"${id}_approvalForm\" name=\"approvalForm\" dojoType=\"dijit.form.Form\">\n\t\t\t\t\t<div style=\"width:100%;height:100%;padding:0;margin:0\">\n\t\t\t\t\t\t<div class=\"banner\">\n\t\t\t\t\t\t\t<div class=\"paneltop\" style=\"width:240px;height:20px;padding:5px;margin:0;\">\n\t\t\t\t\t\t\t\t<label style=\"font-weight:bold;font-size:10pt;\">${_uiStringTable.AppRequestBannerTitle}</label>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div style=\"width:240px;height:45px;padding:5px;margin:0;font-size:10pt;\">\n\t\t\t\t\t\t\t\t${_uiStringTable.AppRequestBannerDescription}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<ul style=\"list-style:none;padding-left:5px;margin-left:5px;overflow:auto\";>\n\t\t\t\t\t\t<li style=\"clear: both;\">\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:10%\">\n\t\t\t\t\t\t\t\t\t<input dojoType=\"dijit.form.RadioButton\" id=\"${id}_reject\" name=\"process\" \n\t\t           \t\t\t\t\t\t\tchecked=\"checked\" value=\"reject\" type=\"radio\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:right;width:90%;\">\n\t\t\t\t\t\t\t\t\t<label style=\"word-wrap:break-word;\" for=\"${id}_reject\"><font size= \"2\"> ${_uiStringTable.RejectRequest} </font></label>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li style=\"clear: both;\">\n\t\t\t\t\t        <div>\n\t\t\t\t\t\t\t\t<div style=\"float:left; width:10%\">\n\t\t\t\t\t\t\t\t\t<input dojoType=\"dijit.form.RadioButton\" id=\"${id}_approve\" name=\"process\" \n\t\t\t\t\t          \t\t\t\t\t\t\t\tvalue=\"approve\" type=\"radio\">\n\t\t\t\t\t          \t</div>\n\t\t\t\t\t\t\t\t<div style=\"float: right; width: 90%;\">\n\t\t\t\t\t\t\t\t\t<label  style=\"word-wrap:break-word;\"for=\"${id}_approve\"><font size= \"2\"> ${_uiStringTable.ApproveRequest} </font></label>\n\t\t\t\t\t\t\t\t</div>\n\t\t        \t\t\t</div>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li style=\"clear: both;\">\n\t\t\t\t\t\t\t<label><font size=\"2\">${_uiStringTable.ApproveDetails}</font></label>\n\t\t\t\t\t\t\t<input id=\"${id}_detail\" name=\"detail\" dojoType=\"ibm.tivoli.tip.dijit.TextInputBox\"\n\t\t\t\t\t\t\t\t   style=\"width:90%\" constraints=\"{maxlen: 50}\" size=\"25\">\n\t\t\t\t\t\t</li>\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t</form>\n\t\t\t</div>\n\n\t\t\t<div dojoType=\"dijit.layout.ContentPane\" region=\"bottom\" class=\"footer\"\n\t\t\t\tstyle=\"background: #B2B2B2 url(../webclient/javascript/simplesrm/srm/dijit/images/ge64_toolbar_top.png) repeat-x scroll left top;margin:0;border-width:2px 0 0 0;border-color:#B0B5B8;\">\n\t\t\t\t<button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"_closeBtn\"\n\t\t\t\t\t \ttype=\"submit\">\n\t\t\t \t\t${_uiStringTable.Close}\n\t\t\t \t</button>\n\t\t\t \t<button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"_apprOKBtn\"\n\t\t\t \t\t    dojoAttachEvent=\"onClick:_onOKClick\" >\n\t\t\t \t\t${_uiStringTable.OK}\n\t\t\t \t</button>\n\t\t\t\t<button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"_apprCancelBtn\"\n\t\t\t\t\t\ttype=\"submit\">\n\t\t\t\t\t${_uiStringTable.Cancel}\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</div>\n\t\t\n\t</div>\n</div>\n",
	parseOnLoad: true,
	hasApproval: false, /* Tell whether the panel should have a approval subpanel */
	ALN: "ALN",
	NUMERIC: "NUMERIC",
	TABLE: "TABLE",
	
	_approvalDisplay: "none",
	_Width: "630px",
	
	_data: null,
	cshKey: "PMRDP_View_DetailsSubmittedRequests.htm",
	_processErrorMessage: "CTJZH2331E",
	
	constructor: function(params) {
		console.log("RequestDetails.constructor()", params);
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
		if (params.approval && params.approval === true) {
			this.hasApproval = true;
			/* Also modify the help key */
			this.cshKey = "PMRDP_View_ApprovalDetails.htm";
		}
		console.log("RequestDetails.constructor()", this.hasApproval);
	},
	
	buildRendering: function() {
		console.log("RequestDetails.buildRendering()");
		try {
			this._approvalDisplay = this.hasApproval ? "" : "none";
			this._width = this.hasApproval ? "880px" : "630px";
			this.inherited(arguments);
			console.log(this._dialog, this);
			
			dojo.connect(this._tabC, "selectChild", dojo.hitch(this, this.tabSel));
			this._comml_table.setOwner(this);
			this.addHelp();
		}
		catch(ex) {
			console.group("Failed generating input form from template");
			console.error(ex);
			console.groupEnd();
			throw new ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError(ex);
		}
	},
	
	postCreate: function() {
		console.log("RequestDetails.postCreate()", this.hasApproval);
		if (this.hasApproval === false) {
			/* Hide the approval subpanel in this case, as well as the OK &
			 * Cancel buttons */
			console.log("Approval set as disabled. Path working.", this._apprOKBtn);
			this._viewSrGenBannerText.innerHTML = this._uiStringTable.ViewSRGenBannerNoApproval;
			dojo.style(this._apprOKBtn.domNode, "display", "none");
			dojo.style(this._apprCancelBtn.domNode, "display", "none");
		} else {
			console.log("Approval set as enabled.", this._closeBtn);
			dojo.style(this._closeBtn.domNode, "display", "none");
		}
		
		var datatypeMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('DATATYPE');
		this.ALN = datatypeMap.valueByMaxvalue("ALN");
		this.NUMERIC = datatypeMap.valueByMaxvalue("NUMERIC");
		this.TABLE = datatypeMap.valueByMaxvalue("MAXTABLE");
		
		this.inherited(arguments);
	},
	
	tabSel: function(child) {
		this._comml_table._grid.update();
	},
	
	_onKey: function(event){		
		//changes original method to support multiple modal dialogs
		if (!this.preOnKeyTest(event)) {
			return; // it's not your event
		}				
		this._dialog._onKey(event);			
	},
	
	show: function() {
		this.patchCode();
		this._dialog.supportsMultipleModal=true; //hack to support multiple modal panels
		this._dialog.show();
		this._dialog.domNode.style.zIndex = dijit._underlay.getDialogZIndex();
	},
	
	setData: function(data)
	{
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		
		if (product!=null && product.indexOf("srm")>=0)  //fpb
		{
			this._data = data.QuerySRM_SRDETResponse.SRM_SRDETSet.SR[0];
		} else
		{
			this._data = data.QueryMXSRDETResponse.MXSRDETSet.SR[0];
		}

		//console.log("--VENKY ** RequestDetails.setData()-- true/false = ", data.QueryMXSRResponse.MXSRSet.SR);
		/* Case with no SR */
		//if (!data.QueryMXSRResponse.MXSRSet.SR) {
		//if (!data.QuerySRM_SRDETResponse.SRM_SRDETSet.SR) {
		  if (!this._data) { 
			console.log("Empty data for this request");
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog(
											{messageId: "CTJZH2321I", type: "info"})).show();
			return; 
		}
		//this._data = data.QuerySRM_SRDETResponse.SRM_SRDETSet.SR[0];
		//this._data = data.QueryMXSRDETResponse.MXSRDETSet.SR[0];

		this._fillGeneral(this._data); 
				
		this._fillAttrTable(this._data);
		
		/* gv : Don't need this tab for SRM

		//gv if (!this._data.PMZHBSLOG) {
		if (!this._data.WORKLOG) {
			console.log("Trying to hide worklog");
			this._workl_banner.innerHTML =
				"<b>" + this._uiStringTable.ViewSRNoWorkl + "</b>";
			dojo.style(this._workl_banner, "padding", "20px 0 0 50px");
		} else {
			console.log("Detected worklog");
			this._buildWorkLog(this._data);
		}*/



		if (!this._data.COMMLOG) {
			console.log("Trying to hide commlog", this._comml_banner);
			this._comml_banner.innerHTML =
				"<b>" + this._uiStringTable.ViewSRNoComml + "</b>";
			dojo.style(this._comml_banner, "padding", "20px 0 0 50px");
			dojo.style(this._comml_table.domNode, "display", "none");
		} else {
			console.log("Detected commlog");
			console.log("this._comml_table", this._comml_table);
			 this._comml_table.refreshData(this._data.TICKETUID); 
		}

        //gv : Make call to display data for SR-Solution 
		if (!this._data.LONGDESCRIPTION) {
			console.log("Trying to hide SR Solution");
			this._workl_banner.innerHTML =
				"<b>" + this._uiStringTable.ViewSRNoSol + "</b>";
			dojo.style(this._workl_banner, "padding", "20px 0 0 50px");
		} else {
			console.log("Detected SR Solution");
			this._buildSolutionForSR(this._data);
		}

		//gv : Make call to display data for Related Record-Solution 
		if (!this._data.RELATEDRECORD) {
			console.log("Trying to hide RR Solution");
			this._workl_banner.innerHTML =
				"<b>" + this._uiStringTable.ViewSRNoSol + "</b>";
			dojo.style(this._workl_banner, "padding", "20px 0 0 50px");
		} else {
			console.log("Detected RR Solution");
			this._buildSolutionForRR(this._data);
		}



		this.show();

	},
	/**
	 * Set the HTML content for the PMZBHSLOG section.
	 */
	_buildPmzLog: function(data) {
		console.log("RequestDetails._buildPmzLog()", data);
		var wlog = data.PMZHBSLOG;
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\">" +
						 this._uiStringTable.Date +
						 "</td><td class=\"title\">" +
						 this._uiStringTable.Summary +
						 "</td></tr></thead><tbody>";
		for (i = 0; i < wlog.length; i++) {
			newContent += "<tr class=\"stroke\"><td>";
			newContent += wlog[i].TIME.formatISODateString();
			newContent += "</td><td>";
			newContent += wlog[i].FULL_MSG_TEXT ? wlog[i].FULL_MSG_TEXT.htmlencode() : "";
			newContent += "</td><td>";
		}
		newContent += "</tbody></table>";
		console.log("Setting work log content", newContent);
		this._workl_table.innerHTML = newContent;
	},
	 /**
	 * Set the HTML content for the WORKLOG section.
	 * Venkyg : 3/11/10
	 */
	_buildWorkLog: function(data) {
		console.log("RequestDetails._buildWorkLog()", data);
		var wlog = data.WORKLOG;
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\">" +
						 this._uiStringTable.Date +
						 "</td><td class=\"title\">" +
						 this._uiStringTable.Summary +
						 "</td></tr></thead><tbody>";
		for (i = 0; i < wlog.length; i++) {
			newContent += "<tr class=\"stroke\"><td>";
			newContent += wlog[i].CREATEDATE.formatISODateString();
			newContent += "</td><td>";
			newContent += wlog[i].DESCRIPTION ? wlog[i].DESCRIPTION.htmlencode() : "";
			newContent += "</td><td>";
		}
		newContent += "</tbody></table>";
		console.log("Setting work log content", newContent);
		this._workl_table.innerHTML = newContent;
		console.log("--Venky---RequestDetails._buildWorkLog()--end of method- newContent = ", newContent);
	},
	 /**
	 * Set the HTML content for the Solutions for SRs
	 * Venkyg : 3/11/10
	 */
	_buildSolutionForSR: function(data) {
		console.log("RequestDetails._buildSolutionForSR()", data);
		var solu = data.LONGDESCRIPTION;
		 
		var problem = "";
		var resolution = ""; 
		var cause = "";
		for (i = 0; i < solu.length; i++) {
			var colName = solu[i].LDOWNERCOL;
			if(colName == 'PROBLEMCODE')
				problem = solu[i].LDTEXT
			else
			if(colName == 'FR2CODE')
				resolution = solu[i].LDTEXT
			else
			if(colName == 'FR1CODE')
				cause = solu[i].LDTEXT
		}

		console.log("RequestDetails._buildSolutionForSR()-- problem", problem,resolution,cause);

        var newContent = "<table class=\"infotable\"><thead><tr><td nowrap class=\"title\">" +
			 this._uiStringTable.ViewSRSolDetails +
			"</td><td class=\"status\" " +
			"</td></tr></thead><tbody>";

		if (problem) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.Symptom + "</td><td>" +
						 problem.htmlencode() + "</td></tr>";
		}
		
		if (cause) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.Cause + "</td><td>" +
						 cause.htmlencode() + "</td></tr>";
		}

		if (resolution) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.Resolution + "</td><td>" +
						 resolution.htmlencode() + "</td></tr>";
		}
		newContent += "</tbody></table>";
		console.log("--Venky---RequestDetails._buildSolutionForSR()--end of method- newContent = ", newContent);
		this._workl_table.innerHTML = newContent;

	},

	 /**
	 * Set the HTML content for the Solutions for RRs
	 * Venkyg : 3/11/10
	 */
  _buildSolutionForRR: function(data) { 
		console.log("RequestDetails._buildSolutionForRR()", data);

		var newContent = "<table class=\"infotable\"><thead><tr><td nowrap class=\"title\">" +
			 this._uiStringTable.ViewRRSolDetails +
			"</td> </tr></thead><tbody>";
		var rRecord = data.RELATEDRECORD;
		for (j = 0; j < rRecord.length; j++) 
		{
			var solu = rRecord[j].LONGDESCRIPTION;

			var problem = "";
			var resolution = ""; 
			var cause = "";
			for (i = 0; i < solu.length; i++) {
				var colName = solu[i].LDOWNERCOL;
				if(colName == 'PROBLEMCODE')
					problem = solu[i].LDTEXT
				else
				if(colName == 'FR2CODE')
					resolution = solu[i].LDTEXT
				else
				if(colName == 'FR1CODE')
					cause = solu[i].LDTEXT
			}

			console.log("RequestDetails._buildSolutionForRR()-- problem", problem,resolution,cause);

			if (problem) {
				newContent += "<tr class=\"stroke\"><td>" +
							 this._uiStringTable.Symptom + "</td><td>" +
							 problem + "</td></tr>";
			}
			
			if (cause) {
				newContent += "<tr class=\"stroke\"><td>" +
							 this._uiStringTable.Cause + "</td><td>" +
							 cause + "</td></tr>";
			}

			if (resolution) {
				newContent += "<tr class=\"stroke\"><td>" +
							 this._uiStringTable.Resolution + "</td><td>" +
							 resolution + "</td></tr>";
			}

			if(j < rRecord.length-1)
				newContent += "<tr class=\"stroke\"><td></td><td> </td></tr>";

		}
		 
		
		newContent += "</tbody></table>";
		console.log("--Venky---RequestDetails._buildSolutionForRR()--end of method- newContent = ", newContent);
		this._solRR_table.innerHTML = newContent;
	},

	/**
	 * Set the HTML content for the general section.
	 */	
	_fillGeneral: function(data) {
		console.log("RequestDetails._fillGeneral()", data);
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\">" +
			 this._uiStringTable.ViewSRDetails +
			"</td><td class=\"status\" dojoAttachPoint=" + data.STATUS +
			"</td></tr></thead><tbody>";
		var genDesc = data.DESCRIPTION;
		if (genDesc) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.Description + "</td><td>" +
						 genDesc.htmlencode() + "</td></tr>";
		}
		var genReq = data.CREATEDBY;
		if (genReq) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.RequestedBy + "</td><td>" +
						 genReq.htmlencode() + "</td></tr>";
		}
		var genCreated = data.CREATIONDATE;
		if (genCreated) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.CreatedOn + "</td><td>" +
						 genCreated.formatISODateString({sel: "datetime"}) + "</td></tr>";
		}
		var genStart = data.TARGETSTART;
		if (genStart) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.StartDateLabel + "</td><td>"+
						 genStart.formatISODateString() + "</td></tr>";
		}
		var genEnd = data.TARGETFINISH;
		if (!genEnd) {
			// forever/indefinite == undefined TARGETFINISH(not present in response)
			genEnd = this._uiStringTable.ForeverLabel;
		}
		else {
			genEnd = genEnd.formatISODateString();			
		}
		
		newContent += "<tr class=\"stroke\"><td>" +
			 this._uiStringTable.EndDateLabel + "</td><td>" +
			 genEnd + "</td></tr>";
		
		var genLastUpdate = data.CHANGEDATE;
		if (genLastUpdate) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.ViewSRLastUpdate + "</td><td>" +
						 genLastUpdate.formatISODateString({sel: "datetime"}) + "</td></tr>";
		}
		var genUpdatedBy = data.CHANGEBY;
		if (genUpdatedBy) {
			newContent += "<tr class=\"stroke\"><td> " +
						 this._uiStringTable.ViewSRUpdatedBy + "</td><td>" +
						 genUpdatedBy + "</td></tr>";
		}
		newContent += "</tbody></table>";
		this._gen_table.innerHTML = newContent;
	},
	
	_fillAttrTable: function(data) {
		console.log("RequestDetails._fillAttrTable()", data);
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\" colspan=2>" +
			 data.DESCRIPTION +"</td></tr></thead><tbody>";
		var attrs = data.TICKETSPEC;
		/* Exit in case of empty data */
		if (!attrs) {
			console.log("RequestDetails._fillAttrTable(): no ticket spec found");
			return;
		}
		for (i = 0; i < attrs.length; i++) {
			/* check what type of value this is */
			var attrType = attrs[i].ASSETATTRIBUTE[0].DATATYPE;
			var val = "";
			if (attrType == "NUMERIC") {
				val = attrs[i].NUMVALUE;
			} else if (attrType == "ALN") {
				val = attrs[i].ALNVALUE;
			} else if (attrType == "TABLE") {
				if (attrs[i].ALNVALUE){
					val = attrs[i].ALNVALUE;
				}
			} else {
				console.log("NEW TYPE", i, attrType);
				//debugger; /* STOP! */
			}
			if ((val != undefined) && (val != "")) {
				newContent += "<tr class=\"stroke\"><td>";
				newContent += attrs[i].ASSETATTRIBUTE[0].DESCRIPTION;
				newContent += "</td><td>";
				newContent += val.toString().htmlencode();
				newContent += "</td></tr>";
			}
		}		
		newContent += "</tbody></table>";
		this._attr_table.innerHTML = newContent;
	},
	
	_fillCommLogDetails: function(index) {
		console.log("RequestDetails._fillCommLogDetails()", index);
		
		var item = this._data.COMMLOG[index];
		var newContent2 = "<table class=\"infotable\"><thead><tr><td class=\"title\">"+
			 this._uiStringTable.Details + "</td></tr></thead><tbody>";
		newContent2 += "<tr><td>" + (item.MESSAGE ? item.MESSAGE.htmlencode() : "") + "</td></tr>";
		newContent2 += "</tbody></table>";
		this._comml_details_det.innerHTML = newContent2;
	},
	
	_onOKClick: function(evt) 
	{
		
		var tid = this._data.TICKETID;
		var approveCheck = dijit.byId(this.id + "_approve").checked	;	
		//var summaryInfo = dijit.byId(this.id + "_summary").value;	

		//var detailInfo = dijit.byId(this.id + "_detail").getValue();
		var detailInfoWidget = dijit.byId(this.id + "_detail");		
		var detailInfo = detailInfoWidget.getValue();
		
		//var detailInfo = dijit.byId(this.id + "_detail").value;

		//console.log("_onOKClick: tid is : " + tid + " ,approveCheck is : " + approveCheck + " ,detailInfo is : " + detailInfo);
		
		detailInfoWidget.validate();
		
		var hasError = detailInfoWidget._isInError;

		if (hasError){
			ibm.tivoli.logger.error("Invalid Detail Input Value!");
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2336E"})).show();
			dojo.stopEvent(evt);			
		}else {
			var bSuccess = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().approveRequest(tid, detailInfo, approveCheck);

			if(!bSuccess) {
				ibm.tivoli.logger.error("Failure approving/rejecting a request");
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2331E"})).show();
				dojo.stopEvent(evt);
			}
			else {
				this.hide();
			}
			return bSuccess;			
		}
	},
	
	hide: function()
	{
		this._dialog.hide();
	},
	
	/* Help stuff */

	//handler:used when user clicks '?'
	openHelp: function(event){
		this.openHelpWindow(this.cshKey);
	},

	//error handler: used when help url can't be retrieved from server
	_errorRetrievingUrl:function() {
		(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2302E"})).show();
	},

	//sets cshKey, adds '?' to title bar, connects help events 
	addHelp: function() {
		var helpNode = document.createElement("span");
		
		dojo.addClass(helpNode , "dijitDialogHelpIcon");			
		dojo.attr(helpNode , "id" , this.id + "_visual_" + this.cshKey);
		dojo.attr(helpNode , "title" , this._uiStringTable["Help"]);
		dojo.attr(helpNode , "tabindex" , 0);
		
		var res = dojo.place(helpNode, this._dialog.closeButtonNode ,"before");
		this.connect(helpNode , "onclick" , "openHelp");
		this.connect(helpNode , "onmouseenter","_onHelpEnter");		
		this.connect(helpNode , "onmouseleave","_onHelpLeave");
		this.connect(helpNode , "onkeypress" , "_onEnterPressed");
		
		var textHelpNode = document.createElement("span");
					
		dojo.addClass(textHelpNode , "closeText");
		dojo.attr(textHelpNode , "id" , this.id + "_text_" + this.cshKey);
		dojo.attr(textHelpNode , "title" , this._uiStringTable["Help"]);			
		
		var textNode = document.createTextNode("?");
		dojo.place(textNode , textHelpNode );
		
		dojo.place(textHelpNode, helpNode);
		
		this.connect(this.domNode,"keypress","_onHelpKey");
	},

	_onHelpEnter: function() {
		var helpNode = dojo.query(".dijitDialogHelpIcon",this.titleBar);
		dojo.addClass(helpNode[0], "dijitDialogHelpIcon-hover");
	},

	_onHelpLeave: function(){
		var helpNode = dojo.query(".dijitDialogHelpIcon-hover",this.titleBar);
		dojo.removeClass(helpNode[0] , "dijitDialogHelpIcon-hover");
	},

	_onHelpKey: function(event) {
		//console.log("current: " + event.keyCode + " / " + event.charOrCode + " target: " + dojo.keys.HELP); 
		
		// help key accessible from whole panel
		if(event.keyCode == dojo.keys.F1){
			
			// on IE dojo.stopEvent() is not enough to cancel this event
			// "onhelp" attribute is valid for IE only
			if (dojo.isIE){ 
				document.onhelp = function(){return false;};
				window.onhelp = function(){return false;};
			}
			
			if(this.cshKey && this.openHelp){				
				dojo.stopEvent(event);			
				this.openHelp(event);
				return false;
			}
		}
		return true;
	},
	
	_onEnterPressed: function(event) {
		//open only if Enter was pressed on help icon
		if ((event.keyCode == dojo.keys.ENTER) && 
			(dojo.hasClass(event.target ,"dijitDialogHelpIcon"))){
			dojo.stopEvent(event);
			this.openHelp(event);
			return false;
		}
		return true;
	}

});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.CommLogGrid",
			 [ibm.tivoli.simplesrm.srm.dijit.ItemChooserGrid,
			  ibm.tivoli.simplesrm.srm.dojo.Formatter], {
	_uiStringTable: null,
	autoQuery: false,

	constructor: function() {
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
		this.gridLayout = [
	      	{
	      	 name: this._uiStringTable.Application,
	      	 field: 'app',
	      	 width: '15%',
	      	 compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare
	      	},
	     	{
	      	 name: this._uiStringTable.To,
	      	 field: 'sendto',
	      	 width: '20%',
	      	 compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare
	      	},
	      	{
	      	 name: this._uiStringTable.From,
	      	 field: 'sendfrom',
	      	 width: '20%',
	      	 compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare
	      	},
	      	{
	      	 name: this._uiStringTable.Date,
	      	 field: 'date',
	      	 width: '15%',
	      	 compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare,
	      	 formatter: dojo.hitch(this, "_formatDatetime")
	      	},
	      	{
			 name: this._uiStringTable.Subject,
			 field: 'subject',
			 width: '30%',
			 compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare,
			 formatter: dojo.hitch(this, this._noWrap)
			}
	      	
   		];
   		
   		this.keyField = "msgid";
	},

	queryData: function() {
		console.log("CommLogGrid.queryData(): ", this._ticketUid);
		var d = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestDetails(
														{id : this._ticketUid});
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product"); 
		d.addCallback(function(response) {
			//gv var logItems = response.QueryPMZHBR1_SRDETResponse.PMZHBR1_SRDETSet.SR[0].COMMLOG;
			//var logItems = response.QuerySRM_SRDETResponse.SRM_SRDETSet.SR[0].COMMLOG;  
			var logItems = "";
			if (product!=null && product.indexOf("srm")>=0)  //fpb
			{
				logItems = response.QuerySRM_SRDETResponse.SRM_SRDETSet.SR[0].COMMLOG;  
			} else
			{
				logItems = response.QueryPMZHBR1_SRDETResponse.PMZHBR1_SRDETSet.SR[0].COMMLOG;
			}
			response.data = [];
			for(var i in logItems) {
				var item = logItems[i]; 
				response.data.push({app: item.CREATEBY,
									date: item.CREATEDATE,
									subject: item.SUBJECT,
									sendto: item.SENDTO,
									sendfrom: item.SENDFROM,
									msgid: i});
			}
		});
		return d;
	},
	
	refreshData: function(ticketUid) {
		this._ticketUid = ticketUid;
		this.refresh();
		this._grid.update();
	},
	
	setOwner: function(owner) {
		this._owner = owner;
	},
	
	onChange: function(item) {
		console.log("On Change CALLED", item, this._owner, this._grid.selection.selectedIndex);
		this._owner._fillCommLogDetails(this._grid.selection.selectedIndex);
	}

});
});

},
'ibm/tivoli/simplesrm/srm/dijit/ConfirmationDialog':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dijit/PopupDialog,dijit/Dialog"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ConfirmationDialog");

dojo.require("ibm.tivoli.simplesrm.srm.dijit.PopupDialog");
dojo.require("dijit.Dialog");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ConfirmationDialog", null, {
	
	_uiStringTable: null,
	
	_messageMapping : {PMRDP_0253A : "CTJZH2352E",
					   PMRDP_0218A : "CTJZH2348E",
					   PMRDP_0221A : "CTJZH2349E",
					   PMRDP_0237A : "CTJZH2351E",
					   PMRDP_0233A : "CTJZH2350E"},
	
	constructor: function()
	{
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
	},
	show : function(title, reqType, content, callbackFn, e) {

		var confirmationDialog = new ibm.tivoli.simplesrm.srm.dijit.PopupDialog(
										{id: 'confirmationDialog', title: title});
		dojo.style(confirmationDialog.closeButtonNode, "visibility", "hidden");
		var onClickCallback = function(mouseEvent) {
			confirmationDialog.hide();
			confirmationDialog.destroyRecursive();
			if (window.event) {
				e = window.event;
			}
			var srcEl = mouseEvent.srcElement? mouseEvent.srcElement : mouseEvent.target; //IE or Firefox
			if (srcEl.id == 'yes') {
				callbackFn(true, e);
			} else {
				callbackFn(false, e);
			}
		};
		var customizedMessage = this._uiStringTable[this._messageMapping[reqType]];
		var customizedMessageWithContent =
						 customizedMessage.replace("\{0\}", "<b>"+content+"</b>");
		var message = customizedMessageWithContent + " " + this._uiStringTable["ConfirmationProceed"];
		var questionDiv = dojo.create('div', {innerHTML: message});
		dojo.addClass(questionDiv,"info");
		var footerDiv = dojo.create('div');

		confirmationDialog.containerNode.appendChild(questionDiv);
		confirmationDialog.containerNode.appendChild(footerDiv);

		var yesButton = new dijit.form.Button(
			{ label: this._uiStringTable.Yes, id: 'yes', onClick: onClickCallback });
		yesButton.placeAt(footerDiv);
	
		var noButton = new dijit.form.Button(
			{ label: this._uiStringTable.No, id: 'no', onClick: onClickCallback });
		noButton.placeAt(footerDiv);

		confirmationDialog.show();
	}
});

});

},
'dijit/place':function(){
define("dijit/place", [
	"dojo/_base/array", // array.forEach array.map array.some
	"dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.getBox
	"."	// dijit (defining dijit.place to match API doc)
], function(array, domGeometry, domStyle, kernel, win, winUtils, dijit){

	// module:
	//		dijit/place
	// summary:
	//		Code to place a popup relative to another node


	function _place(/*DomNode*/ node, choices, layoutNode, aroundNodeCoords){
		// summary:
		//		Given a list of spots to put node, put it at the first spot where it fits,
		//		of if it doesn't fit anywhere then the place with the least overflow
		// choices: Array
		//		Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
		//		Above example says to put the top-left corner of the node at (10,20)
		// layoutNode: Function(node, aroundNodeCorner, nodeCorner, size)
		//		for things like tooltip, they are displayed differently (and have different dimensions)
		//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
		//		It also passes in the available size for the popup, which is useful for tooltips to
		//		tell them that their width is limited to a certain amount.	 layoutNode() may return a value expressing
		//		how much the popup had to be modified to fit into the available space.	 This is used to determine
		//		what the best placement is.
		// aroundNodeCoords: Object
		//		Size of aroundNode, ex: {w: 200, h: 50}

		// get {x: 10, y: 10, w: 100, h:100} type obj representing position of
		// viewport over document
		var view = winUtils.getBox();

		// This won't work if the node is inside a <div style="position: relative">,
		// so reattach it to win.doc.body.	 (Otherwise, the positioning will be wrong
		// and also it might get cutoff)
		if(!node.parentNode || String(node.parentNode.tagName).toLowerCase() != "body"){
			win.body().appendChild(node);
		}

		var best = null;
		array.some(choices, function(choice){
			var corner = choice.corner;
			var pos = choice.pos;
			var overflow = 0;

			// calculate amount of space available given specified position of node
			var spaceAvailable = {
				w: {
					'L': view.l + view.w - pos.x,
					'R': pos.x - view.l,
					'M': view.w
				   }[corner.charAt(1)],
				h: {
					'T': view.t + view.h - pos.y,
					'B': pos.y - view.t,
					'M': view.h
				   }[corner.charAt(0)]
			};

			// configure node to be displayed in given position relative to button
			// (need to do this in order to get an accurate size for the node, because
			// a tooltip's size changes based on position, due to triangle)
			if(layoutNode){
				var res = layoutNode(node, choice.aroundCorner, corner, spaceAvailable, aroundNodeCoords);
				overflow = typeof res == "undefined" ? 0 : res;
			}

			// get node's size
			var style = node.style;
			var oldDisplay = style.display;
			var oldVis = style.visibility;
			if(style.display == "none"){
				style.visibility = "hidden";
				style.display = "";
			}
			var mb = domGeometry. getMarginBox(node);
			style.display = oldDisplay;
			style.visibility = oldVis;

			// coordinates and size of node with specified corner placed at pos,
			// and clipped by viewport
			var
				startXpos = {
					'L': pos.x,
					'R': pos.x - mb.w,
					'M': Math.max(view.l, Math.min(view.l + view.w, pos.x + (mb.w >> 1)) - mb.w) // M orientation is more flexible
				}[corner.charAt(1)],
				startYpos = {
					'T': pos.y,
					'B': pos.y - mb.h,
					'M': Math.max(view.t, Math.min(view.t + view.h, pos.y + (mb.h >> 1)) - mb.h)
				}[corner.charAt(0)],
				startX = Math.max(view.l, startXpos),
				startY = Math.max(view.t, startYpos),
				endX = Math.min(view.l + view.w, startXpos + mb.w),
				endY = Math.min(view.t + view.h, startYpos + mb.h),
				width = endX - startX,
				height = endY - startY;

			overflow += (mb.w - width) + (mb.h - height);

			if(best == null || overflow < best.overflow){
				best = {
					corner: corner,
					aroundCorner: choice.aroundCorner,
					x: startX,
					y: startY,
					w: width,
					h: height,
					overflow: overflow,
					spaceAvailable: spaceAvailable
				};
			}

			return !overflow;
		});

		// In case the best position is not the last one we checked, need to call
		// layoutNode() again.
		if(best.overflow && layoutNode){
			layoutNode(node, best.aroundCorner, best.corner, best.spaceAvailable, aroundNodeCoords);
		}

		// And then position the node.  Do this last, after the layoutNode() above
		// has sized the node, due to browser quirks when the viewport is scrolled
		// (specifically that a Tooltip will shrink to fit as though the window was
		// scrolled to the left).
		//
		// In RTL mode, set style.right rather than style.left so in the common case,
		// window resizes move the popup along with the aroundNode.
		var l = domGeometry.isBodyLtr(),
			s = node.style;
		s.top = best.y + "px";
		s[l ? "left" : "right"] = (l ? best.x : view.w - best.x - best.w) + "px";
		s[l ? "right" : "left"] = "auto";	// needed for FF or else tooltip goes to far left

		return best;
	}

	/*=====
	dijit.place.__Position = function(){
		// x: Integer
		//		horizontal coordinate in pixels, relative to document body
		// y: Integer
		//		vertical coordinate in pixels, relative to document body

		this.x = x;
		this.y = y;
	};
	=====*/

	/*=====
	dijit.place.__Rectangle = function(){
		// x: Integer
		//		horizontal offset in pixels, relative to document body
		// y: Integer
		//		vertical offset in pixels, relative to document body
		// w: Integer
		//		width in pixels.   Can also be specified as "width" for backwards-compatibility.
		// h: Integer
		//		height in pixels.   Can also be specified as "height" from backwards-compatibility.

		this.x = x;
		this.y = y;
		this.w = w;
		this.h = h;
	};
	=====*/

	return (dijit.place = {
		// summary:
		//		Code to place a DOMNode relative to another DOMNode.
		//		Load using require(["dijit/place"], function(place){ ... }).

		at: function(node, pos, corners, padding){
			// summary:
			//		Positions one of the node's corners at specified position
			//		such that node is fully visible in viewport.
			// description:
			//		NOTE: node is assumed to be absolutely or relatively positioned.
			// node: DOMNode
			//		The node to position
			// pos: dijit.place.__Position
			//		Object like {x: 10, y: 20}
			// corners: String[]
			//		Array of Strings representing order to try corners in, like ["TR", "BL"].
			//		Possible values are:
			//			* "BL" - bottom left
			//			* "BR" - bottom right
			//			* "TL" - top left
			//			* "TR" - top right
			// padding: dijit.place.__Position?
			//		optional param to set padding, to put some buffer around the element you want to position.
			// example:
			//		Try to place node's top right corner at (10,20).
			//		If that makes node go (partially) off screen, then try placing
			//		bottom left corner at (10,20).
			//	|	place(node, {x: 10, y: 20}, ["TR", "BL"])
			var choices = array.map(corners, function(corner){
				var c = { corner: corner, pos: {x:pos.x,y:pos.y} };
				if(padding){
					c.pos.x += corner.charAt(1) == 'L' ? padding.x : -padding.x;
					c.pos.y += corner.charAt(0) == 'T' ? padding.y : -padding.y;
				}
				return c;
			});

			return _place(node, choices);
		},

		around: function(
			/*DomNode*/		node,
			/*DomNode || dijit.place.__Rectangle*/ anchor,
			/*String[]*/	positions,
			/*Boolean*/		leftToRight,
			/*Function?*/	layoutNode){

			// summary:
			//		Position node adjacent or kitty-corner to anchor
			//		such that it's fully visible in viewport.
			//
			// description:
			//		Place node such that corner of node touches a corner of
			//		aroundNode, and that node is fully visible.
			//
			// anchor:
			//		Either a DOMNode or a __Rectangle (object with x, y, width, height).
			//
			// positions:
			//		Ordered list of positions to try matching up.
			//			* before: places drop down to the left of the anchor node/widget, or to the right in
			//				the case of RTL scripts like Hebrew and Arabic
			//			* after: places drop down to the right of the anchor node/widget, or to the left in
			//				the case of RTL scripts like Hebrew and Arabic
			//			* above: drop down goes above anchor node
			//			* above-alt: same as above except right sides aligned instead of left
			//			* below: drop down goes below anchor node
			//			* below-alt: same as below except right sides aligned instead of left
			//
			// layoutNode: Function(node, aroundNodeCorner, nodeCorner)
			//		For things like tooltip, they are displayed differently (and have different dimensions)
			//		based on their orientation relative to the parent.	 This adjusts the popup based on orientation.
			//
			// leftToRight:
			//		True if widget is LTR, false if widget is RTL.   Affects the behavior of "above" and "below"
			//		positions slightly.
			//
			// example:
			//	|	placeAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
			//		This will try to position node such that node's top-left corner is at the same position
			//		as the bottom left corner of the aroundNode (ie, put node below
			//		aroundNode, with left edges aligned).	If that fails it will try to put
			// 		the bottom-right corner of node where the top right corner of aroundNode is
			//		(ie, put node above aroundNode, with right edges aligned)
			//

			// if around is a DOMNode (or DOMNode id), convert to coordinates
			var aroundNodePos = (typeof anchor == "string" || "offsetWidth" in anchor)
				? domGeometry.position(anchor, true)
				: anchor;

			// Adjust anchor positioning for the case that a parent node has overflw hidden, therefore cuasing the anchor not to be completely visible
			if(anchor.parentNode){
				var parent = anchor.parentNode;
				while(parent && parent.nodeType == 1 && parent.nodeName != "BODY"){  //ignoring the body will help performance
					var parentPos = domGeometry.position(parent, true);
					var parentStyleOverflow = domStyle.getComputedStyle(parent).overflow;
					if(parentStyleOverflow == "hidden" || parentStyleOverflow == "auto" || parentStyleOverflow == "scroll"){
						var bottomYCoord = Math.min(aroundNodePos.y + aroundNodePos.h, parentPos.y + parentPos.h);
						var rightXCoord = Math.min(aroundNodePos.x + aroundNodePos.w, parentPos.x + parentPos.w);
						aroundNodePos.x = Math.max(aroundNodePos.x, parentPos.x);
						aroundNodePos.y = Math.max(aroundNodePos.y, parentPos.y);
						aroundNodePos.h = bottomYCoord - aroundNodePos.y;
						aroundNodePos.w = rightXCoord - aroundNodePos.x;
					}	
					parent = parent.parentNode;
				}
			}			

			var x = aroundNodePos.x,
				y = aroundNodePos.y,
				width = "w" in aroundNodePos ? aroundNodePos.w : (aroundNodePos.w = aroundNodePos.width),
				height = "h" in aroundNodePos ? aroundNodePos.h : (kernel.deprecated("place.around: dijit.place.__Rectangle: { x:"+x+", y:"+y+", height:"+aroundNodePos.height+", width:"+width+" } has been deprecated.  Please use { x:"+x+", y:"+y+", h:"+aroundNodePos.height+", w:"+width+" }", "", "2.0"), aroundNodePos.h = aroundNodePos.height);

			// Convert positions arguments into choices argument for _place()
			var choices = [];
			function push(aroundCorner, corner){
				choices.push({
					aroundCorner: aroundCorner,
					corner: corner,
					pos: {
						x: {
							'L': x,
							'R': x + width,
							'M': x + (width >> 1)
						   }[aroundCorner.charAt(1)],
						y: {
							'T': y,
							'B': y + height,
							'M': y + (height >> 1)
						   }[aroundCorner.charAt(0)]
					}
				})
			}
			array.forEach(positions, function(pos){
				var ltr =  leftToRight;
				switch(pos){
					case "above-centered":
						push("TM", "BM");
						break;
					case "below-centered":
						push("BM", "TM");
						break;
					case "after":
						ltr = !ltr;
						// fall through
					case "before":
						push(ltr ? "ML" : "MR", ltr ? "MR" : "ML");
						break;
					case "below-alt":
						ltr = !ltr;
						// fall through
					case "below":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "BL" : "BR", ltr ? "TL" : "TR");
						push(ltr ? "BR" : "BL", ltr ? "TR" : "TL");
						break;
					case "above-alt":
						ltr = !ltr;
						// fall through
					case "above":
						// first try to align left borders, next try to align right borders (or reverse for RTL mode)
						push(ltr ? "TL" : "TR", ltr ? "BL" : "BR");
						push(ltr ? "TR" : "TL", ltr ? "BR" : "BL");
						break;
					default:
						// To assist dijit/_base/place, accept arguments of type {aroundCorner: "BL", corner: "TL"}.
						// Not meant to be used directly.
						push(pos.aroundCorner, pos.corner);
				}
			});

			var position = _place(node, choices, layoutNode, {w: width, h: height});
			position.aroundNodePos = aroundNodePos;

			return position;
		}
	});
});

},
'dijit/_HasDropDown':function(){
define("dijit/_HasDropDown", [
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/_base/event", // event.stop
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.add domClass.contains domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/has",
	"dojo/keys", // keys.DOWN_ARROW keys.ENTER keys.ESCAPE
	"dojo/_base/lang", // lang.hitch lang.isFunction
	"dojo/touch",
	"dojo/_base/window", // win.doc
	"dojo/window", // winUtils.getBox
	"./registry",	// registry.byNode()
	"./focus",
	"./popup",
	"./_FocusMixin"
], function(declare, Deferred, event,dom, domAttr, domClass, domGeometry, domStyle, has, keys, lang, touch,
			win, winUtils, registry, focus, popup, _FocusMixin){

/*=====
	var _FocusMixin = dijit._FocusMixin;
=====*/

	// module:
	//		dijit/_HasDropDown
	// summary:
	//		Mixin for widgets that need drop down ability.

	return declare("dijit._HasDropDown", _FocusMixin, {
		// summary:
		//		Mixin for widgets that need drop down ability.

		// _buttonNode: [protected] DomNode
		//		The button/icon/node to click to display the drop down.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then either focusNode or domNode (if focusNode is also missing) will be used.
		_buttonNode: null,

		// _arrowWrapperNode: [protected] DomNode
		//		Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
		//		on where the drop down is set to be positioned.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then _buttonNode will be used.
		_arrowWrapperNode: null,

		// _popupStateNode: [protected] DomNode
		//		The node to set the popupActive class on.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.
		_popupStateNode: null,

		// _aroundNode: [protected] DomNode
		//		The node to display the popup around.
		//		Can be set via a data-dojo-attach-point assignment.
		//		If missing, then domNode will be used.
		_aroundNode: null,

		// dropDown: [protected] Widget
		//		The widget to display as a popup.  This widget *must* be
		//		defined before the startup function is called.
		dropDown: null,

		// autoWidth: [protected] Boolean
		//		Set to true to make the drop down at least as wide as this
		//		widget.  Set to false if the drop down should just be its
		//		default width
		autoWidth: true,

		// forceWidth: [protected] Boolean
		//		Set to true to make the drop down exactly as wide as this
		//		widget.  Overrides autoWidth.
		forceWidth: false,

		// maxHeight: [protected] Integer
		//		The max height for our dropdown.
		//		Any dropdown taller than this will have scrollbars.
		//		Set to 0 for no max height, or -1 to limit height to available space in viewport
		maxHeight: 0,

		// dropDownPosition: [const] String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		dropDownPosition: ["below","above"],

		// _stopClickEvents: Boolean
		//		When set to false, the click events will not be stopped, in
		//		case you want to use them in your subwidget
		_stopClickEvents: true,

		_onDropDownMouseDown: function(/*Event*/ e){
			// summary:
			//		Callback when the user mousedown's on the arrow icon
			if(this.disabled || this.readOnly){ return; }

			// Prevent default to stop things like text selection, but don't stop propogation, so that:
			//		1. TimeTextBox etc. can focusthe <input> on mousedown
			//		2. dropDownButtonActive class applied by _CssStateMixin (on button depress)
			//		3. user defined onMouseDown handler fires
			e.preventDefault();

			this._docHandler = this.connect(win.doc, touch.release, "_onDropDownMouseUp");

			this.toggleDropDown();
		},

		_onDropDownMouseUp: function(/*Event?*/ e){
			// summary:
			//		Callback when the user lifts their mouse after mouse down on the arrow icon.
			//		If the drop down is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
			//		drop down widget.  If the event is missing, then we are not
			//		a mouseup event.
			//
			//		This is useful for the common mouse movement pattern
			//		with native browser <select> nodes:
			//			1. mouse down on the select node (probably on the arrow)
			//			2. move mouse to a menu item while holding down the mouse button
			//			3. mouse up.  this selects the menu item as though the user had clicked it.
			if(e && this._docHandler){
				this.disconnect(this._docHandler);
			}
			var dropDown = this.dropDown, overMenu = false;

			if(e && this._opened){
				// This code deals with the corner-case when the drop down covers the original widget,
				// because it's so large.  In that case mouse-up shouldn't select a value from the menu.
				// Find out if our target is somewhere in our dropdown widget,
				// but not over our _buttonNode (the clickable node)
				var c = domGeometry.position(this._buttonNode, true);
				if(!(e.pageX >= c.x && e.pageX <= c.x + c.w) ||
					!(e.pageY >= c.y && e.pageY <= c.y + c.h)){
					var t = e.target;
					while(t && !overMenu){
						if(domClass.contains(t, "dijitPopup")){
							overMenu = true;
						}else{
							t = t.parentNode;
						}
					}
					if(overMenu){
						t = e.target;
						if(dropDown.onItemClick){
							var menuItem;
							while(t && !(menuItem = registry.byNode(t))){
								t = t.parentNode;
							}
							if(menuItem && menuItem.onClick && menuItem.getParent){
								menuItem.getParent().onItemClick(menuItem, e);
							}
						}
						return;
					}
				}
			}
			if(this._opened){
				if(dropDown.focus && dropDown.autoFocus !== false){
					// Focus the dropdown widget - do it on a delay so that we
					// don't steal our own focus.
					window.setTimeout(lang.hitch(dropDown, "focus"), 1);
				}
			}else{
				// The drop down arrow icon probably can't receive focus, but widget itself should get focus.
				// setTimeout() needed to make it work on IE (test DateTextBox)
				setTimeout(lang.hitch(this, "focus"), 0);
			}

			if(has("ios")){
				this._justGotMouseUp = true;
				setTimeout(lang.hitch(this, function(){
					this._justGotMouseUp = false;
				}), 0);
			}
		},

		_onDropDownClick: function(/*Event*/ e){
			if(has("ios") && !this._justGotMouseUp){
				// This branch fires on iPhone for ComboBox, because the button node is an <input> and doesn't
				// generate touchstart/touchend events.   Pretend we just got a mouse down / mouse up.
				// The if(has("ios") is necessary since IE and desktop safari get spurious onclick events
				// when there are nested tables (specifically, clicking on a table that holds a dijit.form.Select,
				// but not on the Select itself, causes an onclick event on the Select)
				this._onDropDownMouseDown(e);
				this._onDropDownMouseUp(e);
			}

			// The drop down was already opened on mousedown/keydown; just need to call stopEvent().
			if(this._stopClickEvents){
				event.stop(e);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);

			this._buttonNode = this._buttonNode || this.focusNode || this.domNode;
			this._popupStateNode = this._popupStateNode || this.focusNode || this._buttonNode;

			// Add a class to the "dijitDownArrowButton" type class to _buttonNode so theme can set direction of arrow
			// based on where drop down will normally appear
			var defaultPos = {
					"after" : this.isLeftToRight() ? "Right" : "Left",
					"before" : this.isLeftToRight() ? "Left" : "Right",
					"above" : "Up",
					"below" : "Down",
					"left" : "Left",
					"right" : "Right"
			}[this.dropDownPosition[0]] || this.dropDownPosition[0] || "Down";
			domClass.add(this._arrowWrapperNode || this._buttonNode, "dijit" + defaultPos + "ArrowButton");
		},

		postCreate: function(){
			// summary:
			//		set up nodes and connect our mouse and keypress events

			this.inherited(arguments);

			this.connect(this._buttonNode, touch.press, "_onDropDownMouseDown");
			this.connect(this._buttonNode, "onclick", "_onDropDownClick");
			this.connect(this.focusNode, "onkeypress", "_onKey");
			this.connect(this.focusNode, "onkeyup", "_onKeyUp");
		},

		destroy: function(){
			if(this.dropDown){
				// Destroy the drop down, unless it's already been destroyed.  This can happen because
				// the drop down is a direct child of <body> even though it's logically my child.
				if(!this.dropDown._destroyed){
					this.dropDown.destroyRecursive();
				}
				delete this.dropDown;
			}
			this.inherited(arguments);
		},

		_onKey: function(/*Event*/ e){
			// summary:
			//		Callback when the user presses a key while focused on the button node

			if(this.disabled || this.readOnly){ return; }

			var d = this.dropDown, target = e.target;
			if(d && this._opened && d.handleKey){
				if(d.handleKey(e) === false){
					/* false return code means that the drop down handled the key */
					event.stop(e);
					return;
				}
			}
			if(d && this._opened && e.charOrCode == keys.ESCAPE){
				this.closeDropDown();
				event.stop(e);
			}else if(!this._opened &&
					(e.charOrCode == keys.DOWN_ARROW ||
						( (e.charOrCode == keys.ENTER || e.charOrCode == " ") &&
						  //ignore enter and space if the event is for a text input
						  ((target.tagName || "").toLowerCase() !== 'input' ||
						     (target.type && target.type.toLowerCase() !== 'text'))))){
				// Toggle the drop down, but wait until keyup so that the drop down doesn't
				// get a stray keyup event, or in the case of key-repeat (because user held
				// down key for too long), stray keydown events
				this._toggleOnKeyUp = true;
				event.stop(e);
			}
		},

		_onKeyUp: function(){
			if(this._toggleOnKeyUp){
				delete this._toggleOnKeyUp;
				this.toggleDropDown();
				var d = this.dropDown;	// drop down may not exist until toggleDropDown() call
				if(d && d.focus){
					setTimeout(lang.hitch(d, "focus"), 1);
				}
			}
		},

		_onBlur: function(){
			// summary:
			//		Called magically when focus has shifted away from this widget and it's dropdown

			// Don't focus on button if the user has explicitly focused on something else (happens
			// when user clicks another control causing the current popup to close)..
			// But if focus is inside of the drop down then reset focus to me, because IE doesn't like
			// it when you display:none a node with focus.
			var focusMe = focus.curNode && this.dropDown && dom.isDescendant(focus.curNode, this.dropDown.domNode);

			this.closeDropDown(focusMe);

			this.inherited(arguments);
		},

		isLoaded: function(){
			// summary:
			//		Returns true if the dropdown exists and it's data is loaded.  This can
			//		be overridden in order to force a call to loadDropDown().
			// tags:
			//		protected

			return true;
		},

		loadDropDown: function(/*Function*/ loadCallback){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and then calls
			//		the given callback.
			// tags:
			//		protected

			// TODO: for 2.0, change API to return a Deferred, instead of calling loadCallback?
			loadCallback();
		},

		loadAndOpenDropDown: function(){
			// summary:
			//		Creates the drop down if it doesn't exist, loads the data
			//		if there's an href and it hasn't been loaded yet, and
			//		then opens the drop down.  This is basically a callback when the
			//		user presses the down arrow button to open the drop down.
			// returns: Deferred
			//		Deferred for the drop down widget that
			//		fires when drop down is created and loaded
			// tags:
			//		protected
			var d = new Deferred(),
				afterLoad = lang.hitch(this, function(){
					this.openDropDown();
					d.resolve(this.dropDown);
				});
			if(!this.isLoaded()){
				this.loadDropDown(afterLoad);
			}else{
				afterLoad();
			}
			return d;
		},

		toggleDropDown: function(){
			// summary:
			//		Callback when the user presses the down arrow button or presses
			//		the down arrow key to open/close the drop down.
			//		Toggle the drop-down widget; if it is up, close it, if not, open it
			// tags:
			//		protected

			if(this.disabled || this.readOnly){ return; }
			if(!this._opened){
				this.loadAndOpenDropDown();
			}else{
				this.closeDropDown();
			}
		},

		openDropDown: function(){
			// summary:
			//		Opens the dropdown for this widget.   To be called only when this.dropDown
			//		has been created and is ready to display (ie, it's data is loaded).
			// returns:
			//		return value of dijit.popup.open()
			// tags:
			//		protected

			var dropDown = this.dropDown,
				ddNode = dropDown.domNode,
				aroundNode = this._aroundNode || this.domNode,
				self = this;

			// Prepare our popup's height and honor maxHeight if it exists.

			// TODO: isn't maxHeight dependent on the return value from dijit.popup.open(),
			// ie, dependent on how much space is available (BK)

			if(!this._preparedNode){
				this._preparedNode = true;
				// Check if we have explicitly set width and height on the dropdown widget dom node
				if(ddNode.style.width){
					this._explicitDDWidth = true;
				}
				if(ddNode.style.height){
					this._explicitDDHeight = true;
				}
			}

			// Code for resizing dropdown (height limitation, or increasing width to match my width)
			if(this.maxHeight || this.forceWidth || this.autoWidth){
				var myStyle = {
					display: "",
					visibility: "hidden"
				};
				if(!this._explicitDDWidth){
					myStyle.width = "";
				}
				if(!this._explicitDDHeight){
					myStyle.height = "";
				}
				domStyle.set(ddNode, myStyle);

				// Figure out maximum height allowed (if there is a height restriction)
				var maxHeight = this.maxHeight;
				if(maxHeight == -1){
					// limit height to space available in viewport either above or below my domNode
					// (whichever side has more room)
					var viewport = winUtils.getBox(),
						position = domGeometry.position(aroundNode, false);
					maxHeight = Math.floor(Math.max(position.y, viewport.h - (position.y + position.h)));
				}

				// Attach dropDown to DOM and make make visibility:hidden rather than display:none
				// so we call startup() and also get the size
				popup.moveOffScreen(dropDown);

				if(dropDown.startup && !dropDown._started){
					dropDown.startup(); // this has to be done after being added to the DOM
				}
				// Get size of drop down, and determine if vertical scroll bar needed
				var mb = domGeometry.getMarginSize(ddNode);
				var overHeight = (maxHeight && mb.h > maxHeight);
				domStyle.set(ddNode, {
					overflowX: "hidden",
					overflowY: overHeight ? "auto" : "hidden"
				});
				if(overHeight){
					mb.h = maxHeight;
					if("w" in mb){
						mb.w += 16;	// room for vertical scrollbar
					}
				}else{
					delete mb.h;
				}

				// Adjust dropdown width to match or be larger than my width
				if(this.forceWidth){
					mb.w = aroundNode.offsetWidth;
				}else if(this.autoWidth){
					mb.w = Math.max(mb.w, aroundNode.offsetWidth);
				}else{
					delete mb.w;
				}

				// And finally, resize the dropdown to calculated height and width
				if(lang.isFunction(dropDown.resize)){
					dropDown.resize(mb);
				}else{
					domGeometry.setMarginBox(ddNode, mb);
				}
			}

			var retVal = popup.open({
				parent: this,
				popup: dropDown,
				around: aroundNode,
				orient: this.dropDownPosition,
				onExecute: function(){
					self.closeDropDown(true);
				},
				onCancel: function(){
					self.closeDropDown(true);
				},
				onClose: function(){
					domAttr.set(self._popupStateNode, "popupActive", false);
					domClass.remove(self._popupStateNode, "dijitHasDropDownOpen");
					self._opened = false;
				}
			});
			domAttr.set(this._popupStateNode, "popupActive", "true");
			domClass.add(self._popupStateNode, "dijitHasDropDownOpen");
			this._opened=true;

			// TODO: set this.checked and call setStateClass(), to affect button look while drop down is shown
			return retVal;
		},

		closeDropDown: function(/*Boolean*/ focus){
			// summary:
			//		Closes the drop down on this widget
			// focus:
			//		If true, refocuses the button widget
			// tags:
			//		protected

			if(this._opened){
				if(focus){ this.focus(); }
				popup.close(this.dropDown);
				this._opened = false;
			}
		}

	});
});

},
'dijit/tree/TreeStoreModel':function(){
define("dijit/tree/TreeStoreModel", [
	"dojo/_base/array", // array.filter array.forEach array.indexOf array.some
	"dojo/aspect", // aspect.after
	"dojo/_base/declare", // declare
	"dojo/_base/json", // json.stringify
	"dojo/_base/lang" // lang.hitch
], function(array, aspect, declare, json, lang){

	// module:
	//		dijit/tree/TreeStoreModel
	// summary:
	//		Implements dijit.Tree.model connecting to a dojo.data store with a single
	//		root item.

	return declare("dijit.tree.TreeStoreModel", null, {
		// summary:
		//		Implements dijit.Tree.model connecting to a dojo.data store with a single
		//		root item.  Any methods passed into the constructor will override
		//		the ones defined here.

		// store: dojo.data.Store
		//		Underlying store
		store: null,

		// childrenAttrs: String[]
		//		One or more attribute names (attributes in the dojo.data item) that specify that item's children
		childrenAttrs: ["children"],

		// newItemIdAttr: String
		//		Name of attribute in the Object passed to newItem() that specifies the id.
		//
		//		If newItemIdAttr is set then it's used when newItem() is called to see if an
		//		item with the same id already exists, and if so just links to the old item
		//		(so that the old item ends up with two parents).
		//
		//		Setting this to null or "" will make every drop create a new item.
		newItemIdAttr: "id",

		// labelAttr: String
		//		If specified, get label for tree node from this attribute, rather
		//		than by calling store.getLabel()
		labelAttr: "",

	 	// root: [readonly] dojo.data.Item
		//		Pointer to the root item (read only, not a parameter)
		root: null,

		// query: anything
		//		Specifies datastore query to return the root item for the tree.
		//		Must only return a single item.   Alternately can just pass in pointer
		//		to root item.
		// example:
		//	|	{id:'ROOT'}
		query: null,

		// deferItemLoadingUntilExpand: Boolean
		//		Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
		// 		until they are expanded. This allows for lazying loading where only one
		//		loadItem (and generally one network call, consequently) per expansion
		// 		(rather than one for each child).
		// 		This relies on partial loading of the children items; each children item of a
		// 		fully loaded item should contain the label and info about having children.
		deferItemLoadingUntilExpand: false,

		constructor: function(/* Object */ args){
			// summary:
			//		Passed the arguments listed above (store, etc)
			// tags:
			//		private

			lang.mixin(this, args);

			this.connects = [];

			var store = this.store;
			if(!store.getFeatures()['dojo.data.api.Identity']){
				throw new Error("dijit.Tree: store must support dojo.data.Identity");
			}

			// if the store supports Notification, subscribe to the notification events
			if(store.getFeatures()['dojo.data.api.Notification']){
				this.connects = this.connects.concat([
					aspect.after(store, "onNew", lang.hitch(this, "onNewItem"), true),
					aspect.after(store, "onDelete", lang.hitch(this, "onDeleteItem"), true),
					aspect.after(store, "onSet", lang.hitch(this, "onSetItem"), true)
				]);
			}
		},

		destroy: function(){
			var h;
			while(h = this.connects.pop()){ h.remove(); }
			// TODO: should cancel any in-progress processing of getRoot(), getChildren()
		},

		// =======================================================================
		// Methods for traversing hierarchy

		getRoot: function(onItem, onError){
			// summary:
			//		Calls onItem with the root item for the tree, possibly a fabricated item.
			//		Calls onError on error.
			if(this.root){
				onItem(this.root);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						if(items.length != 1){
							throw new Error(this.declaredClass + ": query " + json.stringify(this.query) + " returned " + items.length +
							 	" items, but must return exactly one item");
						}
						this.root = items[0];
						onItem(this.root);
					}),
					onError: onError
				});
			}
		},

		mayHaveChildren: function(/*dojo.data.Item*/ item){
			// summary:
			//		Tells if an item has or may have children.  Implementing logic here
			//		avoids showing +/- expando icon for nodes that we know don't have children.
			//		(For efficiency reasons we may not want to check if an element actually
			//		has children until user clicks the expando node)
			return array.some(this.childrenAttrs, function(attr){
				return this.store.hasAttribute(item, attr);
			}, this);
		},

		getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ onComplete, /*function*/ onError){
			// summary:
			// 		Calls onComplete() with array of child items of given parent item, all loaded.

			var store = this.store;
			if(!store.isItemLoaded(parentItem)){
				// The parent is not loaded yet, we must be in deferItemLoadingUntilExpand
				// mode, so we will load it and just return the children (without loading each
				// child item)
				var getChildren = lang.hitch(this, arguments.callee);
				store.loadItem({
					item: parentItem,
					onItem: function(parentItem){
						getChildren(parentItem, onComplete, onError);
					},
					onError: onError
				});
				return;
			}
			// get children of specified item
			var childItems = [];
			for(var i=0; i<this.childrenAttrs.length; i++){
				var vals = store.getValues(parentItem, this.childrenAttrs[i]);
				childItems = childItems.concat(vals);
			}

			// count how many items need to be loaded
			var _waitCount = 0;
			if(!this.deferItemLoadingUntilExpand){
				array.forEach(childItems, function(item){ if(!store.isItemLoaded(item)){ _waitCount++; } });
			}

			if(_waitCount == 0){
				// all items are already loaded (or we aren't loading them).  proceed...
				onComplete(childItems);
			}else{
				// still waiting for some or all of the items to load
				array.forEach(childItems, function(item, idx){
					if(!store.isItemLoaded(item)){
						store.loadItem({
							item: item,
							onItem: function(item){
								childItems[idx] = item;
								if(--_waitCount == 0){
									// all nodes have been loaded, send them to the tree
									onComplete(childItems);
								}
							},
							onError: onError
						});
					}
				});
			}
		},

		// =======================================================================
		// Inspecting items

		isItem: function(/* anything */ something){
			return this.store.isItem(something);	// Boolean
		},

		fetchItemByIdentity: function(/* object */ keywordArgs){
			this.store.fetchItemByIdentity(keywordArgs);
		},

		getIdentity: function(/* item */ item){
			return this.store.getIdentity(item);	// Object
		},

		getLabel: function(/*dojo.data.Item*/ item){
			// summary:
			//		Get the label for an item
			if(this.labelAttr){
				return this.store.getValue(item,this.labelAttr);	// String
			}else{
				return this.store.getLabel(item);	// String
			}
		},

		// =======================================================================
		// Write interface

		newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
			// summary:
			//		Creates a new item.   See `dojo.data.api.Write` for details on args.
			//		Used in drag & drop when item from external source dropped onto tree.
			// description:
			//		Developers will need to override this method if new items get added
			//		to parents with multiple children attributes, in order to define which
			//		children attribute points to the new item.

			var pInfo = {parent: parent, attribute: this.childrenAttrs[0]}, LnewItem;

			if(this.newItemIdAttr && args[this.newItemIdAttr]){
				// Maybe there's already a corresponding item in the store; if so, reuse it.
				this.fetchItemByIdentity({identity: args[this.newItemIdAttr], scope: this, onItem: function(item){
					if(item){
						// There's already a matching item in store, use it
						this.pasteItem(item, null, parent, true, insertIndex);
					}else{
						// Create new item in the tree, based on the drag source.
						LnewItem=this.store.newItem(args, pInfo);
						if(LnewItem && (insertIndex!=undefined)){
							// Move new item to desired position
							this.pasteItem(LnewItem, parent, parent, false, insertIndex);
						}
					}
				}});
			}else{
				// [as far as we know] there is no id so we must assume this is a new item
				LnewItem=this.store.newItem(args, pInfo);
				if(LnewItem && (insertIndex!=undefined)){
					// Move new item to desired position
					this.pasteItem(LnewItem, parent, parent, false, insertIndex);
				}
			}
		},

		pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
			// summary:
			//		Move or copy an item from one parent item to another.
			//		Used in drag & drop
			var store = this.store,
				parentAttr = this.childrenAttrs[0];	// name of "children" attr in parent item

			// remove child from source item, and record the attribute that child occurred in
			if(oldParentItem){
				array.forEach(this.childrenAttrs, function(attr){
					if(store.containsValue(oldParentItem, attr, childItem)){
						if(!bCopy){
							var values = array.filter(store.getValues(oldParentItem, attr), function(x){
								return x != childItem;
							});
							store.setValues(oldParentItem, attr, values);
						}
						parentAttr = attr;
					}
				});
			}

			// modify target item's children attribute to include this item
			if(newParentItem){
				if(typeof insertIndex == "number"){
					// call slice() to avoid modifying the original array, confusing the data store
					var childItems = store.getValues(newParentItem, parentAttr).slice();
					childItems.splice(insertIndex, 0, childItem);
					store.setValues(newParentItem, parentAttr, childItems);
				}else{
					store.setValues(newParentItem, parentAttr,
						store.getValues(newParentItem, parentAttr).concat(childItem));
				}
			}
		},

		// =======================================================================
		// Callbacks

		onChange: function(/*dojo.data.Item*/ /*===== item =====*/){
			// summary:
			//		Callback whenever an item has changed, so that Tree
			//		can update the label, icon, etc.   Note that changes
			//		to an item's children or parent(s) will trigger an
			//		onChildrenChange() so you can ignore those changes here.
			// tags:
			//		callback
		},

		onChildrenChange: function(/*===== parent, newChildrenList =====*/){
			// summary:
			//		Callback to do notifications about new, updated, or deleted items.
			// parent: dojo.data.Item
			// newChildrenList: dojo.data.Item[]
			// tags:
			//		callback
		},

		onDelete: function(/*dojo.data.Item*/ /*===== item =====*/){
			// summary:
			//		Callback when an item has been deleted.
			// description:
			//		Note that there will also be an onChildrenChange() callback for the parent
			//		of this item.
			// tags:
			//		callback
		},

		// =======================================================================
		// Events from data store

		onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
			// summary:
			//		Handler for when new items appear in the store, either from a drop operation
			//		or some other way.   Updates the tree view (if necessary).
			// description:
			//		If the new item is a child of an existing item,
			//		calls onChildrenChange() with the new list of children
			//		for that existing item.
			//
			// tags:
			//		extension

			// We only care about the new item if it has a parent that corresponds to a TreeNode
			// we are currently displaying
			if(!parentInfo){
				return;
			}

			// Call onChildrenChange() on parent (ie, existing) item with new list of children
			// In the common case, the new list of children is simply parentInfo.newValue or
			// [ parentInfo.newValue ], although if items in the store has multiple
			// child attributes (see `childrenAttr`), then it's a superset of parentInfo.newValue,
			// so call getChildren() to be sure to get right answer.
			this.getChildren(parentInfo.item, lang.hitch(this, function(children){
				this.onChildrenChange(parentInfo.item, children);
			}));
		},

		onDeleteItem: function(/*Object*/ item){
			// summary:
			//		Handler for delete notifications from underlying store
			this.onDelete(item);
		},

		onSetItem: function(item, attribute /*===== , oldValue, newValue =====*/){
			// summary:
			//		Updates the tree view according to changes in the data store.
			// description:
			//		Handles updates to an item's children by calling onChildrenChange(), and
			//		other updates to an item by calling onChange().
			//
			//		See `onNewItem` for more details on handling updates to an item's children.
			// item: Item
			// attribute: attribute-name-string
			// oldValue: object | array
			// newValue: object | array
			// tags:
			//		extension

			if(array.indexOf(this.childrenAttrs, attribute) != -1){
				// item's children list changed
				this.getChildren(item, lang.hitch(this, function(children){
					// See comments in onNewItem() about calling getChildren()
					this.onChildrenChange(item, children);
				}));
			}else{
				// item's label/icon/etc. changed.
				this.onChange(item);
			}
		}
	});
});

},
'dojo/dnd/Selector':function(){
define("dojo/dnd/Selector", ["../main", "./common", "./Container"], function(dojo) {
	// module:
	//		dojo/dnd/Selector
	// summary:
	//		TODOC


/*
	Container item states:
		""			- an item is not selected
		"Selected"	- an item is selected
		"Anchor"	- an item is selected, and is an anchor for a "shift" selection
*/

/*=====
dojo.declare("dojo.dnd.__SelectorArgs", [dojo.dnd.__ContainerArgs], {
	//	singular: Boolean
	//		allows selection of only one element, if true
	singular: false,

	//	autoSync: Boolean
	//		autosynchronizes the source with its list of DnD nodes,
	autoSync: false
});
=====*/

dojo.declare("dojo.dnd.Selector", dojo.dnd.Container, {
	// summary:
	//		a Selector object, which knows how to select its children

	/*=====
	// selection: Set<String>
	//		The set of id's that are currently selected, such that this.selection[id] == 1
	//		if the node w/that id is selected.  Can iterate over selected node's id's like:
	//	|		for(var id in this.selection)
	selection: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		constructor of the Selector
		// node: Node||String
		//		node or node's id to build the selector on
		// params: dojo.dnd.__SelectorArgs?
		//		a dictionary of parameters
		if(!params){ params = {}; }
		this.singular = params.singular;
		this.autoSync = params.autoSync;
		// class-specific variables
		this.selection = {};
		this.anchor = null;
		this.simpleSelection = false;
		// set up events
		this.events.push(
			dojo.connect(this.node, "onmousedown", this, "onMouseDown"),
			dojo.connect(this.node, "onmouseup",   this, "onMouseUp"));
	},

	// object attributes (for markup)
	singular: false,	// is singular property

	// methods
	getSelectedNodes: function(){
		// summary:
		//		returns a list (an array) of selected nodes
		var t = new dojo.NodeList();
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			t.push(dojo.byId(i));
		}
		return t;	// NodeList
	},
	selectNone: function(){
		// summary:
		//		unselects all items
		return this._removeSelection()._removeAnchor();	// self
	},
	selectAll: function(){
		// summary:
		//		selects all items
		this.forInItems(function(data, id){
			this._addItemClass(dojo.byId(id), "Selected");
			this.selection[id] = 1;
		}, this);
		return this._removeAnchor();	// self
	},
	deleteSelectedNodes: function(){
		// summary:
		//		deletes all selected items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var n = dojo.byId(i);
			this.delItem(i);
			dojo.destroy(n);
		}
		this.anchor = null;
		this.selection = {};
		return this;	// self
	},
	forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over selected items;
		//		see `dojo.dnd.Container.forInItems()` for details
		o = o || dojo.global;
		var s = this.selection, e = dojo.dnd._empty;
		for(var i in s){
			if(i in e){ continue; }
			f.call(o, this.getItem(i), i, this);
		}
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map

		dojo.dnd.Selector.superclass.sync.call(this);

		// fix the anchor
		if(this.anchor){
			if(!this.getItem(this.anchor.id)){
				this.anchor = null;
			}
		}

		// fix the selection
		var t = [], e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			if(!this.getItem(i)){
				t.push(i);
			}
		}
		dojo.forEach(t, function(i){
			delete this.selection[i];
		}, this);

		return this;	// self
	},
	insertNodes: function(addSelected, data, before, anchor){
		// summary:
		//		inserts new data items (see `dojo.dnd.Container.insertNodes()` method for details)
		// addSelected: Boolean
		//		all new nodes will be added to selected items, if true, no selection change otherwise
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		var oldCreator = this._normalizedCreator;
		this._normalizedCreator = function(item, hint){
			var t = oldCreator.call(this, item, hint);
			if(addSelected){
				if(!this.anchor){
					this.anchor = t.node;
					this._removeItemClass(t.node, "Selected");
					this._addItemClass(this.anchor, "Anchor");
				}else if(this.anchor != t.node){
					this._removeItemClass(t.node, "Anchor");
					this._addItemClass(t.node, "Selected");
				}
				this.selection[t.node.id] = 1;
			}else{
				this._removeItemClass(t.node, "Selected");
				this._removeItemClass(t.node, "Anchor");
			}
			return t;
		};
		dojo.dnd.Selector.superclass.insertNodes.call(this, data, before, anchor);
		this._normalizedCreator = oldCreator;
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Selector.superclass.destroy.call(this);
		this.selection = this.anchor = null;
	},

	// mouse events
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(this.autoSync){ this.sync(); }
		if(!this.current){ return; }
		if(!this.singular && !dojo.isCopyKey(e) && !e.shiftKey && (this.current.id in this.selection)){
			this.simpleSelection = true;
			if(e.button === dojo.mouseButtons.LEFT){
				// accept the left button and stop the event
				// for IE we don't stop event when multiple buttons are pressed
				dojo.stopEvent(e);
			}
			return;
		}
		if(!this.singular && e.shiftKey){
			if(!dojo.isCopyKey(e)){
				this._removeSelection();
			}
			var c = this.getAllNodes();
			if(c.length){
				if(!this.anchor){
					this.anchor = c[0];
					this._addItemClass(this.anchor, "Anchor");
				}
				this.selection[this.anchor.id] = 1;
				if(this.anchor != this.current){
					var i = 0;
					for(; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
					}
					for(++i; i < c.length; ++i){
						var node = c[i];
						if(node == this.anchor || node == this.current){ break; }
						this._addItemClass(node, "Selected");
						this.selection[node.id] = 1;
					}
					this._addItemClass(this.current, "Selected");
					this.selection[this.current.id] = 1;
				}
			}
		}else{
			if(this.singular){
				if(this.anchor == this.current){
					if(dojo.isCopyKey(e)){
						this.selectNone();
					}
				}else{
					this.selectNone();
					this.anchor = this.current;
					this._addItemClass(this.anchor, "Anchor");
					this.selection[this.current.id] = 1;
				}
			}else{
				if(dojo.isCopyKey(e)){
					if(this.anchor == this.current){
						delete this.selection[this.anchor.id];
						this._removeAnchor();
					}else{
						if(this.current.id in this.selection){
							this._removeItemClass(this.current, "Selected");
							delete this.selection[this.current.id];
						}else{
							if(this.anchor){
								this._removeItemClass(this.anchor, "Anchor");
								this._addItemClass(this.anchor, "Selected");
							}
							this.anchor = this.current;
							this._addItemClass(this.current, "Anchor");
							this.selection[this.current.id] = 1;
						}
					}
				}else{
					if(!(this.current.id in this.selection)){
						this.selectNone();
						this.anchor = this.current;
						this._addItemClass(this.current, "Anchor");
						this.selection[this.current.id] = 1;
					}
				}
			}
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(!this.simpleSelection){ return; }
		this.simpleSelection = false;
		this.selectNone();
		if(this.current){
			this.anchor = this.current;
			this._addItemClass(this.anchor, "Anchor");
			this.selection[this.current.id] = 1;
		}
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		this.simpleSelection = false;
	},

	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		this.onmousemoveEvent = dojo.connect(this.node, "onmousemove", this, "onMouseMove");
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.disconnect(this.onmousemoveEvent);
		delete this.onmousemoveEvent;
	},
	_removeSelection: function(){
		// summary:
		//		unselects all items
		var e = dojo.dnd._empty;
		for(var i in this.selection){
			if(i in e){ continue; }
			var node = dojo.byId(i);
			if(node){ this._removeItemClass(node, "Selected"); }
		}
		this.selection = {};
		return this;	// self
	},
	_removeAnchor: function(){
		if(this.anchor){
			this._removeItemClass(this.anchor, "Anchor");
			this.anchor = null;
		}
		return this;	// self
	}
});

return dojo.dnd.Selector;
});

},
'dijit/_MenuBase':function(){
define("dijit/_MenuBase", [
	"./popup",
	"dojo/window",
	"./_Widget",
	"./_KeyNavContainer",
	"./_TemplatedMixin",
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant domClass.replace
	"dojo/dom-attr",
	"dojo/dom-class", // domClass.replace
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/array"	// array.indexOf
], function(pm, winUtils, _Widget, _KeyNavContainer, _TemplatedMixin,
	declare, dom, domAttr, domClass, lang, array){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _KeyNavContainer = dijit._KeyNavContainer;
=====*/

// module:
//		dijit/_MenuBase
// summary:
//		Base class for Menu and MenuBar

return declare("dijit._MenuBase",
	[_Widget, _TemplatedMixin, _KeyNavContainer],
{
	// summary:
	//		Base class for Menu and MenuBar

	// parentMenu: [readonly] Widget
	//		pointer to menu that displayed me
	parentMenu: null,

	// popupDelay: Integer
	//		number of milliseconds before hovering (without clicking) causes the popup to automatically open.
	popupDelay: 500,

	onExecute: function(){
		// summary:
		//		Attach point for notification about when a menu item has been executed.
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them, because they are about to execute the onClick handler.  In
		//		general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	onCancel: function(/*Boolean*/ /*===== closeAll =====*/){
		// summary:
		//		Attach point for notification about when the user cancels the current menu
		//		This is an internal mechanism used for Menus to signal to their parent to
		//		close them.  In general developers should not attach to or override this method.
		// tags:
		//		protected
	},

	_moveToPopup: function(/*Event*/ evt){
		// summary:
		//		This handles the right arrow key (left arrow key on RTL systems),
		//		which will either open a submenu, or move to the next item in the
		//		ancestor MenuBar
		// tags:
		//		private

		if(this.focusedChild && this.focusedChild.popup && !this.focusedChild.disabled){
			this.focusedChild._onClick(evt);
		}else{
			var topMenu = this._getTopMenu();
			if(topMenu && topMenu._isMenuBar){
				topMenu.focusNext();
			}
		}
	},

	_onPopupHover: function(/*Event*/ /*===== evt =====*/){
		// summary:
		//		This handler is called when the mouse moves over the popup.
		// tags:
		//		private

		// if the mouse hovers over a menu popup that is in pending-close state,
		// then stop the close operation.
		// This can't be done in onItemHover since some popup targets don't have MenuItems (e.g. ColorPicker)
		if(this.currentPopup && this.currentPopup._pendingClose_timer){
			var parentMenu = this.currentPopup.parentMenu;
			// highlight the parent menu item pointing to this popup
			if(parentMenu.focusedChild){
				parentMenu.focusedChild._setSelected(false);
			}
			parentMenu.focusedChild = this.currentPopup.from_item;
			parentMenu.focusedChild._setSelected(true);
			// cancel the pending close
			this._stopPendingCloseTimer(this.currentPopup);
		}
	},

	onItemHover: function(/*MenuItem*/ item){
		// summary:
		//		Called when cursor is over a MenuItem.
		// tags:
		//		protected

		// Don't do anything unless user has "activated" the menu by:
		//		1) clicking it
		//		2) opening it from a parent menu (which automatically focuses it)
		if(this.isActive){
			this.focusChild(item);
			if(this.focusedChild.popup && !this.focusedChild.disabled && !this.hover_timer){
				this.hover_timer = setTimeout(lang.hitch(this, "_openPopup"), this.popupDelay);
			}
		}
		// if the user is mixing mouse and keyboard navigation,
		// then the menu may not be active but a menu item has focus,
		// but it's not the item that the mouse just hovered over.
		// To avoid both keyboard and mouse selections, use the latest.
		if(this.focusedChild){
			this.focusChild(item);
		}
		this._hoveredChild = item;
	},

	_onChildBlur: function(item){
		// summary:
		//		Called when a child MenuItem becomes inactive because focus
		//		has been removed from the MenuItem *and* it's descendant menus.
		// tags:
		//		private
		this._stopPopupTimer();
		item._setSelected(false);
		// Close all popups that are open and descendants of this menu
		var itemPopup = item.popup;
		if(itemPopup){
			this._stopPendingCloseTimer(itemPopup);
			itemPopup._pendingClose_timer = setTimeout(function(){
				itemPopup._pendingClose_timer = null;
				if(itemPopup.parentMenu){
					itemPopup.parentMenu.currentPopup = null;
				}
				pm.close(itemPopup); // this calls onClose
			}, this.popupDelay);
		}
	},

	onItemUnhover: function(/*MenuItem*/ item){
		// summary:
		//		Callback fires when mouse exits a MenuItem
		// tags:
		//		protected

		if(this.isActive){
			this._stopPopupTimer();
		}
		if(this._hoveredChild == item){ this._hoveredChild = null; }
	},

	_stopPopupTimer: function(){
		// summary:
		//		Cancels the popup timer because the user has stop hovering
		//		on the MenuItem, etc.
		// tags:
		//		private
		if(this.hover_timer){
			clearTimeout(this.hover_timer);
			this.hover_timer = null;
		}
	},

	_stopPendingCloseTimer: function(/*dijit._Widget*/ popup){
		// summary:
		//		Cancels the pending-close timer because the close has been preempted
		// tags:
		//		private
		if(popup._pendingClose_timer){
			clearTimeout(popup._pendingClose_timer);
			popup._pendingClose_timer = null;
		}
	},

	_stopFocusTimer: function(){
		// summary:
		//		Cancels the pending-focus timer because the menu was closed before focus occured
		// tags:
		//		private
		if(this._focus_timer){
			clearTimeout(this._focus_timer);
			this._focus_timer = null;
		}
	},

	_getTopMenu: function(){
		// summary:
		//		Returns the top menu in this chain of Menus
		// tags:
		//		private
		for(var top=this; top.parentMenu; top=top.parentMenu);
		return top;
	},

	onItemClick: function(/*dijit._Widget*/ item, /*Event*/ evt){
		// summary:
		//		Handle clicks on an item.
		// tags:
		//		private

		// this can't be done in _onFocus since the _onFocus events occurs asynchronously
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu
			this._markActive();
		}

		this.focusChild(item);

		if(item.disabled){ return false; }

		if(item.popup){
			this._openPopup();
		}else{
			// before calling user defined handler, close hierarchy of menus
			// and restore focus to place it was when menu was opened
			this.onExecute();

			// user defined handler for click
			item.onClick(evt);
		}
	},

	_openPopup: function(){
		// summary:
		//		Open the popup to the side of/underneath the current menu item
		// tags:
		//		protected

		this._stopPopupTimer();
		var from_item = this.focusedChild;
		if(!from_item){ return; } // the focused child lost focus since the timer was started
		var popup = from_item.popup;
		if(popup.isShowingNow){ return; }
		if(this.currentPopup){
			this._stopPendingCloseTimer(this.currentPopup);
			pm.close(this.currentPopup);
		}
		popup.parentMenu = this;
		popup.from_item = from_item; // helps finding the parent item that should be focused for this popup
		var self = this;
		pm.open({
			parent: this,
			popup: popup,
			around: from_item.domNode,
			orient: this._orient || ["after", "before"],
			onCancel: function(){ // called when the child menu is canceled
				// set isActive=false (_closeChild vs _cleanUp) so that subsequent hovering will NOT open child menus
				// which seems aligned with the UX of most applications (e.g. notepad, wordpad, paint shop pro)
				self.focusChild(from_item);	// put focus back on my node
				self._cleanUp();			// close the submenu (be sure this is done _after_ focus is moved)
				from_item._setSelected(true); // oops, _cleanUp() deselected the item
				self.focusedChild = from_item;	// and unset focusedChild
			},
			onExecute: lang.hitch(this, "_cleanUp")
		});

		this.currentPopup = popup;
		// detect mouseovers to handle lazy mouse movements that temporarily focus other menu items
		popup.connect(popup.domNode, "onmouseenter", lang.hitch(self, "_onPopupHover")); // cleaned up when the popped-up widget is destroyed on close

		if(popup.focus){
			// If user is opening the popup via keyboard (right arrow, or down arrow for MenuBar),
			// if the cursor happens to collide with the popup, it will generate an onmouseover event
			// even though the mouse wasn't moved.  Use a setTimeout() to call popup.focus so that
			// our focus() call overrides the onmouseover event, rather than vice-versa.  (#8742)
			popup._focus_timer = setTimeout(lang.hitch(popup, function(){
				this._focus_timer = null;
				this.focus();
			}), 0);
		}
	},

	_markActive: function(){
		// summary:
		//		Mark this menu's state as active.
		//		Called when this Menu gets focus from:
		//			1) clicking it (mouse or via space/arrow key)
		//			2) being opened by a parent menu.
		//		This is not called just from mouse hover.
		//		Focusing a menu via TAB does NOT automatically set isActive
		//		since TAB is a navigation operation and not a selection one.
		//		For Windows apps, pressing the ALT key focuses the menubar
		//		menus (similar to TAB navigation) but the menu is not active
		//		(ie no dropdown) until an item is clicked.
		this.isActive = true;
		domClass.replace(this.domNode, "dijitMenuActive", "dijitMenuPassive");
	},

	onOpen: function(/*Event*/ /*===== e =====*/){
		// summary:
		//		Callback when this menu is opened.
		//		This is called by the popup manager as notification that the menu
		//		was opened.
		// tags:
		//		private

		this.isShowingNow = true;
		this._markActive();
	},

	_markInactive: function(){
		// summary:
		//		Mark this menu's state as inactive.
		this.isActive = false; // don't do this in _onBlur since the state is pending-close until we get here
		domClass.replace(this.domNode, "dijitMenuPassive", "dijitMenuActive");
	},

	onClose: function(){
		// summary:
		//		Callback when this menu is closed.
		//		This is called by the popup manager as notification that the menu
		//		was closed.
		// tags:
		//		private

		this._stopFocusTimer();
		this._markInactive();
		this.isShowingNow = false;
		this.parentMenu = null;
	},

	_closeChild: function(){
		// summary:
		//		Called when submenu is clicked or focus is lost.  Close hierarchy of menus.
		// tags:
		//		private
		this._stopPopupTimer();

		if(this.currentPopup){
			// If focus is on a descendant MenuItem then move focus to me,
			// because IE doesn't like it when you display:none a node with focus,
			// and also so keyboard users don't lose control.
			// Likely, immediately after a user defined onClick handler will move focus somewhere
			// else, like a Dialog.
			if(array.indexOf(this._focusManager.activeStack, this.id) >= 0){
				domAttr.set(this.focusedChild.focusNode, "tabIndex", this.tabIndex);
				this.focusedChild.focusNode.focus();
			}
			// Close all popups that are open and descendants of this menu
			pm.close(this.currentPopup);
			this.currentPopup = null;
		}

		if(this.focusedChild){ // unhighlight the focused item
			this.focusedChild._setSelected(false);
			this.focusedChild._onUnhover();
			this.focusedChild = null;
		}
	},

	_onItemFocus: function(/*MenuItem*/ item){
		// summary:
		//		Called when child of this Menu gets focus from:
		//			1) clicking it
		//			2) tabbing into it
		//			3) being opened by a parent menu.
		//		This is not called just from mouse hover.
		if(this._hoveredChild && this._hoveredChild != item){
			this._hoveredChild._onUnhover(); // any previous mouse movement is trumped by focus selection
		}
	},

	_onBlur: function(){
		// summary:
		//		Called when focus is moved away from this Menu and it's submenus.
		// tags:
		//		protected
		this._cleanUp();
		this.inherited(arguments);
	},

	_cleanUp: function(){
		// summary:
		//		Called when the user is done with this menu.  Closes hierarchy of menus.
		// tags:
		//		private

		this._closeChild(); // don't call this.onClose since that's incorrect for MenuBar's that never close
		if(typeof this.isShowingNow == 'undefined'){ // non-popup menu doesn't call onClose
			this._markInactive();
		}
	}
});

});

},
'ibm/tivoli/simplesrm/srm/dojo/data/srmQuery':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojo/DeferredList,ibm/tivoli/tpae/dojo/data/tpaeQuery,ibm/tivoli/simplesrm/srm/dojo/data/OfferingTree,ibm/tivoli/simplesrm/srm/dojo/data/SolutionTree,ibm/tivoli/simplesrm/srm/dojo/data/TemplatesTree,ibm/tivoli/simplesrm/srm/dojo/Utilities,dojox/xml/DomParser"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

/**
 * These classes provide all the data access for the UI.
 * The high-level get*() methods retrieve the data and reformat for
 * the UI's consumption.  If you want the raw data, call getObjectStore() directly.
 *  
 */

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data._srmQuery");

dojo.require("dojo.DeferredList");
dojo.require("ibm.tivoli.tpae.dojo.data.tpaeQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.OfferingTree");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.SolutionTree");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.TemplatesTree");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Utilities");
dojo.require("dojox.xml.DomParser");



//***** srmQuery *******
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.data._srmQuery", null,
{
	constructor: function()
	{
		dojo.mixin(this, ibm.tivoli.tpae.dojo.data.tpaeQuery());
	},
	
	_sigoptions: null,  //app sigoptions for user

	buildCCR: function(/*object*/form_data, /*object*/request_details,user_data){
		var create_data = {};
		create_data._compact = 1;
		
		/* PMSCCR attributes*/
		
		//normal
//		create_data.ORGID = user_data.SITE[0].ORGID;		
		
		//mandatory
//		create_data.SITEID = user_data.SITE[0].SITEID;
//		create_data.CHANGEBY = form_data.user;
//		create_data.CHANGEDATE ="2006-08-19T19:27:14+02:00";
		create_data.DESCRIPTION = form_data.Description;
//		create_data.HISTORYFLAG = false;
//		create_data.STATUS ="NEW";
		
		//genereted automatically by maximo
//		create_data.PMSCCRID = 10;
//		create_data.PMSCCRNUM = 10;
		
		return create_data;
	},
	buildSR: function(response,form_data,request_details,user_data){
		var create_data ={};
		var statusMap =  this.getDomainSynonymTable('SRSTATUS');	
		var classMap = this.getDomainSynonymTable('TKCLASS');
		var newsr = classMap.valueByMaxvalue('SR');
		
		//SR parameters
		create_data.CREATEDBY  = this.safeGetValue(form_data.requestedby, "");
		create_data.REPORTEDBY = form_data.user;
		
		if(undefined != form_data.RequestedStartDate && form_data.RequestedStartDate.length > 0){
			create_data.TARGETSTART = form_data.RequestedStartDate;
		}
		if(undefined != form_data.RequestedEndDate && form_data.RequestedEndDate.length > 0){
			create_data.TARGETFINISH = form_data.RequestedEndDate;
		}
		
		create_data.COMMODITY = request_details.COMMODITY;//"SRVDEPLY";//
		create_data.COMMODITYGROUP = request_details.COMMODITYGROUP;//"IT";//
		create_data.CLASS = newsr;
//		create_data.AFFECTEDDATE = user_data.PERSON[0].STATUSDATE;//TODO: fake value
		create_data.CLASSSTRUCTUREID = form_data.csid;
		create_data.DESCRIPTION = this.safeGetValue(form_data.Description, "TEST");//TODO: fake backup value
//		create_data.OWNER = user_data.USERID; //TODO: check if it's correct field
		create_data.PMSCCRID = response.CreateSRM_CARDCREATEResponse.SRM_CARDCREATESet.PMSCCR.PMSCCRNUM;
		create_data.PMSCITEMNUM = form_data.ItemNum;
//		create_data.REPORTDATE = user_data.PERSON[0].STATUSDATE;//TODO: fake value
//		create_data.STATUS = statusMap.valueByMaxvalue("DRAFT");
			
		create_data.ITEMNUM= form_data.ItemNum;
		create_data.ITEMSETID = form_data.ItemSetID;
		create_data.ORDERUNIT = this.safeGetValue(request_details.ORDERUNIT, "EACH"); 
		create_data.LINETYPE = request_details.ITEMTYPE;
		create_data.QTY = "1";
		
		//generate automatically by maximo
//		create_data.TICKETID = "10";
				
		//WCA is NOT suported right now - next, if this is a WCA offering, we include the variable parameter data
		var wca_params = /^PMRDPVSRPARM/;
		for(var fd in form_data) {
			if(wca_params.test(fd))
			{
				create_data[fd] = form_data[fd];
			}
		}
		
		return create_data;
	},
	updateSR: function(create_response,form_data,request_details,user_data){
		// by now, the base request has been created
		var me = this;
		// Query for basic things
		var statusMap =  me.getDomainSynonymTable('SRSTATUS');			
		var datatypeMap = me.getDomainSynonymTable('DATATYPE');
		var ALN = datatypeMap.valueByMaxvalue("ALN");
		var NUMERIC = datatypeMap.valueByMaxvalue("NUMERIC");
		var TABLE = datatypeMap.valueByMaxvalue("MAXTABLE");
		
					
		var line_data = {};
		var pdspecs = [];
		var sr = create_response.CreateSRM_SRCREATEResponse.SRM_SRCREATESet.SR;
		
		line_data = {id: sr.TICKETUID};
		line_data.PMSCCRID = sr.PMSCCRID;
		line_data.TICKETID = sr.TICKETID;
        line_data.TICKETUID = sr.TICKETUID;
//        line_data.STATUS = statusMap.valueByMaxvalue("NEW");
        line_data.SOURCE = "TSAMWEBUI"; // marker field to avoid race between escalations
		pdspecs = sr.TICKETSPEC;	
		
		// attribute data
		var nr = 0;
		dojo.forEach(pdspecs, function(pdspec,nr){
			var attr_det = pdspec.ASSETATTRIBUTE[0];
			var attr_val = form_data[pdspec.ASSETATTRID];
			var req = request_details.AttributeByID[pdspec.ASSETATTRID];
			
			if(attr_val === undefined && req){
				attr_val = req.ALNValue || req.ALNVALUE || req.NumValue || req.NUMVALUE || req.TABLEVALUE || req.TableValue;
			}
			
			if(undefined == attr_det || undefined == attr_val) {
				console.log("\tskipping ", pdspec.ASSETATTRID);
				return;
			}
			nr++;
			var attr_spec = "TICKETSPEC."+ nr + ".";

			line_data[attr_spec + "TICKETSPECID"] = pdspec.TICKETSPECID;
			line_data[attr_spec + "ASSETATTRID"] = pdspec.ASSETATTRID;
			line_data[attr_spec + "SECTION"] = "";
			line_data[attr_spec + "REFOBJECTID"] = pdspec.REFOBJECTID;		

			if(ALN == attr_det.DATATYPE) {
				line_data[attr_spec + "ALNVALUE"] = attr_val;
			}
			else if(NUMERIC == attr_det.DATATYPE) {
				line_data[attr_spec + "NUMVALUE"] = attr_val;
			}
			else if(TABLE == attr_det.DATATYPE) {	
				line_data[attr_spec + "TABLEVALUE"] = attr_val;
			}
			else {
				// TODO: now what?
				console.error("createRequest.unrecognized DATATYPE");
				return;	// skip this attribute for now
			}

		});		
		
		return line_data;
	},
	/*
	 * 
	 */
	createRequest: function(/*object*/form_data, /*object*/request_details)
	{
		var ret_deferred = new dojo.Deferred();
		var me = this;		
		var user_data = this.getLoggedInUser();
		var phase1 = null, phase2 = null, phase3 = null;
		
		var ccr_data = this.buildCCR(form_data, request_details, user_data);

		// Phase 1 error.  This function is only called if there is an error creating a CCR.
		var errorCCR = function(response){
			ibm.tivoli.logger.error("",new Error("srmQuery.createRequest: unable to create SRM_CARDCREATE, most likely bad data passed in create request. " + response));
			ret_deferred.errback("CTJZH2338E");
			return response;
		};
		//Phase 2 error
		var errorSR = function(response){
			ibm.tivoli.logger.error("",new Error("srmQuery.createRequest: error creating SRM_SR, most likely bad data passed in create request. " + response));
			ret_deferred.errback("CTJZH2338E");
			return response;
		};
		//Phase 3 error
		var errorUpdateSR = function(response){
			ibm.tivoli.logger.error("",new Error("srmQuery.createRequest: error updating SRM_SR, most likely bad data passed in create request. " + response));
			ret_deferred.errback("CTJZH2334E");
			return response;
		};

		// Completion!  Lastly, this function is called at the end if there is no error.
		var returnResult = function(response){	
			ret_deferred.callback(response);			
		};		
		
		// Phase 3. These functions get called to update the SR, or process an error updating the SR
		var updateSR = function(response){
			var final_data = me.updateSR(response,form_data, request_details, user_data);
			phase3 = me.postToObjectStructure("SRM_SRCREATE", true, final_data);
			phase3.addCallbacks(returnResult,errorUpdateSR);	// Update SR response (phase 3)
			return response;
		};
		// Phase 2.  These functions get called to create a SR, or process an error create the SR
		var createSR = function(response){
			var sr_data = me.buildSR(response,form_data, request_details, user_data);
			phase2 = me.postToObjectStructure("SRM_SRCREATE", true, sr_data);
			phase2.addCallbacks(updateSR,errorSR);				// Create SR response (phase 2)
			return response;
		};
		// Phase 1.  Yes it is a little backwards, but this is the code that starts of processing the request.  The first phase is to 
		// create the CCR.  If it succeeds it will proceed to phase 2.  If it fails it will call the CCR error function above.
		phase1 = me.postToObjectStructure("SRM_CARDCREATE", true, ccr_data);		
		phase1.addCallbacks(createSR,errorCCR);			// Create CCR response (phase 1)
		
		return ret_deferred;		
	},


	/**
	 * get the list of this user's service and catalog requests
	 */
	getRequests: function(params)
	{
		var deferred = null;
		if(undefined == params) {params = {};}
		var _sync = undefined == params.sync ? false : params.sync;
		var _locale_debug = this._getLocaleDebugString();
		
		if(params.ItemNum && params.ItemSetID) {
			// I've been given the ItemNum and ItemSetID. This means we want the offering details.
			// After calling the SRM_OFFERINGDET, transform the data to match what the 
			// TDI getrequestdetails request returned.  This way none of the application code relying
			// on the data has to change.

				// local helper to find the offering's classificationID
			function _getClassificationID(offering)
			{
				var classificationID = "";
				var offeringStructureID = offering.CLASSSTRUCTUREID;
				var n = undefined == offering.CLASSSTRUCTURE? 0 : offering.CLASSSTRUCTURE.length;
				for(var i = 0; i < n; ++i) {
					if(offering.CLASSSTRUCTURE[i].CLASSSTRUCTUREID == offeringStructureID) {
						classificationID = offering.CLASSSTRUCTURE[i].CLASSIFICATIONID;
						break;
					}
				}
				return classificationID;
			}

			// get the data
			console.log("srmQuery.getRequests() enter ", params);
			
         deferred = this.getObjectStructure("SRM_OFFERINGDET", {sync: _sync, _exactmatch: 1, ITEMNUM: params.ItemNum, ITEMSETID: params.ItemSetID});				 
			deferred.addCallback(dojo.hitch(this, function(response) {
				// swizzle the data to look like the TDI response
    			var noff = response.QuerySRM_OFFERINGDETResponse.SRM_OFFERINGDETSet.PMSCOFFERING[0];	// the new offering data
				var Request = [];
				var off =  {
					ClassStructureID: noff.CLASSSTRUCTUREID,
					ClassificationID: _getClassificationID(noff),
					Description: (undefined == noff.DESCRIPTION ? "" : _locale_debug + noff.DESCRIPTION),
					LongDescription: (undefined == noff.LONGDESCRIPTION ? undefined : _locale_debug + noff.LONGDESCRIPTION[0].LDTEXT),
					ImageName: undefined == noff.IMGLIB ? undefined : noff.IMGLIB[0].IMAGENAME,
					ItemID: noff.ITEMID,
					ItemNum: noff.ITEMNUM,
					ItemSetID: noff.ITEMSETID,
					//Price:  (undefined == noff.PRICE ? 0 : noff.PRICE),  
					//ORDERUNIT: noff.ORDERUNIT,
					ITEMTYPE: noff.ITEMTYPE,
					COMMODITY: noff.COMMODITY,
					COMMODITYGROUP: noff.COMMODITYGROUP,
					Status: noff.STATUS,
					Attribute: []
				};
				Request[0] = off;
				off.AttributeByID = {};
				
				var nattrs = noff.PMSCITEMSPEC;
				var num_attrs = nattrs.length;
				for(var i = 0; i < num_attrs; ++i) {
					var nattr = nattrs[i];					
					var offd =  noff.PMSCOFFDIALOG[i];
					var attr = {
						   AssetAttrID: nattr.ASSETATTRIBUTE[0].ASSETATTRIBUTEID,
						   DataType:    nattr.ASSETATTRIBUTE[0].DATATYPE,
						   Description: (undefined == nattr.ASSETATTRIBUTE[0].DESCRIPTION ? "" : _locale_debug + nattr.ASSETATTRIBUTE[0].DESCRIPTION),
						   DisplaySequence: nattr.DISPLAYSEQUENCE,						   
						   Hidden: offd.HIDDEN,
						   //MaxValue: not in new API,
						   ReadOnly: offd.READONLY,
						   Mandatory: offd.MANDATORY
					   };
					   if(undefined != nattr.NUMVALUE) {
						   attr.NumValue = nattr.NUMVALUE;
	     		     	}
		    			if(undefined != nattr.ALNVALUE){
			    			attr.ALNValue = nattr.ALNVALUE;
				    	}
					off.Attribute.push(attr);
					off.AttributeByID[attr.AssetAttrID] = attr;
				}
				response.Request = Request;	// Add the TDI style Request to the response
				this._patchRequestImageName(response.Request[0]);
				return response;
			}));
		}
		else if(undefined != params.id) {
			if("CMR" == params.type) {
				deferred = this.getObjectStructure("PMZHBR1_PMSCMR", {MRID: params.id});
			}
			else if("SR" == params.type) {
				deferred =  this.getObjectStructure("SRM_SR", {TICKETUID: params.id, _fd:"PMZHBT_SRUSRLIST", _verbose:"false"});
			}
		}
		return deferred;
	},

	/**
	 * Returns the details for a given request from the SRDET object structure.
	 * params.id is mandatory and contains the ID of the request.
	 */
	getRequestDetails: function(params) {
		console.log("srmQuery.getRequestDetails() enter ", params);
		deferred =  this.getObjectStructure("SRM_SRDET", {TICKETUID: params.id});
		return deferred;
	},
	getCatalogRequests: function(params)
	{
		// get the status domain we need
		var mrstatq = this.getDomain({DOMAINID: 'MRSTATUS'});
		// get the list of requests
		var cmrq = this.getObjectStructure("PMZHBR1_PMSCMR", params);

		deferred = new dojo.Deferred();	// this is the deferred returned by the function. (see comments in getProjectsServersFlat for details)
		deferred.addErrback(dojo.hitch(this, this._ajaxError));
		
		// when all the queries complete, add a "StatusString" property to each project with the pretty-formatted status
		var _queries = new dojo.DeferredList([mrstatq, cmrq]);
		_queries.addCallback(dojo.hitch(this, function(responses)
		{
			var reqs = [];
			// CMRS
			if(responses[1][0]) {
				var statusMap = this.getDomainSynonymTable('MRSTATUS');
				var cmrs = responses[1][1].QueryPMZHBR1_PMSCMRResponse.PMZHBR1_PMSCMRSet.PMSCMR;
				var count = undefined == cmrs ? 0 : cmrs.length;
				for(var i = 0; i < count; ++i) {
					try {
						var cmr = cmrs[i];
						
						req = {
							key: "CMR" + cmr.MRID,
							id: cmr.MRID,
							type: "CMR",
							STATUS: cmr.STATUS,
							StatusString: statusMap.descriptionByValue(cmr.STATUS),
							STATUSDATE: cmr.STATUSDATE,
							REQUESTEDBY: cmr.REQUESTEDBY,
							REQUESTEDFOR: cmr.REQUESTEDFOR,
							CHANGEDATE: cmr.CHANGEDATE,
							DESCRIPTION: cmr.DESCRIPTION ? cmr.DESCRIPTION : cmr.PMSCMRLINE[0].DESCRIPTION,
							item: cmr
						};
						reqs.push(req);
					}
					catch(ex) {
						ibm.tivoli.logger.error("srmQuery._getRequests: error processing CMR " + i,ex);
						deferred.errback(responses[1][1]);
					}
				}
				deferred.callback({Requests: reqs});	// call the callback the caller would have added
			}
			else {
				deferred.errback(responses[1][1]);	
			}
			return responses;		
		}));
		return deferred;
	},
	
	getServiceRequests: function(params)
	{
		var deferred = null;
		if(undefined == params) { params = {}; }
		var _sync = undefined == params.sync ? false : params.sync;
		var _locale_debug = this._getLocaleDebugString();		
		
		var os_name = "SRM_SR";   //default OS name
		if (params.os!=undefined) {		
			os_name = params.os;	
			params.os=null;
		}
		var sr_object = "SR";    //default object(mbo)
		if (params.sr_object!=undefined) {		
			sr_object = params.sr_object;	
			params.sr_object=null;
		}
		
		//Add timestamp to request to avoid IE caching problem. IE is caching request and not sending it.
		//Fixed in 7.5.0.1
		//if (dojo.isIE) {
		//   var timestamp =  new Date().valueOf();  
		//   params._preventCache = timestamp;
		//}
		
		if(undefined == params.id) {
			// get the status domain we need
			var srstatq = this.getDomain({DOMAINID: 'SRSTATUS'});
			
			//if(undefined == params._fd || params._fd!="") {				 	
				   //params._fd = "SRM_SRUSRLIST";	// limit to SRs the logged in user may see				 
			//}
			
			// get the list of requests
			params._verbose=false;
			var srq =  this.getObjectStructure(os_name, params);  

			deferred = new dojo.Deferred();	// this is the deferred returned by the function. 
			deferred.addErrback(dojo.hitch(this, this._ajaxError));
			
			// when all the queries complete, add a "StatusString" property to each SR with the pretty-formatted status
			var _queries = new dojo.DeferredList([srstatq, srq]);
			_queries.addCallbacks(dojo.hitch(this, function(responses)
			{
				var reqs = [];
				
				// SRs
				if(responses[1][0]) {
					var statusMap = this.getDomainSynonymTable('SRSTATUS');
					var srs;
					
					var query_response = "Query" + os_name + "Response";  //"QuerySRM_SRResponse"
					var srset_response = os_name + "Set";  //"SRM_SRSet"
										 
					//This is equivalent to responses[1][1].QuerySRM_SRResponse.SRM_SRSet.SR;
				    srs = responses[1][1][query_response][srset_response][sr_object];			       
					 
					var count = undefined == srs ? 0 : srs.length;
					for(var i = 0; i < count; ++i) {
						try {
							var sr = srs[i];
						
							req = {
								key: "SR" + sr.TICKETUID,
								id: sr.TICKETUID,
								type: "SR",
								StatusString: statusMap.descriptionByValue(sr.STATUS),
								REQUESTEDBY: sr.CREATEDBY, 
								REQUESTEDFOR: sr.AFFECTEDPERSON,
								item: sr
							}

							for (var name in sr)
							{
								req[name] = sr[name];
							}

							reqs.push(req);
						}
						catch(ex) {
							ibm.tivoli.logger.error("srmQuery._getServiceRequests: error processing SR " + i,ex);
							if(deferred.fired < 0) {
								deferred.errback(responses[1][1]);
							}
						}
					}
				}
				else {
					if(deferred.fired < 0) {
						deferred.errback(responses[1][1]);
					}
				}	
				if(deferred.fired < 0) {
					deferred.callback({Requests: reqs});	// call the callback the caller would have added
				}
				return responses;		
			}), function(responses) 
			{
				if(deferred.fired < 0) {
					deferred.errback(new Error("srmQuery.getServiceRequests query failure"));
				}
			});
		}
		else {
			//deferred =  this.getObjectStructure("SRM_SR", {TICKETUID: params.id, _fd:"PMZHBT_SRUSRLIST"});			
            deferred =  this.getObjectStructure(os_name, {TICKETUID: params.id, _fd: params._fd, _verbose:"false"});				
		}
		return deferred;
	},
	addZero: function(n)
	{
		return n < 10 ? '0' + n : n;
	},
	
	/**
	 * Get Assets
	 * 
	 * @param params
	 * @returns
	 */
	getAssets: function(params)
	{
		var deferred = null;
		if(undefined == params) { params = {}; }
		var _sync = undefined == params.sync ? false : params.sync;
		var _locale_debug = this._getLocaleDebugString();		
		
		var os_name = "MXASSET";   //default OS name
		if (params.os!=undefined) {		
			os_name = params.os;	
			params.os=null;
		}
		var sr_object = "ASSET";    //default object(mbo)
		if (params.sr_object!=undefined) {		
			sr_object = params.sr_object;	
			params.sr_object=null;
		}
		//Get asset for user
		var personid = this.getLoggedInUser().PERSONID;
 		//params["assetusercust.personid"]=personid;
		
		//Add timestamp to request to avoid IE caching problem. IE is caching request and not sending it.
		//Fixed in 7.5.0.1
		//if (dojo.isIE) {
		//   var timestamp =  new Date().valueOf();  
		//   params._preventCache = timestamp;
		//}
		
		if(undefined == params.id) {  //No id, get all assets for user
			// get the status domain we need
			var assetstatq = this.getDomain({DOMAINID: 'ASSETSTATUS'});  //Get the Asset status domain			
						 			
			params._verbose=false;
			var srq =  this.getObjectStructure(os_name, params);  //Get the assets  

			deferred = new dojo.Deferred();	// this is the deferred returned by the function. 
			deferred.addErrback(dojo.hitch(this, this._ajaxError));
			
			// when all the queries complete, add a "StatusString" property to each Asset with the pretty-formatted status
			var _queries = new dojo.DeferredList([assetstatq, srq]);
			_queries.addCallbacks(dojo.hitch(this, function(responses)
			{
				var reqs = [];
				
				// Assets
				if(responses[1][0]) {
					var statusMap = this.getDomainSynonymTable('ASSETSTATUS');  //asset status domain should be cached
					var srs;
					
					var query_response = "Query" + os_name + "Response";  //"QueryMXASSETResponse"
					var asset_response = os_name + "Set";  //"MXASSETSet"
										 
					//This is equivalent to responses[1][1].QueryMXASSETResponse.MXASSETSet.ASSET;
				    var assets = responses[1][1][query_response][asset_response][sr_object];			       
					 
					var count = undefined == assets ? 0 : assets.length;
					for(var i = 0; i < count; ++i) {
						try {
							var asset = assets[i];						
							
							var personid=null, orgid=null, isprimary=null, iscustodian=null, isuser=null;
							if (undefined != asset.ASSETUSERCUST) {
								personid = asset.ASSETUSERCUST[0].PERSONID;
								orgid = asset.ASSETUSERCUST[0].ORGID;
								isprimary = asset.ASSETUSERCUST[0].ISPRIMARY;
								iscustodian = asset.ASSETUSERCUST[0].ISCUSTODIAN;
								isuser = asset.ASSETUSERCUST[0].ISUSER;								
							}
							 
							var req = {
								key: "ASSET" + asset.ASSETID,
								id: asset.ASSETID,								
								type: "ASSET",
								StatusString: statusMap.descriptionByValue(asset.STATUS),
								
								//ASSETNUM: asset.ASSETNUM,
								//SITEID: asset.SITEID,
								//DESCRIPTION: asset.DESCRIPTION,
								//LOCATION: asset.LOCATION,
								//SERIALNUM: asset.SERIALNUM,
								//CHANGEDATE: asset.CHANGEDATE,
								//STATUSDATE: asset.STATUSEDATE,
																
								REFRESHDATE: asset.TLOAMREFRESHDATE==undefined || asset.TLOAMREFRESHDATE==null ?'' : asset.TLOAMREFRESHDATE,
								PLANNEDREFRESHDATE: asset.TLOAMREFRESHPLANDATE==undefined ||asset.TLOAMREFRESHPLANDATE==null?'':asset.TLOAMREFRESHPLANDATE,
								PERSONID: personid,
								ORGID: orgid,
								ISPRIMARY: isprimary,
								ISCUSTODIAN: iscustodian,
								ISUSER: isuser															 
								//item: sr
							}

							//this adds all other attributes 
							for (var name in asset) {
						     		req[name] = asset[name];
							}							

							reqs.push(req);
						}
						catch(ex) {
							ibm.tivoli.logger.error("srmQuery._getAssets: error processing Asset " + i,ex);
							if(deferred.fired < 0) {
								deferred.errback(responses[1][1]);
							}
						}
					}
				}
				else {
					if(deferred.fired < 0) {
						deferred.errback(responses[1][1]);
					}
				}	
				if(deferred.fired < 0) {
					deferred.callback({Requests: reqs});	// call the callback the caller would have added
				}
				return responses;		
			}), function(responses) 
			{
				if(deferred.fired < 0) {
					deferred.errback(new Error("srmQuery.getAssets query failure"));
				}
			});
		}
		else {
			//Get one asset			
            deferred =  this.getObjectStructure(os_name, {ASSETID: params.id,  _verbose:"false"});				
		}
		return deferred;
	},
	

	/**
	 * get data from BULLETINBOARD table
	 */
	getBBoardMessages: function(params)
	{
		console.log("srmQuery.getBBoardMessages() enter ", params);

		var msgs = [];
		var deferred = null;
		if(undefined == params) { params = {}; }
		var _sync = undefined == params.sync ? false : params.sync;
		var _locale_debug = this._getLocaleDebugString(); 
		
		if(undefined == params.id) {
			
			// get the status domain			
			var bbstatq = this.getDomain({DOMAINID: 'BULLETINSTATUS'});

			// get the list of messages			
			var objstr = this.getObjectStructure("SRM_BULLETINBOARD", {_verbose:"false"});
			
			deferred = new dojo.Deferred();	// this is the deferred returned by the function. 
			deferred.addErrback(dojo.hitch(this, this._ajaxError));
			
			// when all the queries complete, add a "StatusString" property to each message with the pretty-formatted status
			var _queries = new dojo.DeferredList([bbstatq, objstr]);
			_queries.addCallback(dojo.hitch(this, function(responses)
			{	
				// BulletinBoard Messages
				if(responses[1][0]) {
					var statusMap = this.getDomainSynonymTable('BULLETINSTATUS');

					// PMBBISTRACKING
					var maxPropValue = responses[1][1].QuerySRM_BULLETINBOARDResponse.SRM_BULLETINBOARDSet.DUMMY_TABLE[0].MAXPROPVALUE;
					var isTracking = 1;
					if (maxPropValue != undefined)
					{
						isTracking = maxPropValue[0].PROPVALUE;
					}
						
					var resp = responses[1][1].QuerySRM_BULLETINBOARDResponse.SRM_BULLETINBOARDSet.DUMMY_TABLE[0].BULLETINBOARD;
					var count = undefined == resp ? 0 : resp.length;
					for(var i = 0; i < count; ++i) {
						try {
							var cr = resp[i];
							
							// Process Bulletin Board Message Status records
							var msgStatus = resp[i].BBOARDMSGSTATUS;
							var viewed = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").No;
							if (undefined != msgStatus) {
							        viewed = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Yes;
							}
							
							// Process Bulletin Board Audience records                            
							
							var msgorgid1 = null;
							var msgsiteid1 = null;
							var persongroup1 = null;
							var msgAudience = resp[i].BBOARDAUDIENCE;		
							
							
							if (undefined != msgAudience) {
								msgorgid1 = msgAudience[0].MSGORGID;
								msgsiteid1 = msgAudience[0].MSGSITEID;
								persongroup1 = msgAudience[0].PERSONGROUP;
							}
                            
							var msg = {
								key: cr.BULLETINBOARDID,
								id: cr.BULLETINBOARDUID,
								type: "BULLETBOARD",
								STATUS: cr.STATUS,
								StatusString: statusMap.descriptionByValue(cr.STATUS),
								SUBJECT: cr.SUBJECT,
								MESSAGE: cr.MESSAGE,
								POSTBY: cr.POSTBY,
								POSTDATE: cr.POSTDATE,
								EXPIREDATE: cr.EXPIREDATE,
								ISVIEWED: viewed,
								MSGORGID: msgorgid1,
								MSGSITEID: msgsiteid1,
								PERSONGROUP: persongroup1,
								ISTRACKING: isTracking

							}
							msgs.push(msg);
						}
						catch(ex) {
							ibm.tivoli.logger.error("srmQuery._getBBoardeMessages: error processing BulletinBoard " + i,ex);
							deferred.errback(responses[1][1]);
						}
					}
				}
				else {
					deferred.errback(responses[1][1]);
				}	
				deferred.callback({Requests: msgs});	// call the callback the caller would have added
				return responses;		
			}));
		}
		else {
			console.log("srmQuery.getBBoardMessages() params should not be specified");
		}
		return deferred;
	},

	
	/**
	 * get the list of person groups this user has access to
	 */
	getPersonGroups: function(params)
	{
		console.log("srmQuery.getPersonGroups() enter ", params);
		
		var deferred = null;
		if(undefined == params) { params = {}; }
		var _sync = undefined == params.sync ? false : params.sync;
		var _locale_debug = this._getLocaleDebugString(); 
		
		if(undefined == params.id) {
			
			// get the list of person groups
			var user = this.getLoggedInUser();
     		var personid=user.PERSONID;
			//var objstr = this.getObjectStructure("SRM_PGTEAM", { _exactmatch: 1, resppartygroup: personid });
			var objstr = this.getObjectStructure("SRM_PGTEAM", { _exactmatch: 1 });

			deferred = new dojo.Deferred();	// this is the deferred returned by the function. 
			deferred.addErrback(dojo.hitch(this, this._ajaxError));
			
			var _queries = new dojo.DeferredList([objstr]);
			_queries.addCallback(dojo.hitch(this, function(responses)
			{
				var pgd = [];
				
				// Person Group Team records
				if(responses[0][0]) {
					var resp = responses[0][1].QuerySRM_PGTEAMResponse.SRM_PGTEAMSet.PERSONGROUPTEAM;
					var count = undefined == resp ? 0 : resp.length;
					for(var i = 0; i < count; ++i) {
						try {
							var cr = resp[i];
							
							var pg  = {
								key: cr.PERSONGROUPTEAMID,
								//id: cr.BULLETINBOARDUID,
								PERSONGROUP: cr.PERSONGROUP,
								RESPPARTYGROUP: cr.RESPPARTYGROUP
							}
							pgd.push(pg);
						}
						catch(ex) {
							ibm.tivoli.logger.error("srmQuery._getBBoardeMessages: error processing BulletinBoard " + i,ex);
							deferred.errback(responses[1][1]);
						}
					}
				}
				else {
					deferred.errback(responses[1][1]);
				}	
				deferred.callback({Requests: pgd});	// call the callback the caller would have added
				return responses;		
			}));
		}
		else {
			console.log("srmQuery.getPersonGroups() params should not be specified");
		}
		return deferred;
	},
	
	/**
	 * get the list of organizations this user has access to
	 */
	getPersonOrgsSites: function(params)
	{
		console.log("srmQuery.getPersonOrgs() enter ", params);
		
		var deferred = null;
		if(undefined == params) { params = {}; }
		var _sync = undefined == params.sync ? false : params.sync;
		var _locale_debug = this._getLocaleDebugString(); 
		
		if(undefined == params.id) {

			// get the list of organizations
			var user = this.getLoggedInUser();
			var loginid = user.LOGINID;
			
			var defSite = "NODEFAULTSITE";
			var defOrg = "NODEFAULTORG"
			if (undefined != user.SITE) {
				defSite = user.SITE[0].SITEID;
				defOrg = user.SITE[0].ORGID;
			}
			
			var objstr = this.getObjectStructure("SRM_ORGSITE", { _exactmatch: 1 });
			//var objstr = this.getObjectStructure("SRM_ORGSITE", { _exactmatch: 1, userid: loginid });

			deferred = new dojo.Deferred();	// this is the deferred returned by the function. 
			deferred.addErrback(dojo.hitch(this, this._ajaxError));
			
			var _queries = new dojo.DeferredList([objstr]);
			_queries.addCallback(dojo.hitch(this, function(responses)
			{
				var orgsite = [];
				
				// Set Default Org\Site
				var os = {
					key: 1,
					SITEID: defSite,
					ORGID: defOrg,
					AUTHALLSITES: false
				}
				orgsite.push(os);
				
				// Site Records
				if(responses[0][0]) {
					var resp = responses[0][1].QuerySRM_ORGSITEResponse.SRM_ORGSITESet.GROUPUSER;
					var count = undefined == resp ? 0 : resp.length;
					var authallsites = false;
					// Check for access to all sites
					for(var i = 0; i < count; ++i) {
						try {
							var cr = resp[i];
							
							var maxGroup = resp[i].MAXGROUP;
							if (maxGroup[0].AUTHALLSITES == true) {
								orgsite[0].AUTHALLSITES = true;
								authallsites = true;
								break;
							}
						}	
						catch(ex) {
							ibm.tivoli.logger.error("srmQuery._getPersonOrgs: error processing BulletinBoard " + i,ex);
							deferred.errback(responses[0][1]);
						}
					}
					// Check for access to individual sites
					if (authallsites == false) {
						for(var i = 0; i < count; ++i) {
							try {
								var siteAuth = resp[i].SITEAUTH;
								if (undefined != siteAuth) {
							    	var siteAuthCount = siteAuth.length;
							    	for (var j = 0; j < siteAuthCount; ++j) {
							    		os = {
											key: 1,
											SITEID: siteAuth[j].SITEID,
											ORGID: siteAuth[j].ORGID,
											AUTHALLSITES: false
										}
										orgsite.push(os);
									}

								}
							
							}
							catch(ex) {
								ibm.tivoli.logger.error("srmQuery._getPersonOrgs: error processing BulletinBoard " + i,ex);
								deferred.errback(responses[0][1]);
							}
						}
					}
				}
				else {
					deferred.errback(responses[1][1]);
				}	
				deferred.callback({Requests: orgsite});	// call the callback the caller would have added
				return responses;		
			}));
		}
		else {
			console.log("srmQuery.getPersonOrgs() params should not be specified");
		}
		return deferred;
	},
	
	approveRequest: function(/*number*/ticketID, /*string*/memo, /*boolean*/approve)
	{
		var srStatusMap = this.getDomainSynonymTable('SRSTATUS');
		var newstatus = approve ? srStatusMap.valueByMaxvalue('PENDING') : srStatusMap.valueByMaxvalue('CLOSED');
		var classMap = this.getDomainSynonymTable('TKCLASS');
		var newsr = classMap.valueByMaxvalue('SR');

		var params = {
			wsUrl: this.baseWSUrl + "TICKET",
			sync: true
		};
				
		params.postData = 
			  '<?xml version="1.0" encoding="UTF-8"?>'
		    + '<soapenv:Envelope xmlns:q0="http://www.ibm.com/maximo" xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">'
		    + '<soapenv:Body>'
			+ '<q0:ticketchangeStatus>'
			+ '<q0:ticket>'
			+ '<q0:TICKET>'
			+ '<q0:CLASS maxvalue="" changed="true">' + newsr + '</q0:CLASS>'
			+ '<q0:TICKETID changed="true">' + ticketID + '</q0:TICKETID>'
			+ '</q0:TICKET>'
			+ '</q0:ticket>'
			+ '<q0:status>'+ newstatus + '</q0:status>'
			+ '<q0:memo><![CDATA[' + memo + ']]></q0:memo>'
			+ '</q0:ticketchangeStatus>'
			+ '</soapenv:Body>'
			+ '</soapenv:Envelope>';
		
		var deferred = this.callWebService(params);
		// the response
		//		<?xml version="1.0" encoding="UTF-8"?>
		//		<max:ticketchangeStatusResponse 
		//			xmlns:max="http://www.ibm.com/maximo" 
		//			creationDateTime="ISO datetime" 
		//			baseLanguage="string" 
		//			transLanguage="string" 
		//			messageID="string" 
		//			maximoVersion="string" /> 

		var bSuccess = false;	// assume the worst
		deferred.addCallbacks(function(response) 
		{				
			console.log(response);
			bSuccess = true;
			return response;
		},
		function(response)
		{
			console.error(response);
			return response;
		});
		return bSuccess;				
	},
	
	/**
	 * Returns the list of ticket templates in a tree format
	 * and caches the result 
	 */

	_templateCache: null,
		getTemplates: function(params)
		 {
			console.log("srmQuery.getTemplates() enter ", params);
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			
			if(undefined == params) { params = {}; }  
			var status="ACTIVE";
			var ccrStatus_domain = this.getDomainSynonymTable('TEMPLATESTATUS');
			status = ccrStatus_domain.valueByMaxvalue('ACTIVE');
			var tmpltclass = "SR";
			var tmpltclass_domain = this.getDomainSynonymTable('TKCLASS');
			tmpltclass = tmpltclass_domain.valueByMaxvalue('SR');
			params["class"]=tmpltclass;
			params.status=status;
			params.selfservaccess="1";
			params._verbose=false;

			var _tree = null;
			if (params._tree) {
				_tree = params._tree;
				delete params._tree;
			}
			var deferred = this.getObjectStructure("SRMTKTEMPLTOS", params);
			//var deferred = this.getObjectStructure("SRMTKTEMPLTOS", {sync: true});
			console.log("srmQuery.getTemplates() deferred:", deferred);

			deferred.addCallback(dojo.hitch(this, function(response) {  
				console.log("srmQuery.getTemplates() inner callback:", response);
				if(response == null)
					return null;
				var template = response.QuerySRMTKTEMPLTOSResponse.SRMTKTEMPLTOSSet.TKTEMPLATE;  
				var tmpltTable;	
				if (template) {
					   tmpltTable = response.QuerySRMTKTEMPLTOSResponse.SRMTKTEMPLTOSSet.TKTEMPLATE; 
				} else {
					tmpltTable = []; /* Fix to PTM PHYP0391GOC - in case of zero offerings */
				}
				var tmpltTree = new ibm.tivoli.simplesrm.srm.dojo.data.TemplatesTree;
				
				if (product!=null && product.indexOf("srm")>=0){
					if(params._search && params._search.length > 0)
						tmpltTree._noParents = true;
				}
				
				
				//reuse other tree for use the same fodler structure
				if(_tree)
					tmpltTree._tree = _tree; 
				for (var i = 0; i < tmpltTable.length; i++) {
					var template =tmpltTable[i];	
					if(params._folder && params._folder.length > 0){
						var classtructure = {DESCRIPTION : params._folder,
											 CLASSSTRUCTUREUID : params._folder};
						template.CLASSSTRUCTURE = new Array();
						template.CLASSSTRUCTURE.push(classtructure);
				    }    
					tmpltTree.addTemplate(template);
				}
				var resTree = { Category : tmpltTree._tree };
				console.log("srmQuery.getTemplates() resTree:", resTree);
				this._templateCache = resTree;
				return resTree;

			}));

			console.log("srmQuery.getTemplates() exit");
			return deferred;
	},
	
	_image_cache:  new Array(),  //image cache	 
	
	/**
	 * Returns the list of offerings in a tree format
	 * and caches the result 
	 */	
	_catalogCache: null,
	 _offTree: null,     // global used to save intermediate Offerings when there are more than 500 in DB and we retrieve 500 at a time. 
	 getRequestsCatalog: function(params)
	 {
		console.log("srmQuery.getRequestsCatalog() enter ", params);
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");		
				
		if(undefined == params) { 
           params = {};
        }
	   params._exactmatch = 1;
		//Get active status offerings only
		var offering_status = "ACTIVE";
		var offeringStatus_domain = this.getDomainSynonymTable('ITEMSTATUS');
		var offering_status = offeringStatus_domain.valueByMaxvalue("ACTIVE");
		params.status = offering_status;
		params._verbose=false;
        //params._fd = "SRM_OFFERING";  //filter offerings not in catalog or catalog is not active
		
		console.log("srmQuery().getRequestsCatalog() params: ", params);
		var deferred =null;
		if (params._usembo!=undefined) {  //use Mbo instead of OS for performance 
			 params._includecols="itemid,itemnum,itemsetid,description,catalogclassstructure";
			 deferred = this.getMbo("PMSCOFFERING", params);
			 delete params['_usembo'];
		} else {
		    deferred = this.getObjectStructure("SRM_OFFERING", params);
		}
		
		deferred.addCallback(dojo.hitch(this, function(response) {
			//console.log("Deferred response: ", response);
			if(response == null)
				return null;
			
			var pmscsrvoff = null;
			if (response.PMSCOFFERINGMboSet)  
				pmscsrvoff = response.PMSCOFFERINGMboSet.PMSCOFFERING;
			else
		        pmscsrvoff = response.QuerySRM_OFFERINGResponse.SRM_OFFERINGSet.PMSCOFFERING; 
          
         var offTable;
			if (pmscsrvoff) {
				 offTable = pmscsrvoff; 
			} else {
				offTable = []; /* Fix to PTM PHYP0391GOC - in case of zero offerings */
			}
			
			var offTree = this._offTree;  //local offering tree
			//Use a local variable if not retrieving the list of catalog offerings
			if (params._search==undefined && params._folder == undefined && this._offTree==null) { 
			   this._offTree = new ibm.tivoli.simplesrm.srm.dojo.data.OfferingTree;
			   offTree = this._offTree;
			   
			   //Not getting Offering catalog
			} else  if (params._search != undefined || params._folder !=undefined) {
				offTree =  new ibm.tivoli.simplesrm.srm.dojo.data.OfferingTree;
			}
			
			if (product!=null && product.indexOf("srm")>=0){
				if(params._search && params._search.length > 0)
					offTree._noParents = true;
			}
			var itemid = -1;  //keep track of last itemid
			for (var i = 0; i < offTable.length; i++) {
				//console.log("current: ", offTable[i].DESCRIPTION);
				
				if (product!=null && product.indexOf("srm")>=0) {
				      var offering =offTable[i];
				      itemid = offering.ITEMID;  
				      
				      if(params._folder && params._folder.length > 0){
				    	  var classtructure = {DESCRIPTION : params._folder,
									 		  CLASSSTRUCTUREUID : params._folder};
		                  if (offering.PMSCCATALOGOFFMAP) {  //Is offering in catalog?
				    	     offering.PMSCCATALOGOFFMAP[0].CLASSSTRUCTURE = new Array();
				    	     offering.PMSCCATALOGOFFMAP[0].CLASSSTRUCTURE.push(classtructure);
                             while(offering.PMSCCATALOGOFFMAP.length!=1) { //delete other arrays entries
                                 offering.PMSCCATALOGOFFMAP.pop();
                             }
	                      } else  if (offering.CATALOGCLASSSTRUCTURE) {  //Is offering in catalog?  
		                	     offering.PMSCCATALOGOFFMAP = new Array();
					    	     offering.PMSCCATALOGOFFMAP[0].CLASSSTRUCTURE = new Array();
					    	     offering.PMSCCATALOGOFFMAP[0].CLASSSTRUCTURE.push(classtructure);
			                  }
		                  }				          
				      offTree.addOffering(offering);
				} else { 
					 offTree.addOffering(offTable[i]);
				}
			}
			
			var resTree;
			if (response.PMSCOFFERINGMboSet)  
				resTree = { Category : offTree._tree, count:  response.PMSCOFFERINGMboSet.rsCount, lastItemID: itemid};  
			else
			    resTree = { Category : offTree._tree, count:  response.QuerySRM_OFFERINGResponse.rsCount, lastItemID: itemid};  
			console.log("srmQuery.getRequestsCatalog() resTree:", resTree);
			this._catalogCache = resTree;
			return resTree;
		}));
		
		console.log("srmQuery.getRequestsCatalog() exit");
		return deferred;
	},
    /**
	 * Returns the list of offerings in a tree format 
	 */
	 getFavItem: function(params)
	 {
		console.log("srmQuery.getFavItem() enter ", params);
		
		if(undefined == params) {params = {};}
		var _sync = undefined == params.sync ? false : params.sync;
		var _user = this.getLoggedInUser();
		var _personid=_user.PERSONID;

		console.log("_personid: ", _personid);
		
		var deferred = this.getObjectStructure("SRM_FAVITEM", {sync: _sync, _exactmatch: 1, PERSONID: _personid});		   
		
		deferred.addCallback(dojo.hitch(this, function(response) {
			console.log("Deferred response: ", response);
			
			var favitems;
			var pmscsrvoff;
			favitems  = response.QuerySRM_FAVITEMResponse.SRM_FAVITEMSet.FAVITEM;
           
			var favTable;	
			if (favitems) {
				favTable =  response.QuerySRM_FAVITEMResponse.SRM_FAVITEMSet.FAVITEM; 
			} else {
				favTable = []; /* Fix to PTM PHYP0391GOC - in case of zero offerings */
			}
			
			console.log(" favTable",favTable);
			
			var offering_status = "ACTIVE";
			var offeringStatus_domain = this.getDomainSynonymTable('ITEMSTATUS');
			var offering_status = offeringStatus_domain.valueByMaxvalue("ACTIVE");
			var offTree = new ibm.tivoli.simplesrm.srm.dojo.data.OfferingTree;
			for (var i = 0; i < favTable.length; i++) {
				var offTable = favTable[i].PMSCOFFERING;
				console.log("********* offTable",offTable);
				for (var j = 0; j < offTable.length; j++) {
					pmscsrvoff= favTable[i].PMSCOFFERING[j];
					pmscsrvoff.DESCRIPTION = favTable[i].DESCRIPTION;
					pmscsrvoff.ITEMNUM = favTable[i].ITEMNUM;
					pmscsrvoff.ITEMSETID = favTable[i].ITEMSETID;
					pmscsrvoff.FAVITEM = true;  
					if (pmscsrvoff.STATUS == offering_status) {
						offTree.addOffering(pmscsrvoff);
					}
				}	
			}
			var resTree = { Category : offTree._tree };
			console.log("srmQuery.getFavItem() resTree:", resTree);
			this._catalogCache = resTree;
			return resTree;
			}));
			
		console.log("srmQuery.getFavItem() exit");
		return deferred;
	},

	getOfferingInfo: function(itemNum)
	{
		var offering = null;
		if(undefined == this._catalogCache) {
			this.getRequestsCatalog({sync: true});
		}
		if(undefined != this._catalogCache) {
			
			function findOffering(category, itemNum) {
				//console.log("...searching category ", category.Description);
				for(var i = 0; i < category.length; ++i) {
					var cat = category[i];
					//console.log("...catagory: ", cat.Description);
					if(cat.Offering) {
						for(var j = 0; j < cat.Offering.length; ++j) {
							var off = cat.Offering[j];
							//console.log("......offering: ", off.ItemNum)
							if(itemNum == off.ItemNum) {
								//console.log("...... foundit.");
								return off;
							}
						}
					}
					if(cat.Category) {
						return findOffering(cat.Category, itemNum);
					}
				}
			}
			
			offering = findOffering(this._catalogCache.Category, itemNum);
			if(offering) {	// the in-context list and what's available to this user may not match
				this._patchRequestImageName(offering);
			}
		}
		return offering;
	},
	

	getIncidentsCatalog: function()
	{
		var deferred = null;
		var requests_catalog = ibm.tivoli.tpae.dojo.data.getConfigProperty("IncidentsCatalog");
		if(requests_catalog && requests_catalog.length > 0) {
			alert("getIncidents was never ported from TDI");
		}
		return deferred;
	},
	// returns a list of offerings that are appropriate in the given context
	getOfferingsInContext: function(contextName)
	{
		var off_in_context = [];
		var offlist = this.getDomainSynonymTable(contextName);
		if(offlist) {
			for(var i = 0; i < offlist.length; ++i) {
				var offering = this.getOfferingInfo(offlist.synonyms[i].MAXVALUE);
				if(offering) {
					off_in_context.push(offering);
				}
			}
		}
		console.log(off_in_context);
		return off_in_context;
	},
	
	//Get User's Shopping Cart (PMSCCR+SRs) for tooltip  
	getShoppingCart: function() {
		console.log("srmQuery.getShoppingCart() enter ");
		//var user = this.getLoggedInUser();
		var user =  this.getLoggedInUser().USERID;		
		
		//Get draft status value
		var draft_status="DRAFT";
		var ccrStatus_domain = this.getDomainSynonymTable('PMSCCRSTATUS');
		draft_status = ccrStatus_domain.valueByMaxvalue("DRAFT");		 
		 		
		//Get latest cart for user in draft status		 	
		var  deferred= this.getObjectStructure("SRM_CART", {_exactmatch: 1, status: draft_status, _orderbydesc:"changedate",_maxItems:1,_verbose:"false"});	 		 
		//var  deferred= this.getObjectStructure("SRM_CART", {_exactmatch: 1, status: draft_status, changeby: user, _orderbydesc:"changedate",_maxItems:1,_verbose:"false"});	 
      	return deferred;		 
	},
	
	// we get the request's icon image name from the query, but have to cook
	// up the path to the actual bits.
	imageCacheUrl: "/SRMCommonsWeb/MaxImageCache/",
	_patchRequestImageName: function(request) 
	{
		try {
			if(undefined == request.ImagePath || undefined == request.ImageName) {
				request.ImagePath = "";
				if(undefined == request.ImageName) {
					request.ImageName = "";
				}
				// build the URL to the offering's image
				if(request.ImageName.length > 0) {
					request.ImagePath =  this.imageCacheUrl + request.ImageName + "?REFID=" + request.ItemID;
				}
				else {
					request.ImagePath = "/SimpleSRM/js/simplesrm/srm/dijit/images/icons/default_request.png";
				}
			}
		}
		catch(ex) {
			ibm.tivoli.logger.error("srmQuery._patchRequestImageName: " + ex,ex);
		}
		return request;
	},
			
	
	/**
	 *  Get classstructures used by solutions
	 *  This gets all of them. Should we only get the top level and then when user click on folder get the children? 
	 * 
	 */
	getSolutionsClassStructures: function(params) {  //fpb
		console.log("srmQuery.getSolutionsClassStructures() enter ", params);
		
		if(undefined == params) { params = {}; }
		 
		params._fd="SRM_SOLUTIONCS";  //gets only CS that are used in solutions (active and for self service)
		params._orderbydesc="CLASSSTRUCTUREID";
	
		//get classstructures used by solutions
		var deferred = this.getObjectStructure("SRM_CLASSSTRUCTURE", params);
		 
		
		deferred.addCallback(dojo.hitch(this, function(response) {  
			console.log("srmQuery.getSolutionsClassStructures() inner callback:", response);
			if(response == null)
				return null;	
			var cs = response.QuerySRM_CLASSSTRUCTUREResponse.SRM_CLASSSTRUCTURESet.CLASSSTRUCTURE;  
			var csTable;	
			if (cs) {
				csTable = response.QuerySRM_CLASSSTRUCTUREResponse.SRM_CLASSSTRUCTURESet.CLASSSTRUCTURE; 
			} else {
				csTable = []; /* Fix to PTM PHYP0391GOC - in case of zero classstructures */
			}
			var csTree = new ibm.tivoli.simplesrm.srm.dojo.data.SolutionTree;  //Todo
			
			for (var i = 0; i < csTable.length; i++) {
				csTree.addSolution(csTable[i]);
			}
			var resTree = { Category : csTree._tree };
			console.log("srmQuery.getSolutionsClassStructures() resTree:", resTree);
			//this._solutionCache = resTree;
			return resTree;						
		}));

		console.log("srmQuery.getSolutionswithClass() exit");
		return deferred;
	},

	
	
	_solutionCache: null,
	/**
	 * Get Solutions
	 */
	getSolutions: function(params)  
	 {
		console.log("srmQuery.getSolutions() enter ", params);
		
		if(undefined == params) { params = {}; }

		var _tree = null;
		//Are we storing solution in an existingn tree?
		if (params._tree) {
			_tree = params._tree;
			delete params._tree;
		}
						
		var deferred = this.getObjectStructure("SRM_SOLUTION", params);
		console.log("srmQuery.getSolutions() deferred:", deferred);

		
		deferred.addCallback(dojo.hitch(this, function(response) {  
			console.log("srmQuery.getSolutions() inner callback:", response);
			if(response == null)
				return null;	
			var solution = response.QuerySRM_SOLUTIONResponse.SRM_SOLUTIONSet.SOLUTION;  
			var solTable;	
			if (solution) {
				solTable = response.QuerySRM_SOLUTIONResponse.SRM_SOLUTIONSet.SOLUTION; 
			} else {
				solTable = []; /* Fix to PTM PHYP0391GOC - in case of zero offerings */
			}
			var solTree = new ibm.tivoli.simplesrm.srm.dojo.data.SolutionTree;
			
			//Merge into existing tree
			if(_tree) {  //fpb
				solTree._tree = _tree;
			}

			for (var i = 0; i < solTable.length; i++) {
				solTree.addSolution(solTable[i]);
			}
			var resTree = { Category : solTree._tree };
			console.log("srmQuery.getSolutions() resTree:", resTree);
			this._solutionCache = resTree;
			return resTree;
						
		}));

		console.log("srmQuery.getSolutions() exit");
		return deferred;
	},
	
	//Get User's number of cart templates  
	getCartTemplatesAmt: function() {
		console.log("srmQuery.getCartTemplatesAmt() enter ");
				
		var user =  this.getLoggedInUser().USERID;
		
		var params = {};
		params._exactmatch=1;
		params._maxItems=1;
		params._compact=1;
		params.sync = true;
		params._includecols="PMSCTMPLID";
		//params.owner=user;
		
		var url = this.baseRestUrl + this.rest_context_root + "/rest/mbo/PMSCTMPL";
				 		 
		var  deferred= this.get(url, true, params );	 
      	return deferred;		 
	},

	
	getFavTemplates: function(params)
	 {
		
		if(undefined == params) { params = {}; }  
		
		params.PERSONID = this.getLoggedInUser().PERSONID;
		
		var deferred = this.getObjectStructure("SRM_FAVTKTEMPLATE", params);

		deferred.addCallback(dojo.hitch(this, function(response) {  

			var favoriteSet = response.QuerySRM_FAVTKTEMPLATEResponse.SRM_FAVTKTEMPLATESet;
			var favoriteTable;	
			if (favoriteSet && favoriteSet.FAVORITE && favoriteSet.FAVORITE.length > 0) {
				favoriteTable = favoriteSet.FAVORITE;
			} else {
				favoriteTable = []; 
			}
			var tmpltTree = new ibm.tivoli.simplesrm.srm.dojo.data.TemplatesTree;

			for (var i = 0; i < favoriteTable.length; i++) {
				tmpltTree.addTemplate(favoriteTable[i].TKTEMPLATE[0]);
			}
			var resTree = { Category : tmpltTree._tree };
			this._templateCache = resTree;
			return resTree;

		}));

		return deferred;
	 },
	 
	//truncate long description
	 truncate: function(description) {
	 	var truncate = 100;
	 	
	 	//Add spacing
	 	var desc = description.replace(/<li>/g, "<li> - ");
	     desc = desc.replace(/<br /g, " <br ");    
	     desc = desc.replace(/<p>/, " <p>");
	     
	     //add space after comma, removed by server OS class
	     desc = desc.replace(/,/g, ", ")
	 	
	 	//Remove html tags because it may contain rich text. 
	 	//TODO - need to improve this:
	 	//  - it will remove things it shouldn't (1<2 and 4>3)
	 	//  - 7.2 supports anchors and we want to leave them in		
	     desc = desc.replace(/<.*?>/g, " ");
	 	
	 	//Fix encoding of "&" RTE encodes it to &amp;amp; 
	 	desc = desc.replace(/&amp;/g, "&");
	 	
	 	//replace non breaking space with a space
	 	desc = desc.replace(/&nbsp;/g, " ");  

	 	if(desc.length > truncate*2) {  //>200?						    
	 								
	 		//truncate on a space, . or ;
	 		truncate = truncate+5;
	 		desc = desc.substring(0, truncate);	// initial truncate
	 		truncate= truncate-1;           //decrement until ending character located
	 		while (truncate>0 && desc.charAt(truncate)!=" " && desc.charAt(truncate)!=";" && desc.charAt(truncate)!="."  ) {
	 		    truncate= truncate-1;
	 		}
	 		if (truncate>0)
	 		   desc = desc.substring(0, truncate+1).replace(/\s+$/, "");	// truncate and trim trailing spaces
	 		
	 		//hacks to truncate text
	 		if (desc.indexOf(" ")==-1 || desc.indexOf(" ")>50) {
	 			desc = desc.substring(0,45) + " " + desc.substring(46);
	 		}
	 		if (desc.length>90 && (desc.indexOf(" ",47)==-1 || desc.indexOf(" ",47)>90)) {
	 			desc = desc.substring(0,90) + " " + desc.substring(91);
	 		} 
	 		
	 		desc += "...";   
	 	}   
	 	return desc;
	 }
	 
});
ibm.tivoli.simplesrm.srm.dojo.data._srmquery = null;
ibm.tivoli.simplesrm.srm.dojo.data.srmQuery = function(){
	// summary: returns the singleton query object
	if(!ibm.tivoli.simplesrm.srm.dojo.data._srmquery){
		ibm.tivoli.simplesrm.srm.dojo.data._srmquery = new ibm.tivoli.simplesrm.srm.dojo.data._srmQuery(); 
	}
	return ibm.tivoli.simplesrm.srm.dojo.data._srmquery;	// Object
};


//****** tsamQuery *******


});

},
'dijit/focus':function(){
define("dijit/focus", [
	"dojo/aspect",
	"dojo/_base/declare", // declare
	"dojo/dom", // domAttr.get dom.isDescendant
	"dojo/dom-attr", // domAttr.get dom.isDescendant
	"dojo/dom-construct", // connect to domConstruct.empty, domConstruct.destroy
	"dojo/Evented",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/_base/sniff", // has("ie")
	"dojo/Stateful",
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.get
	"./a11y",	// a11y.isTabNavigable
	"./registry",	// registry.byId
	"."		// to set dijit.focus
], function(aspect, declare, dom, domAttr, domConstruct, Evented, lang, on, ready, has, Stateful, unload, win, winUtils,
			a11y, registry, dijit){

	// module:
	//		dijit/focus
	// summary:
	//		Returns a singleton that tracks the currently focused node, and which widgets are currently "active".

/*=====
	dijit.focus = {
		// summary:
		//		Tracks the currently focused node, and which widgets are currently "active".
		//		Access via require(["dijit/focus"], function(focus){ ... }).
		//
		//		A widget is considered active if it or a descendant widget has focus,
		//		or if a non-focusable node of this widget or a descendant was recently clicked.
		//
		//		Call focus.watch("curNode", callback) to track the current focused DOMNode,
		//		or focus.watch("activeStack", callback) to track the currently focused stack of widgets.
		//
		//		Call focus.on("widget-blur", func) or focus.on("widget-focus", ...) to monitor when
		//		when widgets become active/inactive
		//
		//		Finally, focus(node) will focus a node, suppressing errors if the node doesn't exist.

		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit._Widget[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		registerIframe: function(iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the <iframe> itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
		},

		registerWin: function(targetWindow, effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow: Window?
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode: DOMNode?
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.
		}
	};
=====*/

	var FocusManager = declare([Stateful, Evented], {
		// curNode: DomNode
		//		Currently focused item on screen
		curNode: null,

		// activeStack: dijit._Widget[]
		//		List of currently active widgets (focused widget and it's ancestors)
		activeStack: [],

		constructor: function(){
			// Don't leave curNode/prevNode pointing to bogus elements
			var check = lang.hitch(this, function(node){
				if(dom.isDescendant(this.curNode, node)){
					this.set("curNode", null);
				}
				if(dom.isDescendant(this.prevNode, node)){
					this.set("prevNode", null);
				}
			});
			aspect.before(domConstruct, "empty", check);
			aspect.before(domConstruct, "destroy", check);
		},

		registerIframe: function(/*DomNode*/ iframe){
			// summary:
			//		Registers listeners on the specified iframe so that any click
			//		or focus event on that iframe (or anything in it) is reported
			//		as a focus/click event on the <iframe> itself.
			// description:
			//		Currently only used by editor.
			// returns:
			//		Handle with remove() method to deregister.
			return this.registerWin(iframe.contentWindow, iframe);
		},

		registerWin: function(/*Window?*/targetWindow, /*DomNode?*/ effectiveNode){
			// summary:
			//		Registers listeners on the specified window (either the main
			//		window or an iframe's window) to detect when the user has clicked somewhere
			//		or focused somewhere.
			// description:
			//		Users should call registerIframe() instead of this method.
			// targetWindow:
			//		If specified this is the window associated with the iframe,
			//		i.e. iframe.contentWindow.
			// effectiveNode:
			//		If specified, report any focus events inside targetWindow as
			//		an event on effectiveNode, rather than on evt.target.
			// returns:
			//		Handle with remove() method to deregister.

			// TODO: make this function private in 2.0; Editor/users should call registerIframe(),

			var _this = this;
			var mousedownListener = function(evt){
				_this._justMouseDowned = true;
				setTimeout(function(){ _this._justMouseDowned = false; }, 0);

				// workaround weird IE bug where the click is on an orphaned node
				// (first time clicking a Select/DropDownButton inside a TooltipDialog)
				if(has("ie") && evt && evt.srcElement && evt.srcElement.parentNode == null){
					return;
				}

				_this._onTouchNode(effectiveNode || evt.target || evt.srcElement, "mouse");
			};

			// Listen for blur and focus events on targetWindow's document.
			// IIRC, I'm using attachEvent() rather than dojo.connect() because focus/blur events don't bubble
			// through dojo.connect(), and also maybe to catch the focus events early, before onfocus handlers
			// fire.
			// Connect to <html> (rather than document) on IE to avoid memory leaks, but document on other browsers because
			// (at least for FF) the focus event doesn't fire on <html> or <body>.
			var doc = has("ie") ? targetWindow.document.documentElement : targetWindow.document;
			if(doc){
				if(has("ie")){
					targetWindow.document.body.attachEvent('onmousedown', mousedownListener);
					var activateListener = function(evt){
						// IE reports that nodes like <body> have gotten focus, even though they have tabIndex=-1,
						// ignore those events
						var tag = evt.srcElement.tagName.toLowerCase();
						if(tag == "#document" || tag == "body"){ return; }

						// Previous code called _onTouchNode() for any activate event on a non-focusable node.   Can
						// probably just ignore such an event as it will be handled by onmousedown handler above, but
						// leaving the code for now.
						if(a11y.isTabNavigable(evt.srcElement)){
							_this._onFocusNode(effectiveNode || evt.srcElement);
						}else{
							_this._onTouchNode(effectiveNode || evt.srcElement);
						}
					};
					doc.attachEvent('onactivate', activateListener);
					var deactivateListener =  function(evt){
						_this._onBlurNode(effectiveNode || evt.srcElement);
					};
					doc.attachEvent('ondeactivate', deactivateListener);

					return {
						remove: function(){
							targetWindow.document.detachEvent('onmousedown', mousedownListener);
							doc.detachEvent('onactivate', activateListener);
							doc.detachEvent('ondeactivate', deactivateListener);
							doc = null;	// prevent memory leak (apparent circular reference via closure)
						}
					};
				}else{
					doc.body.addEventListener('mousedown', mousedownListener, true);
					doc.body.addEventListener('touchstart', mousedownListener, true);
					var focusListener = function(evt){
						_this._onFocusNode(effectiveNode || evt.target);
					};
					doc.addEventListener('focus', focusListener, true);
					var blurListener = function(evt){
						_this._onBlurNode(effectiveNode || evt.target);
					};
					doc.addEventListener('blur', blurListener, true);

					return {
						remove: function(){
							doc.body.removeEventListener('mousedown', mousedownListener, true);
							doc.body.removeEventListener('touchstart', mousedownListener, true);
							doc.removeEventListener('focus', focusListener, true);
							doc.removeEventListener('blur', blurListener, true);
							doc = null;	// prevent memory leak (apparent circular reference via closure)
						}
					};
				}
			}
		},

		_onBlurNode: function(/*DomNode*/ /*===== node =====*/){
			// summary:
			// 		Called when focus leaves a node.
			//		Usually ignored, _unless_ it *isn't* followed by touching another node,
			//		which indicates that we tabbed off the last field on the page,
			//		in which case every widget is marked inactive
			this.set("prevNode", this.curNode);
			this.set("curNode", null);

			if(this._justMouseDowned){
				// the mouse down caused a new widget to be marked as active; this blur event
				// is coming late, so ignore it.
				return;
			}

			// if the blur event isn't followed by a focus event then mark all widgets as inactive.
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
			}
			this._clearActiveWidgetsTimer = setTimeout(lang.hitch(this, function(){
				delete this._clearActiveWidgetsTimer;
				this._setStack([]);
				this.prevNode = null;
			}), 100);
		},

		_onTouchNode: function(/*DomNode*/ node, /*String*/ by){
			// summary:
			//		Callback when node is focused or mouse-downed
			// node:
			//		The node that was touched.
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			// ignore the recent blurNode event
			if(this._clearActiveWidgetsTimer){
				clearTimeout(this._clearActiveWidgetsTimer);
				delete this._clearActiveWidgetsTimer;
			}

			// compute stack of active widgets (ex: ComboButton --> Menu --> MenuItem)
			var newStack=[];
			try{
				while(node){
					var popupParent = domAttr.get(node, "dijitPopupParent");
					if(popupParent){
						node=registry.byId(popupParent).domNode;
					}else if(node.tagName && node.tagName.toLowerCase() == "body"){
						// is this the root of the document or just the root of an iframe?
						if(node === win.body()){
							// node is the root of the main document
							break;
						}
						// otherwise, find the iframe this node refers to (can't access it via parentNode,
						// need to do this trick instead). window.frameElement is supported in IE/FF/Webkit
						node=winUtils.get(node.ownerDocument).frameElement;
					}else{
						// if this node is the root node of a widget, then add widget id to stack,
						// except ignore clicks on disabled widgets (actually focusing a disabled widget still works,
						// to support MenuItem)
						var id = node.getAttribute && node.getAttribute("widgetId"),
							widget = id && registry.byId(id);
						if(widget && !(by == "mouse" && widget.get("disabled"))){
							newStack.unshift(id);
						}
						node=node.parentNode;
					}
				}
			}catch(e){ /* squelch */ }

			this._setStack(newStack, by);
		},

		_onFocusNode: function(/*DomNode*/ node){
			// summary:
			//		Callback when node is focused

			if(!node){
				return;
			}

			if(node.nodeType == 9){
				// Ignore focus events on the document itself.  This is here so that
				// (for example) clicking the up/down arrows of a spinner
				// (which don't get focus) won't cause that widget to blur. (FF issue)
				return;
			}

			this._onTouchNode(node);

			if(node == this.curNode){ return; }
			this.set("curNode", node);
		},

		_setStack: function(/*String[]*/ newStack, /*String*/ by){
			// summary:
			//		The stack of active widgets has changed.  Send out appropriate events and records new stack.
			// newStack:
			//		array of widget id's, starting from the top (outermost) widget
			// by:
			//		"mouse" if the focus/touch was caused by a mouse down event

			var oldStack = this.activeStack;
			this.set("activeStack", newStack);

			// compare old stack to new stack to see how many elements they have in common
			for(var nCommon=0; nCommon<Math.min(oldStack.length, newStack.length); nCommon++){
				if(oldStack[nCommon] != newStack[nCommon]){
					break;
				}
			}

			var widget;
			// for all elements that have gone out of focus, set focused=false
			for(var i=oldStack.length-1; i>=nCommon; i--){
				widget = registry.byId(oldStack[i]);
				if(widget){
					widget._hasBeenBlurred = true;		// TODO: used by form widgets, should be moved there
					widget.set("focused", false);
					if(widget._focusManager == this){
						widget._onBlur(by);
					}
					this.emit("widget-blur", widget, by);
				}
			}

			// for all element that have come into focus, set focused=true
			for(i=nCommon; i<newStack.length; i++){
				widget = registry.byId(newStack[i]);
				if(widget){
					widget.set("focused", true);
					if(widget._focusManager == this){
						widget._onFocus(by);
					}
					this.emit("widget-focus", widget, by);
				}
			}
		},

		focus: function(node){
			// summary:
			//		Focus the specified node, suppressing errors if they occur
			if(node){
				try{ node.focus(); }catch(e){/*quiet*/}
			}
		}
	});

	var singleton = new FocusManager();

	// register top window and all the iframes it contains
	ready(function(){
		var handle = singleton.registerWin(win.doc.parentWindow || win.doc.defaultView);
		if(has("ie")){
			unload.addOnWindowUnload(function(){
				handle.remove();
				handle = null;
			})
		}
	});

	// Setup dijit.focus as a pointer to the singleton but also (for backwards compatibility)
	// as a function to set focus.
	dijit.focus = function(node){
		singleton.focus(node);	// indirection here allows dijit/_base/focus.js to override behavior
	};
	for(var attr in singleton){
		if(!/^_/.test(attr)){
			dijit.focus[attr] = typeof singleton[attr] == "function" ? lang.hitch(singleton, attr) : singleton[attr];
		}
	}
	singleton.watch(function(attr, oldVal, newVal){
		dijit.focus[attr] = newVal;
	});

	return singleton;
});

},
'dojo/i18n':function(){
define("dojo/i18n", ["./_base/kernel", "require", "./has", "./_base/array", "./_base/lang", "./_base/xhr"], function(dojo, require, has, array, lang) {
	// module:
	//		dojo/i18n
	// summary:
	//		This module implements the !dojo/i18n plugin and the v1.6- i18n API
	// description:
	//		We choose to include our own plugin to leverage functionality already contained in dojo
	//		and thereby reduce the size of the plugin compared to various loader implementations. Also, this
	//		allows foreign AMD loaders to be used without their plugins.
	var
		thisModule= dojo.i18n=
			// the dojo.i18n module
			{},

		nlsRe=
			// regexp for reconstructing the master bundle name from parts of the regexp match
			// nlsRe.exec("foo/bar/baz/nls/en-ca/foo") gives:
			// ["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]
			// nlsRe.exec("foo/bar/baz/nls/foo") gives:
			// ["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]
			// so, if match[5] is blank, it means this is the top bundle definition.
			// courtesy of http://requirejs.org
			/(^.*(^|\/)nls)(\/|$)([^\/]*)\/?([^\/]*)/,

		getAvailableLocales= function(
			root,
			locale,
			bundlePath,
			bundleName
		){
			// return a vector of module ids containing all available locales with respect to the target locale
			// For example, assuming:
			//	 * the root bundle indicates specific bundles for "fr" and "fr-ca",
			//	 * bundlePath is "myPackage/nls"
			//	 * bundleName is "myBundle"
			// Then a locale argument of "fr-ca" would return
			//	 ["myPackage/nls/myBundle", "myPackage/nls/fr/myBundle", "myPackage/nls/fr-ca/myBundle"]
			// Notice that bundles are returned least-specific to most-specific, starting with the root.
			//
			// If root===false indicates we're working with a pre-AMD i18n bundle that doesn't tell about the available locales;
			// therefore, assume everything is available and get 404 errors that indicate a particular localization is not available
			//

			for(var result= [bundlePath + bundleName], localeParts= locale.split("-"), current= "", i= 0; i<localeParts.length; i++){
				current+= (current ? "-" : "") + localeParts[i];
				if(!root || root[current]){
					result.push(bundlePath + current + "/" + bundleName);
				}
			}
			return result;
		},

		cache= {},

		getL10nName= dojo.getL10nName = function(moduleName, bundleName, locale){
			locale = locale ? locale.toLowerCase() : dojo.locale;
			moduleName = "dojo/i18n!" + moduleName.replace(/\./g, "/");
			bundleName = bundleName.replace(/\./g, "/");
			return (/root/i.test(locale)) ?
				(moduleName + "/nls/" + bundleName) :
				(moduleName + "/nls/" + locale + "/" + bundleName);
		},

		doLoad = function(require, bundlePathAndName, bundlePath, bundleName, locale, load){
			// get the root bundle which instructs which other bundles are required to contruct the localized bundle
			require([bundlePathAndName], function(root){
				var
					current= cache[bundlePathAndName + "/"]= lang.clone(root.root),
					availableLocales= getAvailableLocales(!root._v1x && root, locale, bundlePath, bundleName);
				require(availableLocales, function(){
					for (var i= 1; i<availableLocales.length; i++){
						cache[availableLocales[i]]= current= lang.mixin(lang.clone(current), arguments[i]);
					}
					// target may not have been resolve (e.g., maybe only "fr" exists when "fr-ca" was requested)
					var target= bundlePathAndName + "/" + locale;
					cache[target]= current;
					load && load(lang.delegate(current));
				});
			});
		},

		normalize = function(id, toAbsMid){
			// note: id may be relative
			var match= nlsRe.exec(id),
				bundlePath= match[1];
			return /^\./.test(bundlePath) ? toAbsMid(bundlePath) + "/" +  id.substring(bundlePath.length) : id;
		};

		load = function(id, require, load){
			// note: id is always absolute
			var
				match= nlsRe.exec(id),
				bundlePath= match[1] + "/",
				bundleName= match[5] || match[4],
				bundlePathAndName= bundlePath + bundleName,
				localeSpecified = (match[5] && match[4]),
				targetLocale=  localeSpecified || dojo.locale,
				target= bundlePathAndName + "/" + targetLocale;

			if(localeSpecified){
				if(cache[target]){
					// a request for a specific local that has already been loaded; just return it
					load(cache[target]);
				}else{
					// a request for a specific local that has not been loaded; load and return just that locale
					doLoad(require, bundlePathAndName, bundlePath, bundleName, targetLocale, load);
				}
				return;
			}// else a non-locale-specific request; therefore always load dojo.locale + dojo.config.extraLocale

			// notice the subtle algorithm that loads targeLocal last, which is the only doLoad application that passes a value for the load callback
			// this makes the sync loader follow a clean code path that loads extras first and then proceeds with tracing the current deps graph
			var extra = dojo.config.extraLocale || [];
			extra = lang.isArray(extra) ? extra : [extra];
			extra.push(targetLocale);
			array.forEach(extra, function(locale){
				doLoad(require, bundlePathAndName, bundlePath, bundleName, locale, locale==targetLocale && load);
			});
		};


	true || has.add("dojo-v1x-i18n-Api",
		// if true, define the v1.x i18n functions
		1
	);

	if(1){
		var
			evalBundle=
				// keep the minifiers off our define!
				// if bundle is an AMD bundle, then __amdResult will be defined; otherwise it's a pre-amd bundle and the bundle value is returned by eval
				new Function("bundle", "var __preAmdResult, __amdResult; function define(bundle){__amdResult= bundle;} __preAmdResult= eval(bundle); return [__preAmdResult, __amdResult];"),

			fixup= function(url, preAmdResult, amdResult){
				// nls/<locale>/<bundle-name> indicates not the root.
				return preAmdResult ? (/nls\/[^\/]+\/[^\/]+$/.test(url) ? preAmdResult : {root:preAmdResult, _v1x:1}) : amdResult;
			},

			syncRequire= function(deps, callback){
				var results= [];
				dojo.forEach(deps, function(mid){
					var url= require.toUrl(mid + ".js");
					if(cache[url]){
						results.push(cache[url]);
					}else{

						try {
							var bundle= require(mid);
							if(bundle){
								results.push(bundle);
								return;
							}
						}catch(e){}

						dojo.xhrGet({
							url:url,
							sync:true,
							load:function(text){
								var result = evalBundle(text);
								results.push(cache[url]= fixup(url, result[0], result[1]));
							},
							error:function(){
								results.push(cache[url]= {});
							}
						});
					}
				});
				callback.apply(null, results);
			};

		thisModule.getLocalization= function(moduleName, bundleName, locale){
			var result,
				l10nName= getL10nName(moduleName, bundleName, locale).substring(10);
			load(l10nName, (1 && !require.isXdUrl(require.toUrl(l10nName + ".js")) ? syncRequire : require), function(result_){ result= result_; });
			return result;
		};

		thisModule.normalizeLocale= function(locale){
			var result = locale ? locale.toLowerCase() : dojo.locale;
			if(result == "root"){
				result = "ROOT";
			}
			return result;
		};
	}

	return lang.mixin(thisModule, {
		dynamic:true,
		normalize:normalize,
		load:load,
		cache:function(mid, value){
			cache[mid] = value;
		}
	});
});

},
'dijit/hccss':function(){
define("dijit/hccss", [
	"require",			// require.toUrl
	"dojo/_base/config", // config.blankGif
	"dojo/dom-class", // domClass.add domConstruct.create domStyle.getComputedStyle
	"dojo/dom-construct", // domClass.add domConstruct.create domStyle.getComputedStyle
	"dojo/dom-style", // domClass.add domConstruct.create domStyle.getComputedStyle
	"dojo/ready", // ready
	"dojo/_base/sniff", // has("ie") has("mozilla")
	"dojo/_base/window" // win.body
], function(require, config, domClass, domConstruct, domStyle, ready, has, win){

	// module:
	//		dijit/hccss
	// summary:
	//		Test if computer is in high contrast mode, and sets dijit_a11y flag on <body> if it is.

	if(has("ie") || has("mozilla")){	// NOTE: checking in Safari messes things up
		// priority is 90 to run ahead of parser priority of 100
		ready(90, function(){
			// summary:
			//		Detects if we are in high-contrast mode or not

			// create div for testing if high contrast mode is on or images are turned off
			var div = domConstruct.create("div",{
				id: "a11yTestNode",
				style:{
					cssText:'border: 1px solid;'
						+ 'border-color:red green;'
						+ 'position: absolute;'
						+ 'height: 5px;'
						+ 'top: -999px;'
						+ 'background-image: url("' + (config.blankGif || require.toUrl("dojo/resources/blank.gif")) + '");'
				}
			}, win.body());

			// test it
			var cs = domStyle.getComputedStyle(div);
			if(cs){
				var bkImg = cs.backgroundImage;
				var needsA11y = (cs.borderTopColor == cs.borderRightColor) || (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)" ));
				if(needsA11y){
					domClass.add(win.body(), "dijit_a11y");
				}
				if(has("ie")){
					div.outerHTML = "";		// prevent mixed-content warning, see http://support.microsoft.com/kb/925014
				}else{
					win.body().removeChild(div);
				}
			}
		});
	}
});

},
'dijit/tree/ForestStoreModel':function(){
define("dijit/tree/ForestStoreModel", [
	"dojo/_base/array", // array.indexOf array.some
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.hitch
	"dojo/_base/window", // win.global
	"./TreeStoreModel"
], function(array, declare, lang, win, TreeStoreModel){

/*=====
var TreeStoreModel = dijit.tree.TreeStoreModel;
=====*/

// module:
//		dijit/tree/ForestStoreModel
// summary:
//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
//		a.k.a. a store that has multiple "top level" items.

return declare("dijit.tree.ForestStoreModel", TreeStoreModel, {
	// summary:
	//		Interface between a dijit.Tree and a dojo.data store that doesn't have a root item,
	//		a.k.a. a store that has multiple "top level" items.
	//
	// description
	//		Use this class to wrap a dojo.data store, making all the items matching the specified query
	//		appear as children of a fabricated "root item".  If no query is specified then all the
	//		items returned by fetch() on the underlying store become children of the root item.
	//		This class allows dijit.Tree to assume a single root item, even if the store doesn't have one.
	//
	//		When using this class the developer must override a number of methods according to their app and
	//		data, including:
	//			- onNewRootItem
	//			- onAddToRoot
	//			- onLeaveRoot
	//			- onNewItem
	//			- onSetItem

	// Parameters to constructor

	// rootId: String
	//		ID of fabricated root item
	rootId: "$root$",

	// rootLabel: String
	//		Label of fabricated root item
	rootLabel: "ROOT",

	// query: String
	//		Specifies the set of children of the root item.
	// example:
	//	|	{type:'continent'}
	query: null,

	// End of parameters to constructor

	constructor: function(params){
		// summary:
		//		Sets up variables, etc.
		// tags:
		//		private

		// Make dummy root item
		this.root = {
			store: this,
			root: true,
			id: params.rootId,
			label: params.rootLabel,
			children: params.rootChildren	// optional param
		};
	},

	// =======================================================================
	// Methods for traversing hierarchy

	mayHaveChildren: function(/*dojo.data.Item*/ item){
		// summary:
		//		Tells if an item has or may have children.  Implementing logic here
		//		avoids showing +/- expando icon for nodes that we know don't have children.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		extension
		return item === this.root || this.inherited(arguments);
	},

	getChildren: function(/*dojo.data.Item*/ parentItem, /*function(items)*/ callback, /*function*/ onError){
		// summary:
		// 		Calls onComplete() with array of child items of given parent item, all loaded.
		if(parentItem === this.root){
			if(this.root.children){
				// already loaded, just return
				callback(this.root.children);
			}else{
				this.store.fetch({
					query: this.query,
					onComplete: lang.hitch(this, function(items){
						this.root.children = items;
						callback(items);
					}),
					onError: onError
				});
			}
		}else{
			this.inherited(arguments);
		}
	},

	// =======================================================================
	// Inspecting items

	isItem: function(/* anything */ something){
		return (something === this.root) ? true : this.inherited(arguments);
	},

	fetchItemByIdentity: function(/* object */ keywordArgs){
		if(keywordArgs.identity == this.root.id){
			var scope = keywordArgs.scope?keywordArgs.scope:win.global;
			if(keywordArgs.onItem){
				keywordArgs.onItem.call(scope, this.root);
			}
		}else{
			this.inherited(arguments);
		}
	},

	getIdentity: function(/* item */ item){
		return (item === this.root) ? this.root.id : this.inherited(arguments);
	},

	getLabel: function(/* item */ item){
		return	(item === this.root) ? this.root.label : this.inherited(arguments);
	},

	// =======================================================================
	// Write interface

	newItem: function(/* dojo.dnd.Item */ args, /*Item*/ parent, /*int?*/ insertIndex){
		// summary:
		//		Creates a new item.   See dojo.data.api.Write for details on args.
		//		Used in drag & drop when item from external source dropped onto tree.
		if(parent === this.root){
			this.onNewRootItem(args);
			return this.store.newItem(args);
		}else{
			return this.inherited(arguments);
		}
	},

	onNewRootItem: function(/* dojo.dnd.Item */ /*===== args =====*/){
		// summary:
		//		User can override this method to modify a new element that's being
		//		added to the root of the tree, for example to add a flag like root=true
	},

	pasteItem: function(/*Item*/ childItem, /*Item*/ oldParentItem, /*Item*/ newParentItem, /*Boolean*/ bCopy, /*int?*/ insertIndex){
		// summary:
		//		Move or copy an item from one parent item to another.
		//		Used in drag & drop
		if(oldParentItem === this.root){
			if(!bCopy){
				// It's onLeaveRoot()'s responsibility to modify the item so it no longer matches
				// this.query... thus triggering an onChildrenChange() event to notify the Tree
				// that this element is no longer a child of the root node
				this.onLeaveRoot(childItem);
			}
		}
		this.inherited(arguments, [childItem,
			oldParentItem === this.root ? null : oldParentItem,
			newParentItem === this.root ? null : newParentItem,
			bCopy,
			insertIndex
		]);
		if(newParentItem === this.root){
			// It's onAddToRoot()'s responsibility to modify the item so it matches
			// this.query... thus triggering an onChildrenChange() event to notify the Tree
			// that this element is now a child of the root node
			this.onAddToRoot(childItem);
		}
	},

	// =======================================================================
	// Handling for top level children

	onAddToRoot: function(/* item */ item){
		// summary:
		//		Called when item added to root of tree; user must override this method
		//		to modify the item so that it matches the query for top level items
		// example:
		//	|	store.setValue(item, "root", true);
		// tags:
		//		extension
		console.log(this, ": item ", item, " added to root");
	},

	onLeaveRoot: function(/* item */ item){
		// summary:
		//		Called when item removed from root of tree; user must override this method
		//		to modify the item so it doesn't match the query for top level items
		// example:
		// 	|	store.unsetAttribute(item, "root");
		// tags:
		//		extension
		console.log(this, ": item ", item, " removed from root");
	},

	// =======================================================================
	// Events from data store

	_requeryTop: function(){
		// reruns the query for the children of the root node,
		// sending out an onSet notification if those children have changed
		var oldChildren = this.root.children || [];
		this.store.fetch({
			query: this.query,
			onComplete: lang.hitch(this, function(newChildren){
				this.root.children = newChildren;

				// If the list of children or the order of children has changed...
				if(oldChildren.length != newChildren.length ||
					array.some(oldChildren, function(item, idx){ return newChildren[idx] != item;})){
					this.onChildrenChange(this.root, newChildren);
				}
			})
		});
	},

	onNewItem: function(/* dojo.data.Item */ item, /* Object */ parentInfo){
		// summary:
		//		Handler for when new items appear in the store.  Developers should override this
		//		method to be more efficient based on their app/data.
		// description:
		//		Note that the default implementation requeries the top level items every time
		//		a new item is created, since any new item could be a top level item (even in
		//		addition to being a child of another item, since items can have multiple parents).
		//
		//		If developers can detect which items are possible top level items (based on the item and the
		//		parentInfo parameters), they should override this method to only call _requeryTop() for top
		//		level items.  Often all top level items have parentInfo==null, but
		//		that will depend on which store you use and what your data is like.
		// tags:
		//		extension
		this._requeryTop();

		this.inherited(arguments);
	},

	onDeleteItem: function(/*Object*/ item){
		// summary:
		//		Handler for delete notifications from underlying store

		// check if this was a child of root, and if so send notification that root's children
		// have changed
		if(array.indexOf(this.root.children, item) != -1){
			this._requeryTop();
		}

		this.inherited(arguments);
	},

	onSetItem: function(/* item */ item,
					/* attribute-name-string */ attribute,
					/* object | array */ oldValue,
					/* object | array */ newValue){
		// summary:
		//		Updates the tree view according to changes to an item in the data store.
		//		Developers should override this method to be more efficient based on their app/data.
		// description:
		//		Handles updates to an item's children by calling onChildrenChange(), and
		//		other updates to an item by calling onChange().
		//
		//		Also, any change to any item re-executes the query for the tree's top-level items,
		//		since this modified item may have started/stopped matching the query for top level items.
		//
		//		If possible, developers should override this function to only call _requeryTop() when
		//		the change to the item has caused it to stop/start being a top level item in the tree.
		// tags:
		//		extension

		this._requeryTop();
		this.inherited(arguments);
	}

});

});

},
'dojox/html/metrics':function(){
define("dojox/html/metrics", ["dojo/_base/kernel","dojo/_base/lang", "dojo/_base/sniff", "dojo/ready", "dojo/_base/unload",
		"dojo/_base/window", "dojo/dom-geometry"],
  function(kernel,lang,has,ready,UnloadUtil,Window,DOMGeom){
	var dhm = lang.getObject("dojox.html.metrics",true);
	var dojox = lang.getObject("dojox");

	//	derived from Morris John's emResized measurer
	dhm.getFontMeasurements = function(){
		//	summary
		//	Returns an object that has pixel equivilents of standard font size values.
		var heights = {
			'1em':0, '1ex':0, '100%':0, '12pt':0, '16px':0, 'xx-small':0, 'x-small':0,
			'small':0, 'medium':0, 'large':0, 'x-large':0, 'xx-large':0
		};
	
		if(has("ie")){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			Window.doc.documentElement.style.fontSize="100%";
		}
	
		//	set up the measuring node.
		var div=Window.doc.createElement("div");
		var ds = div.style;
		ds.position="absolute";
		ds.left="-100px";
		ds.top="0";
		ds.width="30px";
		ds.height="1000em";
		ds.borderWidth="0";
		ds.margin="0";
		ds.padding="0";
		ds.outline="0";
		ds.lineHeight="1";
		ds.overflow="hidden";
		Window.body().appendChild(div);
	
		//	do the measurements.
		for(var p in heights){
			ds.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}
		
		Window.body().removeChild(div);
		div = null;
		return heights; 	//	object
	};

	var fontMeasurements = null;
	
	dhm.getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = dhm.getFontMeasurements();
		}
		return fontMeasurements;
	};

	var measuringNode = null, empty = {};
	dhm.getTextBox = function(/* String */ text, /* Object */ style, /* String? */ className){
		var m, s;
		if(!measuringNode){
			m = measuringNode = Window.doc.createElement("div");
			// Container that we can set contraints on so that it doesn't
			// trigger a scrollbar.
			var c = Window.doc.createElement("div");
			c.appendChild(m);
			s = c.style;
			s.overflow='scroll';
			s.position = "absolute";
			s.left = "0px";
			s.top = "-10000px";
			s.width = "1px";
			s.height = "1px";
			s.visibility = "hidden";
			s.borderWidth = "0";
			s.margin = "0";
			s.padding = "0";
			s.outline = "0";
			Window.body().appendChild(c);
		}else{
			m = measuringNode;
		}
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(arguments.length > 1 && style){
			for(var i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(arguments.length > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;
		var box = DOMGeom.position(m);
		// position doesn't report right (reports 1, since parent is 1)
		// So we have to look at the scrollWidth to get the real width
		// Height is right.
		box.w = m.parentNode.scrollWidth;
		return box;
	};

	//	determine the scrollbar sizes on load.
	var scroll={ w:16, h:16 };
	dhm.getScrollbar=function(){ return { w:scroll.w, h:scroll.h }; };

	dhm._fontResizeNode = null;

	dhm.initOnFontResize = function(interval){
		var f = dhm._fontResizeNode = Window.doc.createElement("iframe");
		var fs = f.style;
		fs.position = "absolute";
		fs.width = "5em";
		fs.height = "10em";
		fs.top = "-10000px";
		if(has("ie")){
			f.onreadystatechange = function(){
				if(f.contentWindow.document.readyState == "complete"){
					f.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
				}
			};
		}else{
			f.onload = function(){
				f.contentWindow.onresize = f.contentWindow.parent[dojox._scopeName].html.metrics._fontresize;
			};
		}
		//The script tag is to work around a known firebug race condition.  See comments in bug #9046
		f.setAttribute("src", "javascript:'<html><head><script>if(\"loadFirebugConsole\" in window){window.loadFirebugConsole();}</script></head><body></body></html>'");
		Window.body().appendChild(f);
		dhm.initOnFontResize = function(){};
	};

	dhm.onFontResize = function(){};
	dhm._fontresize = function(){
		dhm.onFontResize();
	}

	UnloadUtil.addOnUnload(function(){
		// destroy our font resize iframe if we have one
		var f = dhm._fontResizeNode;
		if(f){
			if(has("ie") && f.onresize){
				f.onresize = null;
			}else if(f.contentWindow && f.contentWindow.onresize){
				f.contentWindow.onresize = null;
			}
			dhm._fontResizeNode = null;
		}
	});

	ready(function(){
		// getScrollbar metrics node
		try{
			var n=Window.doc.createElement("div");
			n.style.cssText = "top:0;left:0;width:100px;height:100px;overflow:scroll;position:absolute;visibility:hidden;";
			Window.body().appendChild(n);
			scroll.w = n.offsetWidth - n.clientWidth;
			scroll.h = n.offsetHeight - n.clientHeight;
			Window.body().removeChild(n);
			//console.log("Scroll bar dimensions: ", scroll);
			delete n;
		}catch(e){}

		// text size poll setup
		if("fontSizeWatch" in kernel.config && !!kernel.config.fontSizeWatch){
			dhm.initOnFontResize();
		}
	});
	return dhm;
});
},
'ibm/tivoli/tip/dijit/TIPMessageDialog':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/tip/dijit/nls/resources","dojo/require!dijit/_Widget,dijit/Dialog,dijit/form/CheckBox,ibm/tivoli/tip/dijit/TIPButton,dojo/i18n,dojox/layout/ResizeHandle"], function(dijit,dojo,dojox){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * (C) Copyright IBM Corp. 2007, 2008 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/

dojo.provide("ibm.tivoli.tip.dijit.TIPMessageDialog");
dojo.require("dijit._Widget");
dojo.require("dijit.Dialog"); 
dojo.require("dijit.form.CheckBox");
dojo.require("ibm.tivoli.tip.dijit.TIPButton");
dojo.require("dojo.i18n");
dojo.require("dojox.layout.ResizeHandle");

// NLS
dojo.requireLocalization("ibm.tivoli.tip.dijit", "resources");

// define the widget class
dojo.declare(
	"ibm.tivoli.tip.dijit.TIPMessageDialog", 
    [ dijit._Widget ],
{
    // resizeAxis: String
    //  x | xy | y to limit pane's sizing direction
    resizeAxis: "xy",

	// type: String: defines the type of message dialog ("Error", "Warning", "Info", "Confirm")
	type: "Error",
	
	// portlet title associated w/ this message
	portletTitle: null,

	// message: String: the displayable translated message
	message: null,

	// messageId: String: the displayable translated message's unique identifier
	messageId: null,
	
	// width: String: gives the pixel width of the dialog (Default: 500px)
	width: "380px",
	
	// height: String: gives the pixel height of the dialog (Default: 200px)
	height: "225px",
	
	// buttons: String Array: a list of buttons to display (Default: OK)
	buttons: [],
	
	// callback: Function: a callback function when the dialog is closed
	callback: null,
	
	// parameters to pass on callback when dialog closes
	callbackParms: null,
	
	// url: String: a URL that links the message to an InfoCenter page
	url: null,
	
	// show "Never show again checkbox"
	showCheckbox: false,
	
	// Destroy the dialog on close
	destroyOnClose: true,

	constructor: function() {
		// summary: An extension to the Dojo Dialog widget that supports 
		//      advanced features.
		// resourceMessages_: JSON
		//		Resource bundle.
		// dialog_: dojo.widget.FloatingPane
		//		An instance of the Dialog widget.
		// title_: String
		//		Title bar string.
		// icon_: String
		//		The dialog icon's uri.
		// buttonPressedId_: String
		//		The ID of the button pressed; this value is passed to the callback function.

	    this.resources_ = dojo.i18n.getLocalization("ibm.tivoli.tip.dijit", "resources");
	    
	    this.dialog_ = null;

	    this.title_ = null;
	    this.icon_ = null;
	    this.buttonPressedId_ = -1;
	},


	postCreate: function() { 
	    if (this.buttons.length === 0) {
	        this.buttons.push(this.resources_.DIALOG_BUTTON_OK);
	    }

		var className = null;
	    if (this.type.toLowerCase() == "error") {
	    	if (this.portletTitle) {
		    	this.title_ = dojo.string.substitute(this.resources_.MESSAGE_TITLE, { 0: this.resources_.DIALOG_ERROR, 1: this.portletTitle });
	    	} else {
		        this.title_ = this.resources_.DIALOG_ERROR;
		    }
	        this.icon_ = dojo.moduleUrl("ibm.tivoli.tip.dijit", "themes/images/i_message_critical.png");
	        className = "critical";
	    }
	    else if (this.type.toLowerCase() == "warning") {
	    	if (this.portletTitle) {
		    	this.title_ = dojo.string.substitute(this.resources_.MESSAGE_TITLE, { 0: this.resources_.DIALOG_WARNING, 1: this.portletTitle });
	    	} else {
		        this.title_ = this.resources_.DIALOG_WARNING;
		    }
	        this.icon_ = dojo.moduleUrl("ibm.tivoli.tip.dijit", "themes/images/i_message_warning.png");
	        className = "warning";
	    }
	    else if (this.type.toLowerCase() == "confirm") {
	    	if (this.portletTitle) {
		    	this.title_ = dojo.string.substitute(this.resources_.MESSAGE_TITLE, { 0: this.resources_.DIALOG_CONFIRM, 1: this.portletTitle });
	    	} else {
		        this.title_ = this.resources_.DIALOG_CONFIRM;
		    }
	        this.icon_ = dojo.moduleUrl("ibm.tivoli.tip.dijit", "themes/images/i_message_confirm.png");
	        className = "confirm";
	    }
	    else if (this.type.toLowerCase() == "validation") {
	    	if (this.portletTitle) {
		    	this.title_ = dojo.string.substitute(this.resources_.MESSAGE_TITLE, { 0: this.resources_.DIALOG_VALIDATION, 1: this.portletTitle });
	    	} else {
		        this.title_ = this.resources_.DIALOG_VALIDATION;
		    }
	        this.icon_ = dojo.moduleUrl("ibm.tivoli.tip.dijit", "themes/images/i_message_validation.png");
	        className = "validation";
	    }
	    else { // if (this.type.toLowerCase() == "info") {
	    	if (this.portletTitle) {
		    	this.title_ = dojo.string.substitute(this.resources_.MESSAGE_TITLE, { 0: this.resources_.DIALOG_INFO, 1: this.portletTitle });
	    	} else {
		        this.title_ = this.resources_.DIALOG_INFO;
		    }
	        this.icon_ = dojo.moduleUrl("ibm.tivoli.tip.dijit", "themes/images/i_message_info.png");
	        className = "info";
	    }
	    
		var div = document.createElement('div'); 
//		div.style.width = this.width; 
//		div.style.height = this.height;
        // The following div settings are needed to ensure the dialog is seen when the bottom frames
        // are rendered due to refresh or re-submit during error scenarios (see main_ruleset.jsp).
        // Without the settings, the bottom frame was overlaying the error message. 
		//div.style.top = 0; 
		//div.style.left = 0;
		document.body.appendChild(div);

        this.dialog_ = new dijit.Dialog (
			                             { title: this.title_
		                                 },
		                                 div); 

		var dojoAttachpoint = this.dialog_.containerNode;
		dojoAttachpoint.innerHTML = this.getContent(className);

        //Build and place resize handle       
        var resizeHandleDOM = dojo.doc.createElement( 'span' );
        resizeHandleDOM.className = "dojoxFloatingResizeHandle";    
        dojo.place( resizeHandleDOM, this.dialog_.domNode, "last" );
    
        this.resizeHandle = new dojox.layout.ResizeHandle(
        { 
              targetId: this.dialog_.id, 
            resizeAxis: this.resizeAxis 
        }, resizeHandleDOM );   
	
        this.dialog_.domNode.style.width = this.width;	
        this.dialog_.domNode.style.height = this.height;	
        //this.dialog_.containerNode.style.overflow="auto";
        this.dialog_.domNode.style.overflow = "hidden";        
    
		for (var i = 0; i < this.buttons.length; i++) {
			var button = dojo.byId(this.id + "mmd_button_" + i);
			dojo.connect(button, 'onclick', this, 'onClick');    
		}
    
        this.onCloseListener  = dojo.connect( this.dialog_, "hide", this, "_onHide" );
	  this.onResizeListener = dojo.connect( this.dialog_, "resize", this, "customLayout" );    
	},
	
    /**************************************************************************
    * The dialog has been hidden.  Wait 500 miliseconds to destroy the dialog.
    *
    * HACK -- Can't figure out a better way to destroy the dialog on close.
    **************************************************************************/
    _onHide:function()
    {
      setTimeout( dojo.hitch( this, "destroy" ), 500 );
    },  
	
	onClick: function(/* HTMLEvent */e) {
		var index = this.id.length + "mmd_button_".length;
		this.buttonPressedId_ = parseInt(e.target.id.substring(index), 0);
	    console.log ("TIPMessageDialog.onClick: buttonPressedId_: " + this.buttonPressedId_);
	    var checkbox = dojo.byId (this.id + "neverShowAgain");
	    var checked = checkbox ? checkbox.checked : false;

	    this.dialog_.hide();
	    
	    if (this.callback) {
	    	this.callback(this.buttonPressedId_, this.messageId, checked, this.callbackParms);
	    }
    },

	show: function() {
		this.dialog_.show();
		this.customLayout();
		this.correctPNG();

	},

      customLayout: function() 
      {
		console.debug( dojo.byId( this.id + '_messagediv' ) );
		console.debug( dojo.contentBox( this.dialog_.domNode ) );
		
		var messageDiv = dojo.byId( this.id + '_messagediv' );
		var dialogSize = dojo.contentBox( this.dialog_.domNode );

		var titleBarSize = dojo.contentBox( this.dialog_.titleBar );

		var newSize = {w:0,h:0};

		newSize.w = dialogSize.w - 75;
		if (this.showCheckbox === true) {
			var neverShowCoords = dojo.coords (this.id + "neverShowAgain");
			newSize.h = dialogSize.h - titleBarSize.h - neverShowCoords.h - 90;
		} else {		
			newSize.h = dialogSize.h - titleBarSize.h - 90;
		}

	    dojo.contentBox( messageDiv, newSize );
	},
	
	getContent: function(className) {
		var innerHTML = "";

		innerHTML += "<table class=\"" + className + "\">";
		innerHTML += "<tr valign=\"top\">";
		innerHTML += "<td>";

		innerHTML += "<table>";
		innerHTML += "<tr>";
		innerHTML += "<td rowspan=\"2\">";
		innerHTML += "&nbsp;";
		innerHTML += "<img align=\"middle\" src=\"" + this.icon_ + "\"/>";
		innerHTML += "&nbsp;&nbsp;";
		innerHTML += "</td>";
		if(document.body.dir != "rtl")
			innerHTML += "<td class=\"message-id\" align=\"left\" style=\"display:none\">";  //remove link to lookup message in InfoCenter
		else
			innerHTML += "<td class=\"message-id\" align=\"right\" style=\"display:none\"  >";
		
		/* new code
		 * 1) id added
		 * 2) url (if present) put into href
		 * 3) custom handler can be connected to onclick event
		 */
		innerHTML +="<a href=\"" 
		if(this.url){
			innerHTML += this.url;
		}
		else{
			innerHTML += "javascript:void(0)";
		}
		innerHTML += "\" id=\"" + this.id + "_" + this.messageId +"\">";
		innerHTML += this.messageId;
		innerHTML += "</a>";

		/* original TIP code
		if (this.url) {
			//innerHTML += '<a href="javascript:void(0)" onclick="window.open(\'' + this.url + '\')">';			
			innerHTML +="<a href=\"javascript:void(0)\" id=\"" + this.messageId +"\">";
			innerHTML += this.messageId;
			innerHTML += "</a>";
		}
		else {
			innerHTML += this.messageId;
		}
		*/
		innerHTML += "</td>";
		innerHTML += "</tr>";
		innerHTML += "<tr>";
		if(document.body.dir != "rtl")
		   innerHTML += "<td class=\"message-description\" align=\"left\">";
      else
		   innerHTML += "<td class=\"message-description\" align=\"right\">";

		innerHTML += "<div id='" + this.id + "_messagediv" + "' style='overflow:auto; width:100%;'>";
		innerHTML += "<p>";
		innerHTML += this.message;
		innerHTML += "</p>";
		innerHTML += "</div>";
		innerHTML += "</td>";
		innerHTML += "</tr>";
		innerHTML += "</table>";

		innerHTML += "</td>";
		innerHTML += "</tr>";

		if (this.showCheckbox === true) {
			innerHTML += "<tr>";
			innerHTML += "<td class=\"checkbox\" valign=\"bottom\">";
			innerHTML += "&nbsp;&nbsp;&nbsp;<input type=\"checkbox\" dojoType=\"dijit.form.CheckBox\" id=\"" + this.id + "neverShowAgain\"/><label for=\"" + this.id + "neverShowAgain\">" + this.resources_.NEVER_SHOW + "</label>";
			innerHTML += "</td>";
			innerHTML += "</tr>";
		}

		innerHTML += "<tr>";
		innerHTML += "<td valign=\"bottom\">";

		innerHTML += "<div>";
		innerHTML += "<table width='100%'>";
		innerHTML += "<tr>";
		innerHTML += "<td valign=\"bottom\">";
		if(document.body.dir != "rtl")
			innerHTML += "<div align=\"left\">";
		else
			innerHTML += "<div align=\"right\">";
		for (var i = 0; i < this.buttons.length; i++) {
			innerHTML += "&nbsp;<button dojoType=\"ibm.tivoli.tip.dijit.TIPButton\" id=\"" + this.id + "mmd_button_" + i + "\" value=\"" + this.buttons[i] + "\">";
			innerHTML += this.buttons[i] + "</button>";
		}
		innerHTML += "</td>";
		innerHTML += "</tr>";
		innerHTML += "</table>";
		innerHTML += "</div>";

		innerHTML += "</td>";
		innerHTML += "</tr>";
		innerHTML += "</table>";

		return innerHTML;
	},
	
	// correctly handle PNG transparency in Win IE 5.5 & 6.
	correctPNG: function() {
		var arVersion = navigator.appVersion.split("MSIE");
		var version = parseFloat(arVersion[1]);
		if ((version >= 5.5) && document.body.filters) {
			for (var i = 0; i < document.images.length; i++) {
				var img = document.images[i];
				var imgName = img.src.toUpperCase();
				if (imgName.substring(imgName.length-3, imgName.length) == "PNG") {
					var imgID = img.id ? "id='" + img.id + "' " : "";
					var imgClass = img.className ? "class='" + img.className + "' " : "";
					var imgTitle = img.title ? "title='" + img.title + "' " : "title='" + img.alt + "' ";
					var imgStyle = "display:inline-block;" + img.style.cssText;
					if (img.align == "left") {
						imgStyle = "float:left;" + imgStyle;
					}
					if (img.align == "right") {
						imgStyle = "float:right;" + imgStyle;
					}
					if (img.parentElement.href) {
						imgStyle = "cursor:hand;" + imgStyle;
					}
					var strNewHTML = "<span " + imgID + imgClass + imgTitle +
									 " style=\"" + "width:" + img.width + "px; height:" + img.height + "px;" + imgStyle + ";" +
									 "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader" +
									 "(src=\'" + img.src + "\', sizingMethod='scale');\"></span>";
					img.outerHTML = strNewHTML;
					i = i - 1;
				}
			}
		}    
	},
	
	destroy: function () {
        dojo.disconnect( this.onCloseListener );
        dojo.disconnect( this.onResizeListener );
        
        //TODO:  The fact this can NOT be called means we have not created the widget correctly
        //       This widget should directly extend dialog to be created correctly
        //this.inherited( "destroy", arguments );
        
        if ( this.dialog_ ) { this.dialog_.destroy(); dijit.registry.remove (this.dialog_.id); delete this.dialog_; }
        
		if (dijit.byId (this.id + "neverShowAgain")) {
			dijit.registry.remove (this.id + "neverShowAgain");
		}

		for (var i = 0; i < this.buttons.length; i++) {
			dijit.registry.remove (this.id + "mmd_button_" + i);
		}

		delete this.type;
		delete this.message;
		delete this.messageId;
		delete this.width;
		delete this.height;
		delete this.buttons;
		delete this.callbackParms;
		delete this.url;
		delete this.showCheckbox;
		delete this.destroyOnClose;
		delete this.title_;
		delete this.icon_;
		delete this.resources_;

		dijit.registry.remove (this.id);
	}

});



});

},
'dijit/form/_ComboBoxMenuMixin':function(){
define("dijit/form/_ComboBoxMenuMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/window", // win.doc.createTextNode
	"dojo/i18n!./nls/ComboBox"
], function(array, declare, domAttr, i18n, win){

// module:
//		dijit/form/_ComboBoxMenuMixin
// summary:
//		Focus-less menu for internal use in `dijit.form.ComboBox`

return declare( "dijit.form._ComboBoxMenuMixin", null, {
	// summary:
	//		Focus-less menu for internal use in `dijit.form.ComboBox`
	// tags:
	//		private

	// _messages: Object
	//		Holds "next" and "previous" text for paging buttons on drop down
	_messages: null,

	postMixInProperties: function(){
		this.inherited(arguments);
		this._messages = i18n.getLocalization("dijit.form", "ComboBox", this.lang);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// fill in template with i18n messages
		this.previousButton.innerHTML = this._messages["previousMessage"];
		this.nextButton.innerHTML = this._messages["nextMessage"];
	},

	_setValueAttr: function(/*Object*/ value){
		this.value = value;
		this.onChange(value);
	},

	onClick: function(/*DomNode*/ node){
		if(node == this.previousButton){
			this._setSelectedAttr(null);
			this.onPage(-1);
		}else if(node == this.nextButton){
			this._setSelectedAttr(null);
			this.onPage(1);
		}else{
			this.onChange(node);
		}
	},

	// stubs
	onChange: function(/*Number*/ /*===== direction =====*/){
		// summary:
		//		Notifies ComboBox/FilteringSelect that user selected an option.
		// tags:
		//		callback
	},

	onPage: function(/*Number*/ /*===== direction =====*/){
		// summary:
		//		Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.
		// tags:
		//		callback
	},

	onClose: function(){
		// summary:
		//		Callback from dijit.popup code to this widget, notifying it that it closed
		// tags:
		//		private
		this._setSelectedAttr(null);
	},

	_createOption: function(/*Object*/ item, labelFunc){
		// summary:
		//		Creates an option to appear on the popup menu subclassed by
		//		`dijit.form.FilteringSelect`.

		var menuitem = this._createMenuItem();
		var labelObject = labelFunc(item);
		if(labelObject.html){
			menuitem.innerHTML = labelObject.label;
		}else{
			menuitem.appendChild(
				win.doc.createTextNode(labelObject.label)
			);
		}
		// #3250: in blank options, assign a normal height
		if(menuitem.innerHTML == ""){
			menuitem.innerHTML = "&#160;";	// &nbsp;
		}

		// update menuitem.dir if BidiSupport was required
		this.applyTextDir(menuitem, (menuitem.innerText || menuitem.textContent || ""));

		menuitem.item=item;
		return menuitem;
	},

	createOptions: function(results, options, labelFunc){
		// summary:
		//		Fills in the items in the drop down list
		// results:
		//		Array of items
		// options:
		//		The options to the query function of the store
		//
		// labelFunc:
		//		Function to produce a label in the drop down list from a dojo.data item

		// display "Previous . . ." button
		this.previousButton.style.display = (options.start == 0) ? "none" : "";
		domAttr.set(this.previousButton, "id", this.id + "_prev");
		// create options using _createOption function defined by parent
		// ComboBox (or FilteringSelect) class
		// #2309:
		//		iterate over cache nondestructively
		array.forEach(results, function(item, i){
			var menuitem = this._createOption(item, labelFunc);
			domAttr.set(menuitem, "id", this.id + i);
			this.nextButton.parentNode.insertBefore(menuitem, this.nextButton);
		}, this);
		// display "Next . . ." button
		var displayMore = false;
		// Try to determine if we should show 'more'...
		if(results.total && !results.total.then && results.total != -1){
			if((options.start + options.count) < results.total){
				displayMore = true;
			}else if((options.start + options.count) > results.total && options.count == results.length){
				// Weird return from a data store, where a start + count > maxOptions
				// implies maxOptions isn't really valid and we have to go into faking it.
				// And more or less assume more if count == results.length
				displayMore = true;
			}
		}else if(options.count == results.length){
			//Don't know the size, so we do the best we can based off count alone.
			//So, if we have an exact match to count, assume more.
			displayMore = true;
		}

		this.nextButton.style.display = displayMore ? "" : "none";
		domAttr.set(this.nextButton,"id", this.id + "_next");
		return this.containerNode.childNodes;
	},

	clearResultList: function(){
		// summary:
		//		Clears the entries in the drop down list, but of course keeps the previous and next buttons.
		var container = this.containerNode;
		while(container.childNodes.length > 2){
			container.removeChild(container.childNodes[container.childNodes.length-2]);
		}
		this._setSelectedAttr(null);
	},

	highlightFirstOption: function(){
		// summary:
		//		Highlight the first real item in the list (not Previous Choices).
		this.selectFirstNode();
	},

	highlightLastOption: function(){
		// summary:
		//		Highlight the last real item in the list (not More Choices).
		this.selectLastNode();
	},

	selectFirstNode: function(){
		this.inherited(arguments);
		if(this.getHighlightedOption() == this.previousButton){
			this.selectNextNode();
		}
	},

	selectLastNode: function(){
		this.inherited(arguments);
		if(this.getHighlightedOption() == this.nextButton){
			this.selectPreviousNode();
		}
	},

	getHighlightedOption: function(){
		return this._getSelectedAttr();
	}
});

});

},
'dojo/parser':function(){
define(
	"dojo/parser", ["./_base/kernel", "./_base/lang", "./_base/array", "./_base/html", "./_base/window", "./_base/url",
		"./_base/json", "./aspect", "./date/stamp", "./query", "./on", "./ready"],
	function(dojo, dlang, darray, dhtml, dwindow, _Url, djson, aspect, dates, query, don){

// module:
//		dojo/parser
// summary:
//		The Dom/Widget parsing package

new Date("X"); // workaround for #11279, new Date("") == NaN

var features = {
	// Feature detection for when node.attributes only lists the attributes specified in the markup
	// rather than old IE/quirks behavior where it lists every default value too
	"dom-attributes-explicit": document.createElement("div").attributes.length < 40
};
function has(feature){
	return features[feature];
}


dojo.parser = new function(){
	// summary:
	//		The Dom/Widget parsing package

	var _nameMap = {
		// Map from widget name (ex: "dijit.form.Button") to structure mapping
		// lowercase version of attribute names to the version in the widget ex:
		//	{
		//		label: "label",
		//		onclick: "onClick"
		//	}
	};
	function getNameMap(proto){
		// summary:
		//		Returns map from lowercase name to attribute name in class, ex: {onclick: "onClick"}
		var map = {};
		for(var name in proto){
			if(name.charAt(0)=="_"){ continue; }	// skip internal properties
			map[name.toLowerCase()] = name;
		}
		return map;
	}
	// Widgets like BorderContainer add properties to _Widget via dojo.extend().
	// If BorderContainer is loaded after _Widget's parameter list has been cached,
	// we need to refresh that parameter list (for _Widget and all widgets that extend _Widget).
	aspect.after(dlang, "extend", function(){
		_nameMap = {};
	}, true);

	// Map from widget name (ex: "dijit.form.Button") to constructor
	var _ctorMap = {};

	this._functionFromScript = function(script, attrData){
		// summary:
		//		Convert a <script type="dojo/method" args="a, b, c"> ... </script>
		//		into a function
		// script: DOMNode
		//		The <script> DOMNode
		// attrData: String
		//		For HTML5 compliance, searches for attrData + "args" (typically
		//		"data-dojo-args") instead of "args"
		var preamble = "";
		var suffix = "";
		var argsStr = (script.getAttribute(attrData + "args") || script.getAttribute("args"));
		if(argsStr){
			darray.forEach(argsStr.split(/\s*,\s*/), function(part, idx){
				preamble += "var "+part+" = arguments["+idx+"]; ";
			});
		}
		var withStr = script.getAttribute("with");
		if(withStr && withStr.length){
			darray.forEach(withStr.split(/\s*,\s*/), function(part){
				preamble += "with("+part+"){";
				suffix += "}";
			});
		}
		return new Function(preamble+script.innerHTML+suffix);
	};

	this.instantiate = /*====== dojo.parser.instantiate= ======*/function(nodes, mixin, args){
		// summary:
		//		Takes array of nodes, and turns them into class instances and
		//		potentially calls a startup method to allow them to connect with
		//		any children.
		// nodes: Array
		//		Array of nodes or objects like
		//	|		{
		//	|			type: "dijit.form.Button",
		//	|			node: DOMNode,
		//	|			scripts: [ ... ],	// array of <script type="dojo/..."> children of node
		//	|			inherited: { ... }	// settings inherited from ancestors like dir, theme, etc.
		//	|		}
		// mixin: Object?
		//		An object that will be mixed in with each node in the array.
		//		Values in the mixin will override values in the node, if they
		//		exist.
		// args: Object?
		//		An object used to hold kwArgs for instantiation.
		//		See parse.args argument for details.

		var thelist = [],
		mixin = mixin||{};
		args = args||{};

		// Precompute names of special attributes we are looking for
		// TODO: for 2.0 default to data-dojo- regardless of scopeName (or maybe scopeName won't exist in 2.0)
		var dojoType = (args.scope || dojo._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (args.scope || dojo._scopeName) + "-",// typically "data-dojo-"
			dataDojoType = attrData + "type",						// typically "data-dojo-type"
			dataDojoProps = attrData + "props",						// typically "data-dojo-props"
			dataDojoAttachPoint = attrData + "attach-point",
			dataDojoAttachEvent = attrData + "attach-event",
			dataDojoId = attrData + "id";

		// And make hash to quickly check if a given attribute is special, and to map the name to something friendly
		var specialAttrs = {};
		darray.forEach([dataDojoProps, dataDojoType, dojoType, dataDojoId, "jsId", dataDojoAttachPoint,
				dataDojoAttachEvent, "dojoAttachPoint", "dojoAttachEvent", "class", "style"], function(name){
			specialAttrs[name.toLowerCase()] = name.replace(args.scope, "dojo");
		});

		darray.forEach(nodes, function(obj){
			if(!obj){ return; }

			var node = obj.node || obj,
				type = dojoType in mixin ? mixin[dojoType] : obj.node ? obj.type : (node.getAttribute(dataDojoType) || node.getAttribute(dojoType)),
				ctor = _ctorMap[type] || (_ctorMap[type] = dlang.getObject(type)),
				proto = ctor && ctor.prototype;
			if(!ctor){
				throw new Error("Could not load class '" + type);
			}

			// Setup hash to hold parameter settings for this widget.	Start with the parameter
			// settings inherited from ancestors ("dir" and "lang").
			// Inherited setting may later be overridden by explicit settings on node itself.
			var params = {};

			if(args.defaults){
				// settings for the document itself (or whatever subtree is being parsed)
				dlang.mixin(params, args.defaults);
			}
			if(obj.inherited){
				// settings from dir=rtl or lang=... on a node above this node
				dlang.mixin(params, obj.inherited);
			}

			// Get list of attributes explicitly listed in the markup
			var attributes;
			if(has("dom-attributes-explicit")){
				// Standard path to get list of user specified attributes
				attributes = node.attributes;
			}else{
				// Special path for IE, avoid (sometimes >100) bogus entries in node.attributes
				var clone = /^input$|^img$/i.test(node.nodeName) ? node : node.cloneNode(false),
					attrs = clone.outerHTML.replace(/=[^\s"']+|="[^"]*"|='[^']*'/g, "").replace(/^\s*<[a-zA-Z0-9]*/, "").replace(/>.*$/, "");

				attributes = darray.map(attrs.split(/\s+/), function(name){
					var lcName = name.toLowerCase();
					return {
						name: name,
						// getAttribute() doesn't work for button.value, returns innerHTML of button.
						// but getAttributeNode().value doesn't work for the form.encType or li.value
						value: (node.nodeName == "LI" && name == "value") || lcName == "enctype" ?
								node.getAttribute(lcName) : node.getAttributeNode(lcName).value,
						specified: true
					};
				});
			}

			// Read in attributes and process them, including data-dojo-props, data-dojo-type,
			// dojoAttachPoint, etc., as well as normal foo=bar attributes.
			var i=0, item;
			while(item = attributes[i++]){
				if(!item || !item.specified){
					continue;
				}

				var name = item.name,
					lcName = name.toLowerCase(),
					value = item.value;

				if(lcName in specialAttrs){
					switch(specialAttrs[lcName]){

					// Data-dojo-props.   Save for later to make sure it overrides direct foo=bar settings
					case "data-dojo-props":
						var extra = value;
						break;

					// data-dojo-id or jsId. TODO: drop jsId in 2.0
					case "data-dojo-id":
					case "jsId":
						var jsname = value;
						break;

					// For the benefit of _Templated
					case "data-dojo-attach-point":
					case "dojoAttachPoint":
						params.dojoAttachPoint = value;
						break;
					case "data-dojo-attach-event":
					case "dojoAttachEvent":
						params.dojoAttachEvent = value;
						break;

					// Special parameter handling needed for IE
					case "class":
						params["class"] = node.className;
						break;
					case "style":
						params["style"] = node.style && node.style.cssText;
						break;
					}
				}else{
					// Normal attribute, ex: value="123"

					// Find attribute in widget corresponding to specified name.
					// May involve case conversion, ex: onclick --> onClick
					if(!(name in proto)){
						var map = (_nameMap[type] || (_nameMap[type] = getNameMap(proto)));
						name = map[lcName] || name;
					}

					// Set params[name] to value, doing type conversion
					if(name in proto){
						switch(typeof proto[name]){
						case "string":
							params[name] = value;
							break;
						case "number":
							params[name] = value.length ? Number(value) : NaN;
							break;
						case "boolean":
							// for checked/disabled value might be "" or "checked".	 interpret as true.
							params[name] = value.toLowerCase() != "false";
							break;
						case "function":
							if(value === "" || value.search(/[^\w\.]+/i) != -1){
								// The user has specified some text for a function like "return x+5"
								params[name] = new Function(value);
							}else{
								// The user has specified the name of a function like "myOnClick"
								// or a single word function "return"
								params[name] = dlang.getObject(value, false) || new Function(value);
							}
							break;
						default:
							var pVal = proto[name];
							params[name] =
								(pVal && "length" in pVal) ? (value ? value.split(/\s*,\s*/) : []) :	// array
									(pVal instanceof Date) ?
										(value == "" ? new Date("") :	// the NaN of dates
										value == "now" ? new Date() :	// current date
										dates.fromISOString(value)) :
								(pVal instanceof dojo._Url) ? (dojo.baseUrl + value) :
								djson.fromJson(value);
						}
					}else{
						params[name] = value;
					}
				}
			}

			// Mix things found in data-dojo-props into the params, overriding any direct settings
			if(extra){
				try{
					extra = djson.fromJson.call(args.propsThis, "{" + extra + "}");
					dlang.mixin(params, extra);
				}catch(e){
					// give the user a pointer to their invalid parameters. FIXME: can we kill this in production?
					throw new Error(e.toString() + " in data-dojo-props='" + extra + "'");
				}
			}

			// Any parameters specified in "mixin" override everything else.
			dlang.mixin(params, mixin);

			var scripts = obj.node ? obj.scripts : (ctor && (ctor._noScript || proto._noScript) ? [] :
						query("> script[type^='dojo/']", node));

			// Process <script type="dojo/*"> script tags
			// <script type="dojo/method" event="foo"> tags are added to params, and passed to
			// the widget on instantiation.
			// <script type="dojo/method"> tags (with no event) are executed after instantiation
			// <script type="dojo/connect" data-dojo-event="foo"> tags are dojo.connected after instantiation
			// <script type="dojo/watch" data-dojo-prop="foo"> tags are dojo.watch after instantiation
			// <script type="dojo/on" data-dojo-event="foo"> tags are dojo.on after instantiation
			// note: dojo/* script tags cannot exist in self closing widgets, like <input />
			var connects = [],	// functions to connect after instantiation
				calls = [],		// functions to call after instantiation
				watch = [],  //functions to watch after instantiation
				on = []; //functions to on after instantiation

			if(scripts){
				for(i=0; i<scripts.length; i++){
					var script = scripts[i];
					node.removeChild(script);
					// FIXME: drop event="" support in 2.0. use data-dojo-event="" instead
					var event = (script.getAttribute(attrData + "event") || script.getAttribute("event")),
						prop = script.getAttribute(attrData + "prop"),
						type = script.getAttribute("type"),
						nf = this._functionFromScript(script, attrData);
					if(event){
						if(type == "dojo/connect"){
							connects.push({event: event, func: nf});
						}else if(type == "dojo/on"){
							on.push({event: event, func: nf});
						}else{
							params[event] = nf;
						}
					}else if(type == "dojo/watch"){
						watch.push({prop: prop, func: nf});
					}else{
						calls.push(nf);
					}
				}
			}

			// create the instance
			var markupFactory = ctor.markupFactory || proto.markupFactory;
			var instance = markupFactory ? markupFactory(params, node, ctor) : new ctor(params, node);
			thelist.push(instance);

			// map it to the JS namespace if that makes sense
			if(jsname){
				dlang.setObject(jsname, instance);
			}

			// process connections and startup functions
			for(i=0; i<connects.length; i++){
				aspect.after(instance, connects[i].event, dojo.hitch(instance, connects[i].func), true);
			}
			for(i=0; i<calls.length; i++){
				calls[i].call(instance);
			}
			for(i=0; i<watch.length; i++){
				instance.watch(watch[i].prop, watch[i].func);
			}
			for(i=0; i<on.length; i++){
				don(instance, on[i].event, on[i].func);
			}
		}, this);

		// Call startup on each top level instance if it makes sense (as for
		// widgets).  Parent widgets will recursively call startup on their
		// (non-top level) children
		if(!mixin._started){
			darray.forEach(thelist, function(instance){
				if( !args.noStart && instance  &&
					dlang.isFunction(instance.startup) &&
					!instance._started
				){
					instance.startup();
				}
			});
		}
		return thelist;
	};

	this.parse = /*====== dojo.parser.parse= ======*/ function(rootNode, args){
		// summary:
		//		Scan the DOM for class instances, and instantiate them.
		//
		// description:
		//		Search specified node (or root node) recursively for class instances,
		//		and instantiate them. Searches for either data-dojo-type="Class" or
		//		dojoType="Class" where "Class" is a a fully qualified class name,
		//		like `dijit.form.Button`
		//
		//		Using `data-dojo-type`:
		//		Attributes using can be mixed into the parameters used to instantiate the
		//		Class by using a `data-dojo-props` attribute on the node being converted.
		//		`data-dojo-props` should be a string attribute to be converted from JSON.
		//
		//		Using `dojoType`:
		//		Attributes are read from the original domNode and converted to appropriate
		//		types by looking up the Class prototype values. This is the default behavior
		//		from Dojo 1.0 to Dojo 1.5. `dojoType` support is deprecated, and will
		//		go away in Dojo 2.0.
		//
		// rootNode: DomNode?
		//		A default starting root node from which to start the parsing. Can be
		//		omitted, defaulting to the entire document. If omitted, the `args`
		//		object can be passed in this place. If the `args` object has a
		//		`rootNode` member, that is used.
		//
		// args: Object
		//		a kwArgs object passed along to instantiate()
		//
		//			* noStart: Boolean?
		//				when set will prevent the parser from calling .startup()
		//				when locating the nodes.
		//			* rootNode: DomNode?
		//				identical to the function's `rootNode` argument, though
		//				allowed to be passed in via this `args object.
		//			* template: Boolean
		//				If true, ignores ContentPane's stopParser flag and parses contents inside of
		//				a ContentPane inside of a template.   This allows dojoAttachPoint on widgets/nodes
		//				nested inside the ContentPane to work.
		//			* inherited: Object
		//				Hash possibly containing dir and lang settings to be applied to
		//				parsed widgets, unless there's another setting on a sub-node that overrides
		//			* scope: String
		//				Root for attribute names to search for.   If scopeName is dojo,
		//				will search for data-dojo-type (or dojoType).   For backwards compatibility
		//				reasons defaults to dojo._scopeName (which is "dojo" except when
		//				multi-version support is used, when it will be something like dojo16, dojo20, etc.)
		//			* propsThis: Object
		//				If specified, "this" referenced from data-dojo-props will refer to propsThis.
		//				Intended for use from the widgets-in-template feature of `dijit._WidgetsInTemplateMixin`
		//
		// example:
		//		Parse all widgets on a page:
		//	|		dojo.parser.parse();
		//
		// example:
		//		Parse all classes within the node with id="foo"
		//	|		dojo.parser.parse(dojo.byId('foo'));
		//
		// example:
		//		Parse all classes in a page, but do not call .startup() on any
		//		child
		//	|		dojo.parser.parse({ noStart: true })
		//
		// example:
		//		Parse all classes in a node, but do not call .startup()
		//	|		dojo.parser.parse(someNode, { noStart:true });
		//	|		// or
		//	|		dojo.parser.parse({ noStart:true, rootNode: someNode });

		// determine the root node based on the passed arguments.
		var root;
		if(!args && rootNode && rootNode.rootNode){
			args = rootNode;
			root = args.rootNode;
		}else{
			root = rootNode;
		}
		root = root ? dhtml.byId(root) : dwindow.body();
		args = args || {};

		var dojoType = (args.scope || dojo._scopeName) + "Type",		// typically "dojoType"
			attrData = "data-" + (args.scope || dojo._scopeName) + "-",	// typically "data-dojo-"
			dataDojoType = attrData + "type",						// typically "data-dojo-type"
			dataDojoTextDir = attrData + "textdir";					// typically "data-dojo-textdir"

		// List of all nodes on page w/dojoType specified
		var list = [];

		// Info on DOMNode currently being processed
		var node = root.firstChild;

		// Info on parent of DOMNode currently being processed
		//	- inherited: dir, lang, and textDir setting of parent, or inherited by parent
		//	- parent: pointer to identical structure for my parent (or null if no parent)
		//	- scripts: if specified, collects <script type="dojo/..."> type nodes from children
		var inherited = args && args.inherited;
		if(!inherited){
			function findAncestorAttr(node, attr){
				return (node.getAttribute && node.getAttribute(attr)) ||
					(node !== dwindow.doc && node !== dwindow.doc.documentElement && node.parentNode ? findAncestorAttr(node.parentNode, attr) : null);
			}
			inherited = {
				dir: findAncestorAttr(root, "dir"),
				lang: findAncestorAttr(root, "lang"),
				textDir: findAncestorAttr(root, dataDojoTextDir)
			};
			for(var key in inherited){
				if(!inherited[key]){ delete inherited[key]; }
			}
		}
		var parent = {
			inherited: inherited
		};

		// For collecting <script type="dojo/..."> type nodes (when null, we don't need to collect)
		var scripts;

		// when true, only look for <script type="dojo/..."> tags, and don't recurse to children
		var scriptsOnly;

		function getEffective(parent){
			// summary:
			//		Get effective dir, lang, textDir settings for specified obj
			//		(matching "parent" object structure above), and do caching.
			//		Take care not to return null entries.
			if(!parent.inherited){
				parent.inherited = {};
				var node = parent.node,
					grandparent = getEffective(parent.parent);
				var inherited  = {
					dir: node.getAttribute("dir") || grandparent.dir,
					lang: node.getAttribute("lang") || grandparent.lang,
					textDir: node.getAttribute(dataDojoTextDir) || grandparent.textDir
				};
				for(var key in inherited){
					if(inherited[key]){
						parent.inherited[key] = inherited[key];
					}
				}
			}
			return parent.inherited;
		}

		// DFS on DOM tree, collecting nodes with data-dojo-type specified.
		while(true){
			if(!node){
				// Finished this level, continue to parent's next sibling
				if(!parent || !parent.node){
					break;
				}
				node = parent.node.nextSibling;
				scripts = parent.scripts;
				scriptsOnly = false;
				parent = parent.parent;
				continue;
			}

			if(node.nodeType != 1){
				// Text or comment node, skip to next sibling
				node = node.nextSibling;
				continue;
			}

			if(scripts && node.nodeName.toLowerCase() == "script"){
				// Save <script type="dojo/..."> for parent, then continue to next sibling
				type = node.getAttribute("type");
				if(type && /^dojo\/\w/i.test(type)){
					scripts.push(node);
				}
				node = node.nextSibling;
				continue;
			}
			if(scriptsOnly){
				node = node.nextSibling;
				continue;
			}

			// Check for data-dojo-type attribute, fallback to backward compatible dojoType
			var type = node.getAttribute(dataDojoType) || node.getAttribute(dojoType);

			// Short circuit for leaf nodes containing nothing [but text]
			var firstChild = node.firstChild;
			if(!type && (!firstChild || (firstChild.nodeType == 3 && !firstChild.nextSibling))){
				node = node.nextSibling;
				continue;
			}

			// Setup data structure to save info on current node for when we return from processing descendant nodes
			var current = {
				node: node,
				scripts: scripts,
				parent: parent
			};

			// If dojoType/data-dojo-type specified, add to output array of nodes to instantiate
			var ctor = type && (_ctorMap[type] || (_ctorMap[type] = dlang.getObject(type))), // note: won't find classes declared via dojo.Declaration
				childScripts = ctor && !ctor.prototype._noScript ? [] : null; // <script> nodes that are parent's children
			if(type){
				list.push({
					"type": type,
					node: node,
					scripts: childScripts,
					inherited: getEffective(current) // dir & lang settings for current node, explicit or inherited
				});
			}

			// Recurse, collecting <script type="dojo/..."> children, and also looking for
			// descendant nodes with dojoType specified (unless the widget has the stopParser flag).
			// When finished with children, go to my next sibling.
			node = firstChild;
			scripts = childScripts;
			scriptsOnly = ctor && ctor.prototype.stopParser && !(args && args.template);
			parent = current;

		}

		// go build the object instances
		var mixin = args && args.template ? {template: true} : null;
		return this.instantiate(list, mixin, args); // Array
	};
}();


//Register the parser callback. It should be the first callback
//after the a11y test.
if(dojo.config.parseOnLoad){
	dojo.ready(100, dojo.parser, "parse");
}

return dojo.parser;
});

},
'dojox/grid/_RowSelector':function(){
define("dojox/grid/_RowSelector", [
	"dojo/_base/declare",
	"./_View"
], function(declare, _View){

return declare('dojox.grid._RowSelector', _View, {
	// summary:
	//	Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.
	defaultWidth: "2em",
	noscroll: true,
	padBorderWidth: 2,
	buildRendering: function(){
		this.inherited('buildRendering', arguments);
		this.scrollboxNode.style.overflow = "hidden";
		this.headerNode.style.visibility = "hidden";
	},
	getWidth: function(){
		return this.viewWidth || this.defaultWidth;
	},
	buildRowContent: function(inRowIndex, inRowNode){
		var w = this.contentWidth || 0;
		inRowNode.innerHTML = '<table class="dojoxGridRowbarTable" style="width:' + w + 'px;height:1px;" border="0" cellspacing="0" cellpadding="0" role="presentation"><tr><td class="dojoxGridRowbarInner">&nbsp;</td></tr></table>';
	},
	renderHeader: function(){
	},
	updateRow: function(){
	},
	resize: function(){
		this.adaptHeight();
	},
	adaptWidth: function(){
		// Only calculate this here - rather than every call to buildRowContent
		if(!("contentWidth" in this) && this.contentNode){
			this.contentWidth = this.contentNode.offsetWidth - this.padBorderWidth;
		}
	},
	// styling
	doStyleRowNode: function(inRowIndex, inRowNode){
		var n = [ "dojoxGridRowbar dojoxGridNonNormalizedCell" ];
		if(this.grid.rows.isOver(inRowIndex)){
			n.push("dojoxGridRowbarOver");
		}
		if(this.grid.selection.isSelected(inRowIndex)){
			n.push("dojoxGridRowbarSelected");
		}
		inRowNode.className = n.join(" ");
	},
	// event handlers
	domouseover: function(e){
		this.grid.onMouseOverRow(e);
	},
	domouseout: function(e){
		if(!this.isIntraRowEvent(e)){
			this.grid.onMouseOutRow(e);
		}
	}
});
});
},
'ibm/tivoli/simplesrm/srm/dojo/Formatter':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.Formatter");

dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

dojo.declare("ibm.tivoli.simplesrm.srm.dojo.Formatter", null, {

	_uiStringTable: null,

	constructor: function()
	{
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
	},
	_formatDate: function(d) {
		//console.log("MyRecordsGrid._formatDate(%s)", d);
		// When we changed from the webservice to TDI, the date lost the 'T'
		if (d) {
			if (d.search("9999") === 0) {
				d = this._uiStringTable.ForeverLabel;
			} else {
				var isod = d.replace(' ', 'T');
				var format_opts = {fullYear:true, selector: "date"};
				var dt = dojo.date.stamp.fromISOString(isod);
				if(dt) {
					d = dojo.date.locale.format(dt, format_opts);
					d = "<div style='oveflow:hidden;white-space:nowrap' title='"+
						 d + "'>" + d + "</div>";
				}
			}
		}
		return d;
	},

	/**
	 * Format a date displaying with the date and WITHOUT time.
	 * TODO Rename this function to _formatDate
	 */	
	_formatDatetime: function(d) {
		if(d) {
			if(d.search("9999") === 0) {
				d = this.__uiStringTable.ForeverLabel; 
			}
			else {
				var dt = d.formatISODateString();
				if(dt) {
					d = "<div style='oveflow:hidden;white-space:nowrap' title='"+
						 dt + "'>" + dt + "</div>";
				}
			}
		}
		return d;
	},
	
	/**
	 * Format a date displaying date AND time.
	 * TODO Rename this function to _formatDateTime
	 */
	_formatDateTimeReally: function(d) {
		if (d) {
			if(d.search("9999") === 0) {
				d = this.__uiStringTable.ForeverLabel; 
			} else {
				var dt = d.formatISODateString({sel: "datetime"});
				if (dt) {
					d = "<div style='oveflow:hidden;white-space:nowrap' title='"+
						 dt + "'>" + dt + "</div>";
				}
			}
		}
		return d;
	},
	
	_formatStringSafe: function(s) {
		return (undefined === s || null === s) ? "" : s;
	},
	
	_formatStringHtml: function(s) {
		//console.log("formatter - " + s);
		if (s==undefined ||s==null | s=="")	
			return s;			
		
		//decode html tags
        s= s.replace(/&lt;/g, "<");
        s= s.replace(/&gt;/g, ">");
        
        //Add spacing
		s = s.replace(/<li>/g, "<li> - ");
        s = s.replace(/<br /g, " <br ");    
        s = s.replace(/<p>/, " <p>");
        
        //remove html tags
		s= s.replace(/<.*?>/g, " ");		
				
        s = s.replace(/&amp;/g, "&");
		
		//replace non breaking space with a space
		s = s.replace(/&nbsp;/g, " ");
		
		//console.log("formatter,output - " + s);
		return s;		
				 
	},
	
	_formatCost: function(c) {
		if(c) {
			c = dojo.currency.format(c, {currency: "USD"});
		}
		return c;
	},

	_formatIcon: function(s, rowIndex) {
		return this._formatIconSz(s, rowIndex, 20);
	},
	
	_formatIconSz: function(s, rowIndex, w) {
		if(s) {
			//var icon = this.imagesPath + "icons/" + s;
			var r = this.simpleGrid.getItem(rowIndex);
			var icon = this.imageCacheUrl + s + "?REFID=" + r.ItemID;
			return "<img height='"+w+"' width='"+w+"' src='"+ icon + "' >";
		}
		return '';
	
	},
	
	_sortDefault: function(a, b) {
		return (a < b) ? -1 : (a > b) ? 1 : 0;
	},
	
	_sortString: function(a, b) {
		if(a && b) {
			return a.localeCompare(b);
		}
		if ((a==null || a.length==0) && b) {
			return -1;
		}
		if ((b==null || b.length==0) && a) {
			return 1;
		}
		return 0;
	},
	
	_sortNumber: function(a, b) {
		if(a && b) {
			return (a - b);
		}
		return 0;
	}

});

});

},
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-point=\"valueNode\"\n/></span>\n",
'dojo/dnd/Manager':function(){
define("dojo/dnd/Manager", ["../main", "../Evented", "./common", "./autoscroll", "./Avatar"], function(dojo, Evented) {
	// module:
	//		dojo/dnd/Manager
	// summary:
	//		TODOC


var Manager = dojo.declare("dojo.dnd.Manager", [Evented], {
	// summary:
	//		the manager of DnD operations (usually a singleton)
	constructor: function(){
		this.avatar  = null;
		this.source = null;
		this.nodes = [];
		this.copy  = true;
		this.target = null;
		this.canDropFlag = false;
		this.events = [];
	},

	// avatar's offset from the mouse
	OFFSET_X: 16,
	OFFSET_Y: 16,

	// methods
	overSource: function(source){
		// summary:
		//		called when a source detected a mouse-over condition
		// source: Object
		//		the reporter
		if(this.avatar){
			this.target = (source && source.targetState != "Disabled") ? source : null;
			this.canDropFlag = Boolean(this.target);
			this.avatar.update();
		}
		dojo.publish("/dnd/source/over", [source]);
	},
	outSource: function(source){
		// summary:
		//		called when a source detected a mouse-out condition
		// source: Object
		//		the reporter
		if(this.avatar){
			if(this.target == source){
				this.target = null;
				this.canDropFlag = false;
				this.avatar.update();
				dojo.publish("/dnd/source/over", [null]);
			}
		}else{
			dojo.publish("/dnd/source/over", [null]);
		}
	},
	startDrag: function(source, nodes, copy){
		// summary:
		//		called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		this.source = source;
		this.nodes  = nodes;
		this.copy   = Boolean(copy); // normalizing to true boolean
		this.avatar = this.makeAvatar();
		dojo.body().appendChild(this.avatar.node);
		dojo.publish("/dnd/start", [source, nodes, this.copy]);
		this.events = [
			dojo.connect(dojo.doc, "onmousemove", this, "onMouseMove"),
			dojo.connect(dojo.doc, "onmouseup",   this, "onMouseUp"),
			dojo.connect(dojo.doc, "onkeydown",   this, "onKeyDown"),
			dojo.connect(dojo.doc, "onkeyup",     this, "onKeyUp"),
			// cancel text selection and text dragging
			dojo.connect(dojo.doc, "ondragstart",   dojo.stopEvent),
			dojo.connect(dojo.body(), "onselectstart", dojo.stopEvent)
		];
		var c = "dojoDnd" + (copy ? "Copy" : "Move");
		dojo.addClass(dojo.body(), c);
	},
	canDrop: function(flag){
		// summary:
		//		called to notify if the current target can accept items
		var canDropFlag = Boolean(this.target && flag);
		if(this.canDropFlag != canDropFlag){
			this.canDropFlag = canDropFlag;
			this.avatar.update();
		}
	},
	stopDrag: function(){
		// summary:
		//		stop the DnD in progress
		dojo.removeClass(dojo.body(), ["dojoDndCopy", "dojoDndMove"]);
		dojo.forEach(this.events, dojo.disconnect);
		this.events = [];
		this.avatar.destroy();
		this.avatar = null;
		this.source = this.target = null;
		this.nodes = [];
	},
	makeAvatar: function(){
		// summary:
		//		makes the avatar; it is separate to be overwritten dynamically, if needed
		return new dojo.dnd.Avatar(this);
	},
	updateAvatar: function(){
		// summary:
		//		updates the avatar; it is separate to be overwritten dynamically, if needed
		this.avatar.update();
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		var a = this.avatar;
		if(a){
			dojo.dnd.autoScrollNodes(e);
			//dojo.dnd.autoScroll(e);
			var s = a.node.style;
			s.left = (e.pageX + this.OFFSET_X) + "px";
			s.top  = (e.pageY + this.OFFSET_Y) + "px";
			var copy = Boolean(this.source.copyState(dojo.isCopyKey(e)));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.avatar){
			if(this.target && this.canDropFlag){
				var copy = Boolean(this.source.copyState(dojo.isCopyKey(e))),
				params = [this.source, this.nodes, copy, this.target, e];
				dojo.publish("/dnd/drop/before", params);
				dojo.publish("/dnd/drop", params);
			}else{
				dojo.publish("/dnd/cancel");
			}
			this.stopDrag();
		}
	},

	// keyboard event processors
	onKeyDown: function(e){
		// summary:
		//		event processor for onkeydown:
		//		watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag
		// e: Event
		//		keyboard event
		if(this.avatar){
			switch(e.keyCode){
				case dojo.keys.CTRL:
					var copy = Boolean(this.source.copyState(true));
					if(this.copy != copy){
						this._setCopyStatus(copy);
					}
					break;
				case dojo.keys.ESCAPE:
					dojo.publish("/dnd/cancel");
					this.stopDrag();
					break;
			}
		}
	},
	onKeyUp: function(e){
		// summary:
		//		event processor for onkeyup, watching for CTRL for copy/move status
		// e: Event
		//		keyboard event
		if(this.avatar && e.keyCode == dojo.keys.CTRL){
			var copy = Boolean(this.source.copyState(false));
			if(this.copy != copy){
				this._setCopyStatus(copy);
			}
		}
	},

	// utilities
	_setCopyStatus: function(copy){
		// summary:
		//		changes the copy status
		// copy: Boolean
		//		the copy status
		this.copy = copy;
		this.source._markDndStatus(this.copy);
		this.updateAvatar();
		dojo.replaceClass(dojo.body(),
			"dojoDnd" + (this.copy ? "Copy" : "Move"),
			"dojoDnd" + (this.copy ? "Move" : "Copy"));
	}
});

// dojo.dnd._manager:
//		The manager singleton variable. Can be overwritten if needed.
dojo.dnd._manager = null;

Manager.manager = dojo.dnd.manager = function(){
	// summary:
	//		Returns the current DnD manager.  Creates one if it is not created yet.
	if(!dojo.dnd._manager){
		dojo.dnd._manager = new dojo.dnd.Manager();
	}
	return dojo.dnd._manager;	// Object
};

return Manager;
});

},
'dijit/form/ToggleButton':function(){
define("dijit/form/ToggleButton", [
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"./Button",
	"./_ToggleButtonMixin"
], function(declare, kernel, Button, _ToggleButtonMixin){

/*=====
	var Button = dijit.form.Button;
	var _ToggleButtonMixin = dijit.form._ToggleButtonMixin;
=====*/

	// module:
	//		dijit/form/ToggleButton
	// summary:
	//		A templated button widget that can be in two states (checked or not).


	return declare("dijit.form.ToggleButton", [Button, _ToggleButtonMixin], {
		// summary:
		//		A templated button widget that can be in two states (checked or not).
		//		Can be base class for things like tabs or checkbox or radio buttons

		baseClass: "dijitToggleButton",

		setChecked: function(/*Boolean*/ checked){
			// summary:
			//		Deprecated.  Use set('checked', true/false) instead.
			kernel.deprecated("setChecked("+checked+") is deprecated. Use set('checked',"+checked+") instead.", "", "2.0");
			this.set('checked', checked);
		}
	});
});

},
'ibm/tivoli/simplesrm/srm/dijit/ContextButton':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,dijit/Toolbar,dijit/form/Button,dijit/form/DropDownButton,dijit/Menu,ibm/tivoli/simplesrm/srm/dijit/CreateCatalogRequest"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ContextButton");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.RequestButton");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MultiRequestButton");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ContextButtonSet");


dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("dijit.Toolbar");
dojo.require("dijit.form.Button");
dojo.require("dijit.form.DropDownButton");
dojo.require("dijit.Menu");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.CreateCatalogRequest");


dojo.declare("ibm.tivoli.simplesrm.srm.dijit.RequestButton", dijit.form.Button, 
{
	requestInfo: null,
	
	postMixInProperties: function()
	{
		this.inherited(arguments);
		this.title = this.requestInfo.Description.htmlencode();
		this.label = this.requestInfo.Description.htmlencode();
		this.showLabel = false;
		this.iconClass = "request_button";
		this.baseClass="srm_button";
	},
	postCreate: function()
	{
		this.iconNode.innerHTML = "<img alt='' src='" + this.requestInfo.ImagePath + "'>";
		this.inherited(arguments);
	},
	onClick: function(evt)
	{
	}
});
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.MultiRequestButton", dijit.form.DropDownButton, 
{
	requestInfo: null,
	
	postMixInProperties: function()
	{
		console.log("MultiRequestButton.posMixInProperties");
		this.showLabel = false;
		this.iconClass = "request_button";
		this.inherited(arguments);
	},
	postCreate: function()
	{
		//dojo.addClass(this.domNode, "srm_button");
		this.iconNode.innerHTML = "<img alt='' src='" + this.requestInfo[0].ImagePath + "'>";

		this.dropDown = new dijit.Menu();
		for(var i= 0; i < this.requestInfo.length; ++i) {
			var off =  this.requestInfo[i];
			var mi = new dijit.MenuItem({label: off.Description.htmlencode(), iconClass: "nodisplay"});
			dojo.addClass(mi, "srmDropDownMenuItem");
			dojo.mixin(mi, {requestInfo: off});
			this.connect(mi, "onClick", this.onClick);
			this.dropDown.addChild(mi);
		}
		this.inherited(arguments);
	}
});
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ContextButtonSet", [dijit._Widget, ibm.tivoli.simplesrm.srm.dijit.CreatorFactory], 
{
	contextName: "",
	offeringList: null,
	toolbar: null,
	click_context: {},
	length: 0,

	_buttonSet: null,
	
	_createLabel: "Create",
	
	constructor: function()
	{
		console.log("ContextButtonSet.ctor");
		this._createLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").ContextButtonSetLabelCreate;
	},

	postCreate: function()
	{
		console.log("ContextButtonSet.postCreate");

		this._buttonSet = new dijit.WidgetSet();
		
		var ctxItems = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getOfferingsInContext(this.contextName);
		this.length = ctxItems.length;
		var groups = this._groupRequests(ctxItems);
		for(var key in groups) {
			if(groups.hasOwnProperty(key)){
				var btn;
				ctxItems = groups[key];
				if(ctxItems.length == 1) {
					btn = new ibm.tivoli.simplesrm.srm.dijit.RequestButton({requestInfo: ctxItems[0], onClick: dojo.hitch(this, "onClick")});
				}
				else {
					btn = new ibm.tivoli.simplesrm.srm.dijit.MultiRequestButton({label: this._createLabel, requestInfo: ctxItems, onClick: dojo.hitch(this, "onClick")});
				}
				this.toolbar.addChild(btn);
				this._buttonSet.add(btn);
			}
		}
	},
	setContext: function(ctx)
	{
		this.click_context = ctx;
	},
	// group requests by icon	
	_groupRequests: function(req_list)
	{
		var reqGroups = {};
		for(var i =0; i < req_list.length; ++i) {
			var req = req_list[i];
			if(!reqGroups[req.ImageName]) {
				reqGroups[req.ImageName] = [];
			}
			reqGroups[req.ImageName].push(req);
		}
		return reqGroups;
	},
	_setDisabledAttr: function(newval)
	{
		this._buttonSet.forEach(function(w) {w.attr("disabled", newval);}); 
	},
	onClick: function(evt)
	{
		var w = dijit.getEnclosingWidget(evt.target);
		var off = w.requestInfo;
		if(dojo.isObject(this.click_context)){
			dojo.mixin(off, this.click_context);
		}
		console.log("ContextButtonSet.onClick: ", off.ItemNum);
		this.createAndShowInputForm(off, false);
	}

});

});

},
'dojo/date/stamp':function(){
define("dojo/date/stamp", ["../_base/kernel", "../_base/lang", "../_base/array"], function(dojo, lang, array) {
	// module:
	//		dojo/date/stamp
	// summary:
	//		TODOC

lang.getObject("date.stamp", true, dojo);

// Methods to convert dates to or from a wire (string) format using well-known conventions

dojo.date.stamp.fromISOString = function(/*String*/formattedString, /*Number?*/defaultTime){
	//	summary:
	//		Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.
	//
	//	description:
	//		Accepts a string formatted according to a profile of ISO8601 as defined by
	//		[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	//		Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	//		The following combinations are valid:
	//
	//			* dates only
	//			|	* yyyy
	//			|	* yyyy-MM
	//			|	* yyyy-MM-dd
	// 			* times only, with an optional time zone appended
	//			|	* THH:mm
	//			|	* THH:mm:ss
	//			|	* THH:mm:ss.SSS
	// 			* and "datetimes" which could be any combination of the above
	//
	//		timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	//		Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	//		input may return null.  Arguments which are out of bounds will be handled
	// 		by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	//		Only years between 100 and 9999 are supported.
	//
  	//	formattedString:
	//		A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00
	//
	//	defaultTime:
	//		Used for defaults for fields omitted in the formattedString.
	//		Uses 1970-01-01T00:00:00.0Z by default.

	if(!dojo.date.stamp._isoRegExp){
		dojo.date.stamp._isoRegExp =
//TODO: could be more restrictive and check for 00-59, etc.
			/^(?:(\d{4})(?:-(\d{2})(?:-(\d{2}))?)?)?(?:T(\d{2}):(\d{2})(?::(\d{2})(.\d+)?)?((?:[+-](\d{2}):(\d{2}))|Z)?)?$/;
	}

	var match = dojo.date.stamp._isoRegExp.exec(formattedString),
		result = null;

	if(match){
		match.shift();
		if(match[1]){match[1]--;} // Javascript Date months are 0-based
		if(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds

		if(defaultTime){
			// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0
			defaultTime = new Date(defaultTime);
			array.forEach(array.map(["FullYear", "Month", "Date", "Hours", "Minutes", "Seconds", "Milliseconds"], function(prop){
				return defaultTime["get" + prop]();
			}), function(value, index){
				match[index] = match[index] || value;
			});
		}
		result = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults
		if(match[0] < 100){
			result.setFullYear(match[0] || 1970);
		}

		var offset = 0,
			zoneSign = match[7] && match[7].charAt(0);
		if(zoneSign != 'Z'){
			offset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);
			if(zoneSign != '-'){ offset *= -1; }
		}
		if(zoneSign){
			offset -= result.getTimezoneOffset();
		}
		if(offset){
			result.setTime(result.getTime() + offset * 60000);
		}
	}

	return result; // Date or null
};

/*=====
	dojo.date.stamp.__Options = function(){
		//	selector: String
		//		"date" or "time" for partial formatting of the Date object.
		//		Both date and time will be formatted by default.
		//	zulu: Boolean
		//		if true, UTC/GMT is used for a timezone
		//	milliseconds: Boolean
		//		if true, output milliseconds
		this.selector = selector;
		this.zulu = zulu;
		this.milliseconds = milliseconds;
	}
=====*/

dojo.date.stamp.toISOString = function(/*Date*/dateObject, /*dojo.date.stamp.__Options?*/options){
	//	summary:
	//		Format a Date object as a string according a subset of the ISO-8601 standard
	//
	//	description:
	//		When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	//		The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	//		Does not check bounds.  Only years between 100 and 9999 are supported.
	//
	//	dateObject:
	//		A Date object

	var _ = function(n){ return (n < 10) ? "0" + n : n; };
	options = options || {};
	var formattedDate = [],
		getter = options.zulu ? "getUTC" : "get",
		date = "";
	if(options.selector != "time"){
		var year = dateObject[getter+"FullYear"]();
		date = ["0000".substr((year+"").length)+year, _(dateObject[getter+"Month"]()+1), _(dateObject[getter+"Date"]())].join('-');
	}
	formattedDate.push(date);
	if(options.selector != "date"){
		var time = [_(dateObject[getter+"Hours"]()), _(dateObject[getter+"Minutes"]()), _(dateObject[getter+"Seconds"]())].join(':');
		var millis = dateObject[getter+"Milliseconds"]();
		if(options.milliseconds){
			time += "."+ (millis < 100 ? "0" : "") + _(millis);
		}
		if(options.zulu){
			time += "Z";
		}else if(options.selector != "time"){
			var timezoneOffset = dateObject.getTimezoneOffset();
			var absOffset = Math.abs(timezoneOffset);
			time += (timezoneOffset > 0 ? "-" : "+") +
				_(Math.floor(absOffset/60)) + ":" + _(absOffset%60);
		}
		formattedDate.push(time);
	}
	return formattedDate.join('T'); // String
};

return dojo.date.stamp;
});

},
'dojox/gfx/_base':function(){
define("dojox/gfx/_base", ["dojo/_base/lang", "dojo/_base/html", "dojo/_base/Color", "dojo/_base/sniff", "dojo/_base/window",
	    "dojo/_base/array","dojo/dom", "dojo/dom-construct","dojo/dom-geometry"], 
  function(lang, html, Color, has, win, arr, dom, domConstruct, domGeom){
	// module:
	//		dojox/gfx
	// summary:
	//		This module contains common core Graphics API used by different graphics renderers.
	var g = lang.getObject("dojox.gfx", true),
		b = g._base = {};
	/*===== g = dojox.gfx; b = dojox.gfx._base; =====*/
	
	// candidates for dojox.style (work on VML and SVG nodes)
	g._hasClass = function(/*DomNode*/node, /*String*/classStr){
		//	summary:
		//		Returns whether or not the specified classes are a portion of the
		//		class list currently applied to the node.
		// return (new RegExp('(^|\\s+)'+classStr+'(\\s+|$)')).test(node.className)	// Boolean
		var cls = node.getAttribute("className");
		return cls && (" " + cls + " ").indexOf(" " + classStr + " ") >= 0;  // Boolean
	};
	g._addClass = function(/*DomNode*/node, /*String*/classStr){
		//	summary:
		//		Adds the specified classes to the end of the class list on the
		//		passed node.
		var cls = node.getAttribute("className") || "";
		if(!cls || (" " + cls + " ").indexOf(" " + classStr + " ") < 0){
			node.setAttribute("className", cls + (cls ? " " : "") + classStr);
		}
	};
	g._removeClass = function(/*DomNode*/node, /*String*/classStr){
		//	summary: Removes classes from node.
		var cls = node.getAttribute("className");
		if(cls){
			node.setAttribute(
				"className",
				cls.replace(new RegExp('(^|\\s+)' + classStr + '(\\s+|$)'), "$1$2")
			);
		}
	};

	// candidate for dojox.html.metrics (dynamic font resize handler is not implemented here)

	//	derived from Morris John's emResized measurer
	b._getFontMeasurements = function(){
		//	summary:
		//		Returns an object that has pixel equivilents of standard font
		//		size values.
		var heights = {
			'1em': 0, '1ex': 0, '100%': 0, '12pt': 0, '16px': 0, 'xx-small': 0,
			'x-small': 0, 'small': 0, 'medium': 0, 'large': 0, 'x-large': 0,
			'xx-large': 0
		};
		var p;

		if(has("ie")){
			//	we do a font-size fix if and only if one isn't applied already.
			//	NOTE: If someone set the fontSize on the HTML Element, this will kill it.
			win.doc.documentElement.style.fontSize="100%";
		}

		//	set up the measuring node.
		var div = domConstruct.create("div", {style: {
				position: "absolute",
				left: "0",
				top: "-100px",
				width: "30px",
				height: "1000em",
				borderWidth: "0",
				margin: "0",
				padding: "0",
				outline: "none",
				lineHeight: "1",
				overflow: "hidden"
			}}, win.body());

		//	do the measurements.
		for(p in heights){
			div.style.fontSize = p;
			heights[p] = Math.round(div.offsetHeight * 12/16) * 16/12 / 1000;
		}

		win.body().removeChild(div);
		return heights; //object
	};

	var fontMeasurements = null;

	b._getCachedFontMeasurements = function(recalculate){
		if(recalculate || !fontMeasurements){
			fontMeasurements = b._getFontMeasurements();
		}
		return fontMeasurements;
	};

	// candidate for dojox.html.metrics

	var measuringNode = null, empty = {};
	b._getTextBox = function(	/*String*/ text,
								/*Object*/ style,
								/*String?*/ className){
		var m, s, al = arguments.length;
		var i;
		if(!measuringNode){
			measuringNode = domConstruct.create("div", {style: {
				position: "absolute",
				top: "-10000px",
				left: "0"
			}}, win.body());
		}
		m = measuringNode;
		// reset styles
		m.className = "";
		s = m.style;
		s.borderWidth = "0";
		s.margin = "0";
		s.padding = "0";
		s.outline = "0";
		// set new style
		if(al > 1 && style){
			for(i in style){
				if(i in empty){ continue; }
				s[i] = style[i];
			}
		}
		// set classes
		if(al > 2 && className){
			m.className = className;
		}
		// take a measure
		m.innerHTML = text;

		if(m["getBoundingClientRect"]){
			var bcr = m.getBoundingClientRect();
			return {l: bcr.left, t: bcr.top, w: bcr.width || (bcr.right - bcr.left), h: bcr.height || (bcr.bottom - bcr.top)};
		}else{
			return domGeom.getMarginBox(m);
		}
	};

	// candidate for dojo.dom

	var uniqueId = 0;
	b._getUniqueId = function(){
		// summary: returns a unique string for use with any DOM element
		var id;
		do{
			id = dojo._scopeName + "xUnique" + (++uniqueId);
		}while(dom.byId(id));
		return id;
	};

	lang.mixin(g, {
		//	summary:
		//		defines constants, prototypes, and utility functions for the core Graphics API

		// default shapes, which are used to fill in missing parameters
		defaultPath: {
			//	summary:
			//		Defines the default Path prototype object.
			type: "path", 
			//	type: String
			//		Specifies this object is a Path, default value 'path'.
			path: ""
			//	path: String
			//		The path commands. See W32C SVG 1.0 specification. 
			//		Defaults to empty string value.
		},
		defaultPolyline: {
			//	summary:
			//		Defines the default PolyLine prototype.
			type: "polyline", 
			//	type: String
			//		Specifies this object is a PolyLine, default value 'polyline'.
			points: []
			//	points: Array
			//		An array of point objects [{x:0,y:0},...] defining the default polyline's line segments. Value is an empty array [].
		},
		defaultRect: {
			//	summary:
			//		Defines the default Rect prototype.
			type: "rect",
			//	type: String
			//		Specifies this default object is a type of Rect. Value is 'rect' 
			x: 0, 
			//	x: Number
			//		The X coordinate of the default rectangles position, value 0.
			y: 0, 
			//	y: Number
			//		The Y coordinate of the default rectangle's position, value 0.
			width: 100, 
			//	width: Number
			//		The width of the default rectangle, value 100.
			height: 100, 
			//	height: Number
			//		The height of the default rectangle, value 100.
			r: 0
			//	r: Number
			//		The corner radius for the default rectangle, value 0.
		},
		defaultEllipse: {
			//	summary:
			//		Defines the default Ellipse prototype.
			type: "ellipse", 
			//	type: String
			//		Specifies that this object is a type of Ellipse, value is 'ellipse'
			cx: 0, 
			//	cx: Number
			//		The X coordinate of the center of the ellipse, default value 0.
			cy: 0, 
			//	cy: Number
			//		The Y coordinate of the center of the ellipse, default value 0.
			rx: 200,
			//	rx: Number
			//		The radius of the ellipse in the X direction, default value 200.
			ry: 100
			//	ry: Number
			//		The radius of the ellipse in the Y direction, default value 200.
		},
		defaultCircle: {
			//	summary:
			//		An object defining the default Circle prototype.
			type: "circle", 
			//	type: String
			//		Specifies this object is a circle, value 'circle'
			cx: 0, 
			//	cx: Number
			//		The X coordinate of the center of the circle, default value 0.
			cy: 0, 
			//	cy: Number
			//		The Y coordinate of the center of the circle, default value 0.
			r: 100
			//	r: Number
			//		The radius, default value 100.
		},
		defaultLine: {
			//	summary:
			//		An pbject defining the default Line prototype.
			type: "line", 
			//	type: String
			//		Specifies this is a Line, value 'line'
			x1: 0, 
			//	x1: Number
			//		The X coordinate of the start of the line, default value 0.
			y1: 0, 
			//	y1: Number
			//		The Y coordinate of the start of the line, default value 0.
			x2: 100,
			//	x2: Number
			//		The X coordinate of the end of the line, default value 100.
			y2: 100
			//	y2: Number
			//		The Y coordinate of the end of the line, default value 100.
		},
		defaultImage: {
			//	summary:
			//		Defines the default Image prototype.
			type: "image",
			//	type: String
			//		Specifies this object is an image, value 'image'.
			x: 0, 
			//	x: Number
			//		The X coordinate of the image's position, default value 0.
			y: 0, 
			//	y: Number
			//		The Y coordinate of the image's position, default value 0.
			width: 0,
			//	width: Number
			//		The width of the image, default value 0.
			height: 0,
			//	height:Number
			//		The height of the image, default value 0.
			src: ""
			//	src: String
			//		The src url of the image, defaults to empty string.
		},
		defaultText: {
			//	summary:
			//		Defines the default Text prototype.
			type: "text", 
			//	type: String
			//		Specifies this is a Text shape, value 'text'.
			x: 0, 
			//	x: Number
			//		The X coordinate of the text position, default value 0.
			y: 0, 
			//	y: Number
			//		The Y coordinate of the text position, default value 0.
			text: "",
			//	text: String
			//		The text to be displayed, default value empty string.
			align: "start",
			//	align:	String
			//		The horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.
			decoration: "none",
			//	decoration: String
			//		The text decoration , one of 'none', ... . Default value 'none'.
			rotated: false,
			//	rotated: Boolean
			//		Whether the text is rotated, boolean default value false.
			kerning: true
			//	kerning: Boolean
			//		Whether kerning is used on the text, boolean default value true.
		},
		defaultTextPath: {
			//	summary:
			//		Defines the default TextPath prototype.
			type: "textpath", 
			//	type: String
			//		Specifies this is a TextPath, value 'textpath'.
			text: "", 
			//	text: String
			//		The text to be displayed, default value empty string.
			align: "start",
			//	align: String
			//		The horizontal text alignment, one of 'start', 'end', 'center'. Default value 'start'.
			decoration: "none",
			//	decoration: String
			//		The text decoration , one of 'none', ... . Default value 'none'.
			rotated: false,
			//	rotated: Boolean
			//		Whether the text is rotated, boolean default value false.
			kerning: true
			//	kerning: Boolean
			//		Whether kerning is used on the text, boolean default value true.
		},

		// default stylistic attributes
		defaultStroke: {
			//	summary:
			//		A stroke defines stylistic properties that are used when drawing a path.  
			//		This object defines the default Stroke prototype.
			type: "stroke", 
			//	type: String
			//		Specifies this object is a type of Stroke, value 'stroke'.
			color: "black", 
			//	color: String
			//		The color of the stroke, default value 'black'.
			style: "solid",
			//	style: String
			//		The style of the stroke, one of 'solid', ... . Default value 'solid'.
			width: 1,
			//	width: Number
			//		The width of a stroke, default value 1.
			cap: "butt",
			//	cap: String
			//		The endcap style of the path. One of 'butt', 'round', ... . Default value 'butt'.
			join: 4
			//	join: Number
			//		The join style to use when combining path segments. Default value 4.
		},
		defaultLinearGradient: {
			//	summary:
			//		An object defining the default stylistic properties used for Linear Gradient fills.
			//		Linear gradients are drawn along a virtual line, which results in appearance of a rotated pattern in a given direction/orientation.
			type: "linear", 
			//	type: String
			//		Specifies this object is a Linear Gradient, value 'linear'
			x1: 0, 
			//	x1: Number
			//		The X coordinate of the start of the virtual line along which the gradient is drawn, default value 0.
			y1: 0, 
			//	y1: Number
			//		The Y coordinate of the start of the virtual line along which the gradient is drawn, default value 0.
			x2: 100,
			//	x2: Number
			//		The X coordinate of the end of the virtual line along which the gradient is drawn, default value 100.
			y2: 100,
			//	y2: Number
			//		The Y coordinate of the end of the virtual line along which the gradient is drawn, default value 100.
			colors: [
				{ offset: 0, color: "black" }, { offset: 1, color: "white" }
			]
			//	colors: Array
			//		An array of colors at given offsets (from the start of the line).  The start of the line is
			//		defined at offest 0 with the end of the line at offset 1.
			//		Default value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white. 
		},
		defaultRadialGradient: {
			// summary:
			//		An object specifying the default properties for RadialGradients using in fills patterns.
			type: "radial",
			//	type: String
			//		Specifies this is a RadialGradient, value 'radial'
			cx: 0, 
			//	cx: Number
			//		The X coordinate of the center of the radial gradient, default value 0.
			cy: 0, 
			//	cy: Number
			//		The Y coordinate of the center of the radial gradient, default value 0.
			r: 100,
			//	r: Number
			//		The radius to the end of the radial gradient, default value 100.
			colors: [
				{ offset: 0, color: "black" }, { offset: 1, color: "white" }
			]
			//	colors: Array
			//		An array of colors at given offsets (from the center of the radial gradient).  
			//		The center is defined at offest 0 with the outer edge of the gradient at offset 1.
			//		Default value, [{ offset: 0, color: 'black'},{offset: 1, color: 'white'}], is a gradient from black to white. 
		},
		defaultPattern: {
			// summary:
			//		An object specifying the default properties for a Pattern using in fill operations.
			type: "pattern", 
			// type: String
			//		Specifies this object is a Pattern, value 'pattern'.
			x: 0, 
			//	x: Number
			//		The X coordinate of the position of the pattern, default value is 0.
			y: 0, 
			//	y: Number
			//		The Y coordinate of the position of the pattern, default value is 0.
			width: 0, 
			//	width: Number
			//		The width of the pattern image, default value is 0.
			height: 0, 
			//	height: Number
			//		The height of the pattern image, default value is 0.
			src: ""
			//	src: String
			//		A url specifing the image to use for the pattern.
		},
		defaultFont: {
			// summary:
			//		An object specifying the default properties for a Font used in text operations.
			type: "font", 
			// type: String
			//		Specifies this object is a Font, value 'font'.
			style: "normal", 
			//	style: String
			//		The font style, one of 'normal', 'bold', default value 'normal'.
			variant: "normal",
			//	variant: String
			//		The font variant, one of 'normal', ... , default value 'normal'.
			weight: "normal", 
			//	weight: String
			//		The font weight, one of 'normal', ..., default value 'normal'.
			size: "10pt", 
			//	size: String
			//		The font size (including units), default value '10pt'.
			family: "serif"
			//	family: String
			//		The font family, one of 'serif', 'sanserif', ..., default value 'serif'.
		},

		getDefault: (function(){
			//	summary:
			//		Returns a function used to access default memoized prototype objects (see them defined above).
			var typeCtorCache = {};
			// a memoized delegate()
			return function(/*String*/ type){
				var t = typeCtorCache[type];
				if(t){
					return new t();
				}
				t = typeCtorCache[type] = new Function();
				t.prototype = g[ "default" + type ];
				return new t();
			}
		})(),

		normalizeColor: function(/*dojo.Color|Array|string|Object*/ color){
			//	summary:
			//		converts any legal color representation to normalized
			//		dojo.Color object
			return (color instanceof Color) ? color : new Color(color); // dojo.Color
		},
		normalizeParameters: function(existed, update){
			//	summary:
			//		updates an existing object with properties from an 'update'
			//		object
			//	existed: Object
			//		the target object to be updated
			//	update:  Object
			//		the 'update' object, whose properties will be used to update
			//		the existed object
			var x;
			if(update){
				var empty = {};
				for(x in existed){
					if(x in update && !(x in empty)){
						existed[x] = update[x];
					}
				}
			}
			return existed;	// Object
		},
		makeParameters: function(defaults, update){
			//	summary:
			//		copies the original object, and all copied properties from the
			//		'update' object
			//	defaults: Object
			//		the object to be cloned before updating
			//	update:   Object
			//		the object, which properties are to be cloned during updating
			var i = null;
			if(!update){
				// return dojo.clone(defaults);
				return lang.delegate(defaults);
			}
			var result = {};
			for(i in defaults){
				if(!(i in result)){
					result[i] = lang.clone((i in update) ? update[i] : defaults[i]);
				}
			}
			return result; // Object
		},
		formatNumber: function(x, addSpace){
			// summary: converts a number to a string using a fixed notation
			// x: Number
			//		number to be converted
			// addSpace: Boolean
			//		whether to add a space before a positive number
			var val = x.toString();
			if(val.indexOf("e") >= 0){
				val = x.toFixed(4);
			}else{
				var point = val.indexOf(".");
				if(point >= 0 && val.length - point > 5){
					val = x.toFixed(4);
				}
			}
			if(x < 0){
				return val; // String
			}
			return addSpace ? " " + val : val; // String
		},
		// font operations
		makeFontString: function(font){
			// summary: converts a font object to a CSS font string
			// font:	Object:	font object (see dojox.gfx.defaultFont)
			return font.style + " " + font.variant + " " + font.weight + " " + font.size + " " + font.family; // Object
		},
		splitFontString: function(str){
			// summary:
			//		converts a CSS font string to a font object
			// description:
			//		Converts a CSS font string to a gfx font object. The CSS font
			//		string components should follow the W3C specified order
			//		(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
			//		style, variant, weight, size, optional line height (will be
			//		ignored), and family.
			// str: String
			//		a CSS font string
			var font = g.getDefault("Font");
			var t = str.split(/\s+/);
			do{
				if(t.length < 5){ break; }
				font.style   = t[0];
				font.variant = t[1];
				font.weight  = t[2];
				var i = t[3].indexOf("/");
				font.size = i < 0 ? t[3] : t[3].substring(0, i);
				var j = 4;
				if(i < 0){
					if(t[4] == "/"){
						j = 6;
					}else if(t[4].charAt(0) == "/"){
						j = 5;
					}
				}
				if(j < t.length){
					font.family = t.slice(j).join(" ");
				}
			}while(false);
			return font;	// Object
		},
		// length operations
		cm_in_pt: 72 / 2.54, 
			//	cm_in_pt: Number
			//		points per centimeter (constant)
		mm_in_pt: 7.2 / 2.54,
			//	mm_in_pt: Number
			//		points per millimeter (constant)
		px_in_pt: function(){
			//	summary: returns the current number of pixels per point.
			return g._base._getCachedFontMeasurements()["12pt"] / 12;	// Number
		},
		pt2px: function(len){
			//	summary: converts points to pixels
			//	len: Number
			//		a value in points
			return len * g.px_in_pt();	// Number
		},
		px2pt: function(len){
			//	summary: converts pixels to points
			//	len: Number
			//		a value in pixels
			return len / g.px_in_pt();	// Number
		},
		normalizedLength: function(len) {
			//	summary: converts any length value to pixels
			//	len: String
			//		a length, e.g., '12pc'
			if(len.length === 0){ return 0; }
			if(len.length > 2){
				var px_in_pt = g.px_in_pt();
				var val = parseFloat(len);
				switch(len.slice(-2)){
					case "px": return val;
					case "pt": return val * px_in_pt;
					case "in": return val * 72 * px_in_pt;
					case "pc": return val * 12 * px_in_pt;
					case "mm": return val * g.mm_in_pt * px_in_pt;
					case "cm": return val * g.cm_in_pt * px_in_pt;
				}
			}
			return parseFloat(len);	// Number
		},

		pathVmlRegExp: /([A-Za-z]+)|(\d+(\.\d+)?)|(\.\d+)|(-\d+(\.\d+)?)|(-\.\d+)/g,
			//	pathVmlRegExp: RegExp
			//		a constant regular expression used to split a SVG/VML path into primitive components
		pathSvgRegExp: /([A-Za-z])|(\d+(\.\d+)?)|(\.\d+)|(-\d+(\.\d+)?)|(-\.\d+)/g,
			//	pathVmlRegExp: RegExp
			//		a constant regular expression used to split a SVG/VML path into primitive components

		equalSources: function(a /*Object*/, b /*Object*/){
			//	summary: compares event sources, returns true if they are equal
			//	a: first event source
			//	b: event source to compare against a
			return a && b && a === b;
		},

		switchTo: function(renderer/*String|Object*/){
			//	summary: switch the graphics implementation to the specified renderer.
			//	renderer: 
			//		Either the string name of a renderer (eg. 'canvas', 'svg, ...) or the renderer
			//		object to switch to.
			var ns = typeof renderer == "string" ? g[renderer] : renderer;
			if(ns){
				arr.forEach(["Group", "Rect", "Ellipse", "Circle", "Line",
						"Polyline", "Image", "Text", "Path", "TextPath",
						"Surface", "createSurface", "fixTarget"], function(name){
					g[name] = ns[name];
				});
			}
		}
	});
	return g; // defaults object api
});

},
'dojo/Stateful':function(){
define("dojo/Stateful", ["./_base/kernel", "./_base/declare", "./_base/lang", "./_base/array"], function(dojo, declare, lang, array) {
	// module:
	//		dojo/Stateful
	// summary:
	//		TODOC

return dojo.declare("dojo.Stateful", null, {
	// summary:
	//		Base class for objects that provide named properties with optional getter/setter
	//		control and the ability to watch for property changes
	// example:
	//	|	var obj = new dojo.Stateful();
	//	|	obj.watch("foo", function(){
	//	|		console.log("foo changed to " + this.get("foo"));
	//	|	});
	//	|	obj.set("foo","bar");
	postscript: function(mixin){
		if(mixin){
			lang.mixin(this, mixin);
		}
	},

	get: function(/*String*/name){
		// summary:
		//		Get a property on a Stateful instance.
		//	name:
		//		The property to get.
		//	returns:
		//		The property value on this Stateful instance.
		// description:
		//		Get a named property on a Stateful object. The property may
		//		potentially be retrieved via a getter method in subclasses. In the base class
		// 		this just retrieves the object's property.
		// 		For example:
		//	|	stateful = new dojo.Stateful({foo: 3});
		//	|	stateful.get("foo") // returns 3
		//	|	stateful.foo // returns 3

		return this[name]; //Any
	},
	set: function(/*String*/name, /*Object*/value){
		// summary:
		//		Set a property on a Stateful instance
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		//	returns:
		//		The function returns this dojo.Stateful instance.
		// description:
		//		Sets named properties on a stateful object and notifies any watchers of
		// 		the property. A programmatic setter may be defined in subclasses.
		// 		For example:
		//	|	stateful = new dojo.Stateful();
		//	|	stateful.watch(function(name, oldValue, value){
		//	|		// this will be called on the set below
		//	|	}
		//	|	stateful.set(foo, 5);
		//
		//	set() may also be called with a hash of name/value pairs, ex:
		//	|	myObj.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	})
		//	This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks){
			this._watchCallbacks(name, oldValue, value);
		}
		return this; //dojo.Stateful
	},
	watch: function(/*String?*/name, /*Function*/callback){
		// summary:
		//		Watches a property for changes
		//	name:
		//		Indicates the property to watch. This is optional (the callback may be the
		// 		only parameter), and if omitted, all the properties will be watched
		// returns:
		//		An object handle for the watch. The unwatch method of this object
		// 		can be used to discontinue watching this property:
		//		|	var watchHandle = obj.watch("foo", callback);
		//		|	watchHandle.unwatch(); // callback won't be called now
		//	callback:
		//		The function to execute when the property changes. This will be called after
		//		the property has been changed. The callback will be called with the |this|
		//		set to the instance, the first argument as the name of the property, the
		// 		second argument as the old value and the third argument as the new value.

		var callbacks = this._watchCallbacks;
		if(!callbacks){
			var self = this;
			callbacks = this._watchCallbacks = function(name, oldValue, value, ignoreCatchall){
				var notify = function(propertyCallbacks){
					if(propertyCallbacks){
                        propertyCallbacks = propertyCallbacks.slice();
						for(var i = 0, l = propertyCallbacks.length; i < l; i++){
							try{
								propertyCallbacks[i].call(self, name, oldValue, value);
							}catch(e){
								console.error(e);
							}
						}
					}
				};
				notify(callbacks['_' + name]);
				if(!ignoreCatchall){
					notify(callbacks["*"]); // the catch-all
				}
			}; // we use a function instead of an object so it will be ignored by JSON conversion
		}
		if(!callback && typeof name === "function"){
			callback = name;
			name = "*";
		}else{
			// prepend with dash to prevent name conflicts with function (like "name" property)
			name = '_' + name;
		}
		var propertyCallbacks = callbacks[name];
		if(typeof propertyCallbacks !== "object"){
			propertyCallbacks = callbacks[name] = [];
		}
		propertyCallbacks.push(callback);
		return {
			unwatch: function(){
				propertyCallbacks.splice(array.indexOf(propertyCallbacks, callback), 1);
			}
		}; //Object
	}

});

});

},
'ibm/tivoli/simplesrm/srm/dijit/InlineMessage':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dijit/_Widget,dijit/_Templated,ibm/tivoli/simplesrm/srm/dijit/OpenHelp,dojo/i18n"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.InlineMessage");

// include modules
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");
dojo.require("dojo.i18n");

dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.InlineMessage",
	[dijit._Widget, dijit._Templated, ibm.tivoli.simplesrm.srm.dijit.OpenHelp],
{
	templateString:"<div>\n<!--\n @HTML_LONG_COPYRIGHT_BEGIN@\n @HTML_LONG_COPYRIGHT_END@\n-->\n\t<table dojoAttachPoint=\"messageBox\" style=\"padding:3px !important\">\n\t\t<tr>\n\t\t\t<td><div dojoAttachPoint=\"messageIcon\"></div></td>\n\t\t\t<td><a dojoAttachPoint=\"messageIdBox\" class=\"message-id\" href=\"\">${messageId}:</a></td>\n\t\t\t<td class=\"message-description\" style=\"padding-left:5px; width:100%\">${messageText}</td>\n\t\t</tr>\n\t</table>\n</div>",	
	_uiStringTable: null,
	
	messageId: "",
	messageType: "",
	messageText: "",
	
	messageBox: null,
	messageIdBox: null,
	icon: null,
	
	constructor: function()
	{
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
	},
	postMixInProperties: function() {
		console.log("InlineMessage.postMixInProperties");
		if ((this.messageId !== null) && (this.messageId !== undefined) && (this.messageId !== "")) {
			this.messageType = this.messageId.substring(this.messageId.length -1);
			if ((this.messageType != 'I') && (this.messageType != 'W') && (this.messageType != 'E')) {
				console.debug("Invalid messageType: " + this.messageType + ".");
				this._setDefaultMessage();
			}
			else {
				//this.messageText = this._uiStringTable[this.messageId].substring(this._uiStringTable[this.messageId].indexOf(': '));
				this.messageText = this._uiStringTable[this.messageId];
				if(this.messageText){
					this.messageText = this.messageText.replace(this.messageId, "");
				}
				else{ 
					this.messageText = this.messageId;
				}
			}
		}
		else {
			console.debug("Null, undefined or empty messageId: " + this.messageId + ".");
			this._setDefaultMessage();
		}
	},
	
	postCreate: function() {
		console.log("InlineMessage.postCreate");
		this.inherited(arguments);
		
		this._applyStyle();
		
		var link = dojo.byId(this.messageIdBox);
		dojo.connect(link , "onclick" , this , "openHelp"); 
	},
	
	openHelp: function(event){
		dojo.stopEvent(event);
		
		var params = [{helpKey: "PMRDP_Messages.htm"}, {messageCode: this.messageId}, {messageType: this.messageType}];
		this.openHelpWindow(params);
	},
			
	_applyStyle: function() {
		switch(this.messageType) {
			case 'M':
				dojo.addClass(this.messageBox, 'info');
				dojo.addClass(this.messageIcon, 'infoicon');
				break;
			case 'W':
				dojo.addClass(this.messageBox, 'warning');
				dojo.addClass(this.messageIcon, 'wrnicon');
				break;
			case 'E':
				dojo.addClass(this.messageBox, 'critical');
				dojo.addClass(this.messageIcon, 'erricon');
				break;
			default:
				dojo.addClass(this.messageBox, 'info');
				dojo.addClass(this.messageIcon, 'infoicon');
				break;
		}
	},
	
	_setDefaultMessage: function() {
		this.messageId = 'CTJZH2316E';
		this.messageType = 'E';
		this.messageText = this._uiStringTable[this.messageId];
	},
	
	_dummy: null
});

});

},
'ibm/tivoli/simplesrm/srm/dojo/Hoverer':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.Hoverer");

/*
** Hoverer is a general purpose class that should probably be declared somewhere else
**
** Create a new Hoverer on a DOM node, and it will fire onHover when the mouse has stood still for a while
*/
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.Hoverer", null,
{
	jiggle: 3, 				// pixels the mouse can move in x or y and still be considered still
	still_time: 500,		// millisecs mouse must be still
	monitoredNode: null,	// the node I'm attached to and monitoring for a hovering mouse
	_x0: -1,				// the starting point and time
	_y0: -1,
	_t0: -1,
	_moveHandler: null,		// dojo.hitch(this, "_onmousemove") and save the result
	_onHoverHandler: null,	// dojo.hitch(this, "_onHover") and save the result
	_connHandles: null,		// event connection handles
	_move_connHandle: null,	// the connection handle for mousemove - gets connected and disconnedted a lot
	_timer: -1,				// the window.setTimeout timer ID
	_data: null,			// holds user-supplied data that might be needed in an onHover handler

	/*
	** create a new Hoverer
	** node: the DOM node we're waiting for the mouse to hover over
	** delay: optional, milliseconds the mouse must sit still to trigger OnHover
	**           defaults to 500ms.
	*/
	constructor: function(/*int?*/delay) 
	{
		//console.log("Hoverer.ctor");
		if( !isNaN(delay) ) {
			this.still_time = delay
		}
		this._connHandles = [];
		this._data = new Object();
	},
	/*
	** Call destroy when you're finished with this Hoverer to disconnect internal event handlers
	*/
	destroy: function()
	{
		//console.log("Hoverer.destroy");
		this._disconnectNode();
	},
	/*
	** Give the Hoverer a DOM node to monitor
	*/
	setDOMNode: function(/*DOM node*/node)
	{
		//console.log("Hoverer.setNode(%o)", node);
		if(this.monitoredNode) {
			this._disconnectNode();
		}
		this.monitoredNode = node;
		if(node) {
			this._connHandles.push(dojo.connect(this.monitoredNode, "onmouseover", this, "_onmouseover"));
			this._connHandles.push(dojo.connect(this.monitoredNode, "onmouseout",  this, "_onmouseout"));
		}
	},
	getDOMNode: function()
	{
		return this.monitoredNode;
	},
	/*
	** OnHover gets passed a copy of this
	** if there's data you need in your handler, 
	** use setData to store it here
	*/
	setData: function(/*string*/name, /*any*/value)
	{
		this._data[name] = value;
	},
	/*
	** retrieve data stored with setData
	*/
	getData: function(/*string*/name)
	{
		return this._data[name];	// could be undefined
	},
	/*
	** Start watching for the mouse to hover over my monitored DOM node
	** Since Hoverer starts monitoring onmouseover, call connect if you set the 
	** monitored node from it's onmouseover or onclick and you want to start immediatly
	**
	** evt: optional, the DOM event passed into your onmouseover or onclick event
	**
	*/
	connect: function(evt)
	{
		//console.log("Hoverer.connect");
		this._hook();
		this._restart(evt);
	},
	/********** internal helpers ****************/
	_disconnectNode: function()
	{
		//console.log("Hoverer._disconnectNode");
		this._unhook();
		this._clear();
		var c;
		while(c = this._connHandles.pop()) {
			dojo.disconnect(c);
		}
		this.monitoredNode = null;
	},
	_hook: function()
	{
		//console.log("Hoverer._hook(%o)", this.monitoredNode);
		if(this._moveHandler == null) {
			this._moveHandler = dojo.hitch(this, "_onmousemove");
			this._onHoverHandler = dojo.hitch(this, "_fire_onHover");
		}
		if(this._move_connHandle == null) {
			this._move_connHandle = dojo.connect(this.monitoredNode, "onmousemove", null, this._moveHandler);
		}
	},
	_unhook: function()
	{
		//console.log("Hoverer._unhook(%o)", this.monitoredNode);
		if(this._move_connHandle) {
			dojo.disconnect(this._move_connHandle);
			this._move_connHandle = null;
		}
	},
	/*** internal mouse event handlers ***/
	_onmouseover: function(evt)
	{
		this._hook();
	},
	_onmouseout: function(evt)
	{
		this._clear();
		this._unhook();
	},
	_onmousemove: function(evt)
	{
		//console.log("Hoverer._onmousemove: (%d)", evt.timeStamp);
		// ignore it if the mouse moves just a tiny bit
		if(this._t0 > 0 &&
		   Math.abs(evt.clientX - this._t0) < this.jiggle &&
		   Math.abs(evt.clientY - this._t0) < this.jiggle)
		{
			//console.log("Hoverer._onmousemove: looking good: (%d, %d)", evt.clientX, evt.clientY);

			// the mouse has moved a tiny bit.  Check to see if we've been
			// here long enough to be hovering
			if(evt.timeStamp - this._t0 >= this.still_time) {
				// ta da
				if(this._timer) {
					window.clearTimeout(this._timer);
					this._timer = -1;
				}
				this._fire_onHover();
				this._restart(evt);
			}
		}
		else {
			this._restart(evt);
		}
	},
	/*
	** start over
	*/
	_restart: function(evt)
	{
		//console.log("Hoverer._restart");
		this._clear();
		this._t0 = evt.timeStamp;
		this._x0 = evt.clientX;
		this._y0 = evt.clientY;
		this._timer = window.setTimeout(this._onHoverHandler, this.still_time);
	},
	/*
	** clear the internal timer
	*/
	_clear: function()
	{
		//console.log("Hoverer._clear");
		if(this._timer > 0) {
			window.clearTimeout(this._timer);
		}
		this._timer = this._t0 = this._x0 = this._y0 = -1;
	},
	/*
	** fire the OnHover event, passing this Hoverer to handlers
	*/
	_fire_onHover: function()
	{
		try {
			this.OnHover(this);
		}
		catch(ex) {
			new ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError(ex);
			console.error("An error occured handling Hoverer.OnHover: ", ex);
		}
	},
	/*
	** override, or use dojo.connect to handle OnHover
	*/
	OnHover: function(hoverer)
	{
		//console.log("***** you are hovering *****");
	}
});


});

},
'dijit/form/ComboButton':function(){
require({cache:{
'url:dijit/form/templates/ComboButton.html':"<table class=\"dijit dijitReset dijitInline dijitLeft\"\n\tcellspacing='0' cellpadding='0' role=\"presentation\"\n\t><tbody role=\"presentation\"><tr role=\"presentation\"\n\t\t><td class=\"dijitReset dijitStretch dijitButtonNode\" data-dojo-attach-point=\"buttonNode\" data-dojo-attach-event=\"ondijitclick:_onClick,onkeypress:_onButtonKeyPress\"\n\t\t><div id=\"${id}_button\" class=\"dijitReset dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><div class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitInline dijitButtonText\" id=\"${id}_label\" data-dojo-attach-point=\"containerNode\" role=\"presentation\"></div\n\t\t></div\n\t\t></td\n\t\t><td id=\"${id}_arrow\" class='dijitReset dijitRight dijitButtonNode dijitArrowButton'\n\t\t\tdata-dojo-attach-point=\"_popupStateNode,focusNode,_buttonNode\"\n\t\t\tdata-dojo-attach-event=\"onkeypress:_onArrowKeyPress\"\n\t\t\ttitle=\"${optionsTitle}\"\n\t\t\trole=\"button\" aria-haspopup=\"true\"\n\t\t\t><div class=\"dijitReset dijitArrowButtonInner\" role=\"presentation\"></div\n\t\t\t><div class=\"dijitReset dijitArrowButtonChar\" role=\"presentation\">&#9660;</div\n\t\t></td\n\t\t><td style=\"display:none !important;\"\n\t\t\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" data-dojo-attach-point=\"valueNode\"\n\t\t/></td></tr></tbody\n></table>\n"}});
define("dijit/form/ComboButton", [
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"../focus",		// focus.focus()
	"./DropDownButton",
	"dojo/text!./templates/ComboButton.html"
], function(declare, event, keys, focus, DropDownButton, template){

/*=====
	var DropDownButton = dijit.form.DropDownButton;
=====*/

// module:
//		dijit/form/ComboButton
// summary:
//		A combination button and drop-down button.

return declare("dijit.form.ComboButton", DropDownButton, {
	// summary:
	//		A combination button and drop-down button.
	//		Users can click one side to "press" the button, or click an arrow
	//		icon to display the drop down.
	//
	// example:
	// |	<button data-dojo-type="dijit.form.ComboButton" onClick="...">
	// |		<span>Hello world</span>
	// |		<div data-dojo-type="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
	// |	dojo.body().appendChild(button1.domNode);
	//

	templateString: template,

	// Map widget attributes to DOMNode attributes.
	_setIdAttr: "",	// override _FormWidgetMixin which puts id on the focusNode
	_setTabIndexAttr: ["focusNode", "titleNode"],
	_setTitleAttr: "titleNode",

	// optionsTitle: String
	//		Text that describes the options menu (accessibility)
	optionsTitle: "",

	baseClass: "dijitComboButton",

	// Set classes like dijitButtonContentsHover or dijitArrowButtonActive depending on
	// mouse action over specified node
	cssStateNodes: {
		"buttonNode": "dijitButtonNode",
		"titleNode": "dijitButtonContents",
		"_popupStateNode": "dijitDownArrowButton"
	},

	_focusedNode: null,

	_onButtonKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for right arrow key when focus is on left part of button
		if(evt.charOrCode == keys[this.isLeftToRight() ? "RIGHT_ARROW" : "LEFT_ARROW"]){
			focus.focus(this._popupStateNode);
			event.stop(evt);
		}
	},

	_onArrowKeyPress: function(/*Event*/ evt){
		// summary:
		//		Handler for left arrow key when focus is on right part of button
		if(evt.charOrCode == keys[this.isLeftToRight() ? "LEFT_ARROW" : "RIGHT_ARROW"]){
			focus.focus(this.titleNode);
			event.stop(evt);
		}
	},

	focus: function(/*String*/ position){
		// summary:
		//		Focuses this widget to according to position, if specified,
		//		otherwise on arrow node
		// position:
		//		"start" or "end"
		if(!this.disabled){
			focus.focus(position == "start" ? this.titleNode : this._popupStateNode);
		}
	}
});

});

},
'ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable':function(){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

/*
 * Message IDs are formed as CTJZHxxxxY where xxxx is the 4-digit
 * range of the functional component and Y is one of E, W, or I.
 * For the Web UI, the range is 2300-2999.
 */

define({ root:
{
	dummy_: ""
},
"en": true,
"zh": true,
"zh-tw": true,
"tr": true,
"th": true,
"sv": true,
"sl": true,
"sk": true,
"ru": true,
"ro": true,
"pt": true,
"pt-pt": true,
"pl": true,
"nl": true,
"nb": true,
"ko": true,
"kk": true,
"ja": true,
"it": true,
"hu": true,
"hr": true,
"he": true,
"fr": true,
"fi": true,
"es": true,
"el": true,
"de": true,
"da": true,
"cs": true,
"ca": true,
"az": true,
"ar": true
});

},
'dijit/form/_AutoCompleterMixin':function(){
define("dijit/form/_AutoCompleterMixin", [
	"dojo/_base/connect", // keys keys.SHIFT
	"dojo/data/util/filter", // patternToRegExp
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred.when
	"dojo/dom-attr", // domAttr.get
	"dojo/_base/event", // event.stop
	"dojo/keys",
	"dojo/_base/lang", // lang.clone lang.hitch
	"dojo/query", // query
	"dojo/regexp", // regexp.escapeString
	"dojo/_base/sniff", // has("ie")
	"dojo/string", // string.substitute
	"dojo/_base/window", // win.doc.selection.createRange
	"./DataList",
	"../registry",	// registry.byId
	"./_TextBoxMixin"	// defines _TextBoxMixin.selectInputText
], function(connect, filter, declare, Deferred, domAttr, event, keys, lang, query, regexp, has, string, win,
			DataList, registry, _TextBoxMixin){

	// module:
	//		dijit/form/_AutoCompleterMixin
	// summary:
	//		A mixin that implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`


	return declare("dijit.form._AutoCompleterMixin", null, {
		// summary:
		//		A mixin that implements the base functionality for `dijit.form.ComboBox`/`dijit.form.FilteringSelect`
		// description:
		//		All widgets that mix in dijit.form._AutoCompleterMixin must extend `dijit.form._FormValueWidget`.
		// tags:
		//		protected

		// item: Object
		//		This is the item returned by the dojo.data.store implementation that
		//		provides the data for this ComboBox, it's the currently selected item.
		item: null,

		// pageSize: Integer
		//		Argument to data provider.
		//		Specifies number of search results per page (before hitting "next" button)
		pageSize: Infinity,

		// store: [const] dojo.store.api.Store
		//		Reference to data provider object used by this ComboBox
		store: null,

		// fetchProperties: Object
		//		Mixin to the store's fetch.
		//		For example, to set the sort order of the ComboBox menu, pass:
		//	|	{ sort: [{attribute:"name",descending: true}] }
		//		To override the default queryOptions so that deep=false, do:
		//	|	{ queryOptions: {ignoreCase: true, deep: false} }
		fetchProperties:{},

		// query: Object
		//		A query that can be passed to 'store' to initially filter the items,
		//		before doing further filtering based on `searchAttr` and the key.
		//		Any reference to the `searchAttr` is ignored.
		query: {},

		// autoComplete: Boolean
		//		If user types in a partial string, and then tab out of the `<input>` box,
		//		automatically copy the first entry displayed in the drop down list to
		//		the `<input>` field
		autoComplete: true,

		// highlightMatch: String
		// 		One of: "first", "all" or "none".
		//
		//		If the ComboBox/FilteringSelect opens with the search results and the searched
		//		string can be found, it will be highlighted.  If set to "all"
		//		then will probably want to change `queryExpr` parameter to '*${0}*'
		//
		//		Highlighting is only performed when `labelType` is "text", so as to not
		//		interfere with any HTML markup an HTML label might contain.
		highlightMatch: "first",

		// searchDelay: Integer
		//		Delay in milliseconds between when user types something and we start
		//		searching based on that value
		searchDelay: 100,

		// searchAttr: String
		//		Search for items in the data store where this attribute (in the item)
		//		matches what the user typed
		searchAttr: "name",

		// labelAttr: String?
		//		The entries in the drop down list come from this attribute in the
		//		dojo.data items.
		//		If not specified, the searchAttr attribute is used instead.
		labelAttr: "",

		// labelType: String
		//		Specifies how to interpret the labelAttr in the data store items.
		//		Can be "html" or "text".
		labelType: "text",

		// queryExpr: String
		//		This specifies what query ComboBox/FilteringSelect sends to the data store,
		//		based on what the user has typed.  Changing this expression will modify
		//		whether the drop down shows only exact matches, a "starting with" match,
		//		etc.  Use it in conjunction with highlightMatch.
		//		dojo.data query expression pattern.
		//		`${0}` will be substituted for the user text.
		//		`*` is used for wildcards.
		//		`${0}*` means "starts with", `*${0}*` means "contains", `${0}` means "is"
		queryExpr: "${0}*",

		// ignoreCase: Boolean
		//		Set true if the ComboBox/FilteringSelect should ignore case when matching possible items
		ignoreCase: true,

		// Flags to _HasDropDown to limit height of drop down to make it fit in viewport
		maxHeight: -1,

		// For backwards compatibility let onClick events propagate, even clicks on the down arrow button
		_stopClickEvents: false,

		_getCaretPos: function(/*DomNode*/ element){
			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
			var pos = 0;
			if(typeof(element.selectionStart) == "number"){
				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
				pos = element.selectionStart;
			}else if(has("ie")){
				// in the case of a mouse click in a popup being handled,
				// then the win.doc.selection is not the textarea, but the popup
				// var r = win.doc.selection.createRange();
				// hack to get IE 6 to play nice. What a POS browser.
				var tr = win.doc.selection.createRange().duplicate();
				var ntr = element.createTextRange();
				tr.move("character",0);
				ntr.move("character",0);
				try{
					// If control doesn't have focus, you get an exception.
					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
					// There appears to be no workaround for this - googled for quite a while.
					ntr.setEndPoint("EndToEnd", tr);
					pos = String(ntr.text).replace(/\r/g,"").length;
				}catch(e){
					// If focus has shifted, 0 is fine for caret pos.
				}
			}
			return pos;
		},

		_setCaretPos: function(/*DomNode*/ element, /*Number*/ location){
			location = parseInt(location);
			_TextBoxMixin.selectInputText(element, location, location);
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			// Additional code to set disabled state of ComboBox node.
			// Overrides _FormValueWidget._setDisabledAttr() or ValidationTextBox._setDisabledAttr().
			this.inherited(arguments);
			this.domNode.setAttribute("aria-disabled", value);
		},

		_abortQuery: function(){
			// stop in-progress query
			if(this.searchTimer){
				clearTimeout(this.searchTimer);
				this.searchTimer = null;
			}
			if(this._fetchHandle){
				if(this._fetchHandle.cancel){
					this._cancelingQuery = true;
					this._fetchHandle.cancel();
					this._cancelingQuery = false;
				}
				this._fetchHandle = null;
			}
		},

		_onInput: function(/*Event*/ evt){
			// summary:
			//		Handles paste events
			this.inherited(arguments);
			if(evt.charOrCode == 229){ // IME or cut/paste event
				this._onKey(evt);
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles keyboard events

			var key = evt.charOrCode;

			// except for cutting/pasting case - ctrl + x/v
			if(evt.altKey || ((evt.ctrlKey || evt.metaKey) && (key != 'x' && key != 'v')) || key == keys.SHIFT){
				return; // throw out weird key combinations and spurious events
			}

			var doSearch = false;
			var pw = this.dropDown;
			var highlighted = null;
			this._prev_key_backspace = false;
			this._abortQuery();

			// _HasDropDown will do some of the work:
			//		1. when drop down is not yet shown:
			//			- if user presses the down arrow key, call loadDropDown()
			//		2. when drop down is already displayed:
			//			- on ESC key, call closeDropDown()
			//			- otherwise, call dropDown.handleKey() to process the keystroke
			this.inherited(arguments);

			if(this._opened){
				highlighted = pw.getHighlightedOption();
			}
			switch(key){
				case keys.PAGE_DOWN:
				case keys.DOWN_ARROW:
				case keys.PAGE_UP:
				case keys.UP_ARROW:
					// Keystroke caused ComboBox_menu to move to a different item.
					// Copy new item to <input> box.
					if(this._opened){
						this._announceOption(highlighted);
					}
					event.stop(evt);
					break;

				case keys.ENTER:
					// prevent submitting form if user presses enter. Also
					// prevent accepting the value if either Next or Previous
					// are selected
					if(highlighted){
						// only stop event on prev/next
						if(highlighted == pw.nextButton){
							this._nextSearch(1);
							event.stop(evt);
							break;
						}else if(highlighted == pw.previousButton){
							this._nextSearch(-1);
							event.stop(evt);
							break;
						}
					}else{
						// Update 'value' (ex: KY) according to currently displayed text
						this._setBlurValue(); // set value if needed
						this._setCaretPos(this.focusNode, this.focusNode.value.length); // move cursor to end and cancel highlighting
					}
					// default case:
					// if enter pressed while drop down is open, or for FilteringSelect,
					// if we are in the middle of a query to convert a directly typed in value to an item,
					// prevent submit
					if(this._opened || this._fetchHandle){
						event.stop(evt);
					}
					// fall through

				case keys.TAB:
					var newvalue = this.get('displayedValue');
					//	if the user had More Choices selected fall into the
					//	_onBlur handler
					if(pw && (
						newvalue == pw._messages["previousMessage"] ||
						newvalue == pw._messages["nextMessage"])
					){
						break;
					}
					if(highlighted){
						this._selectOption(highlighted);
					}
					// fall through

				case keys.ESCAPE:
					if(this._opened){
						this._lastQuery = null; // in case results come back later
						this.closeDropDown();
					}
					break;

				case ' ':
					if(highlighted){
						// user is effectively clicking a choice in the drop down menu
						event.stop(evt);
						this._selectOption(highlighted);
						this.closeDropDown();
					}else{
						// user typed a space into the input box, treat as normal character
						doSearch = true;
					}
					break;

				case keys.DELETE:
				case keys.BACKSPACE:
					this._prev_key_backspace = true;
					doSearch = true;
					break;

				default:
					// Non char keys (F1-F12 etc..)  shouldn't open list.
					// Ascii characters and IME input (Chinese, Japanese etc.) should.
					//IME input produces keycode == 229.
					doSearch = typeof key == 'string' || key == 229;
			}
			if(doSearch){
				// need to wait a tad before start search so that the event
				// bubbles through DOM and we have value visible
				this.item = undefined; // undefined means item needs to be set
				this.searchTimer = setTimeout(lang.hitch(this, "_startSearchFromInput"),1);
			}
		},

		_autoCompleteText: function(/*String*/ text){
			// summary:
			// 		Fill in the textbox with the first item from the drop down
			// 		list, and highlight the characters that were
			// 		auto-completed. For example, if user typed "CA" and the
			// 		drop down list appeared, the textbox would be changed to
			// 		"California" and "ifornia" would be highlighted.

			var fn = this.focusNode;

			// IE7: clear selection so next highlight works all the time
			_TextBoxMixin.selectInputText(fn, fn.value.length);
			// does text autoComplete the value in the textbox?
			var caseFilter = this.ignoreCase? 'toLowerCase' : 'substr';
			if(text[caseFilter](0).indexOf(this.focusNode.value[caseFilter](0)) == 0){
				var cpos = this.autoComplete ? this._getCaretPos(fn) : fn.value.length;
				// only try to extend if we added the last character at the end of the input
				if((cpos+1) > fn.value.length){
					// only add to input node as we would overwrite Capitalisation of chars
					// actually, that is ok
					fn.value = text;//.substr(cpos);
					// visually highlight the autocompleted characters
					_TextBoxMixin.selectInputText(fn, cpos);
				}
			}else{
				// text does not autoComplete; replace the whole value and highlight
				fn.value = text;
				_TextBoxMixin.selectInputText(fn);
			}
		},

		_openResultList: function(/*Object*/ results, /*Object*/ query, /*Object*/ options){
			// summary:
			//		Callback when a search completes.
			// description:
			//		1. generates drop-down list and calls _showResultList() to display it
			//		2. if this result list is from user pressing "more choices"/"previous choices"
			//			then tell screen reader to announce new option
			this._fetchHandle = null;
			if(	this.disabled ||
				this.readOnly ||
				(query[this.searchAttr] !== this._lastQuery)	// TODO: better way to avoid getting unwanted notify
			){
				return;
			}
			var wasSelected = this.dropDown.getHighlightedOption();
			this.dropDown.clearResultList();
			if(!results.length && options.start == 0){ // if no results and not just the previous choices button
				this.closeDropDown();
				return;
			}

			// Fill in the textbox with the first item from the drop down list,
			// and highlight the characters that were auto-completed. For
			// example, if user typed "CA" and the drop down list appeared, the
			// textbox would be changed to "California" and "ifornia" would be
			// highlighted.

			var nodes = this.dropDown.createOptions(
				results,
				options,
				lang.hitch(this, "_getMenuLabelFromItem")
			);

			// show our list (only if we have content, else nothing)
			this._showResultList();

			// #4091:
			//		tell the screen reader that the paging callback finished by
			//		shouting the next choice
			if(options.direction){
				if(1 == options.direction){
					this.dropDown.highlightFirstOption();
				}else if(-1 == options.direction){
					this.dropDown.highlightLastOption();
				}
				if(wasSelected){
					this._announceOption(this.dropDown.getHighlightedOption());
				}
			}else if(this.autoComplete && !this._prev_key_backspace
				// when the user clicks the arrow button to show the full list,
				// startSearch looks for "*".
				// it does not make sense to autocomplete
				// if they are just previewing the options available.
				&& !/^[*]+$/.test(query[this.searchAttr].toString())){
					this._announceOption(nodes[1]); // 1st real item
			}
		},

		_showResultList: function(){
			// summary:
			//		Display the drop down if not already displayed, or if it is displayed, then
			//		reposition it if necessary (reposition may be necessary if drop down's height changed).
			this.closeDropDown(true);
			this.openDropDown();
			this.domNode.setAttribute("aria-expanded", "true");
		},

		loadDropDown: function(/*Function*/ /*===== callback =====*/){
			// Overrides _HasDropDown.loadDropDown().
			// This is called when user has pressed button icon or pressed the down arrow key
			// to open the drop down.

			this._startSearchAll();
		},

		isLoaded: function(){
			// signal to _HasDropDown that it needs to call loadDropDown() to load the
			// drop down asynchronously before displaying it
			return false;
		},

		closeDropDown: function(){
			// Overrides _HasDropDown.closeDropDown().  Closes the drop down (assuming that it's open).
			// This method is the callback when the user types ESC or clicking
			// the button icon while the drop down is open.  It's also called by other code.
			this._abortQuery();
			if(this._opened){
				this.inherited(arguments);
				this.domNode.setAttribute("aria-expanded", "false");
				this.focusNode.removeAttribute("aria-activedescendant");
			}
		},

		_setBlurValue: function(){
			// if the user clicks away from the textbox OR tabs away, set the
			// value to the textbox value
			// #4617:
			//		if value is now more choices or previous choices, revert
			//		the value
			var newvalue = this.get('displayedValue');
			var pw = this.dropDown;
			if(pw && (
				newvalue == pw._messages["previousMessage"] ||
				newvalue == pw._messages["nextMessage"]
				)
			){
				this._setValueAttr(this._lastValueReported, true);
			}else if(typeof this.item == "undefined"){
				// Update 'value' (ex: KY) according to currently displayed text
				this.item = null;
				this.set('displayedValue', newvalue);
			}else{
				if(this.value != this._lastValueReported){
					this._handleOnChange(this.value, true);
				}
				this._refreshState();
			}
		},

		_setItemAttr: function(/*item*/ item, /*Boolean?*/ priorityChange, /*String?*/ displayedValue){
			// summary:
			//		Set the displayed valued in the input box, and the hidden value
			//		that gets submitted, based on a dojo.data store item.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('item', value)
			// tags:
			//		private
			var value = '';
			if(item){
				if(!displayedValue){
					displayedValue = this.store._oldAPI ?	// remove getValue() for 2.0 (old dojo.data API)
						this.store.getValue(item, this.searchAttr) : item[this.searchAttr];
				}
				value = this._getValueField() != this.searchAttr ? this.store.getIdentity(item) : displayedValue;
			}
			this.set('value', value, priorityChange, displayedValue, item);
		},

		_announceOption: function(/*Node*/ node){
			// summary:
			//		a11y code that puts the highlighted option in the textbox.
			//		This way screen readers will know what is happening in the
			//		menu.

			if(!node){
				return;
			}
			// pull the text value from the item attached to the DOM node
			var newValue;
			if(node == this.dropDown.nextButton ||
				node == this.dropDown.previousButton){
				newValue = node.innerHTML;
				this.item = undefined;
				this.value = '';
			}else{
				newValue = (this.store._oldAPI ? 	// remove getValue() for 2.0 (old dojo.data API)
					this.store.getValue(node.item, this.searchAttr) : node.item[this.searchAttr]).toString();
				this.set('item', node.item, false, newValue);
			}
			// get the text that the user manually entered (cut off autocompleted text)
			this.focusNode.value = this.focusNode.value.substring(0, this._lastInput.length);
			// set up ARIA activedescendant
			this.focusNode.setAttribute("aria-activedescendant", domAttr.get(node, "id"));
			// autocomplete the rest of the option to announce change
			this._autoCompleteText(newValue);
		},

		_selectOption: function(/*DomNode*/ target){
			// summary:
			//		Menu callback function, called when an item in the menu is selected.
			this.closeDropDown();
			if(target){
				this._announceOption(target);
			}
			this._setCaretPos(this.focusNode, this.focusNode.value.length);
			this._handleOnChange(this.value, true);
		},

		_startSearchAll: function(){
			this._startSearch('');
		},

		_startSearchFromInput: function(){
			this._startSearch(this.focusNode.value.replace(/([\\\*\?])/g, "\\$1"));
		},

		_getQueryString: function(/*String*/ text){
			return string.substitute(this.queryExpr, [text]);
		},

		_startSearch: function(/*String*/ key){
			// summary:
			//		Starts a search for elements matching key (key=="" means to return all items),
			//		and calls _openResultList() when the search completes, to display the results.
			if(!this.dropDown){
				var popupId = this.id + "_popup",
					dropDownConstructor = lang.isString(this.dropDownClass) ?
						lang.getObject(this.dropDownClass, false) : this.dropDownClass;
				this.dropDown = new dropDownConstructor({
					onChange: lang.hitch(this, this._selectOption),
					id: popupId,
					dir: this.dir,
					textDir: this.textDir
				});
				this.focusNode.removeAttribute("aria-activedescendant");
				this.textbox.setAttribute("aria-owns",popupId); // associate popup with textbox
			}
			this._lastInput = key; // Store exactly what was entered by the user.

			// Setup parameters to be passed to store.query().
			// Create a new query to prevent accidentally querying for a hidden
			// value from FilteringSelect's keyField
			var query = lang.clone(this.query); // #5970
			var options = {
				start: 0,
				count: this.pageSize,
				queryOptions: {		// remove for 2.0
					ignoreCase: this.ignoreCase,
					deep: true
				}
			};
			lang.mixin(options, this.fetchProperties);

			// Generate query
			var qs = this._getQueryString(key), q;
			if(this.store._oldAPI){
				// remove this branch for 2.0
				q = qs;
			}else{
				// Query on searchAttr is a regex for benefit of dojo.store.Memory,
				// but with a toString() method to help dojo.store.JsonRest.
				// Search string like "Co*" converted to regex like /^Co.*$/i.
				q = filter.patternToRegExp(qs, this.ignoreCase);
				q.toString = function(){ return qs; };
			}
			this._lastQuery = query[this.searchAttr] = q;

			// Function to run the query, wait for the results, and then call _openResultList()
			var _this = this,
				startQuery = function(){
					var resPromise = _this._fetchHandle = _this.store.query(query, options);
					Deferred.when(resPromise, function(res){
						_this._fetchHandle = null;
						res.total = resPromise.total;
						_this._openResultList(res, query, options);
					}, function(err){
						_this._fetchHandle = null;
						if(!_this._cancelingQuery){	// don't treat canceled query as an error
							console.error(_this.declaredClass + ' ' + err.toString());
							_this.closeDropDown();
						}
					});
				};

			// #5970: set _lastQuery, *then* start the timeout
			// otherwise, if the user types and the last query returns before the timeout,
			// _lastQuery won't be set and their input gets rewritten

			this.searchTimer = setTimeout(lang.hitch(this, function(query, _this){
				this.searchTimer = null;

				startQuery();

				// Setup method to handle clicking next/previous buttons to page through results
				this._nextSearch = this.dropDown.onPage = function(direction){
					options.start += options.count * direction;
					//	tell callback the direction of the paging so the screen
					//	reader knows which menu option to shout
					options.direction = direction;
					startQuery();
					_this.focus();
				};
			}, query, this), this.searchDelay);
		},

		_getValueField: function(){
			// summary:
			//		Helper for postMixInProperties() to set this.value based on data inlined into the markup.
			//		Returns the attribute name in the item (in dijit.form._ComboBoxDataStore) to use as the value.
			return this.searchAttr;
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.query={};
			this.fetchProperties={};
		},

		postMixInProperties: function(){
			if(!this.store){
				var srcNodeRef = this.srcNodeRef;
				var list = this.list;
				if(list){
					this.store = registry.byId(list);
				}else{
					// if user didn't specify store, then assume there are option tags
					this.store = new DataList({}, srcNodeRef);
				}

				// if there is no value set and there is an option list, set
				// the value to the first value to be consistent with native Select
				// Firefox and Safari set value
				// IE6 and Opera set selectedIndex, which is automatically set
				// by the selected attribute of an option tag
				// IE6 does not set value, Opera sets value = selectedIndex
				if(!("value" in this.params)){
					var item = (this.item = this.store.fetchSelectedItem());
					if(item){
						var valueField = this._getValueField();
						// remove getValue() for 2.0 (old dojo.data API)
						this.value = this.store._oldAPI ? this.store.getValue(item, valueField) : item[valueField];
					}
				}
			}

			this.inherited(arguments);
		},

		postCreate: function(){
			// summary:
			//		Subclasses must call this method from their postCreate() methods
			// tags:
			//		protected

			// find any associated label element and add to ComboBox node.
			var label=query('label[for="'+this.id+'"]');
			if(label.length){
				label[0].id = (this.id+"_label");
				this.domNode.setAttribute("aria-labelledby", label[0].id);

			}
			this.inherited(arguments);
		},

		_getMenuLabelFromItem: function(/*Item*/ item){
			var label = this.labelFunc(item, this.store),
				labelType = this.labelType;
			// If labelType is not "text" we don't want to screw any markup ot whatever.
			if(this.highlightMatch != "none" && this.labelType == "text" && this._lastInput){
				label = this.doHighlight(label, this._escapeHtml(this._lastInput));
				labelType = "html";
			}
			return {html: labelType == "html", label: label};
		},

		doHighlight: function(/*String*/ label, /*String*/ find){
			// summary:
			//		Highlights the string entered by the user in the menu.  By default this
			//		highlights the first occurrence found. Override this method
			//		to implement your custom highlighting.
			// tags:
			//		protected

			var
				// Add (g)lobal modifier when this.highlightMatch == "all" and (i)gnorecase when this.ignoreCase == true
				modifiers = (this.ignoreCase ? "i" : "") + (this.highlightMatch == "all" ? "g" : ""),
				i = this.queryExpr.indexOf("${0}");
			find = regexp.escapeString(find); // escape regexp special chars
			return this._escapeHtml(label).replace(
				// prepend ^ when this.queryExpr == "${0}*" and append $ when this.queryExpr == "*${0}"
				new RegExp((i == 0 ? "^" : "") + "("+ find +")" + (i == (this.queryExpr.length - 4) ? "$" : ""), modifiers),
				'<span class="dijitComboBoxHighlightMatch">$1</span>'
			); // returns String, (almost) valid HTML (entities encoded)
		},

		_escapeHtml: function(/*String*/ str){
			// TODO Should become dojo.html.entities(), when exists use instead
			// summary:
			//		Adds escape sequences for special characters in XML: &<>"'
			str = String(str).replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
				.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;"); //balance"
			return str; // string
		},

		reset: function(){
			// Overrides the _FormWidget.reset().
			// Additionally reset the .item (to clean up).
			this.item = null;
			this.inherited(arguments);
		},

		labelFunc: function(/*item*/ item, /*dojo.store.api.Store*/ store){
			// summary:
			//		Computes the label to display based on the dojo.data store item.
			// returns:
			//		The label that the ComboBox should display
			// tags:
			//		private

			// Use toString() because XMLStore returns an XMLItem whereas this
			// method is expected to return a String (#9354).
			// Remove getValue() for 2.0 (old dojo.data API)
			return (store._oldAPI ? store.getValue(item, this.labelAttr || this.searchAttr) :
				item[this.labelAttr || this.searchAttr]).toString(); // String
		},

		_setValueAttr: function(/*String*/ value, /*Boolean?*/ priorityChange, /*String?*/ displayedValue, /*item?*/ item){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the select.
			this._set("item", item||null); // value not looked up in store
			if(!value){ value = ''; } // null translates to blank
			this.inherited(arguments);
		},
		_setTextDirAttr: function(/*String*/ textDir){
			// summary:
			//		Setter for textDir, needed for the dropDown's textDir update.
			// description:
			//		Users shouldn't call this function; they should be calling
			//		set('textDir', value)
			// tags:
			//		private
			this.inherited(arguments);
			// update the drop down also (_ComboBoxMenuMixin)
			if(this.dropDown){
				this.dropDown._set("textDir", textDir);
			}
		}
	});
});

},
'dojox/grid/Selection':function(){
define("dojox/grid/Selection", [
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/dom-attr"
], function(declare, array, lang, domAttr){

return declare("dojox.grid.Selection", null, {
	// summary:
	//		Manages row selection for grid. Owned by grid and used internally
	//		for selection. Override to implement custom selection.

	constructor: function(inGrid){
		this.grid = inGrid;
		this.selected = [];

		this.setMode(inGrid.selectionMode);
	},

	mode: 'extended',

	selected: null,
	updating: 0,
	selectedIndex: -1,

	setMode: function(mode){
		if(this.selected.length){
			this.deselectAll();
		}
		if(mode != 'extended' && mode != 'multiple' && mode != 'single' && mode != 'none'){
			this.mode = 'extended';
		}else{
			this.mode = mode;
		}
	},

	onCanSelect: function(inIndex){
		return this.grid.onCanSelect(inIndex);
	},

	onCanDeselect: function(inIndex){
		return this.grid.onCanDeselect(inIndex);
	},

	onSelected: function(inIndex){
	},

	onDeselected: function(inIndex){
	},

	//onSetSelected: function(inIndex, inSelect) { };
	onChanging: function(){
	},

	onChanged: function(){
	},

	isSelected: function(inIndex){
		if(this.mode == 'none'){
			return false;
		}
		return this.selected[inIndex];
	},

	getFirstSelected: function(){
		if(!this.selected.length||this.mode == 'none'){ return -1; }
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getNextSelected: function(inPrev){
		if(this.mode == 'none'){ return -1; }
		for(var i=inPrev+1, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				return i;
			}
		}
		return -1;
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(i);
			}
		}
		return result;
	},

	getSelectedCount: function(){
		var c = 0;
		for(var i=0; i<this.selected.length; i++){
			if(this.selected[i]){
				c++;
			}
		}
		return c;
	},

	_beginUpdate: function(){
		if(this.updating === 0){
			this.onChanging();
		}
		this.updating++;
	},

	_endUpdate: function(){
		this.updating--;
		if(this.updating === 0){
			this.onChanged();
		}
	},

	select: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(this.mode != 'multiple'){
			this.deselectAll(inIndex);
			this.addToSelection(inIndex);
		}else{
			this.toggleSelect(inIndex);
		}
	},

	addToSelection: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(lang.isArray(inIndex)){
			array.forEach(inIndex, this.addToSelection, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selected[inIndex]){
			this.selectedIndex = inIndex;
		}else{
			if(this.onCanSelect(inIndex) !== false){
				this.selectedIndex = inIndex;
				var rowNode = this.grid.getRowNode(inIndex);
				if(rowNode){
					domAttr.set(rowNode, "aria-selected", "true");
				}
				this._beginUpdate();
				this.selected[inIndex] = true;
				//this.grid.onSelected(inIndex);
				this.onSelected(inIndex);
				//this.onSetSelected(inIndex, true);
				this._endUpdate();
			}
		}
	},

	deselect: function(inIndex){
		if(this.mode == 'none'){ return; }
		if(lang.isArray(inIndex)){
			array.forEach(inIndex, this.deselect, this);
			return;
		}
		inIndex = Number(inIndex);
		if(this.selectedIndex == inIndex){
			this.selectedIndex = -1;
		}
		if(this.selected[inIndex]){
			if(this.onCanDeselect(inIndex) === false){
				return;
			}
			var rowNode = this.grid.getRowNode(inIndex);
			if(rowNode){
				domAttr.set(rowNode, "aria-selected", "false");
			}
			this._beginUpdate();
			delete this.selected[inIndex];
			//this.grid.onDeselected(inIndex);
			this.onDeselected(inIndex);
			//this.onSetSelected(inIndex, false);
			this._endUpdate();
		}
	},

	setSelected: function(inIndex, inSelect){
		this[(inSelect ? 'addToSelection' : 'deselect')](inIndex);
	},

	toggleSelect: function(inIndex){
		if(lang.isArray(inIndex)){
			array.forEach(inIndex, this.toggleSelect, this);
			return;
		}
		this.setSelected(inIndex, !this.selected[inIndex]);
	},

	_range: function(inFrom, inTo, func){
		var s = (inFrom >= 0 ? inFrom : inTo), e = inTo;
		if(s > e){
			e = s;
			s = inTo;
		}
		for(var i=s; i<=e; i++){
			func(i);
		}
	},

	selectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, lang.hitch(this, "addToSelection"));
	},

	deselectRange: function(inFrom, inTo){
		this._range(inFrom, inTo, lang.hitch(this, "deselect"));
	},

	insert: function(inIndex){
		this.selected.splice(inIndex, 0, false);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex++;
		}
	},

	remove: function(inIndex){
		this.selected.splice(inIndex, 1);
		if(this.selectedIndex >= inIndex){
			this.selectedIndex--;
		}
	},

	deselectAll: function(inExcept){
		for(var i in this.selected){
			if((i!=inExcept)&&(this.selected[i]===true)){
				this.deselect(i);
			}
		}
	},

	clickSelect: function(inIndex, inCtrlKey, inShiftKey){
		if(this.mode == 'none'){ return; }
		this._beginUpdate();
		if(this.mode != 'extended'){
			this.select(inIndex);
		}else{
			var lastSelected = this.selectedIndex;
			if(!inCtrlKey){
				this.deselectAll(inIndex);
			}
			if(inShiftKey){
				this.selectRange(lastSelected, inIndex);
			}else if(inCtrlKey){
				this.toggleSelect(inIndex);
			}else{
				this.addToSelection(inIndex);
			}
		}
		this._endUpdate();
	},

	clickSelectEvent: function(e){
		this.clickSelect(e.rowIndex, dojo.isCopyKey(e), e.shiftKey);
	},

	clear: function(){
		this._beginUpdate();
		this.deselectAll();
		this._endUpdate();
	}
});
});
},
'url:dijit/layout/templates/_ScrollingTabControllerButton.html':"<div data-dojo-attach-event=\"onclick:_onClick\">\n\t<div role=\"presentation\" class=\"dijitTabInnerDiv\" data-dojo-attach-point=\"innerDiv,focusNode\">\n\t\t<div role=\"presentation\" class=\"dijitTabContent dijitButtonContents\" data-dojo-attach-point=\"tabContent\">\n\t\t\t<img role=\"presentation\" alt=\"\" src=\"${_blankGif}\" class=\"dijitTabStripIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t\t<span data-dojo-attach-point=\"containerNode,titleNode\" class=\"dijitButtonText\"></span>\n\t\t</div>\n\t</div>\n</div>",
'dijit/form/ComboBoxMixin':function(){
require({cache:{
'url:dijit/form/templates/DropDownBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n"}});
define("dijit/form/ComboBoxMixin", [
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred",
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin
	"dojo/store/util/QueryResults",	// dojo.store.util.QueryResults
	"./_AutoCompleterMixin",
	"./_ComboBoxMenu",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownBox.html"
], function(declare, Deferred, kernel, lang, QueryResults, _AutoCompleterMixin, _ComboBoxMenu, _HasDropDown, template){

/*=====
	var _AutoCompleterMixin = dijit.form._AutoCompleterMixin;
	var _ComboBoxMenu = dijit.form._ComboBoxMenu;
	var _HasDropDown = dijit._HasDropDown;
=====*/

	// module:
	//		dijit/form/ComboBoxMixin
	// summary:
	//		Provides main functionality of ComboBox widget

	return declare("dijit.form.ComboBoxMixin", [_HasDropDown, _AutoCompleterMixin], {
		// summary:
		//		Provides main functionality of ComboBox widget

		// dropDownClass: [protected extension] Function String
		//		Dropdown widget class used to select a date/time.
		//		Subclasses should specify this.
		dropDownClass: _ComboBoxMenu,

		// hasDownArrow: Boolean
		//		Set this textbox to have a down arrow button, to display the drop down list.
		//		Defaults to true.
		hasDownArrow: true,

		templateString: template,

		baseClass: "dijitTextBox dijitComboBox",

		/*=====
		// store: [const] dojo.store.api.Store || dojo.data.api.Read
		//		Reference to data provider object used by this ComboBox.
		//
		//		Should be dojo.store.api.Store, but dojo.data.api.Read supported
		//		for backwards compatibility.
		store: null,
		=====*/

		// Set classes like dijitDownArrowButtonHover depending on
		// mouse action over button node
		cssStateNodes: {
			"_buttonNode": "dijitDownArrowButton"
		},

		_setHasDownArrowAttr: function(/*Boolean*/ val){
			this._set("hasDownArrow", val);
			this._buttonNode.style.display = val ? "" : "none";
		},

		_showResultList: function(){
			// hide the tooltip
			this.displayMessage("");
			this.inherited(arguments);
		},

		_setStoreAttr: function(store){
			// For backwards-compatibility, accept dojo.data store in addition to dojo.store.store.  Remove in 2.0.
			if(!store.get){
				lang.mixin(store, {
					_oldAPI: true,
					get: function(id){
						// summary:
						//		Retrieves an object by it's identity. This will trigger a fetchItemByIdentity.
						//		Like dojo.store.DataStore.get() except returns native item.
						var deferred = new Deferred();
						this.fetchItemByIdentity({
							identity: id,
							onItem: function(object){
								deferred.resolve(object);
							},
							onError: function(error){
								deferred.reject(error);
							}
						});
						return deferred.promise;
					},
					query: function(query, options){
						// summary:
						//		Queries the store for objects.   Like dojo.store.DataStore.query()
						//		except returned Deferred contains array of native items.
						var deferred = new Deferred(function(){ fetchHandle.abort && fetchHandle.abort(); });
						var fetchHandle = this.fetch(lang.mixin({
							query: query,
							onBegin: function(count){
								deferred.total = count;
							},
							onComplete: function(results){
								deferred.resolve(results);
							},
							onError: function(error){
								deferred.reject(error);
							}
						}, options));
						return QueryResults(deferred);
					}
				});
			}
			this._set("store", store);
		},

		postMixInProperties: function(){
			// Since _setValueAttr() depends on this.store, _setStoreAttr() needs to execute first.
			// Unfortunately, without special code, it ends up executing second.
			if(this.params.store){
				this._setStoreAttr(this.params.store);
			}

			this.inherited(arguments);

			// User may try to access this.store.getValue() etc.  in a custom labelFunc() function.
			// It's not available with the new data store for handling inline <option> tags, so add it.
			if(!this.params.store){
				var clazz = this.declaredClass;
				lang.mixin(this.store, {
					getValue: function(item, attr){
						kernel.deprecated(clazz + ".store.getValue(item, attr) is deprecated for builtin store.  Use item.attr directly", "", "2.0");
						return item[attr];
					},
					getLabel: function(item){
						kernel.deprecated(clazz + ".store.getLabel(item) is deprecated for builtin store.  Use item.label directly", "", "2.0");
						return item.name;
					},
					fetch: function(args){
						kernel.deprecated(clazz + ".store.fetch() is deprecated for builtin store.", "Use store.query()", "2.0");
						var shim = ["dojo/data/ObjectStore"];	// indirection so it doesn't get rolled into a build
						require(shim, lang.hitch(this, function(ObjectStore){
							new ObjectStore({objectStore: this}).fetch(args);
						}));
					}
				});
			}
		}
	});
});

},
'dijit/form/_TextBoxMixin':function(){
define("dijit/form/_TextBoxMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys.ALT keys.CAPS_LOCK keys.CTRL keys.META keys.SHIFT
	"dojo/_base/lang", // lang.mixin
	".."	// for exporting dijit._setSelectionRange, dijit.selectInputText
], function(array, declare, dom, event, keys, lang, dijit){

// module:
//		dijit/form/_TextBoxMixin
// summary:
//		A mixin for textbox form input widgets

var _TextBoxMixin = declare("dijit.form._TextBoxMixin", null, {
	// summary:
	//		A mixin for textbox form input widgets

	// trim: Boolean
	//		Removes leading and trailing whitespace if true.  Default is false.
	trim: false,

	// uppercase: Boolean
	//		Converts all characters to uppercase if true.  Default is false.
	uppercase: false,

	// lowercase: Boolean
	//		Converts all characters to lowercase if true.  Default is false.
	lowercase: false,

	// propercase: Boolean
	//		Converts the first character of each word to uppercase if true.
	propercase: false,

	// maxLength: String
	//		HTML INPUT tag maxLength declaration.
	maxLength: "",

	// selectOnClick: [const] Boolean
	//		If true, all text will be selected when focused with mouse
	selectOnClick: false,

	// placeHolder: String
	//		Defines a hint to help users fill out the input field (as defined in HTML 5).
	//		This should only contain plain text (no html markup).
	placeHolder: "",

	_getValueAttr: function(){
		// summary:
		//		Hook so get('value') works as we like.
		// description:
		//		For `dijit.form.TextBox` this basically returns the value of the <input>.
		//
		//		For `dijit.form.MappedTextBox` subclasses, which have both
		//		a "displayed value" and a separate "submit value",
		//		This treats the "displayed value" as the master value, computing the
		//		submit value from it via this.parse().
		return this.parse(this.get('displayedValue'), this.constraints);
	},

	_setValueAttr: function(value, /*Boolean?*/ priorityChange, /*String?*/ formattedValue){
		// summary:
		//		Hook so set('value', ...) works.
		//
		// description:
		//		Sets the value of the widget to "value" which can be of
		//		any type as determined by the widget.
		//
		// value:
		//		The visual element value is also set to a corresponding,
		//		but not necessarily the same, value.
		//
		// formattedValue:
		//		If specified, used to set the visual element value,
		//		otherwise a computed visual value is used.
		//
		// priorityChange:
		//		If true, an onChange event is fired immediately instead of
		//		waiting for the next blur event.

		var filteredValue;
		if(value !== undefined){
			// TODO: this is calling filter() on both the display value and the actual value.
			// I added a comment to the filter() definition about this, but it should be changed.
			filteredValue = this.filter(value);
			if(typeof formattedValue != "string"){
				if(filteredValue !== null && ((typeof filteredValue != "number") || !isNaN(filteredValue))){
					formattedValue = this.filter(this.format(filteredValue, this.constraints));
				}else{ formattedValue = ''; }
			}
		}
		if(formattedValue != null && formattedValue != undefined && ((typeof formattedValue) != "number" || !isNaN(formattedValue)) && this.textbox.value != formattedValue){
			this.textbox.value = formattedValue;
			this._set("displayedValue", this.get("displayedValue"));
		}

		if(this.textDir == "auto"){
			this.applyTextDir(this.focusNode, formattedValue);
		}

		this.inherited(arguments, [filteredValue, priorityChange]);
	},

	// displayedValue: String
	//		For subclasses like ComboBox where the displayed value
	//		(ex: Kentucky) and the serialized value (ex: KY) are different,
	//		this represents the displayed value.
	//
	//		Setting 'displayedValue' through set('displayedValue', ...)
	//		updates 'value', and vice-versa.  Otherwise 'value' is updated
	//		from 'displayedValue' periodically, like onBlur etc.
	//
	//		TODO: move declaration to MappedTextBox?
	//		Problem is that ComboBox references displayedValue,
	//		for benefit of FilteringSelect.
	displayedValue: "",

	_getDisplayedValueAttr: function(){
		// summary:
		//		Hook so get('displayedValue') works.
		// description:
		//		Returns the displayed value (what the user sees on the screen),
		// 		after filtering (ie, trimming spaces etc.).
		//
		//		For some subclasses of TextBox (like ComboBox), the displayed value
		//		is different from the serialized value that's actually
		//		sent to the server (see dijit.form.ValidationTextBox.serialize)

		// TODO: maybe we should update this.displayedValue on every keystroke so that we don't need
		// this method
		// TODO: this isn't really the displayed value when the user is typing
		return this.filter(this.textbox.value);
	},

	_setDisplayedValueAttr: function(/*String*/ value){
		// summary:
		//		Hook so set('displayedValue', ...) works.
		// description:
		//		Sets the value of the visual element to the string "value".
		//		The widget value is also set to a corresponding,
		//		but not necessarily the same, value.

		if(value === null || value === undefined){ value = '' }
		else if(typeof value != "string"){ value = String(value) }

		this.textbox.value = value;

		// sets the serialized value to something corresponding to specified displayedValue
		// (if possible), and also updates the textbox.value, for example converting "123"
		// to "123.00"
		this._setValueAttr(this.get('value'), undefined);

		this._set("displayedValue", this.get('displayedValue'));

		// textDir support
		if(this.textDir == "auto"){
			this.applyTextDir(this.focusNode, value);
		}
	},

	format: function(value /*=====, constraints =====*/){
		// summary:
		//		Replaceable function to convert a value to a properly formatted string.
		// value: String
		// constraints: Object
		// tags:
		//		protected extension
		return ((value == null || value == undefined) ? "" : (value.toString ? value.toString() : value));
	},

	parse: function(value /*=====, constraints =====*/){
		// summary:
		//		Replaceable function to convert a formatted string to a value
		// value: String
		// constraints: Object
		// tags:
		//		protected extension

		return value;	// String
	},

	_refreshState: function(){
		// summary:
		//		After the user types some characters, etc., this method is
		//		called to check the field for validity etc.  The base method
		//		in `dijit.form.TextBox` does nothing, but subclasses override.
		// tags:
		//		protected
	},

	/*=====
	onInput: function(event){
		// summary:
		//		Connect to this function to receive notifications of various user data-input events.
		//		Return false to cancel the event and prevent it from being processed.
		// event:
		//		keydown | keypress | cut | paste | input
		// tags:
		//		callback
	},
	=====*/
	onInput: function(){},

	__skipInputEvent: false,
	_onInput: function(){
		// summary:
		//		Called AFTER the input event has happened
		// set text direction according to textDir that was defined in creation
		if(this.textDir == "auto"){
			this.applyTextDir(this.focusNode, this.focusNode.value);
		}

		this._refreshState();

		// In case someone is watch()'ing for changes to displayedValue
		this._set("displayedValue", this.get("displayedValue"));
	},

	postCreate: function(){
		// setting the value here is needed since value="" in the template causes "undefined"
		// and setting in the DOM (instead of the JS object) helps with form reset actions
		this.textbox.setAttribute("value", this.textbox.value); // DOM and JS values should be the same

		this.inherited(arguments);

		// normalize input events to reduce spurious event processing
		//	onkeydown: do not forward modifier keys
		//	           set charOrCode to numeric keycode
		//	onkeypress: do not forward numeric charOrCode keys (already sent through onkeydown)
		//	onpaste & oncut: set charOrCode to 229 (IME)
		//	oninput: if primary event not already processed, set charOrCode to 229 (IME), else do not forward
		var handleEvent = function(e){
			var charCode = e.charOrCode || e.keyCode || 229;
			if(e.type == "keydown"){
				switch(charCode){ // ignore "state" keys
					case keys.SHIFT:
					case keys.ALT:
					case keys.CTRL:
					case keys.META:
					case keys.CAPS_LOCK:
						return;
					default:
						if(charCode >= 65 && charCode <= 90){ return; } // keydown for A-Z can be processed with keypress
				}
			}
			if(e.type == "keypress" && typeof charCode != "string"){ return; }
			if(e.type == "input"){
				if(this.__skipInputEvent){ // duplicate event
					this.__skipInputEvent = false;
					return;
				}
			}else{
				this.__skipInputEvent = true;
			}
			// create fake event to set charOrCode and to know if preventDefault() was called
			var faux = lang.mixin({}, e, {
				charOrCode: charCode,
				wasConsumed: false,
				preventDefault: function(){
					faux.wasConsumed = true;
					e.preventDefault();
				},
				stopPropagation: function(){ e.stopPropagation(); }
			});
			// give web page author a chance to consume the event
			if(this.onInput(faux) === false){
				event.stop(faux); // return false means stop
			}
			if(faux.wasConsumed){ return; } // if preventDefault was called
			setTimeout(lang.hitch(this, "_onInput", faux), 0); // widget notification after key has posted
		};
		array.forEach([ "onkeydown", "onkeypress", "onpaste", "oncut", "oninput" ], function(event){
			this.connect(this.textbox, event, handleEvent);
		}, this);
	},

	_blankValue: '', // if the textbox is blank, what value should be reported
	filter: function(val){
		// summary:
		//		Auto-corrections (such as trimming) that are applied to textbox
		//		value on blur or form submit.
		// description:
		//		For MappedTextBox subclasses, this is called twice
		// 			- once with the display value
		//			- once the value as set/returned by set('value', ...)
		//		and get('value'), ex: a Number for NumberTextBox.
		//
		//		In the latter case it does corrections like converting null to NaN.  In
		//		the former case the NumberTextBox.filter() method calls this.inherited()
		//		to execute standard trimming code in TextBox.filter().
		//
		//		TODO: break this into two methods in 2.0
		//
		// tags:
		//		protected extension
		if(val === null){ return this._blankValue; }
		if(typeof val != "string"){ return val; }
		if(this.trim){
			val = lang.trim(val);
		}
		if(this.uppercase){
			val = val.toUpperCase();
		}
		if(this.lowercase){
			val = val.toLowerCase();
		}
		if(this.propercase){
			val = val.replace(/[^\s]+/g, function(word){
				return word.substring(0,1).toUpperCase() + word.substring(1);
			});
		}
		return val;
	},

	_setBlurValue: function(){
		this._setValueAttr(this.get('value'), true);
	},

	_onBlur: function(e){
		if(this.disabled){ return; }
		this._setBlurValue();
		this.inherited(arguments);

		if(this._selectOnClickHandle){
			this.disconnect(this._selectOnClickHandle);
		}
	},

	_isTextSelected: function(){
		return this.textbox.selectionStart == this.textbox.selectionEnd;
	},

	_onFocus: function(/*String*/ by){
		if(this.disabled || this.readOnly){ return; }

		// Select all text on focus via click if nothing already selected.
		// Since mouse-up will clear the selection need to defer selection until after mouse-up.
		// Don't do anything on focus by tabbing into the widget since there's no associated mouse-up event.
		if(this.selectOnClick && by == "mouse"){
			this._selectOnClickHandle = this.connect(this.domNode, "onmouseup", function(){
				// Only select all text on first click; otherwise users would have no way to clear
				// the selection.
				this.disconnect(this._selectOnClickHandle);

				// Check if the user selected some text manually (mouse-down, mouse-move, mouse-up)
				// and if not, then select all the text
				if(this._isTextSelected()){
					_TextBoxMixin.selectInputText(this.textbox);
				}
			});
		}
		// call this.inherited() before refreshState(), since this.inherited() will possibly scroll the viewport
		// (to scroll the TextBox into view), which will affect how _refreshState() positions the tooltip
		this.inherited(arguments);

		this._refreshState();
	},

	reset: function(){
		// Overrides dijit._FormWidget.reset().
		// Additionally resets the displayed textbox value to ''
		this.textbox.value = '';
		this.inherited(arguments);
	},
	_setTextDirAttr: function(/*String*/ textDir){
		// summary:
		//		Setter for textDir.
		// description:
		//		Users shouldn't call this function; they should be calling
		//		set('textDir', value)
		// tags:
		//		private

		// only if new textDir is different from the old one
		// and on widgets creation.
		if(!this._created
			|| this.textDir != textDir){
				this._set("textDir", textDir);
				// so the change of the textDir will take place immediately.
				this.applyTextDir(this.focusNode, this.focusNode.value);
		}
	}
});


_TextBoxMixin._setSelectionRange = dijit._setSelectionRange = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	if(element.setSelectionRange){
		element.setSelectionRange(start, stop);
	}
};

_TextBoxMixin.selectInputText = dijit.selectInputText = function(/*DomNode*/ element, /*Number?*/ start, /*Number?*/ stop){
	// summary:
	//		Select text in the input element argument, from start (default 0), to stop (default end).

	// TODO: use functions in _editor/selection.js?
	element = dom.byId(element);
	if(isNaN(start)){ start = 0; }
	if(isNaN(stop)){ stop = element.value ? element.value.length : 0; }
	try{
		element.focus();
		_TextBoxMixin._setSelectionRange(element, start, stop);
	}catch(e){ /* squelch random errors (esp. on IE) from unexpected focus changes or DOM nodes being hidden */ }
};

return _TextBoxMixin;
});

},
'dijit/form/SimpleTextarea':function(){
define("dijit/form/SimpleTextarea", [
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/_base/sniff", // has("ie") has("opera")
	"dojo/_base/window", // win.doc.selection win.doc.selection.createRange
	"./TextBox"
], function(declare, domClass, has, win, TextBox){

/*=====
	var TextBox = dijit.form.TextBox;
=====*/

// module:
//		dijit/form/SimpleTextarea
// summary:
//		A simple textarea that degrades, and responds to
// 		minimal LayoutContainer usage, and works with dijit.form.Form.
//		Doesn't automatically size according to input, like Textarea.

return declare("dijit.form.SimpleTextarea", TextBox, {
	// summary:
	//		A simple textarea that degrades, and responds to
	// 		minimal LayoutContainer usage, and works with dijit.form.Form.
	//		Doesn't automatically size according to input, like Textarea.
	//
	// example:
	//	|	<textarea data-dojo-type="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40></textarea>
	//
	// example:
	//	|	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");

	baseClass: "dijitTextBox dijitTextArea",

	// rows: Number
	//		The number of rows of text.
	rows: "3",

	// rows: Number
	//		The number of characters per line.
	cols: "20",

	templateString: "<textarea ${!nameAttrSetting} data-dojo-attach-point='focusNode,containerNode,textbox' autocomplete='off'></textarea>",

	postMixInProperties: function(){
		// Copy value from srcNodeRef, unless user specified a value explicitly (or there is no srcNodeRef)
		// TODO: parser will handle this in 2.0
		if(!this.value && this.srcNodeRef){
			this.value = this.srcNodeRef.value;
		}
		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);
		if(has("ie") && this.cols){ // attribute selectors is not supported in IE6
			domClass.add(this.textbox, "dijitTextAreaCols");
		}
	},

	filter: function(/*String*/ value){
		// Override TextBox.filter to deal with newlines... specifically (IIRC) this is for IE which writes newlines
		// as \r\n instead of just \n
		if(value){
			value = value.replace(/\r/g,"");
		}
		return this.inherited(arguments);
	},

	_onInput: function(/*Event?*/ e){
		// Override TextBox._onInput() to enforce maxLength restriction
		if(this.maxLength){
			var maxLength = parseInt(this.maxLength);
			var value = this.textbox.value.replace(/\r/g,'');
			var overflow = value.length - maxLength;
			if(overflow > 0){
				var textarea = this.textbox;
				if(textarea.selectionStart){
					var pos = textarea.selectionStart;
					var cr = 0;
					if(has("opera")){
						cr = (this.textbox.value.substring(0,pos).match(/\r/g) || []).length;
					}
					this.textbox.value = value.substring(0,pos-overflow-cr)+value.substring(pos-cr);
					textarea.setSelectionRange(pos-overflow, pos-overflow);
				}else if(win.doc.selection){ //IE
					textarea.focus();
					var range = win.doc.selection.createRange();
					// delete overflow characters
					range.moveStart("character", -overflow);
					range.text = '';
					// show cursor
					range.select();
				}
			}
		}
		this.inherited(arguments);
	}
});

});

},
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode\" data-dojo-attach-event='onclick:onClick'>\n    <div role=\"presentation\" class='dijitTabInnerDiv' data-dojo-attach-point='innerDiv'>\n        <div role=\"presentation\" class='dijitTabContent' data-dojo-attach-point='tabContent'>\n        \t<div role=\"presentation\" data-dojo-attach-point='focusNode'>\n\t\t        <img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitTabButtonIcon\" data-dojo-attach-point='iconNode' />\n\t\t        <span data-dojo-attach-point='containerNode' class='tabLabel'></span>\n\t\t        <span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t        \t\tdata-dojo-attach-event='onclick: onClickCloseButton' role=\"presentation\">\n\t\t            <span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t        ></span>\n\t\t\t</div>\n        </div>\n    </div>\n</div>\n",
'ibm/tivoli/simplesrm/srm/dojo/data/SolutionTree':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.SolutionTree");

dojo.declare("ibm.tivoli.simplesrm.srm.dojo.data.SolutionTree",
			 null,
{

	_tree : null,
   _noParents : false,

	/**
	 * Produces an empty object that will be the solution tree.
	 */
	constructor : function() {
		this._tree = new Array();
	},
	
	//adds solutions or classsstructures
	addSolution : function(solution) {
		//console.log("solutionTree.addsolution() entry", solution);
		var lastParent = null;		
		 	
		//CLASSSTRUCTURE handling code		
		var parents = null;		
		
		if (solution.CLASSSTRUCTUREID!=undefined) {
			var parents = solution.CLASSSTRUCTURE;
			if (parents==undefined) {
				parents = new Array();
			}	
			
		   //Add leaf object to classstructure hierarchy array
		   var leaf = {};
		   leaf.CLASSSTRUCTUREID = solution.CLASSSTRUCTUREID;
		   leaf.CLASSSTRUCTUREUID = solution.CLASSSTRUCTUREUID;
		   if (solution.DESCRIPTION)
		      leaf.DESCRIPTION = solution.DESCRIPTION;
		   if (solution.PARENT)
			   leaf.PARENT = solution.PARENT;
   		   parents.push(leaf);
		}
		
		//Order classstructures if that's what we are working with 
		if (parents!=null) {		
		   //Order classstructure
           var sorted_parents = new Array();

           for (var i = 0; i < parents.length; i++) {  //find top
              var clst = parents[i];
              if (clst.PARENT == undefined) {
                 sorted_parents.push(clst);
                 _parent = clst.CLASSSTRUCTUREID;
                 break;	        		
              }   
            }
            if (_parent!=null) {  //now follow parent to put in order
               var found = true;
               while (found) {	        		
                  found= false;
                  for (var i = 0; i < parents.length; i++) {
                     var clst = parents[i];
                     if (clst.PARENT == _parent) {
                         sorted_parents.push(clst);
                         _parent = clst.CLASSSTRUCTUREID;
                         found = true;
                         break;
                     }   
                  }
               }
               if (sorted_parents.length>0)
                  parents = sorted_parents;
            } //end of manual ordering     

			for (var i = 0; i < parents.length; i++) {
				if (lastParent == null) {
					/* We're at top level */
					lastParent = this.addElt(this._tree, parents[i]);
				} else {
					//debugger;
					if (lastParent.Category == undefined) {
						lastParent.Category = new Array();
					}
					lastParent = this.addElt(lastParent.Category, parents[i]);  //add to tree
				}
			}
		
		} 
		
		/* Solution handling */
		if (lastParent != undefined) {
			if (lastParent.Offering == undefined) {
				lastParent.Offering = new Array();
			}
			if (solution.SOLUTION)  //Is there a solution?
			   this.addElt(lastParent.Offering, solution);
		} else {
			if (solution.SOLUTION)  //Is there a solution?
			   this.addElt(this._tree, solution);
		}

		//debugger;
		//console.log("solutionTree.addsolution() exit", this._tree);
	},
	
	addElt : function(array, elt) {
		/* search for elt in array */
		var found = false;
		var leaf = null;
		for (var i = 0; i < array.length; i++) {
			//console.log("comparing ", array[i], " & " , elt);

         //Dup solution?
			if ( ((elt.SOLUTIONID != undefined)	&&(array[i].ItemID == elt.SOLUTIONID))) {
				found = true;
				leaf = array[i];
			}
         //Existing classstructure?
			if (((elt.CLASSSTRUCTUREUID !== undefined)&& (array[i].ClassStructureID == elt.CLASSSTRUCTUREUID))){				
				found = true;
				leaf = array[i];
			}
		}
		/* not found, add it */
		if (found === false) {
			var desc = elt.DESCRIPTION;
			if (desc==undefined) {            //fix
		            desc=elt.SOLUTION;
		    }
			leaf = { Description : desc,
					 ID : elt.SOLUTIONID,
                     ClassStructureID : elt.CLASSSTRUCTUREUID,
                     csid: elt.CLASSSTRUCTUREID,                
					 Solution : elt.SOLUTION,
					 LongDescription  : elt.PROBLEMCODE_LONGDESCRIPTION, //Symptom
					 Score : elt.SCORE
				   };
			
			var MINDIGITS = 30;
			if (elt.SOLUTION && desc.length < MINDIGITS) 
				leaf.spaces = MINDIGITS - desc.length;			
			 
			if (elt.SOLUTION==null &&  elt.CLASSSTRUCTUREUID!=null) { //classification item
				leaf.ID =  elt.CLASSSTRUCTUREUID;
				 leaf.ImageName = "getonserver";  //to force retrieving solution classification (folder) image
			}
			
			if(elt.Solution && elt.AVGRANKING > 0){
				var rankImage = "img_rate" + elt.AVGRANKING + "star.gif"
				console.log("rankImage",rankImage);
				leaf.ImageName2 = rankImage;
			}
			
			if (elt.IMGLIB != undefined) {
				leaf.ImageName = elt.IMGLIB[0].IMAGENAME;
			}

			array.push(leaf);
		}
		return leaf;
	},
	
	clean : function() {
		this._tree = new Array();
	}

});

});

},
'ibm/tivoli/simplesrm/srm/dojo/data/OfferingTree':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.OfferingTree");

dojo.declare("ibm.tivoli.simplesrm.srm.dojo.data.OfferingTree",
			 null,
{
    _tree : null,
    _noParents : false,

	/**
	 * Produces an empty object that will be the offering tree.
	 */
	constructor : function() {
		this._tree = new Array();
	},
	
	addOffering : function(offering) {
		//console.log("OfferingTree.addOffering() entry", offering);
		var lastParent = null;
		var catOffMap = null;  //store classstructures in CATALOGCLASSSTRUCTURE attribute for performance  //fpb 
		
		//get user's itemset to filter on Org.  
		try {
			var site =   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getLoggedInUser().SITE[0];
	        var itemsetid=null;
	        if (site.ORGANIZATION) {
	           var itemsetid =  site.ORGANIZATION[0].ITEMSETID;
	        }
			
			if (itemsetid!=null && offering.ITEMSETID!=null) {  //filter out offering not in Org.
				if (itemsetid!=offering.ITEMSETID) {
					console.log("OfferingTree.addOffering() - skip offering, different org: ", offering.ITEMNUM);
					return;
				}
			}		
			
         //also filter out offerings not in a catalog (and not a favorite) 
	     if (offering.FAVITEM==undefined  && offering.CATALOGCLASSSTRUCTURE==undefined && offering.PMSCCATALOGOFFMAP==undefined) {  //no offering-catalog association  //fpb	        	
             console.log("OfferingTree.addOffering() - skip offering, not in catalog: ", offering.ITEMNUM);
	           return;
	        } 

		} catch(ex) {
			console.log(ex);			
		}			
		
		/* include the parents in the tree */
		
		//Handle offerings in multiple catalogs
		var offeringsmap = [];
		
		var catalog_status = "ACTIVE";
		var catalogStatus_domain = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('ITEMSTATUS');
		var catalog_active_status = catalogStatus_domain.valueByMaxvalue("ACTIVE");
		
		//If we are using CATALOGCLASSSTRUCTURE instead of PMSCCATALOGOFFMAP (for performance)			
		if (offering.CATALOGCLASSSTRUCTURE!=undefined ) {  //fpb
			catOffMap = eval('(' + offering.CATALOGCLASSSTRUCTURE + ')');		
			if (catOffMap!=undefined) {
            offering.IMAGENAME  = catOffMap.IMAGENAME;  //We stuffed imagename in too!
				catOffMap = catOffMap.CATOFFMAP;
         }
		}
		if (offering.PMSCCATALOGOFFMAP) {
			for (var i=0; i<offering.PMSCCATALOGOFFMAP.length; i++) {
				//Make sure catalog is active
				var off_catalog = offering.PMSCCATALOGOFFMAP[i].ITEMNUM;  //catalog name
				var off_catalog_itemset = offering.PMSCCATALOGOFFMAP[i].ITEMSETID;  //catalog itemset
				if (off_catalog!=null){
                   var  catalogs = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().cache.general.get("catalogs");
                   if (catalogs!=undefined && catalogs!=null) {
                	   for (var j=0;j<catalogs.length;j++) {
                        if (catalogs[j].ITEMNUM == off_catalog && (off_catalog_itemset==null || catalogs[j].ITEMSETID == off_catalog_itemset)) {                			   
                			   if(catalogs[j].STATUS== catalog_active_status) {  
                				   var path = offering.PMSCCATALOGOFFMAP[i].CLASSSTRUCTURE;               					
                				    offeringsmap.push(path);                				   
                			   }
                			   break;
                		   }
                	   }
                   }
				} else{				
				   var path = offering.PMSCCATALOGOFFMAP[i].CLASSSTRUCTURE;               					
				   offeringsmap.push(path);
				}
			}

		} else if (catOffMap!=null) {  //Mbo-only //fpb
			for (var i=0; i<catOffMap.length; i++) {
				var path = catOffMap[i].CS;
				   
		        //Fix shortened key names
		        for (var j = 0; j < path.length; j++) {
	        	   var clst = path[j];        	 
		           clst.DESCRIPTION = clst.D;
		           delete clst['D'];
		           
		           clst.CLASSSTRUCTUREID = clst.CSID;
		           delete clst['CSID'];
		           
                   var csuidstr =  clst.CSUID.replace(/,/g,"");
	               csuidstr =  csuidstr.replace(/\./g,"");
			       clst.CLASSSTRUCTUREUID = parseInt(csuidstr);		          
		           delete clst['CSUID'];
		           
			       //clst.CLASSIFICATIONID = clst.CLID;
		           
		           clst.PARENT = clst.P;
		           delete clst['P'];
		        }
				
				//Make sure catalog is active
				var off_catalog = catOffMap[i].ITEMNUM;  //offering catalog mapping name
				var off_catalog_itemset = catOffMap[i].ITEMSETID;  //offering catalog mapping itemset (can be null)
				if (off_catalog!=null){
                   var  catalogs = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().cache.general.get("catalogs");  //get catalogs
                   if (catalogs!=undefined && catalogs!=null) {
                	   for (var j=0;j<catalogs.length;j++) {
                		   if (catalogs[j].ITEMNUM == off_catalog && (off_catalog_itemset==null || catalogs[j].ITEMSETID == off_catalog_itemset)) {                			   
                			   if(catalogs[j].STATUS== catalog_active_status) {                				        					
                				    offeringsmap.push(path);                				   
                			   }
                			   break;
                		   }
                	   }
                   }
				} else{			        		   
			        offeringsmap.push(path);
				}
			}
		} else { 
		   offeringsmap.push(null);  //Offering with no classstructure, favorite, perhaps
		}
				
		//Handle offerings in multiple catalogs
		for (var j=0; j<offeringsmap.length; j++) {
		   lastParent = null;
		   var path = offeringsmap[j];
		  
		   if (path != undefined && !this._noParents) {
	          //Order manually because we can't do it on server using order by clause in CLASSHIERARCHY relationship
              //Using parent and classstructureid, we can put the items in order.
	          var _parent = null;
 			  var sorted_parents = new Array();
	          for (var i = 0; i < path.length; i++) {  //find top
	        	 var clst = path[i];
	        	 if (clst.PARENT == undefined) {
	        	 	sorted_parents.push(clst);
	        		_parent = clst.CLASSSTRUCTUREID;
	        		break;	        		
	        	 }   
	          }
	          if (_parent!=null) {  //now follow parent to put in order
	        	  var found = true;
	        	  while (found) {	        		
	        	     found= false;
   	        	     for (var i = 0; i < path.length; i++) {
	        		     var clst = path[i];
	        		     if (clst.PARENT == _parent) {
	        			     sorted_parents.push(clst);
	        			     _parent = clst.CLASSSTRUCTUREID;
	        			     found = true;
	        			     break;
	        		      }   
	        	     }
	               }
	        	if (sorted_parents.length>0)
	        		path = sorted_parents;
	          } //end of manual ordering      		        
			
	           //Add classification folders to tree
			   for (var i = 0; i < path.length; i++) {
				   if (lastParent == null) {
					   /* We're at top level */
					   lastParent = this.addElt(this._tree, path[i]);
				   } else {
					   //debugger;
					  if (lastParent.Category == undefined) {
						   lastParent.Category = new Array();
					   }
					   lastParent = this.addElt(lastParent.Category, path[i]);
				   }
			   }		
		    }
		
		    /* then the offering itself */
		    if (lastParent != undefined) {
		      if (lastParent.Offering == undefined) {
		        lastParent.Offering = new Array();
    	      }
	    	  this.addElt(lastParent.Offering, offering);
		    } else {
			   this.addElt(this._tree, offering);
		    }				
		}

		//debugger;
		//console.log("OfferingTree.addOffering() exit", this._tree);
		
	},
	
	addElt : function(array, elt) {
		/* search for elt in array */
		var found = false;
		var leaf = null;
		for (var i = 0; i < array.length; i++) {
			//console.log("comparing ", array[i], " & " , elt);
			if (((elt.CLASSSTRUCTUREUID !== undefined)&& (array[i].ID == elt.CLASSSTRUCTUREUID)) ||
				 ((elt.ITEMID != undefined)	&&(array[i].ItemID == elt.ITEMID))) {
				found = true;
				leaf = array[i];
			}
		}
		/* not found, add it */
		if (found === false) {
			//debugger;
			leaf = { Ancestor : elt.CLASSSTRUCTUREUID,
					 //Ancestor : elt.PARENT,  
					 //ClassStructureID : elt.CLASSSTRUCTUREID,  
					 ClassStructureID : elt.CLASSSTRUCTUREUID,
					 //ClassificationID : elt.CLASSSTRUCTUREID,  
					 Description : elt.DESCRIPTION,
					 ID : elt.CLASSSTRUCTUREUID,
					 ItemID : elt.ITEMID,
					 ItemNum : elt.ITEMNUM,
					 ItemSetID : elt.ITEMSETID,
					 Score : elt.SCORE
				   };
			
			if (elt.LONGDESCRIPTION != undefined) {
				leaf.LongDescription = elt.LONGDESCRIPTION[0].LDTEXT;
			} 
			if (elt.LONGDESCRIPTION == undefined && elt.DESCRIPTION_LONGDESCRIPTION != undefined) {
				leaf.LongDescription = elt.DESCRIPTION_LONGDESCRIPTION;
			}
			if (elt.IMGLIB != undefined) {
				leaf.ImageName = elt.IMGLIB[0].IMAGENAME;			
		    } else if (elt.IMAGENAME!=undefined) {  //also storing imagename here  when using mbo instead of OS //fpb
			   leaf.ImageName = elt.IMAGENAME;
		   }
			//if (elt.CLASSIFICATIONID != undefined) {
				//leaf.ClassificationID = elt.CLASSIFICATIONID;			
			//}			
			if (leaf.Description == undefined) {				
				leaf.Description = leaf.ClassStructureID.toString();				
			} 
			//else {
			//	console.log("No classif ID here");
			//}
			array.push(leaf);
		}
		return leaf;
	},
	
	clean : function() {
		this._tree = new Array();
	}

});

});

},
'dijit/form/RadioButton':function(){
define("dijit/form/RadioButton", [
	"dojo/_base/declare", // declare
	"./CheckBox",
	"./_RadioButtonMixin"
], function(declare, CheckBox, _RadioButtonMixin){

/*=====
	var CheckBox = dijit.form.CheckBox;
	var _RadioButtonMixin = dijit.form._RadioButtonMixin;
=====*/

	// module:
	//		dijit/form/RadioButton
	// summary:
	//		Radio button widget

	return declare("dijit.form.RadioButton", [CheckBox, _RadioButtonMixin], {
		// summary:
		// 		Same as an HTML radio, but with fancy styling.

		baseClass: "dijitRadio"
	});
});

},
'ibm/tivoli/simplesrm/srm/dijit/WidgetBase':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dojo/cookie,ibm/tivoli/simplesrm/srm/dojo/SimpleSRMError,dojo/i18n"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.WidgetBase");

dojo.require("dojo.cookie");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError");
dojo.require("dojo.i18n");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

// the WidgetBase class is the base class for other widgets
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.WidgetBase", null,
{	
	srmTokenName: "SimpleSRMToken",
	proxyUrl: "/SRMCommonsWeb/ProxyServlet",
	imageCacheUrl: "/SRMCommonsWeb/MaxImageCache/",
	_uiStringTable: null,

	// constructor declares properties
	constructor: function(/*object*/params, /*domNode*/domNode)
	{
		console.log("WidgetBase.ctor");
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
	},
	isLoggedIn: function() {
		return (null != dojo.cookie(this.srmTokenName));
	},
	getRelativePath: function(/* string */ pathFragment)
	{
		var relPath;
		if(this.iContext) {
			relPath = this.iContext.io.rewriteURI(pathFragment);
		}
		else {
			relPath = dojo.moduleUrl(this.declaredClass.substring(0, this.declaredClass.lastIndexOf('.')), pathFragment).toString();
		}
		return relPath;
	},
	_crossFade: function(outnode, innode) 
	{
		if(dojo.isIE) {
			// this still doesn't work!
			// for some reason, the inlist gets the correct styling, but never shows up
			if(outnode) {
				dojo.style(outnode, "display", "none");
			}
			dojo.style(innode, "display", "block");
		}
		else {
			var shower = dojo.fadeIn({
				node: innode,
				duration: 500,
				onPlay: function() {
					dojo.style(innode, "display", "block");
				}});
			if(outnode) {			
				var hider = dojo.fadeOut({
					node: outnode,
					duration: 500,
					onEnd:function(){
						dojo.style(outnode,"display", "none");
					}});
				dojo.fx.chain([hider, shower]).play();
			}
			else {
				shower.play();
			}
		}			
	}
});

});

},
'ibm/tivoli/simplesrm/srm/dojo/data/Cache':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojox/collections/Dictionary"], function(dijit,dojo,dojox){
dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.Cache");

dojo.require("dojox.collections.Dictionary");
/**
 * an object used as associative array is private (accessible only via public methods).
 * each entry contains properties :
 * <ul>		 
 * <li>	value: "some string"</li>
 * <li>	timestamp: 12333333333 - creation time</li>		
 * <li> timeout: 30 - duration in milisec</li>
 * <li>	onPurge: function(){} - callback executed on removal</li>	
 * </ul>
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.data.Cache", null, 
{	
	
	constructor: function(){
		var store = new dojox.collections.Dictionary();
		
		var checkKeyType = function(key){
			if(!dojo.isString(key)) {
				throw new TypeError("key should be string. argument passed: " + key);
			}
		};
		
		
		this.get = function(key){		
			checkKeyType(key);
			
			if(this.isExpired(key)){
				this.remove(key);
			}
			var item = store.item(key)
			return  item ? item.value : undefined;			
		};
		
		this.put = function(key,value,options){
			checkKeyType(key);
			
			if(value === undefined){
				throw new TypeError("illegal value. argument passed: " + value);
			}
			var item = {			
				value: value ,
				timestamp: new Date().getTime()	
			};
			if(options){
				item.timeout = !isNaN(options.timeout) ? options.timeout : undefined;
				item.onPurge = dojo.isFunction(options.onPurge)? options.onPurge : undefined;
			}
			store.add(key,item);
		};
		
		this.isExpired =  function(key){
			checkKeyType(key);
			var item = store.item(key),
				currentTime = new Date().getTime();
			if(item && (item.timeout !== undefined) && (item.timestamp + item.timeout < currentTime)){
				return true;
			}
			return false;
		};
		
		this.remove =  function(key){
			checkKeyType(key);
			var item = store.item(key);
			if (item){
				if(item.onPurge){
					item.onPurge();
				}
				store.remove(key);				
			}
		};
		
		this.removeGroup = function(groupKey) {
			var keys = store.getKeyList(),
				that = this;
			dojo.forEach(keys,function(key){
				if(key.indexOf(groupKey) == 0){
					that.remove(key);
				}
			});			
		};
		
		this.purge = function(){
			var keys = store.getKeyList(),
				that = this;
			dojo.forEach(keys,function(key){
				if(that.isExpired(key)){
					that.remove(key);
				}
			});
		};
		
		this.clear = function(){		
			store.clear();
		};
		
		this.getKeys = function(){
			return store.getKeyList();
		};
		
		this.countKeys = function(){
			var total = store.count;
			return total;
		};
	},
	
	
	/**
	 * @param {String} key
	 * @throws TypeError
	 * @type {Object}
	 */
	get: undefined,
	
	/**
	 * @param {String} key
	 * @param {object} value can be null
	 * @param {Object} options - supported properties: timeout,onPurge.
	 * @throws TypeError
	 * @type {void}
	 */
	put: undefined,
	
	/**
	 * @param {String} key
	 * @return {Boolean} true if element exists and has expired
	 */
	isExpired: undefined,
	
	/**
	 * executes onPurge and removes an entry (deletes property from object)
	 * @param {String} key
	 * @type {void}
	 */
	remove: undefined,
	
	/**
	 * deletes all items having a common prefix of groupKey
	 * @param {String} groupKey
	 * @type {void}
	 */
	removeGroup: undefined,
	
	/**
	 * removes all entries that have expired
	 * @type {void}
	 */
	purge: undefined,
	
	/**
	 * removes all entries without executing onPurge
	 * @type {void}
	 */
	clear: undefined,
	
	/**
	 * count entries in the store
	 * @return {Number}
	 */
	countKeys: undefined
	
});
});

},
'dijit/main':function(){
define("dijit/main", [
	"dojo/_base/kernel"
], function(dojo){
	// module:
	//		dijit
	// summary:
	//		The dijit package main module

	return dojo.dijit;
});

},
'ibm/tivoli/tip/dijit/nls/resources':function(){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * (C) Copyright IBM Corp. 2007 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/

define({ root:
{
	dummy_: ""
},	
"en": true,
"zh": true,
"zh-tw": true,
"tr": true,
"th": true,
"sv": true,
"sl": true,
"sk": true,
"ru": true,
"ro": true,
"pt": true,
"pt-pt": true,
"pl": true,
"nl": true,
"nb": true,
"ko": true,
"kk": true,
"ja": true,
"it": true,
"hu": true,
"hr": true,
"he": true,
"fr": true,
"fi": true,
"es": true,
"el": true,
"de": true,
"da": true,
"cs": true,
"ca": true,
"az": true,
"ar": true
});

},
'dojox/gfx/shape':function(){
define("dojox/gfx/shape", ["./_base", "dojo/_base/lang", "dojo/_base/declare", "dojo/_base/window", "dojo/_base/sniff",
	"dojo/_base/connect", "dojo/_base/array", "dojo/dom-construct", "dojo/_base/Color", "./matrix"], 
  function(g, lang, declare, win, has, events, arr, domConstruct, Color, matrixLib){

/*===== 
	dojox.gfx.shape = {
		// summary:
		//		This module contains the core graphics Shape API.
		//		Different graphics renderer implementation modules (svg, canvas, vml, silverlight, etc.) extend this 
		//		basic api to provide renderer-specific implementations for each shape.
	};
  =====*/

	var shape = g.shape = {};
	// a set of ids (keys=type)
	var _ids = {};
	// a simple set impl to map shape<->id
	var registry = {};
	
	shape.register = function(/*dojox.gfx.shape.Shape*/shape){
		// summary: 
		//		Register the specified shape into the graphics registry.
		// shape: dojox.gfx.shape.Shape
		//		The shape to register.
		// returns:
		//		The unique id associated with this shape.
		// the id pattern : type+number (ex: Rect0,Rect1,etc)
		var t = shape.declaredClass.split('.').pop();
		var i = t in _ids ? ++_ids[t] : ((_ids[t] = 0));
		var uid = t+i;
		registry[uid] = shape;
		return uid;
	};
	
	shape.byId = function(/*String*/id){
		// summary: 
		//		Returns the shape that matches the specified id.
		// id: String
		//		The unique identifier for this Shape.
		return registry[id]; //dojox.gfx.shape.Shape
	};
	
	shape.dispose = function(/*dojox.gfx.shape.Shape*/shape){
		// summary: 
		//		Removes the specified shape from the registry.
		// shape: dojox.gfx.shape.Shape
		//		The shape to unregister.
		delete registry[shape.getUID()];
	};
	
	declare("dojox.gfx.shape.Shape", null, {
		// summary: a Shape object, which knows how to apply
		// graphical attributes and transformations
	
		constructor: function(){
			//	rawNode: Node
			//		underlying graphics-renderer-specific implementation object (if applicable)
			this.rawNode = null;
			//	shape: Object: an abstract shape object
			//	(see dojox.gfx.defaultPath,
			//	dojox.gfx.defaultPolyline,
			//	dojox.gfx.defaultRect,
			//	dojox.gfx.defaultEllipse,
			//	dojox.gfx.defaultCircle,
			//	dojox.gfx.defaultLine,
			//	or dojox.gfx.defaultImage)
			this.shape = null;
	
			//	matrix: dojox.gfx.Matrix2D
			//		a transformation matrix
			this.matrix = null;
	
			//	fillStyle: Object
			//		a fill object
			//		(see dojox.gfx.defaultLinearGradient,
			//		dojox.gfx.defaultRadialGradient,
			//		dojox.gfx.defaultPattern,
			//		or dojo.Color)
			this.fillStyle = null;
	
			//	strokeStyle: Object
			//		a stroke object
			//		(see dojox.gfx.defaultStroke)
			this.strokeStyle = null;
	
			// bbox: dojox.gfx.Rectangle
			//		a bounding box of this shape
			//		(see dojox.gfx.defaultRect)
			this.bbox = null;
	
			// virtual group structure
	
			// parent: Object
			//		a parent or null
			//		(see dojox.gfx.Surface,
			//		dojox.gfx.shape.VirtualGroup,
			//		or dojox.gfx.Group)
			this.parent = null;
	
			// parentMatrix: dojox.gfx.Matrix2D
			//	a transformation matrix inherited from the parent
			this.parentMatrix = null;
			
			var uid = shape.register(this);
			this.getUID = function(){
				return uid;
			}
		},	
	
		// trivial getters
	
		getNode: function(){
			// summary: Different graphics rendering subsystems implement shapes in different ways.  This
			//	method provides access to the underlying graphics subsystem object.  Clients calling this
			//	method and using the return value must be careful not to try sharing or using the underlying node
			//	in a general way across renderer implementation.
			//	Returns the underlying graphics Node, or null if no underlying graphics node is used by this shape.
			return this.rawNode; // Node
		},
		getShape: function(){
			// summary: returns the current Shape object or null
			//	(see dojox.gfx.defaultPath,
			//	dojox.gfx.defaultPolyline,
			//	dojox.gfx.defaultRect,
			//	dojox.gfx.defaultEllipse,
			//	dojox.gfx.defaultCircle,
			//	dojox.gfx.defaultLine,
			//	or dojox.gfx.defaultImage)
			return this.shape; // Object
		},
		getTransform: function(){
			// summary: Returns the current transformation matrix applied to this Shape or null
			return this.matrix;	// dojox.gfx.Matrix2D
		},
		getFill: function(){
			// summary: Returns the current fill object or null
			//	(see dojox.gfx.defaultLinearGradient,
			//	dojox.gfx.defaultRadialGradient,
			//	dojox.gfx.defaultPattern,
			//	or dojo.Color)
			return this.fillStyle;	// Object
		},
		getStroke: function(){
			// summary: Returns the current stroke object or null
			//	(see dojox.gfx.defaultStroke)
			return this.strokeStyle;	// Object
		},
		getParent: function(){
			// summary: Returns the parent Shape, Group or VirtualGroup or null if this Shape is unparented.
			//	(see dojox.gfx.Surface,
			//	dojox.gfx.shape.VirtualGroup,
			//	or dojox.gfx.Group)
			return this.parent;	// Object
		},
		getBoundingBox: function(){
			// summary: Returns the bounding box Rectanagle for this shape or null if a BoundingBox cannot be
			//	calculated for the shape on the current renderer or for shapes with no geometric area (points).
			//	A bounding box is a rectangular geometric region
			//	defining the X and Y extent of the shape.
			//	(see dojox.gfx.defaultRect)
			return this.bbox;	// dojox.gfx.Rectangle
		},
		getTransformedBoundingBox: function(){
			// summary: returns an array of four points or null
			//	four points represent four corners of the untransformed bounding box
			var b = this.getBoundingBox();
			if(!b){
				return null;	// null
			}
			var m = this._getRealMatrix(),
				gm = matrixLib;
			return [	// Array
					gm.multiplyPoint(m, b.x, b.y),
					gm.multiplyPoint(m, b.x + b.width, b.y),
					gm.multiplyPoint(m, b.x + b.width, b.y + b.height),
					gm.multiplyPoint(m, b.x, b.y + b.height)
				];
		},
		getEventSource: function(){
			// summary: returns a Node, which is used as
			//	a source of events for this shape
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			return this.rawNode;	// Node
		},
	
		// empty settings
	
		setShape: function(shape){
			// summary: sets a shape object
			//	(the default implementation simply ignores it)
			// shape: Object
			//	a shape object
			//	(see dojox.gfx.defaultPath,
			//	dojox.gfx.defaultPolyline,
			//	dojox.gfx.defaultRect,
			//	dojox.gfx.defaultEllipse,
			//	dojox.gfx.defaultCircle,
			//	dojox.gfx.defaultLine,
			//	or dojox.gfx.defaultImage)
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			this.shape = g.makeParameters(this.shape, shape);
			this.bbox = null;
			return this;	// self
		},
		setFill: function(fill){
			// summary: sets a fill object
			//	(the default implementation simply ignores it)
			// fill: Object
			//	a fill object
			//	(see dojox.gfx.defaultLinearGradient,
			//	dojox.gfx.defaultRadialGradient,
			//	dojox.gfx.defaultPattern,
			//	or dojo.Color)
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			if(!fill){
				// don't fill
				this.fillStyle = null;
				return this;	// self
			}
			var f = null;
			if(typeof(fill) == "object" && "type" in fill){
				// gradient or pattern
				switch(fill.type){
					case "linear":
						f = g.makeParameters(g.defaultLinearGradient, fill);
						break;
					case "radial":
						f = g.makeParameters(g.defaultRadialGradient, fill);
						break;
					case "pattern":
						f = g.makeParameters(g.defaultPattern, fill);
						break;
				}
			}else{
				// color object
				f = g.normalizeColor(fill);
			}
			this.fillStyle = f;
			return this;	// self
		},
		setStroke: function(stroke){
			// summary: sets a stroke object
			//	(the default implementation simply ignores it)
			// stroke: Object
			//	a stroke object
			//	(see dojox.gfx.defaultStroke)
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			if(!stroke){
				// don't stroke
				this.strokeStyle = null;
				return this;	// self
			}
			// normalize the stroke
			if(typeof stroke == "string" || lang.isArray(stroke) || stroke instanceof Color){
				stroke = {color: stroke};
			}
			var s = this.strokeStyle = g.makeParameters(g.defaultStroke, stroke);
			s.color = g.normalizeColor(s.color);
			return this;	// self
		},
		setTransform: function(matrix){
			// summary: sets a transformation matrix
			// matrix: dojox.gfx.Matrix2D
			//	a matrix or a matrix-like object
			//	(see an argument of dojox.gfx.Matrix2D
			//	constructor for a list of acceptable arguments)
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			this.matrix = matrixLib.clone(matrix ? matrixLib.normalize(matrix) : matrixLib.identity);
			return this._applyTransform();	// self
		},
	
		_applyTransform: function(){
			// summary: physically sets a matrix
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			return this;	// self
		},
	
		// z-index
	
		moveToFront: function(){
			// summary: moves a shape to front of its parent's list of shapes
			var p = this.getParent();
			if(p){
				p._moveChildToFront(this);
				this._moveToFront();	// execute renderer-specific action
			}
			return this;	// self
		},
		moveToBack: function(){
			// summary: moves a shape to back of its parent's list of shapes
			var p = this.getParent();
			if(p){
				p._moveChildToBack(this);
				this._moveToBack();	// execute renderer-specific action
			}
			return this;
		},
		_moveToFront: function(){
			// summary: renderer-specific hook, see dojox.gfx.shape.Shape.moveToFront()
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
		},
		_moveToBack: function(){
			// summary: renderer-specific hook, see dojox.gfx.shape.Shape.moveToFront()
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
		},
	
		// apply left & right transformation
	
		applyRightTransform: function(matrix){
			// summary: multiplies the existing matrix with an argument on right side
			//	(this.matrix * matrix)
			// matrix: dojox.gfx.Matrix2D
			//	a matrix or a matrix-like object
			//	(see an argument of dojox.gfx.Matrix2D
			//	constructor for a list of acceptable arguments)
			return matrix ? this.setTransform([this.matrix, matrix]) : this;	// self
		},
		applyLeftTransform: function(matrix){
			// summary: multiplies the existing matrix with an argument on left side
			//	(matrix * this.matrix)
			// matrix: dojox.gfx.Matrix2D
			//	a matrix or a matrix-like object
			//	(see an argument of dojox.gfx.Matrix2D
			//	constructor for a list of acceptable arguments)
			return matrix ? this.setTransform([matrix, this.matrix]) : this;	// self
		},
		applyTransform: function(matrix){
			// summary: a shortcut for dojox.gfx.Shape.applyRightTransform
			// matrix: dojox.gfx.Matrix2D
			//	a matrix or a matrix-like object
			//	(see an argument of dojox.gfx.Matrix2D
			//	constructor for a list of acceptable arguments)
			return matrix ? this.setTransform([this.matrix, matrix]) : this;	// self
		},
	
		// virtual group methods
	
		removeShape: function(silently){
			// summary: removes the shape from its parent's list of shapes
			// silently: Boolean
			// 		if true, do not redraw a picture yet
			if(this.parent){
				this.parent.remove(this, silently);
			}
			return this;	// self
		},
		_setParent: function(parent, matrix){
			// summary: sets a parent
			// parent: Object
			//	a parent or null
			//	(see dojox.gfx.Surface,
			//	dojox.gfx.shape.VirtualGroup,
			//	or dojox.gfx.Group)
			// matrix: dojox.gfx.Matrix2D
			//	a 2D matrix or a matrix-like object
			this.parent = parent;
			return this._updateParentMatrix(matrix);	// self
		},
		_updateParentMatrix: function(matrix){
			// summary: updates the parent matrix with new matrix
			// matrix: dojox.gfx.Matrix2D
			//	a 2D matrix or a matrix-like object
			this.parentMatrix = matrix ? matrixLib.clone(matrix) : null;
			return this._applyTransform();	// self
		},
		_getRealMatrix: function(){
			// summary: returns the cumulative ('real') transformation matrix
			//	by combining the shape's matrix with its parent's matrix
			var m = this.matrix;
			var p = this.parent;
			while(p){
				if(p.matrix){
					m = matrixLib.multiply(p.matrix, m);
				}
				p = p.parent;
			}
			return m;	// dojox.gfx.Matrix2D
		}
	});
	
	shape._eventsProcessing = {
		connect: function(name, object, method){
			// summary: connects a handler to an event on this shape
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
			// redirect to fixCallback to normalize events and add the gfxTarget to the event. The latter
			// is done by dojox.gfx.fixTarget which is defined by each renderer
			return events.connect(this.getEventSource(), name, shape.fixCallback(this, g.fixTarget, object, method));
			
		},
		disconnect: function(token){
			// summary: connects a handler by token from an event on this shape
			// COULD BE RE-IMPLEMENTED BY THE RENDERER!
	
			events.disconnect(token);
		}
	};
	
	shape.fixCallback = function(gfxElement, fixFunction, scope, method){
		//  summary:
		//      Wraps the callback to allow for tests and event normalization
		//      before it gets invoked. This is where 'fixTarget' is invoked.
		//  gfxElement: Object
		//      The GFX object that triggers the action (ex.: 
		//      dojox.gfx.Surface and dojox.gfx.Shape). A new event property
		//      'gfxTarget' is added to the event to reference this object.
		//      for easy manipulation of GFX objects by the event handlers.
		//  fixFunction: Function
		//      The function that implements the logic to set the 'gfxTarget'
		//      property to the event. It should be 'dojox.gfx.fixTarget' for
		//      most of the cases
		//  scope: Object
		//      Optional. The scope to be used when invoking 'method'. If
		//      omitted, a global scope is used.
		//  method: Function|String
		//      The original callback to be invoked.
		if(!method){
			method = scope;
			scope = null;
		}
		if(lang.isString(method)){
			scope = scope || win.global;
			if(!scope[method]){ throw(['dojox.gfx.shape.fixCallback: scope["', method, '"] is null (scope="', scope, '")'].join('')); }
			return function(e){  
				return fixFunction(e,gfxElement) ? scope[method].apply(scope, arguments || []) : undefined; }; // Function
		}
		return !scope 
			? function(e){ 
				return fixFunction(e,gfxElement) ? method.apply(scope, arguments) : undefined; } 
			: function(e){ 
				return fixFunction(e,gfxElement) ? method.apply(scope, arguments || []) : undefined; }; // Function
	};
	lang.extend(shape.Shape, shape._eventsProcessing);
	
	shape.Container = {
		// summary: a container of shapes, which can be used
		//	as a foundation for renderer-specific groups, or as a way
		//	to logically group shapes (e.g, to propagate matricies)
	
		_init: function() {
			// children: Array: a list of children
			this.children = [];
		},
	
		// group management
	
		openBatch: function() {
			// summary: starts a new batch, subsequent new child shapes will be held in
			//	the batch instead of appending to the container directly
		},
		closeBatch: function() {
			// summary: submits the current batch, append all pending child shapes to DOM
		},
		add: function(shape){
			// summary: adds a shape to the list
			// shape: dojox.gfx.Shape
			//		the shape to add to the list
			var oldParent = shape.getParent();
			if(oldParent){
				oldParent.remove(shape, true);
			}
			this.children.push(shape);
			return shape._setParent(this, this._getRealMatrix());	// self
		},
		remove: function(shape, silently){
			// summary: removes a shape from the list
			//	shape: dojox.gfx.shape.Shape
			//		the shape to remove
			// silently: Boolean
			//		if true, do not redraw a picture yet
			for(var i = 0; i < this.children.length; ++i){
				if(this.children[i] == shape){
					if(silently){
						// skip for now
					}else{
						shape.parent = null;
						shape.parentMatrix = null;
					}
					this.children.splice(i, 1);
					break;
				}
			}
			return this;	// self
		},
		clear: function(){
			// summary: removes all shapes from a group/surface
			var shape;
			for(var i = 0; i < this.children.length;++i){
				shape = this.children[i];
				shape.parent = null;
				shape.parentMatrix = null;
			}
			this.children = [];
			return this;	// self
		},
	
		// moving child nodes
	
		_moveChildToFront: function(shape){
			// summary: moves a shape to front of the list of shapes
			//	shape: dojox.gfx.shape.Shape
			//		one of the child shapes to move to the front
			for(var i = 0; i < this.children.length; ++i){
				if(this.children[i] == shape){
					this.children.splice(i, 1);
					this.children.push(shape);
					break;
				}
			}
			return this;	// self
		},
		_moveChildToBack: function(shape){
			// summary: moves a shape to back of the list of shapes
			//	shape: dojox.gfx.shape.Shape
			//		one of the child shapes to move to the front
			for(var i = 0; i < this.children.length; ++i){
				if(this.children[i] == shape){
					this.children.splice(i, 1);
					this.children.unshift(shape);
					break;
				}
			}
			return this;	// self
		}
	};
	
	declare("dojox.gfx.shape.Surface", null, {
		// summary: a surface object to be used for drawings
		constructor: function(){
			// underlying node
			this.rawNode = null;
			// the parent node
			this._parent = null;
			// the list of DOM nodes to be deleted in the case of destruction
			this._nodes = [];
			// the list of events to be detached in the case of destruction
			this._events = [];
		},
		destroy: function(){
			// summary: destroy all relevant external resources and release all
			//	external references to make this object garbage-collectible
			arr.forEach(this._nodes, domConstruct.destroy);
			this._nodes = [];
			arr.forEach(this._events, events.disconnect);
			this._events = [];
			this.rawNode = null;	// recycle it in _nodes, if it needs to be recycled
			if(has("ie")){
				while(this._parent.lastChild){
					domConstruct.destroy(this._parent.lastChild);
				}
			}else{
				this._parent.innerHTML = "";
			}
			this._parent = null;
		},
		getEventSource: function(){
			// summary: returns a node, which can be used to attach event listeners
			return this.rawNode; // Node
		},
		_getRealMatrix: function(){
			// summary: always returns the identity matrix
			return null;	// dojox.gfx.Matrix2D
		},
		isLoaded: true,
		onLoad: function(/*dojox.gfx.Surface*/ surface){
			// summary: local event, fired once when the surface is created
			// asynchronously, used only when isLoaded is false, required
			// only for Silverlight.
		},
		whenLoaded: function(/*Object|Null*/ context, /*Function|String*/ method){
			var f = lang.hitch(context, method);
			if(this.isLoaded){
				f(this);
			}else{
				var h = events.connect(this, "onLoad", function(surface){
					events.disconnect(h);
					f(surface);
				});
			}
		}
	});
	
	lang.extend(shape.Surface, shape._eventsProcessing);
	
	declare("dojox.gfx.Point", null, {
		// summary: a hypothetical 2D point to be used for drawings - {x, y}
		// description: This object is defined for documentation purposes.
		//	You should use the naked object instead: {x: 1, y: 2}.
	});
	
	declare("dojox.gfx.Rectangle", null, {
		// summary: a hypothetical rectangle - {x, y, width, height}
		// description: This object is defined for documentation purposes.
		//	You should use the naked object instead: {x: 1, y: 2, width: 100, height: 200}.
	});
	
	declare("dojox.gfx.shape.Rect", shape.Shape, {
		// summary: a generic rectangle
		constructor: function(rawNode){
			// rawNode: Node
			//		The underlying graphics system object (typically a DOM Node)
			this.shape = g.getDefault("Rect");
			this.rawNode = rawNode;
		},
		getBoundingBox: function(){
			// summary: returns the bounding box (its shape in this case)
			return this.shape;	// dojox.gfx.Rectangle
		}
	});
	
	declare("dojox.gfx.shape.Ellipse", shape.Shape, {
		// summary: a generic ellipse
		constructor: function(rawNode){
			// rawNode: Node
			//		a DOM Node
			this.shape = g.getDefault("Ellipse");
			this.rawNode = rawNode;
		},
		getBoundingBox: function(){
			// summary: returns the bounding box
			if(!this.bbox){
				var shape = this.shape;
				this.bbox = {x: shape.cx - shape.rx, y: shape.cy - shape.ry,
					width: 2 * shape.rx, height: 2 * shape.ry};
			}
			return this.bbox;	// dojox.gfx.Rectangle
		}
	});
	
	declare("dojox.gfx.shape.Circle", shape.Shape, {
		// summary: a generic circle
		//	(this is a helper object, which is defined for convenience)
		constructor: function(rawNode){
			// rawNode: Node
			//		a DOM Node
			this.shape = g.getDefault("Circle");
			this.rawNode = rawNode;
		},
		getBoundingBox: function(){
			// summary: returns the bounding box
			if(!this.bbox){
				var shape = this.shape;
				this.bbox = {x: shape.cx - shape.r, y: shape.cy - shape.r,
					width: 2 * shape.r, height: 2 * shape.r};
			}
			return this.bbox;	// dojox.gfx.Rectangle
		}
	});
	
	declare("dojox.gfx.shape.Line", shape.Shape, {
		// summary: a generic line
		//	(this is a helper object, which is defined for convenience)
		constructor: function(rawNode){
			// rawNode: Node
			//		a DOM Node
			this.shape = g.getDefault("Line");
			this.rawNode = rawNode;
		},
		getBoundingBox: function(){
			// summary: returns the bounding box
			if(!this.bbox){
				var shape = this.shape;
				this.bbox = {
					x:		Math.min(shape.x1, shape.x2),
					y:		Math.min(shape.y1, shape.y2),
					width:	Math.abs(shape.x2 - shape.x1),
					height:	Math.abs(shape.y2 - shape.y1)
				};
			}
			return this.bbox;	// dojox.gfx.Rectangle
		}
	});
	
	declare("dojox.gfx.shape.Polyline", shape.Shape, {
		// summary: a generic polyline/polygon
		//	(this is a helper object, which is defined for convenience)
		constructor: function(rawNode){
			// rawNode: Node
			//		a DOM Node
			this.shape = g.getDefault("Polyline");
			this.rawNode = rawNode;
		},
		setShape: function(points, closed){
			// summary: sets a polyline/polygon shape object
			// points: Object
			//		a polyline/polygon shape object
			// closed: Boolean
			//		close the polyline to make a polygon
			if(points && points instanceof Array){
				// points: Array: an array of points
				this.inherited(arguments, [{points: points}]);
				if(closed && this.shape.points.length){
					this.shape.points.push(this.shape.points[0]);
				}
			}else{
				this.inherited(arguments, [points]);
			}
			return this;	// self
		},
		_normalizePoints: function(){
			// summary: normalize points to array of {x:number, y:number}
			var p = this.shape.points, l = p && p.length;
			if(l && typeof p[0] == "number"){
				var points = [];
				for(var i = 0; i < l; i += 2){
					points.push({x: p[i], y: p[i + 1]});
				}
				this.shape.points = points;
			}
		},
		getBoundingBox: function(){
			// summary: returns the bounding box
			if(!this.bbox && this.shape.points.length){
				var p = this.shape.points;
				var l = p.length;
				var t = p[0];
				var bbox = {l: t.x, t: t.y, r: t.x, b: t.y};
				for(var i = 1; i < l; ++i){
					t = p[i];
					if(bbox.l > t.x) bbox.l = t.x;
					if(bbox.r < t.x) bbox.r = t.x;
					if(bbox.t > t.y) bbox.t = t.y;
					if(bbox.b < t.y) bbox.b = t.y;
				}
				this.bbox = {
					x:		bbox.l,
					y:		bbox.t,
					width:	bbox.r - bbox.l,
					height:	bbox.b - bbox.t
				};
			}
			return this.bbox;	// dojox.gfx.Rectangle
		}
	});
	
	declare("dojox.gfx.shape.Image", shape.Shape, {
		// summary: a generic image
		//	(this is a helper object, which is defined for convenience)
		constructor: function(rawNode){
			// rawNode: Node
			//		a DOM Node
			this.shape = g.getDefault("Image");
			this.rawNode = rawNode;
		},
		getBoundingBox: function(){
			// summary: returns the bounding box (its shape in this case)
			return this.shape;	// dojox.gfx.Rectangle
		},
		setStroke: function(){
			// summary: ignore setting a stroke style
			return this;	// self
		},
		setFill: function(){
			// summary: ignore setting a fill style
			return this;	// self
		}
	});
	
	declare("dojox.gfx.shape.Text", shape.Shape, {
		// summary: a generic text
		constructor: function(rawNode){
			// rawNode: Node
			//		a DOM Node
			this.fontStyle = null;
			this.shape = g.getDefault("Text");
			this.rawNode = rawNode;
		},
		getFont: function(){
			// summary: returns the current font object or null
			return this.fontStyle;	// Object
		},
		setFont: function(newFont){
			// summary: sets a font for text
			// newFont: Object
			//		a font object (see dojox.gfx.defaultFont) or a font string
			this.fontStyle = typeof newFont == "string" ? g.splitFontString(newFont) :
				g.makeParameters(g.defaultFont, newFont);
			this._setFont();
			return this;	// self
		}
	});
	
	shape.Creator = {
		// summary: shape creators
		createShape: function(shape){
			// summary: creates a shape object based on its type; it is meant to be used
			//	by group-like objects
			// shape: Object
			//		a shape descriptor object
			switch(shape.type){
				case g.defaultPath.type:		return this.createPath(shape);
				case g.defaultRect.type:		return this.createRect(shape);
				case g.defaultCircle.type:	return this.createCircle(shape);
				case g.defaultEllipse.type:	return this.createEllipse(shape);
				case g.defaultLine.type:		return this.createLine(shape);
				case g.defaultPolyline.type:	return this.createPolyline(shape);
				case g.defaultImage.type:		return this.createImage(shape);
				case g.defaultText.type:		return this.createText(shape);
				case g.defaultTextPath.type:	return this.createTextPath(shape);
			}
			return null;
		},
		createGroup: function(){
			// summary: creates a group shape
			return this.createObject(g.Group);	// dojox.gfx.Group
		},
		createRect: function(rect){
			// summary: creates a rectangle shape
			// rect: Object
			//		a path object (see dojox.gfx.defaultRect)
			return this.createObject(g.Rect, rect);	// dojox.gfx.Rect
		},
		createEllipse: function(ellipse){
			// summary: creates an ellipse shape
			// ellipse: Object
			//		an ellipse object (see dojox.gfx.defaultEllipse)
			return this.createObject(g.Ellipse, ellipse);	// dojox.gfx.Ellipse
		},
		createCircle: function(circle){
			// summary: creates a circle shape
			// circle: Object
			//		a circle object (see dojox.gfx.defaultCircle)
			return this.createObject(g.Circle, circle);	// dojox.gfx.Circle
		},
		createLine: function(line){
			// summary: creates a line shape
			// line: Object
			//		a line object (see dojox.gfx.defaultLine)
			return this.createObject(g.Line, line);	// dojox.gfx.Line
		},
		createPolyline: function(points){
			// summary: creates a polyline/polygon shape
			// points: Object
			//		a points object (see dojox.gfx.defaultPolyline)
			//		or an Array of points
			return this.createObject(g.Polyline, points);	// dojox.gfx.Polyline
		},
		createImage: function(image){
			// summary: creates a image shape
			// image: Object
			//		an image object (see dojox.gfx.defaultImage)
			return this.createObject(g.Image, image);	// dojox.gfx.Image
		},
		createText: function(text){
			// summary: creates a text shape
			// text: Object
			//		a text object (see dojox.gfx.defaultText)
			return this.createObject(g.Text, text);	// dojox.gfx.Text
		},
		createPath: function(path){
			// summary: creates a path shape
			// path: Object
			//		a path object (see dojox.gfx.defaultPath)
			return this.createObject(g.Path, path);	// dojox.gfx.Path
		},
		createTextPath: function(text){
			// summary: creates a text shape
			// text: Object
			//		a textpath object (see dojox.gfx.defaultTextPath)
			return this.createObject(g.TextPath, {}).setText(text);	// dojox.gfx.TextPath
		},
		createObject: function(shapeType, rawShape){
			// summary: creates an instance of the passed shapeType class
			// SHOULD BE RE-IMPLEMENTED BY THE RENDERER!
			// shapeType: Function
			//		a class constructor to create an instance of
			// rawShape: Object 
			//		properties to be passed in to the classes 'setShape' method
	
			return null;	// dojox.gfx.Shape
		}
	};
	
	return shape;
});


},
'ibm/tivoli/tip/dijit/TIPTableRefreshButton':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/tip/dijit/nls/resources","dojo/require!dijit/form/Button,dijit/Tooltip"], function(dijit,dojo,dojox){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * 5724-C51
 *
 * (C) Copyright IBM Corp. 2008 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/
dojo.require("dijit.form.Button");
dojo.require("dijit.Tooltip");

// NLS
dojo.requireLocalization("ibm.tivoli.tip.dijit", "resources");

dojo.provide("ibm.tivoli.tip.dijit.TIPTableRefreshButton");
/******************************************************************************
* Provides Table Refresh button that allows for "busy" animation. 
*
* Authors: Joseph Firebaugh
******************************************************************************/
dojo.declare("ibm.tivoli.tip.dijit.TIPTableRefreshButton", dijit.form.Button,
{
    baseClass: "tipTableRefreshButton",

	 //templateString:"<div class=\"dijit dijitLeft dijitInline ${baseClass}\"\n\tdojoAttachEvent=\"onclick:_onButtonClick,onmouseenter:_onMouse,onmouseleave:_onMouse,onmousedown:_onMouse\"\n\t><div class='dijitRight'\n\t\t><button class=\"dijitStretch dijitButtonNode dijitButtonContents\" dojoAttachPoint=\"focusNode,titleNode\"\n\t\t\ttype=\"${type}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t><span class=\"dijitInline ${iconClass}\" dojoAttachPoint=\"iconNode\" \n \t\t\t\t><span class=\"dijitToggleButtonIconChar\">&#10003</span \n\t\t\t></span\n\t\t\t><span class=\"dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\">${label}</span\n\t\t></button\n\t></div\n></div>\n",
    templateString:"<div class=\"dijit dijitLeft dijitInline ${baseClass}\"\n\tdojoAttachEvent=\"ondijitclick:_onClick\"\n\t><div class='dijitRight'\n\t\t><button class=\"dijitStretch dijitButtonNode dijitButtonContents\" dojoAttachPoint=\"focusNode,titleNode\"\n\t\t\ttype=\"${type}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t><span class=\"dijitInline ${iconClass}\" dojoAttachPoint=\"iconNode\" \n \t\t\t\t><span class=\"dijitToggleButtonIconChar\">&#10003</span \n\t\t\t></span\n\t\t\t><span class=\"dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\">${label}</span\n\t\t></button\n\t></div\n></div>\n",
    
    postCreate: function()
    {
		var resources = dojo.i18n.getLocalization("ibm.tivoli.tip.dijit", "resources");
		this.titleNode.title = resources.REFRESH;
		// in dojo 1.2.3, _FormWidgets scroll themselves into view when they, or their container get focus.
		// this is causing my UI to jump when even clicking on widgets that are already visible
		this._scroll = false;
    }
    
});
});

},
'dijit/_OnDijitClickMixin':function(){
define("dijit/_OnDijitClickMixin", [
	"dojo/on",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.ENTER keys.SPACE
	"dojo/_base/declare", // declare
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window" // win.doc.addEventListener win.doc.attachEvent win.doc.detachEvent
], function(on, array, keys, declare, has, unload, win){

	// module:
	//		dijit/_OnDijitClickMixin
	// summary:
	//		Mixin so you can pass "ondijitclick" to this.connect() method,
	//		as a way to handle clicks by mouse, or by keyboard (SPACE/ENTER key)


	// Keep track of where the last keydown event was, to help avoid generating
	// spurious ondijitclick events when:
	// 1. focus is on a <button> or <a>
	// 2. user presses then releases the ENTER key
	// 3. onclick handler fires and shifts focus to another node, with an ondijitclick handler
	// 4. onkeyup event fires, causing the ondijitclick handler to fire
	var lastKeyDownNode = null;
	if(has("ie")){
		(function(){
			var keydownCallback = function(evt){
				lastKeyDownNode = evt.srcElement;
			};
			win.doc.attachEvent('onkeydown', keydownCallback);
			unload.addOnWindowUnload(function(){
				win.doc.detachEvent('onkeydown', keydownCallback);
			});
		})();
	}else{
		win.doc.addEventListener('keydown', function(evt){
			lastKeyDownNode = evt.target;
		}, true);
	}

	// Custom a11yclick (a.k.a. ondijitclick) event
	var a11yclick = function(node, listener){
		if(/input|button/i.test(node.nodeName)){
			// pass through, the browser already generates click event on SPACE/ENTER key
			return on(node, "click", listener);
		}else{
			// Don't fire the click event unless both the keydown and keyup occur on this node.
			// Avoids problems where focus shifted to this node or away from the node on keydown,
			// either causing this node to process a stray keyup event, or causing another node
			// to get a stray keyup event.

			function clickKey(/*Event*/ e){
				return (e.keyCode == keys.ENTER || e.keyCode == keys.SPACE) &&
						!e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
			}
			var handles = [
				on(node, "keypress", function(e){
					//console.log(this.id + ": onkeydown, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
					if(clickKey(e)){
						// needed on IE for when focus changes between keydown and keyup - otherwise dropdown menus do not work
						lastKeyDownNode = e.target;

						// Prevent viewport scrolling on space key in IE<9.
						// (Reproducible on test_Button.html on any of the first dijit.form.Button examples)
						// Do this onkeypress rather than onkeydown because onkeydown.preventDefault() will
						// suppress the onkeypress event, breaking _HasDropDown
						e.preventDefault();
					}
				}),

				on(node, "keyup", function(e){
					//console.log(this.id + ": onkeyup, e.target = ", e.target, ", lastKeyDownNode was ", lastKeyDownNode, ", equality is ", (e.target === lastKeyDownNode));
					if(clickKey(e) && e.target == lastKeyDownNode){	// === breaks greasemonkey
						//need reset here or have problems in FF when focus returns to trigger element after closing popup/alert
						lastKeyDownNode = null;
						listener.call(this, e);
					}
				}),

				on(node, "click", function(e){
					// and connect for mouse clicks too (or touch-clicks on mobile)
					listener.call(this, e);
				})
			];

			return {
				remove: function(){
					array.forEach(handles, function(h){ h.remove(); });
				}
			};
		}
	};

	return declare("dijit._OnDijitClickMixin", null, {
		connect: function(
				/*Object|null*/ obj,
				/*String|Function*/ event,
				/*String|Function*/ method){
			// summary:
			//		Connects specified obj/event to specified method of this object
			//		and registers for disconnect() on widget destroy.
			// description:
			//		Provide widget-specific analog to connect.connect, except with the
			//		implicit use of this widget as the target object.
			//		This version of connect also provides a special "ondijitclick"
			//		event which triggers on a click or space or enter keyup.
			//		Events connected with `this.connect` are disconnected upon
			//		destruction.
			// returns:
			//		A handle that can be passed to `disconnect` in order to disconnect before
			//		the widget is destroyed.
			// example:
			//	|	var btn = new dijit.form.Button();
			//	|	// when foo.bar() is called, call the listener we're going to
			//	|	// provide in the scope of btn
			//	|	btn.connect(foo, "bar", function(){
			//	|		console.debug(this.toString());
			//	|	});
			// tags:
			//		protected

			return this.inherited(arguments, [obj, event == "ondijitclick" ? a11yclick : event, method]);
		}
	});
});

},
'ibm/tivoli/tip/dijit/TIPTableToolbar':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dijit/_Templated,dijit/Toolbar,ibm/tivoli/tip/dijit/TIPTableSearchField"], function(dijit,dojo,dojox){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * 5724-C51
 *
 * (C) Copyright IBM Corp. 2007 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit.Toolbar");

dojo.require("ibm.tivoli.tip.dijit.TIPTableSearchField");

dojo.provide("ibm.tivoli.tip.dijit.TIPTableToolbar");

/******************************************************************************
* A dijit.Toolbar and a TIPTableSearchField combined into one.
*
* Authors: Joseph Firebaugh
******************************************************************************/
dojo.declare("ibm.tivoli.tip.dijit.TIPTableToolbar",
            [ dijit._Widget, dijit._Templated ],
{
  widgetsInTemplate: true,
  
  templateString:"<table border=\"0\" cellpadding=\"0\" cellspacing=\"0\" class=\"tableToolbar\">\n<tr>\n\t<td class=\"TIPTableToolbarArea\">\n\t<div dojoType=\"dijit.Toolbar\" dojoAttachPoint=\"toolbar\" class=\"tableToolbarArea\" ></div>\n\t</td>\n    <td class=\"TIPTableSearchFieldArea\">\n    <div dojoType=\"ibm.tivoli.tip.dijit.TIPTableSearchField\" dojoAttachPoint=\"searchField\"></div>\n    </td>\n</tr>\n</table>",
  
  getToolbar: function()
  {
    return this.toolbar;
  },
  
  destroy: function()
  {
  	this.searchField.destroy();
  	this.toolbar.destroy();
  	
  	this.inherited( arguments );
  }    
});

});

},
'dojo/dnd/autoscroll':function(){
define("dojo/dnd/autoscroll", ["../main", "../window"], function(dojo) {
	// module:
	//		dojo/dnd/autoscroll
	// summary:
	//		TODOC

dojo.getObject("dnd", true, dojo);

dojo.dnd.getViewport = dojo.window.getBox;

dojo.dnd.V_TRIGGER_AUTOSCROLL = 32;
dojo.dnd.H_TRIGGER_AUTOSCROLL = 32;

dojo.dnd.V_AUTOSCROLL_VALUE = 16;
dojo.dnd.H_AUTOSCROLL_VALUE = 16;

dojo.dnd.autoScroll = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the window, if
	//		necesary
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!
	var v = dojo.window.getBox(), dx = 0, dy = 0;
	if(e.clientX < dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = -dojo.dnd.H_AUTOSCROLL_VALUE;
	}else if(e.clientX > v.w - dojo.dnd.H_TRIGGER_AUTOSCROLL){
		dx = dojo.dnd.H_AUTOSCROLL_VALUE;
	}
	if(e.clientY < dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = -dojo.dnd.V_AUTOSCROLL_VALUE;
	}else if(e.clientY > v.h - dojo.dnd.V_TRIGGER_AUTOSCROLL){
		dy = dojo.dnd.V_AUTOSCROLL_VALUE;
	}
	window.scrollBy(dx, dy);
};

dojo.dnd._validNodes = {"div": 1, "p": 1, "td": 1};
dojo.dnd._validOverflow = {"auto": 1, "scroll": 1};

dojo.dnd.autoScrollNodes = function(e){
	// summary:
	//		a handler for onmousemove event, which scrolls the first avaialble
	//		Dom element, it falls back to dojo.dnd.autoScroll()
	// e: Event
	//		onmousemove event

	// FIXME: needs more docs!

	var b, t, w, h, rx, ry, dx = 0, dy = 0, oldLeft, oldTop;

	for(var n = e.target; n;){
		if(n.nodeType == 1 && (n.tagName.toLowerCase() in dojo.dnd._validNodes)){
			var s = dojo.getComputedStyle(n),
				overflow = (s.overflow.toLowerCase() in dojo.dnd._validOverflow),
				overflowX = (s.overflowX.toLowerCase() in dojo.dnd._validOverflow),
				overflowY = (s.overflowY.toLowerCase() in dojo.dnd._validOverflow);
			if(overflow || overflowX || overflowY){
				b = dojo._getContentBox(n, s);
				t = dojo.position(n, true);
			}
			// overflow-x
			if(overflow || overflowX){
				w = Math.min(dojo.dnd.H_TRIGGER_AUTOSCROLL, b.w / 2);
				rx = e.pageX - t.x;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					rx += dojo.body().scrollLeft;
				}
				dx = 0;
				if(rx > 0 && rx < b.w){
					if(rx < w){
						dx = -w;
					}else if(rx > b.w - w){
						dx = w;
					}
					oldLeft = n.scrollLeft;
					n.scrollLeft = n.scrollLeft + dx;
				}
			}
			// overflow-y
			if(overflow || overflowY){
				//console.log(b.l, b.t, t.x, t.y, n.scrollLeft, n.scrollTop);
				h = Math.min(dojo.dnd.V_TRIGGER_AUTOSCROLL, b.h / 2);
				ry = e.pageY - t.y;
				if(dojo.isWebKit || dojo.isOpera){
					// FIXME: this code should not be here, it should be taken into account
					// either by the event fixing code, or the dojo.position()
					// FIXME: this code doesn't work on Opera 9.5 Beta
					ry += dojo.body().scrollTop;
				}
				dy = 0;
				if(ry > 0 && ry < b.h){
					if(ry < h){
						dy = -h;
					}else if(ry > b.h - h){
						dy = h;
					}
					oldTop = n.scrollTop;
					n.scrollTop  = n.scrollTop  + dy;
				}
			}
			if(dx || dy){ return; }
		}
		try{
			n = n.parentNode;
		}catch(x){
			n = null;
		}
	}
	dojo.dnd.autoScroll(e);
};

	return dojo.dnd;
});

},
'dijit/form/_RadioButtonMixin':function(){
define("dijit/form/_RadioButtonMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/event", // event.stop
	"dojo/_base/lang", // lang.hitch
	"dojo/query", // query
	"dojo/_base/window", // win.doc
	"../registry"	// registry.getEnclosingWidget
], function(array, declare, domAttr, event, lang, query, win, registry){

	// module:
	//		dijit/form/_RadioButtonMixin
	// summary:
	// 		Mixin to provide widget functionality for an HTML radio button

	return declare("dijit.form._RadioButtonMixin", null, {
		// summary:
		// 		Mixin to provide widget functionality for an HTML radio button

		// type: [private] String
		//		type attribute on <input> node.
		//		Users should not change this value.
		type: "radio",

		_getRelatedWidgets: function(){
			// Private function needed to help iterate over all radio buttons in a group.
			var ary = [];
			query("input[type=radio]", this.focusNode.form || win.doc).forEach( // can't use name= since query doesn't support [] in the name
				lang.hitch(this, function(inputNode){
					if(inputNode.name == this.name && inputNode.form == this.focusNode.form){
						var widget = registry.getEnclosingWidget(inputNode);
						if(widget){
							ary.push(widget);
						}
					}
				})
			);
			return ary;
		},

		_setCheckedAttr: function(/*Boolean*/ value){
			// If I am being checked then have to deselect currently checked radio button
			this.inherited(arguments);
			if(!this._created){ return; }
			if(value){
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					if(widget != this && widget.checked){
						widget.set('checked', false);
					}
				}));
			}
		},

		_onClick: function(/*Event*/ e){
			if(this.checked || this.disabled){ // nothing to do
				event.stop(e);
				return false;
			}
			if(this.readOnly){ // ignored by some browsers so we have to resync the DOM elements with widget values
				event.stop(e);
				array.forEach(this._getRelatedWidgets(), lang.hitch(this, function(widget){
					domAttr.set(this.focusNode || this.domNode, 'checked', widget.checked);
				}));
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'url:dijit/templates/TreeNode.html':"<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div data-dojo-attach-point=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\" data-dojo-attach-event=\"onmouseenter:_onMouseEnter, onmouseleave:_onMouseLeave, onclick:_onClick, ondblclick:_onDblClick\"\n\t\t><img src=\"${_blankGif}\" alt=\"\" data-dojo-attach-point=\"expandoNode\" class=\"dijitTreeExpando\" role=\"presentation\"\n\t\t/><span data-dojo-attach-point=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"\n\t\t></span\n\t\t><span data-dojo-attach-point=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" data-dojo-attach-point=\"iconNode\" class=\"dijitIcon dijitTreeIcon\" role=\"presentation\"\n\t\t\t/><span data-dojo-attach-point=\"labelNode\" class=\"dijitTreeLabel\" role=\"treeitem\" tabindex=\"-1\" aria-selected=\"false\" data-dojo-attach-event=\"onfocus:_onLabelFocus\"></span>\n\t\t</span\n\t></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\" style=\"display: none;\"></div>\n</div>\n",
'dojo/dnd/TimedMoveable':function(){
define("dojo/dnd/TimedMoveable", ["../main", "./Moveable"], function(dojo) {
	// module:
	//		dojo/dnd/TimedMoveable
	// summary:
	//		TODOC

	/*=====
	dojo.declare("dojo.dnd.__TimedMoveableArgs", [dojo.dnd.__MoveableArgs], {
		// timeout: Number
		//		delay move by this number of ms,
		//		accumulating position changes during the timeout
		timeout: 0
	});
	=====*/

	// precalculate long expressions
	var oldOnMove = dojo.dnd.Moveable.prototype.onMove;

	dojo.declare("dojo.dnd.TimedMoveable", dojo.dnd.Moveable, {
		// summary:
		//		A specialized version of Moveable to support an FPS throttling.
		//		This class puts an upper restriction on FPS, which may reduce
		//		the CPU load. The additional parameter "timeout" regulates
		//		the delay before actually moving the moveable object.

		// object attributes (for markup)
		timeout: 40,	// in ms, 40ms corresponds to 25 fps

		constructor: function(node, params){
			// summary:
			//		an object that makes a node moveable with a timer
			// node: Node||String
			//		a node (or node's id) to be moved
			// params: dojo.dnd.__TimedMoveableArgs
			//		object with additional parameters.

			// sanitize parameters
			if(!params){ params = {}; }
			if(params.timeout && typeof params.timeout == "number" && params.timeout >= 0){
				this.timeout = params.timeout;
			}
		},

		onMoveStop: function(/* dojo.dnd.Mover */ mover){
			if(mover._timer){
				// stop timer
				clearTimeout(mover._timer);
				// reflect the last received position
				oldOnMove.call(this, mover, mover._leftTop)
			}
			dojo.dnd.Moveable.prototype.onMoveStop.apply(this, arguments);
		},
		onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
			mover._leftTop = leftTop;
			if(!mover._timer){
				var _t = this;	// to avoid using dojo.hitch()
				mover._timer = setTimeout(function(){
					// we don't have any pending requests
					mover._timer = null;
					// reflect the last received position
					oldOnMove.call(_t, mover, mover._leftTop);
				}, this.timeout);
			}
		}
	});

	return dojo.dnd.TimedMoveable;
	
});

},
'dijit/form/_ListMouseMixin':function(){
define("dijit/form/_ListMouseMixin", [
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/touch",
	"./_ListBase"
], function(declare, event, touch, _ListBase){

/*=====
var _ListBase = dijit.form._ListBase;
=====*/

// module:
//		dijit/form/_ListMouseMixin
// summary:
//		a mixin to handle mouse or touch events for a focus-less menu

return declare( "dijit.form._ListMouseMixin", _ListBase, {
	// summary:
	//		a Mixin to handle mouse or touch events for a focus-less menu
	//		Abstract methods that must be defined externally:
	//			onClick: item was chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
	// tags:
	//		private

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, touch.press, "_onMouseDown");
		this.connect(this.domNode, touch.release, "_onMouseUp");
		this.connect(this.domNode, "onmouseover", "_onMouseOver");
		this.connect(this.domNode, "onmouseout", "_onMouseOut");
	},

	_onMouseDown: function(/*Event*/ evt){
		event.stop(evt);
		if(this._hoveredNode){
			this.onUnhover(this._hoveredNode);
			this._hoveredNode = null;
		}
		this._isDragging = true;
		this._setSelectedAttr(this._getTarget(evt));
	},

	_onMouseUp: function(/*Event*/ evt){
		event.stop(evt);
		this._isDragging = false;
		var selectedNode = this._getSelectedAttr();
		var target = this._getTarget(evt);
		var hoveredNode = this._hoveredNode;
		if(selectedNode && target == selectedNode){
			this.onClick(selectedNode);
		}else if(hoveredNode && target == hoveredNode){ // drag to select
			this._setSelectedAttr(hoveredNode);
			this.onClick(hoveredNode);
		}
	},

	_onMouseOut: function(/*Event*/ /*===== evt ====*/){
		if(this._hoveredNode){
			this.onUnhover(this._hoveredNode);
			if(this._getSelectedAttr() == this._hoveredNode){
				this.onSelect(this._hoveredNode);
			}
			this._hoveredNode = null;
		}
		if(this._isDragging){
			this._cancelDrag = (new Date()).getTime() + 1000; // cancel in 1 second if no _onMouseOver fires
		}
	},

	_onMouseOver: function(/*Event*/ evt){
		if(this._cancelDrag){
			var time = (new Date()).getTime();
			if(time > this._cancelDrag){
				this._isDragging = false;
			}
			this._cancelDrag = null;
		}
		var node = this._getTarget(evt);
		if(!node){ return; }
		if(this._hoveredNode != node){
			if(this._hoveredNode){
				this._onMouseOut({ target: this._hoveredNode });
			}
			if(node && node.parentNode == this.containerNode){
				if(this._isDragging){
					this._setSelectedAttr(node);
				}else{
					this._hoveredNode = node;
					this.onHover(node);
				}
			}
		}
	}
});

});

},
'url:dijit/templates/Tree.html':"<div class=\"dijitTree dijitTreeContainer\" role=\"tree\"\n\tdata-dojo-attach-event=\"onkeypress:_onKeyPress\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" data-dojo-attach-point=\"indentDetector\"></div>\n</div>\n",
'ibm/tivoli/simplesrm/srm/dojo/Logger':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.Logger");
dojo.provide("ibm.tivoli.simplesrm.srm.dojo.LogLevel");



/**
 * creates elements in enum ibm.tivoli.simplesrm.srm.dojo.LogLevels
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.LogLevel",null, {
	constructor: function(params){
		if (!params || !dojo.isString(params.name) || isNaN(params.rank) || !dojo.isString(params.serverName)){
			throw new TypeError("invalid properties passed");
		}
		this.name = params.name;
		this.rank = params.rank;
		this.serverName = params.serverName;
	}
});


/**
 * generally log levels are the same as in FireBug(ALL and OFF have been added). 
 * levels on the server may be different (i.e. log4j or Java Logging API) so
 * a mapping is provided via "serverName" field.<br> 
 * levels: ALL(lowest rank),LOG,DEBUG,INFO,WARN,ERROR,OFF(highest rank).
 */
ibm.tivoli.simplesrm.srm.dojo.LogLevels = {	
	ALL  : new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "ALL"  , rank:-1, serverName: "ALL"}) ,
	LOG  : new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "LOG"  , rank: 0, serverName: "FINE"}) ,
	DEBUG: new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "DEBUG", rank: 1, serverName: "CONFIG"}) ,
	INFO : new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "INFO" , rank: 2, serverName: "INFO"}) ,
	WARN : new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "WARN" , rank: 3, serverName: "WARNING"}) ,
	ERROR: new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "ERROR", rank: 4, serverName: "SEVERE"}) ,
	OFF  : new ibm.tivoli.simplesrm.srm.dojo.LogLevel({name: "OFF"  , rank: 5, serverName: "OFF"})
};



/**
 * provides server logging. logging methods are named after FireBug console.xxx methods
 * use currentLogLevel to configure correct log level. it can be used via shortcut ibm.tivoli.logger 
 * <br><br>
 * NOTE: all logging method have an optional argument of type Error.
 * if provided additional info is appended to the message (line number, file name, error message)
 * message won't be logged if it has lower log level (rank) then currentLogLevel.
 *  default value:ibm.tivoli.simplesrm.srm.dojo.LogLevels.ERROR  	
 *
 * <br><br>
 * Example: ibm.tivoli.logger.log("something bad happened",new Error())
 * @see ibm.tivoli.simplesrm.srm.dojo.LogLevel
 * @see ibm.tivoli.simplesrm.srm.dojo.LogLevels
 * @see ibm.tivoli.simplesrm.srm.dijit.SimpleSrmApp
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.Logger", null, 
{
	id: '',
	constructor: function(params){
		var levels = ibm.tivoli.simplesrm.srm.dojo.LogLevels;
		var currentLogLevel = levels.ERROR;
		var id = '';  //need a Dom id for sendevent
		
		if (params && params.id){
			id = params.id;  
		} 		
		
		/** 
		 * private method:do not use directly.<br>
		 * all exceptions during execution are caught.
		 * @param {ibm.tivoli.simplesrm.srm.dojo.LogLevel} level
		 * @param {String} message
		 * @param {Error} error  (optional)
		 * @return {Boolean} false if message log level was to low 
		 */
		var send = function(level,message,error)
		{			
			try{
				if(currentLogLevel.rank > level.rank){
					return false; 
				}
				
				var msg = dojo.isString(message) ? message : "";
				
				if(error) {
					msg +=  " [" ;
					msg +=  error.message ? " Message: " + error.message : "";
					msg +=  (error.lineNumber !== undefined) ? " | Line: " + error.lineNumber : ""; 
					msg +=  error.fileName   ? " | File: " + error.fileName : "";
					msg +=  " ]";
				}
				
				if (id=='') {				
					var clientdiv = dojo.query(".clientarea");
					if (clientdiv.length>0) {
						id =  clientdiv[0].id;					    					
					}
				}
				
				//Commented out the code to send the error to the server. The response is causing the cursor to be changed which is throwing off some fields.
				//Don't think it's of much use anyway.				
				//sendEvent("logerror", id,  msg); 
				
				//dojo.xhrPost({
				//	url: "/SRMCommonsWeb/MessageLogger",
				//	content: {level: level.serverName, message: msg},
				//	sync: false,
				//	error: function(response, ioArgs) {
				//		console.warn("Failed sending log message to the server: ", msg);
				//	}
				//});	
			}
			catch(exception){
				console.warn("Failed to send log message with error: ",exception);			
			}
			return true;
		};
		
		this.log = function(message, error)	{ send(levels.LOG,message,error);};
		this.debug = function(message, error)	{ send(levels.DEBUG,message,error);};
		this.info = function(message, error)	{ send(levels.INFO,message,error);};
		this.warn = function(message, error)	{ send(levels.WARN,message,error);};
		this.error = function(message, error)	{ send(levels.ERROR,message,error);};
		
		this.setLevel = function(level){
			if(level instanceof ibm.tivoli.simplesrm.srm.dojo.LogLevel){
				currentLogLevel = level;
			}
			else {
				throw new TypeError("LogLevel expected");
			}
		};
		this.getLevel = function(){ return currentLogLevel;};
	},
	/** @param {ibm.tivoli.simplesrm.srm.dojo.LogLevel} @type {void}*/
	setLevel: undefined,
	/** @return {ibm.tivoli.simplesrm.srm.dojo.LogLevel}*/
	getLevel: undefined,
	
	/** @param {String} message	 @param {Error} error (optional)  @type void	 */
	log:   undefined,
	/** @param {String} message	 @param {Error} error (optional) @type void	 */
	debug: undefined,
	/** @param {String} message	 @param {Error} error (optional)@type void	 */
	info:  undefined,
	/** @param {String} message	 @param {Error} error (optional) @type void	 */
	warn:  undefined,
	/** @param {String} message	 @param {Error} error (optional) @type void	 */
	error: undefined
	
});
ibm.tivoli.logger = null;
if(!ibm.tivoli.logger) {	
   ibm.tivoli.logger = new ibm.tivoli.simplesrm.srm.dojo.Logger();	    
}

});

},
'dojo/cldr/monetary':function(){
define("dojo/cldr/monetary", ["../main"], function(dojo) {
	// module:
	//		dojo/cldr/monetary
	// summary:
	//		TODOC

dojo.getObject("cldr.monetary", true, dojo);

dojo.cldr.monetary.getData = function(/*String*/code){
// summary: A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.
// code: an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code

// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/currencyData/fractions

	var placesData = {
		ADP:0,AFN:0,ALL:0,AMD:0,BHD:3,BIF:0,BYR:0,CLF:0,CLP:0,
		COP:0,CRC:0,DJF:0,ESP:0,GNF:0,GYD:0,HUF:0,IDR:0,IQD:0,
		IRR:3,ISK:0,ITL:0,JOD:3,JPY:0,KMF:0,KPW:0,KRW:0,KWD:3,
		LAK:0,LBP:0,LUF:0,LYD:3,MGA:0,MGF:0,MMK:0,MNT:0,MRO:0,
		MUR:0,OMR:3,PKR:0,PYG:0,RSD:0,RWF:0,SLL:0,SOS:0,STD:0,
		SYP:0,TMM:0,TND:3,TRL:0,TZS:0,UGX:0,UZS:0,VND:0,VUV:0,
		XAF:0,XOF:0,XPF:0,YER:0,ZMK:0,ZWD:0
	};

	var roundingData = {CHF:5};

	var places = placesData[code], round = roundingData[code];
	if(typeof places == "undefined"){ places = 2; }
	if(typeof round == "undefined"){ round = 0; }

	return {places: places, round: round}; // Object
};

return dojo.cldr.monetary;
});

},
'dojo/cookie':function(){
define("dojo/cookie", ["./_base/kernel", "./regexp"], function(dojo, regexp) {
	// module:
	//		dojo/cookie
	// summary:
	//		TODOC


/*=====
dojo.__cookieProps = function(){
	//	expires: Date|String|Number?
	//		If a number, the number of days from today at which the cookie
	//		will expire. If a date, the date past which the cookie will expire.
	//		If expires is in the past, the cookie will be deleted.
	//		If expires is omitted or is 0, the cookie will expire when the browser closes.
	//	path: String?
	//		The path to use for the cookie.
	//	domain: String?
	//		The domain to use for the cookie.
	//	secure: Boolean?
	//		Whether to only send the cookie on secure connections
	this.expires = expires;
	this.path = path;
	this.domain = domain;
	this.secure = secure;
}
=====*/


dojo.cookie = function(/*String*/name, /*String?*/value, /*dojo.__cookieProps?*/props){
	//	summary:
	//		Get or set a cookie.
	//	description:
	// 		If one argument is passed, returns the value of the cookie
	// 		For two or more arguments, acts as a setter.
	//	name:
	//		Name of the cookie
	//	value:
	//		Value for the cookie
	//	props:
	//		Properties for the cookie
	//	example:
	//		set a cookie with the JSON-serialized contents of an object which
	//		will expire 5 days from now:
	//	|	dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });
	//
	//	example:
	//		de-serialize a cookie back into a JavaScript object:
	//	|	var config = dojo.fromJson(dojo.cookie("configObj"));
	//
	//	example:
	//		delete a cookie:
	//	|	dojo.cookie("configObj", null, {expires: -1});
	var c = document.cookie, ret;
	if(arguments.length == 1){
		var matches = c.match(new RegExp("(?:^|; )" + regexp.escapeString(name) + "=([^;]*)"));
		ret = matches ? decodeURIComponent(matches[1]) : undefined; 
	}else{
		props = props || {};
// FIXME: expires=0 seems to disappear right away, not on close? (FF3)  Change docs?
		var exp = props.expires;
		if(typeof exp == "number"){
			var d = new Date();
			d.setTime(d.getTime() + exp*24*60*60*1000);
			exp = props.expires = d;
		}
		if(exp && exp.toUTCString){ props.expires = exp.toUTCString(); }

		value = encodeURIComponent(value);
		var updatedCookie = name + "=" + value, propName;
		for(propName in props){
			updatedCookie += "; " + propName;
			var propValue = props[propName];
			if(propValue !== true){ updatedCookie += "=" + propValue; }
		}
		document.cookie = updatedCookie;
	}
	return ret; // String|undefined
};

dojo.cookie.isSupported = function(){
	//	summary:
	//		Use to determine if the current browser supports cookies or not.
	//
	//		Returns true if user allows cookies.
	//		Returns false if user doesn't allow cookies.

	if(!("cookieEnabled" in navigator)){
		this("__djCookieTest__", "CookiesAllowed");
		navigator.cookieEnabled = this("__djCookieTest__") == "CookiesAllowed";
		if(navigator.cookieEnabled){
			this("__djCookieTest__", "", {expires: -1});
		}
	}
	return navigator.cookieEnabled;
};

return dojo.cookie;
});

},
'dojo/cache':function(){
define("dojo/cache", ["./_base/kernel", "./text"], function(dojo, text){
	// module:
	//		dojo/cache
	// summary:
	//		The module defines dojo.cache by loading dojo/text.

	//dojo.cache is defined in dojo/text
	return dojo.cache;
});

},
'url:dijit/form/templates/DropDownBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\"\n\trole=\"combobox\"\n\t><div class='dijitReset dijitRight dijitButtonNode dijitArrowButton dijitDownArrowButton dijitArrowButtonContainer'\n\t\tdata-dojo-attach-point=\"_buttonNode, _popupStateNode\" role=\"presentation\"\n\t\t><input class=\"dijitReset dijitInputField dijitArrowButtonInner\" value=\"&#9660; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t\t\t${_buttonInputDisabled}\n\t/></div\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class='dijitReset dijitInputInner' ${!nameAttrSetting} type=\"text\" autocomplete=\"off\"\n\t\t\tdata-dojo-attach-point=\"textbox,focusNode\" role=\"textbox\" aria-haspopup=\"true\"\n\t/></div\n></div>\n",
'ibm/tivoli/simplesrm/srm/dijit/MultipleModal':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/DialogUnderlay"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MultipleModal");

dojo.require("dijit.DialogUnderlay");

/**
 *  groups methods needed to support multiple modal panels
 */
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.MultipleModal",
	null,
	{		
		/** "property signature" to recognized if class was mixed with MultipleModal
		 * @type {Boolean} 
		 */
		supportsMultipleModal : true,
		
		/** 
		 * modifies dijit.DialogUnderlay to support multiple modal panels.
		 * should be run before any modal panel is created.<br><br>
		 * Flow:<br>
		 * dijit._underlay singleton maintains a counter of opened modal panels.
		 * based on this counter it calculates its zIndex.
		 * each panel before being displayed has to get correct zIndex (based on the counter).
		 * with each Underaly.show() underlay counter is increased(underlay covers older modal panels),
		 * with each Underaly.hide() counter is decreased. 
		 * when counter reaches 0 original hide() method is invoked and dijit._underlay gets hidden.
		 * @see ibm.tivoli.simplesrm.srm.dijit.DojoUpgrades
		 * @type {void}
		 */
		patchCode: function(){	
			
			if(!isNaN(dijit.DialogUnderlay.prototype.counter)) {
				return;
			}				
			var newHide = function(){
				if(this.counter < 1) {
					console.log("dijit.DialogUnderlay : oldHide invoked ");
					this.counter = -1;
					 try {
					   this.oldHide();
					 } catch(ex) {
						 //in IE we're getting an exception  here - dijit.DialogUnderlay.bgIframe does not exist
						 console.log("dijit.DialogUnderlay : patchcode exception -  " + ex);
						 this.domNode.style.display = "none";
					 }
				} else {
					this.counter--;
					this.domNode.style.zIndex = this.getUnderlayZIndex();
					console.log("dijit.DialogUnderlay : counter decremented. current = " + this.counter);
				}
			}; 
			var newShow = function() {
				this.counter++;
				this.domNode.style.zIndex = this.getUnderlayZIndex();						
				console.log("dijit.DialogUnderlay : counter incremented. current = " + this.counter);
				this.oldShow();
			};
			
			var getDialogZIndex = function(){
				// modal panels will have even z-index
				// underlay and modal panel shouldn't have the same z-index
				return 499 + 2 * dijit._underlay.counter;
			};
			
			var getUnderlayZIndex = function(){
				// underlay will have odd z-index
				return 498 + 2 *this.counter;
			};
			
			dijit.DialogUnderlay.extend({
				counter: -1 ,
				oldHide: dijit.DialogUnderlay.prototype.hide,
				oldShow: dijit.DialogUnderlay.prototype.show,
				hide: newHide ,
				show: newShow,
				getUnderlayZIndex: getUnderlayZIndex,
				getDialogZIndex: getDialogZIndex
				
			});
								
		},
			
				
			
		/**
		 * checks if event comes from current modal widget.
		 * traverses DOM hierarchy up to document tag. if event comes from other widget mixed
		 * with MultipleModal then it should be ignored.
		 * @param {Event} evt
		 * @return {Boolean} false - event from other modal widget 
		 */
		preOnKeyTest: function(evt){
			var node = evt.target; 
			while(node && (node.nodeName != "#document")){				
				var widget = dijit.byNode(node);
				//console.log("widget: " + widget);
				if(widget && widget.supportsMultipleModal && (widget != this)){
					//console.log("it's event from another modal dialog");
					return false;
				}					
				node = node.parentNode;
				//console.log("node: " + node);
			}
			
			//Does event comes from tpae dialog? If so we want to ignore event
			if (modalWaitLayers && modalWaitLayers.length>0)
				return false;
			
			//console.log("it's your event");
			return true;
		}

	}
);
});

},
'dijit/ProgressBar':function(){
require({cache:{
'url:dijit/templates/ProgressBar.html':"<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\n\t><div  data-dojo-attach-point=\"internalProgress\" class=\"dijitProgressBarFull\"\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\n\t\t><span style=\"visibility:hidden\">&#160;</span\n\t></div\n\t><div data-dojo-attach-point=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\n\t><img data-dojo-attach-point=\"indeterminateHighContrastImage\" class=\"dijitProgressBarIndeterminateHighContrastImage\" alt=\"\"\n/></div>\n"}});
define("dijit/ProgressBar", [
	"require",			// require.toUrl
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/lang", // lang.mixin
	"dojo/number", // number.format
	"./_Widget",
	"./_TemplatedMixin",
	"dojo/text!./templates/ProgressBar.html"
], function(require, declare, domClass, lang, number, _Widget, _TemplatedMixin, template){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

// module:
//		dijit/ProgressBar
// summary:
//		A progress indication widget, showing the amount completed
//		(often the percentage completed) of a task.


return declare("dijit.ProgressBar", [_Widget, _TemplatedMixin], {
	// summary:
	//		A progress indication widget, showing the amount completed
	//		(often the percentage completed) of a task.
	//
	// example:
	// |	<div data-dojo-type="ProgressBar"
	// |		 places="0"
	// |		 value="..." maximum="...">
	// |	</div>

	// progress: [const] String (Percentage or Number)
	//		Number or percentage indicating amount of task completed.
	// 		Deprecated.   Use "value" instead.
	progress: "0",

	// value: String (Percentage or Number)
	//		Number or percentage indicating amount of task completed.
	// 		With "%": percentage value, 0% <= progress <= 100%, or
	// 		without "%": absolute value, 0 <= progress <= maximum.
	//		Infinity means that the progress bar is indeterminate.
	value: "",

	// maximum: [const] Float
	//		Max sample number
	maximum: 100,

	// places: [const] Number
	//		Number of places to show in values; 0 by default
	places: 0,

	// indeterminate: [const] Boolean
	// 		If false: show progress value (number or percentage).
	// 		If true: show that a process is underway but that the amount completed is unknown.
	// 		Deprecated.   Use "value" instead.
	indeterminate: false,

	// label: String?
	//		Label on progress bar.   Defaults to percentage for determinate progress bar and
	//		blank for indeterminate progress bar.
	label:"",

	// name: String
	//		this is the field name (for a form) if set. This needs to be set if you want to use
	//		this widget in a dijit.form.Form widget (such as dijit.Dialog)
	name: '',

	templateString: template,

	// _indeterminateHighContrastImagePath: [private] URL
	//		URL to image to use for indeterminate progress bar when display is in high contrast mode
	_indeterminateHighContrastImagePath:
		require.toUrl("./themes/a11y/indeterminate_progress.gif"),

	postMixInProperties: function(){
		this.inherited(arguments);
		if(!("value" in this.params)){
			this.value = this.indeterminate ? Infinity : this.progress;
		}
	},

	buildRendering: function(){
		this.inherited(arguments);
		this.indeterminateHighContrastImage.setAttribute("src",
			this._indeterminateHighContrastImagePath.toString());
		this.update();
	},

	update: function(/*Object?*/attributes){
		// summary:
		//		Internal method to change attributes of ProgressBar, similar to set(hash).  Users should call
		//		set("value", ...) rather than calling this method directly.
		// attributes:
		//		May provide progress and/or maximum properties on this parameter;
		//		see attribute specs for details.
		// example:
		//	|	myProgressBar.update({'indeterminate': true});
		//	|	myProgressBar.update({'progress': 80});
		//	|	myProgressBar.update({'indeterminate': true, label:"Loading ..." })
		// tags:
		//		private

		// TODO: deprecate this method and use set() instead

		lang.mixin(this, attributes || {});
		var tip = this.internalProgress, ap = this.domNode;
		var percent = 1;
		if(this.indeterminate){
			ap.removeAttribute("aria-valuenow");
			ap.removeAttribute("aria-valuemin");
			ap.removeAttribute("aria-valuemax");
		}else{
			if(String(this.progress).indexOf("%") != -1){
				percent = Math.min(parseFloat(this.progress)/100, 1);
				this.progress = percent * this.maximum;
			}else{
				this.progress = Math.min(this.progress, this.maximum);
				percent = this.maximum ? this.progress / this.maximum : 0;
			}

			ap.setAttribute("aria-describedby", this.labelNode.id);
			ap.setAttribute("aria-valuenow", this.progress);
			ap.setAttribute("aria-valuemin", 0);
			ap.setAttribute("aria-valuemax", this.maximum);
		}
		this.labelNode.innerHTML = this.report(percent);

		domClass.toggle(this.domNode, "dijitProgressBarIndeterminate", this.indeterminate);
		tip.style.width = (percent * 100) + "%";
		this.onChange();
	},

	_setValueAttr: function(v){
		this._set("value", v);
		if(v == Infinity){
			this.update({indeterminate:true});
		}else{
			this.update({indeterminate:false, progress:v});
		}
	},

	_setLabelAttr: function(label){
		this._set("label", label);
		this.update();
	},

	_setIndeterminateAttr: function(indeterminate){
		// Deprecated, use set("value", ...) instead
		this.indeterminate = indeterminate;
		this.update();
	},

	report: function(/*float*/percent){
		// summary:
		//		Generates message to show inside progress bar (normally indicating amount of task completed).
		//		May be overridden.
		// tags:
		//		extension

		return this.label ? this.label :
				(this.indeterminate ? "&#160;" : number.format(percent, { type: "percent", places: this.places, locale: this.lang }));
	},

	onChange: function(){
		// summary:
		//		Callback fired when progress updates.
		// tags:
		//		extension
	}
});

});

},
'dojox/grid/_ViewManager':function(){
define("dojox/grid/_ViewManager", [
	"dojo/_base/declare",
	"dojo/_base/sniff",
	"dojo/dom-class"
], function(declare, has, domClass){

return declare('dojox.grid._ViewManager', null, {
	// summary:
	//		A collection of grid views. Owned by grid and used internally for managing grid views.
	// description:
	//		Grid creates views automatically based on grid's layout structure.
	//		Users should typically not need to access individual views or the views collection directly.
	constructor: function(inGrid){
		this.grid = inGrid;
	},

	defaultWidth: 200,

	views: [],

	// operations
	resize: function(){
		this.onEach("resize");
	},

	render: function(){
		this.onEach("render");
	},

	// views
	addView: function(inView){
		inView.idx = this.views.length;
		this.views.push(inView);
	},

	destroyViews: function(){
		for(var i=0, v; v=this.views[i]; i++){
			v.destroy();
		}
		this.views = [];
	},

	getContentNodes: function(){
		var nodes = [];
		for(var i=0, v; v=this.views[i]; i++){
			nodes.push(v.contentNode);
		}
		return nodes;
	},

	forEach: function(inCallback){
		for(var i=0, v; v=this.views[i]; i++){
			inCallback(v, i);
		}
	},

	onEach: function(inMethod, inArgs){
		inArgs = inArgs || [];
		for(var i=0, v; v=this.views[i]; i++){
			if(inMethod in v){
				v[inMethod].apply(v, inArgs);
			}
		}
	},

	// layout
	normalizeHeaderNodeHeight: function(){
		var rowNodes = [];
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.headerContentNode.firstChild){
				rowNodes.push(v.headerContentNode);
			}
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	normalizeRowNodeHeights: function(inRowNodes){
		var h = 0;
		var currHeights = [];
		if(this.grid.rowHeight){
			h = this.grid.rowHeight;
		}else{
			if(inRowNodes.length <= 1){
				// no need to normalize if we are the only one...
				return;
			}
			for(var i=0, n; (n=inRowNodes[i]); i++){
				// We only care about the height - so don't use marginBox.  This
				// depends on the container not having any margin (which it shouldn't)
				// Also - we only look up the height if the cell doesn't have the
				// dojoxGridNonNormalizedCell class (like for row selectors)
				if(!domClass.contains(n, "dojoxGridNonNormalizedCell")){
					currHeights[i] = n.firstChild.offsetHeight;
					h =  Math.max(h, currHeights[i]);
				}
			}
			h = (h >= 0 ? h : 0);
	
			//Work around odd FF3 rendering bug: #8864.
			//A one px increase fixes FireFox 3's rounding bug for fractional font sizes.
			if((has("mozilla") || has("ie") > 8 ) && h){h++;}
		}
		for(i=0; (n=inRowNodes[i]); i++){
			if(currHeights[i] != h){
				n.firstChild.style.height = h + "px";
			}
		}
	},
	
	resetHeaderNodeHeight: function(){
		for(var i=0, v, n; (v=this.views[i]); i++){
			n = v.headerContentNode.firstChild;
			if(n){
				n.style.height = "";
			}
		}
	},

	renormalizeRow: function(inRowIndex){
		var rowNodes = [];
		for(var i=0, v, n; (v=this.views[i])&&(n=v.getRowNode(inRowIndex)); i++){
			n.firstChild.style.height = '';
			rowNodes.push(n);
		}
		this.normalizeRowNodeHeights(rowNodes);
	},

	getViewWidth: function(inIndex){
		return this.views[inIndex].getWidth() || this.defaultWidth;
	},

	// must be called after view widths are properly set or height can be miscalculated
	// if there are flex columns
	measureHeader: function(){
		// need to reset view header heights so they are properly measured.
		this.resetHeaderNodeHeight();
		this.forEach(function(inView){
			inView.headerContentNode.style.height = '';
		});
		var h = 0;
		// calculate maximum view header height
		this.forEach(function(inView){
			h = Math.max(inView.headerNode.offsetHeight, h);
		});
		return h;
	},

	measureContent: function(){
		var h = 0;
		this.forEach(function(inView){
			h = Math.max(inView.domNode.offsetHeight, h);
		});
		return h;
	},

	findClient: function(inAutoWidth){
		// try to use user defined client
		var c = this.grid.elasticView || -1;
		// attempt to find implicit client
		if(c < 0){
			for(var i=1, v; (v=this.views[i]); i++){
				if(v.viewWidth){
					for(i=1; (v=this.views[i]); i++){
						if(!v.viewWidth){
							c = i;
							break;
						}
					}
					break;
				}
			}
		}
		// client is in the middle by default
		if(c < 0){
			c = Math.floor(this.views.length / 2);
		}
		return c;
	},

	arrange: function(l, w){
		var i, v, vw, len = this.views.length, self = this;
		// find the client
		var c = (w <= 0 ? len : this.findClient());
		// layout views
		var setPosition = function(v, l){
			var ds = v.domNode.style;
			var hs = v.headerNode.style;

			if(!self.grid.isLeftToRight()){
				ds.right = l + 'px';
				// fixed rtl, the scrollbar is on the right side in FF or WebKit
				if (has("ff") < 4 || has("webkit")){
					hs.right = l + v.getScrollbarWidth() + 'px';
					hs.width = parseInt(hs.width, 10) - v.getScrollbarWidth() + 'px';
				}else{
					hs.right = l + 'px';
				}
			}else{
				ds.left = l + 'px';
				hs.left = l + 'px';
			}
			ds.top = 0 + 'px';
			hs.top = 0;
		};
		// for views left of the client
		//BiDi TODO: The left and right should not appear in BIDI environment. Should be replaced with
		//leading and tailing concept.
		for(i=0; (v=this.views[i])&&(i<c); i++){
			// get width
			vw = this.getViewWidth(i);
			// process boxes
			v.setSize(vw, 0);
			setPosition(v, l);
			if(v.headerContentNode && v.headerContentNode.firstChild){
				vw = v.getColumnsWidth()+v.getScrollbarWidth();
			}else{
				vw = v.domNode.offsetWidth;
			}
			// update position
			l += vw;
		}
		// next view (is the client, i++ == c)
		i++;
		// start from the right edge
		var r = w;
		// for views right of the client (iterated from the right)
		for(var j=len-1; (v=this.views[j])&&(i<=j); j--){
			// get width
			vw = this.getViewWidth(j);
			// set size
			v.setSize(vw, 0);
			// measure in pixels
			vw = v.domNode.offsetWidth;
			// update position
			r -= vw;
			// set position
			setPosition(v, r);
		}
		if(c<len){
			v = this.views[c];
			// position the client box between left and right boxes
			vw = Math.max(1, r-l);
			// set size
			v.setSize(vw + 'px', 0);
			setPosition(v, l);
		}
		return l;
	},

	// rendering
	renderRow: function(inRowIndex, inNodes, skipRenorm){
		var rowNodes = [];
		for(var i=0, v, n, rowNode; (v=this.views[i])&&(n=inNodes[i]); i++){
			rowNode = v.renderRow(inRowIndex);
			n.appendChild(rowNode);
			rowNodes.push(rowNode);
		}
		if(!skipRenorm){
			this.normalizeRowNodeHeights(rowNodes);
		}
	},
	
	rowRemoved: function(inRowIndex){
		this.onEach("rowRemoved", [ inRowIndex ]);
	},
	
	// updating
	updateRow: function(inRowIndex, skipRenorm){
		for(var i=0, v; v=this.views[i]; i++){
			v.updateRow(inRowIndex);
		}
		if(!skipRenorm){
			this.renormalizeRow(inRowIndex);
		}
	},
	
	updateRowStyles: function(inRowIndex){
		this.onEach("updateRowStyles", [ inRowIndex ]);
	},
	
	// scrolling
	setScrollTop: function(inTop){
		var top = inTop;
		for(var i=0, v; v=this.views[i]; i++){
			top = v.setScrollTop(inTop);
			// Work around IE not firing scroll events that cause header offset
			// issues to occur.
			if(has("ie") && v.headerNode && v.scrollboxNode){
				v.headerNode.scrollLeft = v.scrollboxNode.scrollLeft;
			}
		}
		return top;
		//this.onEach("setScrollTop", [ inTop ]);
	},
	
	getFirstScrollingView: function(){
		// summary: Returns the first grid view with a scroll bar
		for(var i=0, v; (v=this.views[i]); i++){
			if(v.hasHScrollbar() || v.hasVScrollbar()){
				return v;
			}
		}
		return null;
	}
});
});
},
'ibm/tivoli/simplesrm/srm/dijit/MessageDetails':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dijit/Dialog,dijit/_Widget,dijit/_Templated,dijit/form/Button,dijit/form/CheckBox,dijit/form/SimpleTextarea,dijit/form/TextBox,ibm/tivoli/tip/dijit/TextInputBox,dijit/form/Form,dijit/layout/BorderContainer,dijit/layout/TabContainer,dijit/layout/ContentPane,ibm/tivoli/simplesrm/srm/dijit/MessageDialog,ibm/tivoli/simplesrm/srm/dijit/OpenHelp,ibm/tivoli/simplesrm/srm/dijit/MultipleModal,ibm/tivoli/simplesrm/srm/dijit/MyRecordsGrid,ibm/tivoli/simplesrm/srm/dijit/ItemChooserGrid,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dojo/Utilities,ibm/tivoli/simplesrm/srm/dojo/Formatter"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MessageDetails");

dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

dojo.require("dijit.Dialog");
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit.form.Button");
dojo.require("dijit.form.CheckBox");
dojo.require("dijit.form.SimpleTextarea");
dojo.require("dijit.form.TextBox");
dojo.require("ibm.tivoli.tip.dijit.TextInputBox");
dojo.require("dijit.form.Form");
dojo.require("dijit.layout.BorderContainer");
dojo.require("dijit.layout.TabContainer");
dojo.require("dijit.layout.ContentPane");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MessageDialog");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MultipleModal");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ItemChooserGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Utilities");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Formatter");

/**
 * This panel shows the details or a bulletin board message. A dialog is embedded,
 * so per default it will show up as a popup dialog.
 *  
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.MessageDetails",
			 [dijit._Widget,
			  dijit._Templated,
			  ibm.tivoli.simplesrm.srm.dijit.MultipleModal,
			  ibm.tivoli.simplesrm.srm.dijit.OpenHelp],
{
	_uiStringTable: null,
	widgetsInTemplate: true,
	templateString:"<div class=\"templateddialog\">\n<!--\n @HTML_LONG_COPYRIGHT_BEGIN@\n @HTML_LONG_COPYRIGHT_END@\n-->\n\t<div dojoType=\"dijit.Dialog\"\n\t\t dojoAttachPoint=\"_dialog\"\n\t\t title=\"${_uiStringTable.ViewBBMessageTitle}\"\n\t\t class=\"tundra simplesrm templateddialog mydialog\">\n\t\t<div dojoType=\"dijit.layout.BorderContainer\"\n\t\t\tstyle=\"width:${_width};height:430px;background-color:#DCE2E7;padding:0;margin:0;\"> \n\t\t\t<div dojoType=\"dijit.layout.ContentPane\" region=\"center\" style=\"padding:0;margin:0;\">\n\t\t\t\t<div dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t style=\"padding:0;margin:0;font-size:10pt;\">\n\t\t\t\t\t<div dojoType=\"dijit.layout.TabContainer\"\n\t\t\t\t\t\t dojoAttachPoint=\"_tabC\"\n\t\t\t\t\t\t style=\"width:630px;height:630px;padding:0;margin:0;\">\n\t\t\t\t\t\t<div id=\"${id}_general\" dojoType=\"dijit.layout.ContentPane\"\n\t\t\t\t\t\t \t closeable=\"false\" title=\"${_uiStringTable.ViewSRGeneral}\"\n\t\t\t\t\t\t \t dojoAttachPoint=\"_gen\"\n\t\t\t\t\t\t \t style=\"background-color:#DCE2E7;padding:0;margin:0\">\n\t\t\t\t\t\t\t<div class=\"banner\">\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:50px;height:50px;margin:10px;\">\n\t\t\t\t\t\t\t\t\t<img src=\"../webclient/javascript/simplesrm/srm/dijit/images/icons/default_request.png\" width=\"50\" height=\"50\" alt=\"\"/>\n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:370px;height:50px;margin:10px;\"\n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"_viewSrGenBannerText\">\n\t\t\t\t\t\t\t\t\t${_uiStringTable.ViewBBMessageBanner}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class=\"clear\"></div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_gen_table></div>\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t<div dojoAttachPoint=_attr_table></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t\n\t\t\t\n\t\t\t<div dojoType=\"dijit.layout.ContentPane\" dojoAttachPoint=\"_apprC\" class=\"approval\"\n\t\t\t\t region=\"right\" style=\"display:${_approvalDisplay}\">\n\t\t\t\t<form id=\"${id}_approvalForm\" name=\"approvalForm\" dojoType=\"dijit.form.Form\">\n\t\t\t\t\t<div style=\"width:100%;height:100%;padding:0;margin:0\">\n\t\t\t\t\t\t<div class=\"banner\">\n\t\t\t\t\t\t\t<div class=\"paneltop\" style=\"width:240px;height:20px;padding:5px;margin:0;\">\n\t\t\t\t\t\t\t\t<label style=\"font-weight:bold;font-size:10pt;\">${_uiStringTable.AppRequestBannerTitle}</label>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div style=\"width:240px;height:45px;padding:5px;margin:0;font-size:10pt;\">\n\t\t\t\t\t\t\t\t${_uiStringTable.AppRequestBannerDescription}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<ul style=\"list-style:none;padding-left:5px;margin-left:5px;overflow:auto\";>\n\t\t\t\t\t\t<li style=\"clear: both;\">\n\t\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t\t<div style=\"float:left;width:10%\">\n\t\t\t\t\t\t\t\t\t<input dojoType=\"dijit.form.RadioButton\" id=\"${id}_reject\" name=\"process\" \n\t\t           \t\t\t\t\t\t\tchecked=\"checked\" value=\"reject\" type=\"radio\">\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style=\"float:right;width:90%;\">\n\t\t\t\t\t\t\t\t\t<label style=\"word-wrap:break-word;\" for=\"${id}_reject\"><font size= \"2\"> ${_uiStringTable.RejectRequest} </font></label>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li style=\"clear: both;\">\n\t\t\t\t\t        <div>\n\t\t\t\t\t\t\t\t<div style=\"float:left; width:10%\">\n\t\t\t\t\t\t\t\t\t<input dojoType=\"dijit.form.RadioButton\" id=\"${id}_approve\" name=\"process\" \n\t\t\t\t\t          \t\t\t\t\t\t\t\tvalue=\"approve\" type=\"radio\">\n\t\t\t\t\t          \t</div>\n\t\t\t\t\t\t\t\t<div style=\"float: right; width: 90%;\">\n\t\t\t\t\t\t\t\t\t<label  style=\"word-wrap:break-word;\"for=\"${id}_approve\"><font size= \"2\"> ${_uiStringTable.ApproveRequest} </font></label>\n\t\t\t\t\t\t\t\t</div>\n\t\t        \t\t\t</div>\n\t\t\t\t\t\t</li>\n\t\t\t\t\t\t<li style=\"clear: both;\">\n\t\t\t\t\t\t\t<label><font size=\"2\">${_uiStringTable.ApproveDetails}</font></label>\n\t\t\t\t\t\t\t<input id=\"${id}_detail\" name=\"detail\" dojoType=\"ibm.tivoli.tip.dijit.TextInputBox\"\n\t\t\t\t\t\t\t\t   style=\"width:90%\" constraints=\"{maxlen: 50}\" size=\"25\">\n\t\t\t\t\t\t</li>\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</div>\n\t\t\t\t</form>\n\t\t\t</div>\n\n\t\t\t<div dojoType=\"dijit.layout.ContentPane\" region=\"bottom\" class=\"footer\"\n\t\t\t\tstyle=\"background: #B2B2B2 url(../webclient/javascript/simplesrm/srm/dijit/images/ge64_toolbar_top.png) repeat-x scroll left top;margin:0;border-width:2px 0 0 0;border-color:#B0B5B8;\">\n\t\t\t\t<button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"_closeBtn\"\n\t\t\t\t\t \tdojoAttachEvent=\"onClick:_onCloseClick\">\n\t\t\t \t\t${_uiStringTable.Close}\n\t\t\t \t</button>\n\t\t\t \t<button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"_apprOKBtn\"\n\t\t\t \t\t    dojoAttachEvent=\"onClick:_onOKClick\" >\n\t\t\t \t\t${_uiStringTable.OK}\n\t\t\t \t</button>\n\t\t\t\t<button dojoType=\"dijit.form.Button\" dojoAttachPoint=\"_apprCancelBtn\"\n\t\t\t\t\t\ttype=\"submit\">\n\t\t\t\t\t${_uiStringTable.Cancel}\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t\t\n\t\t</div>\n\t\t\n\t</div>\n</div>\n",
	parseOnLoad: true,
	hasApproval: false, /* Tell whether the panel should have a approval subpanel */
	ALN: "ALN",
	NUMERIC: "NUMERIC",
	TABLE: "TABLE",
	
	_approvalDisplay: "none",
	_Width: "630px",
	
	_data: null,
	cshKey: "PMRDP_View_SubmittedRequests.htm",
	_processErrorMessage: "CTJZH2331E",
	
	constructor: function(params) {
		console.log("MessageDetails.constructor()", params);
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
		if (params.approval && params.approval === true) {
			//this.hasApproval = true;
			/* Also modify the help key */
			this.cshKey = "PMRDP_View_ApprovalDetails.htm";
		}
		console.log("MessageDetails.constructor()");
	},
	
	buildRendering: function() {
		console.log("MessageDetails.buildRendering()");
		try {
			this._approvalDisplay = this.hasApproval ? "" : "none";
			this._width = this.hasApproval ? "880px" : "630px";
			this.inherited(arguments);
			console.log(this._dialog, this);
			
			dojo.connect(this._tabC, "selectChild", dojo.hitch(this, this.tabSel));
			//this._comml_table.setOwner(this);
			this.addHelp();
		}
		catch(ex) {
			console.group("Failed generating input form from template");
			console.error(ex);
			console.groupEnd();
			throw new ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError(ex);
		}
	},
	
	postCreate: function() {
		console.log("MessageDetails.postCreate()", this.hasApproval);
		if (this.hasApproval === false) {
			/* Hide the approval subpanel in this case, as well as the OK &
			 * Cancel buttons */
			console.log("Approval set as disabled. Path working.", this._apprOKBtn);
			this._viewSrGenBannerText.innerHTML = this._uiStringTable.ViewBBMessageBanner;
			dojo.style(this._apprOKBtn.domNode, "display", "none");
			dojo.style(this._apprCancelBtn.domNode, "display", "none");
		} else {
			console.log("Approval set as enabled.", this._closeBtn);
			dojo.style(this._closeBtn.domNode, "display", "none");
		}
		
		var datatypeMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('DATATYPE');
		this.ALN = datatypeMap.valueByMaxvalue("ALN");
		this.NUMERIC = datatypeMap.valueByMaxvalue("NUMERIC");
		this.TABLE = datatypeMap.valueByMaxvalue("MAXTABLE");
		
		this.inherited(arguments);
	},
	
	tabSel: function(child) {
		//this._comml_table._grid.update();
	},
	
	_onKey: function(event){		
		//changes original method to support multiple modal dialogs
		if (!this.preOnKeyTest(event)) {
			return; // it's not your event
		}				
		this._dialog._onKey(event);			
	},
	
	show: function() {
		this.patchCode();
		this._dialog.supportsMultipleModal=true; //hack to support multiple modal panels
		this._dialog.show();
		this._dialog.domNode.style.zIndex = dijit._underlay.getDialogZIndex();
	},
	
	setData: function(data)
	{
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		
		if (product!=null && product.indexOf("srm")>=0)  
		{
			var maxrest_context_root = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().rest_context_root; 
						
			this.restOS = maxrest_context_root + "/rest/srm/"; 
			//this._data = data.QuerySRMSRDETResponse.SRMSRDETSet.SR[0];
			//this._data = data.QuerySRM_BBOARDResponse.SRM_BBOARDSet.BULLETINBOARD[0]
			this._data = data;
		} else
		{
			//this._data = data.QueryMXSRDETResponse.MXSRDETSet.SR[0];
			//this._data = data.QuerySRM_BBOARDResponse.SRM_BBOARDSet.BULLETINBOARD[0]
			this._data = data;
		}


		/* Case with no Message Data */
		  if (!this._data) { 
			console.log("Empty data for this request");
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog(
											{messageId: "CTJZH2321I", type: "info"})).show();
			return; 
		}
		//this._data = data.QuerySRMSRDETResponse.SRMSRDETSet.SR[0];
		//this._data = data.QueryMXSRDETResponse.MXSRDETSet.SR[0];

		this._fillGeneral(this._data); 
				
		//this._fillAttrTable(this._data);
		
		this.show();

	},
	/**
	 * Set the HTML content for the PMZBHSLOG section.
	 */
	_buildPmzLog: function(data) {
		console.log("MessageDetails._buildPmzLog()", data);
		var wlog = data.PMZHBSLOG;
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\">" +
						 this._uiStringTable.Date +
						 "</td><td class=\"title\">" +
						 this._uiStringTable.Summary +
						 "</td></tr></thead><tbody>";
		for (i = 0; i < wlog.length; i++) {
			newContent += "<tr class=\"stroke\"><td>";
			newContent += wlog[i].TIME.formatISODateString();
			newContent += "</td><td>";
			newContent += wlog[i].FULL_MSG_TEXT ? wlog[i].FULL_MSG_TEXT.htmlencode() : "";
			newContent += "</td><td>";
		}
		newContent += "</tbody></table>";
		console.log("Setting work log content", newContent);
		this._workl_table.innerHTML = newContent;
	},


	 /**
	 * Set the HTML content for the Messages
	 */

	/**
	 * Set the HTML content for the general section.
	 */	
	_fillGeneral: function(data) {
		console.log("MessageDetails._fillGeneral()", data);
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\">" +
			 this._uiStringTable.ViewBBMessageDetails +
			"</td><td class=\"status\" dojoAttachPoint=" + data.STATUS +
			"</td></tr></thead><tbody>";
		var genSubj = data.SUBJECT;
		if (genSubj) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.Subject + "</td><td>" +
						 genSubj.htmlencode() + "</td></tr>";
		}
		var genMsg = data.MESSAGE;
		if (genMsg) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.Message + "</td><td>" +
						 genMsg.htmlencode() + "</td></tr>";
		}
		var genPosted = data.POSTDATE;
		if (genPosted) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.PostDate + "</td><td>" +
						 genPosted.formatISODateString({sel: "datetime"}) + "</td></tr>";
		}
		var genExpires = data.EXPIREDATE;
		if (genExpires) {
			newContent += "<tr class=\"stroke\"><td>" +
						 this._uiStringTable.ExpireDate + "</td><td>"+
						 genExpires.formatISODateString({sel: "datetime"}) + "</td></tr>";
		}
		
		var genPostBy = data.POSTBY;
		if (genPostBy) {
			newContent += "<tr class=\"stroke\"><td> " +
						 this._uiStringTable.PostBy + "</td><td>" +
						 genPostBy + "</td></tr>";
		}
		newContent += "</tbody></table>";
		this._gen_table.innerHTML = newContent;
	},
	
	_fillAttrTable: function(data) {
		console.log("MessageDetails._fillAttrTable()", data);
		var newContent = "<table class=\"infotable\"><thead><tr><td class=\"title\" colspan=2>" +
			 data.DESCRIPTION +"</td></tr></thead><tbody>";
		var attrs = data.TICKETSPEC;
		/* Exit in case of empty data */
		if (!attrs) {
			console.log("MessageDetails._fillAttrTable(): no ticket spec found");
			return;
		}
		for (i = 0; i < attrs.length; i++) {
			/* check what type of value this is */
			var attrType = attrs[i].ASSETATTRIBUTE[0].DATATYPE;
			var val = "";
			if (attrType == "NUMERIC") {
				val = attrs[i].NUMVALUE;
			} else if (attrType == "ALN") {
				val = attrs[i].ALNVALUE;
			} else if (attrType == "TABLE") {
				if (attrs[i].ALNVALUE){
					val = attrs[i].ALNVALUE;
				}
			} else {
				console.log("NEW TYPE", i, attrType);
				//debugger; /* STOP! */
			}
			if ((val != undefined) && (val != "")) {
				newContent += "<tr class=\"stroke\"><td>";
				newContent += attrs[i].ASSETATTRIBUTE[0].DESCRIPTION;
				newContent += "</td><td>";
				newContent += val.toString().htmlencode();
				newContent += "</td></tr>";
			}
		}		
		newContent += "</tbody></table>";
		this._attr_table.innerHTML = newContent;
	},
	//Venky
	_onCloseClick: function(evt) 
	{ 
		console.log("MessageDetails._onCloseClick()--- this._data = "+this._data.id+"--Viewed = "+this._data.ISVIEWED); 
		var bbUId = this._data.id;

		if(this._data.ISVIEWED == 'NO')
		{
			console.log("MessageDetails._onCloseClick() INSIDE ***");
			sendEvent("bbmsgviewed",  "mx121",  bbUId);
		}

		this.hide();
		return true;
	},
	
	_onOKClick: function(evt) 
	{
		
		var tid = this._data.TICKETID;
		var approveCheck = dijit.byId(this.id + "_approve").checked	;	
		//var summaryInfo = dijit.byId(this.id + "_summary").value;	

		//var detailInfo = dijit.byId(this.id + "_detail").getValue();
		var detailInfoWidget = dijit.byId(this.id + "_detail");		
		var detailInfo = detailInfoWidget.getValue();
		
		//var detailInfo = dijit.byId(this.id + "_detail").value;

		//console.log("_onOKClick: tid is : " + tid + " ,approveCheck is : " + approveCheck + " ,detailInfo is : " + detailInfo);
		
		detailInfoWidget.validate();
		
		var hasError = detailInfoWidget._isInError;

		if (hasError){
			ibm.tivoli.logger.error("Invalid Detail Input Value!");
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2336E"})).show();
			dojo.stopEvent(evt);			
		}else {
			var bSuccess = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().approveRequest(tid, detailInfo, approveCheck);

			if(!bSuccess) {
				ibm.tivoli.logger.error("Failure approving/rejecting a request");
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2331E"})).show();
				dojo.stopEvent(evt);
			}
			else {
				this.hide();
			}
			return bSuccess;			
		}
	},
	
	hide: function()
	{
		this._dialog.hide();
	},
	
	/* Help stuff */

	//handler:used when user clicks '?'
	openHelp: function(event){
		//this.openHelpWindow(this.cshKey);
	},

	//error handler: used when help url can't be retrieved from server
	_errorRetrievingUrl:function() {
		(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2302E"})).show();
	},

	//sets cshKey, adds '?' to title bar, connects help events 
	addHelp: function() {
		var helpNode = document.createElement("span");
		
		dojo.addClass(helpNode , "dijitDialogHelpIcon");			
		dojo.attr(helpNode , "id" , this.id + "_visual_" + this.cshKey);
		dojo.attr(helpNode , "title" , this._uiStringTable["Help"]);
		dojo.attr(helpNode , "tabindex" , 0);
		
		var res = dojo.place(helpNode, this._dialog.closeButtonNode ,"before");
		this.connect(helpNode , "onclick" , "openHelp");
		this.connect(helpNode , "onmouseenter","_onHelpEnter");		
		this.connect(helpNode , "onmouseleave","_onHelpLeave");
		this.connect(helpNode , "onkeypress" , "_onEnterPressed");
		
		var textHelpNode = document.createElement("span");
					
		dojo.addClass(textHelpNode , "closeText");
		dojo.attr(textHelpNode , "id" , this.id + "_text_" + this.cshKey);
		dojo.attr(textHelpNode , "title" , this._uiStringTable["Help"]);			
		
		var textNode = document.createTextNode("?");
		dojo.place(textNode , textHelpNode );
		
		dojo.place(textHelpNode, helpNode);
		
		this.connect(this.domNode,"keypress","_onHelpKey");
	},

	_onHelpEnter: function() {
		var helpNode = dojo.query(".dijitDialogHelpIcon",this.titleBar);
		dojo.addClass(helpNode[0], "dijitDialogHelpIcon-hover");
	},

	_onHelpLeave: function(){
		var helpNode = dojo.query(".dijitDialogHelpIcon-hover",this.titleBar);
		dojo.removeClass(helpNode[0] , "dijitDialogHelpIcon-hover");
	},

	_onHelpKey: function(event) {
		//console.log("current: " + event.keyCode + " / " + event.charOrCode + " target: " + dojo.keys.HELP); 
		
		// help key accessible from whole panel
		if(event.keyCode == dojo.keys.F1){
			
			// on IE dojo.stopEvent() is not enough to cancel this event
			// "onhelp" attribute is valid for IE only
			if (dojo.isIE){ 
				document.onhelp = function(){return false;};
				window.onhelp = function(){return false;};
			}
			
			if(this.cshKey && this.openHelp){				
				dojo.stopEvent(event);			
				this.openHelp(event);
				return false;
			}
		}
		return true;
	},
	
	_onEnterPressed: function(event) {
		//open only if Enter was pressed on help icon
		if ((event.keyCode == dojo.keys.ENTER) && 
			(dojo.hasClass(event.target ,"dijitDialogHelpIcon"))){
			dojo.stopEvent(event);
			this.openHelp(event);
			return false;
		}
		return true;
	}

});
});

},
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\ttabIndex=\"-1\" role=\"presentation\" data-dojo-attach-point=\"valueNode\"\n/></span>\n",
'ibm/tivoli/tpae/dojo/data/tpaeQuery':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dojo/data/Cache"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.tpae.dojo.data.ajaxQuery");
dojo.provide("ibm.tivoli.tpae.dojo.data._ajaxQuery");

dojo.provide("ibm.tivoli.tpae.dojo.data.tpaeQuery");
dojo.provide("ibm.tivoli.tpae.dojo.data._tpaeQuery");
dojo.provide("ibm.tivoli.tpae.dojo.data.SynonymDomain");
dojo.provide("ibm.tivoli.tpae.data.loggedInUsername");

dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.Cache");


//TODO - this can be removed (along with references) and use getLoggedInUser() instead
ibm.tivoli.tpae.data.loggedInUsername = "";	// a global. gasp!

/**
 * Handle ajax data queries.
 * Directs the query through the proxy servlet if necessary 
 */
dojo.declare("ibm.tivoli.tpae.dojo.data._ajaxQuery", null, 
{
	_proxyUrl: "/SRMCommonsWeb/ProxyServlet",
	_timeout: Infinity,
	devMode: false,
   token: '',  //auth token 
   loginid: '',

   _cacheTimeoutStatic: 0,
   _cacheTimeoutSeldomChanged: 0,
  
	constructor: function()
	{
		this._timeout = parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty("QueryTimeout"),10);
		if(isNaN(this._timeout) || this._timeout < 0) {
			this._timeout = Infinity;
		}
		var dm = ibm.tivoli.tpae.dojo.data.getConfigProperty("Devmode");
		this.devMode = (dm == "true" || dm == "1");

		this._cacheTimeoutStatic = parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty("CacheTimeoutStatic"),10);
		if(isNaN(this._cacheTimeoutStatic) || this._cacheTimeoutStatic < 0) {
			this._cacheTimeoutStatic = Infinity;
		}

		this._cacheTimeoutSeldomChanged = parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty("CacheTimeoutSeldomChanged"),10);
		if(isNaN(this._cacheTimeoutSeldomChanged) || this._cacheTimeoutSeldomChanged < 0) {
			this._cacheTimeoutSeldomChanged = 900000;
		}

	},
	useProxy: function(url)
	{     	
		var bUseProxy=true;
		var bp = ibm.tivoli.tpae.dojo.data.getConfigProperty("UseProxy");  
		if (bp!=null) 
		    bUseProxy = (bp=='true' || bp=='1');				

		if(!this.devMode) {
			if('/' == url.charAt(0)) {
				bUseProxy = false;
			}
			else {
				var m = url.match(new RegExp(":\\/\\/(\\w+)"));
				if(m) {
					var data_host = m[1];
					bUseProxy = (data_host != window.location.host);
				}
			}
		}
		return bUseProxy;
	},

	//Set auth tokens  
	setToken: function(token_p, loginid_p) {  
		if (token_p!=null)  
	    	this.token= token_p;
	    if (loginid_p!=null)  
	    	this.loginid= loginid_p;	      
	},

	get: function(/*string*/url, /*boolean*/sync, /*object*/query_args)
	{
		var _data = {};
		var _url = url;
		var _sync = undefined == sync ? true : sync;		
		var _xtraHeaders = {};
		var type = "json";
		if (query_args["handleas"]) {
			type =  query_args["handleas"];
		}		
	
		var useProxy = this.useProxy(_url);
		if(useProxy) {
			_url = this._proxyUrl;
			_xtraHeaders["x-targeturl"] = url;
		}
		if( url.match(new RegExp("\\/rest")) ) {
			_data._format = "json";
		}
		else {
			_data.format = "json";
		}
		if (query_args["Cache-Control"]) {
			_xtraHeaders["Cache-Control"] = query_args["Cache-Control"];
			delete query_args["Cache-Control"];
		}

      //Pass langcode if it was passed to us when starting
      if (ibm.tivoli.tpae.dojo.data._langcode!=null &&  ibm.tivoli.tpae.dojo.data._langcode.length>0) {
			_data._lang = ibm.tivoli.tpae.dojo.data._langcode;
      }

		if (this.token!=null && this.token!='')  
			_xtraHeaders["__mxtoken"] = this.token;
				 
		if (this.loginid!=null & this.loginid!='')  
			_xtraHeaders["__mxuser"] = this.loginid;

		for(var p in query_args) {
			_data[p] = query_args[p];
		}
		var errHandler = dojo.hitch(this, this._ajaxError);
		
		var _deferred = dojo.xhrGet({
			url: _url,
			content: _data,
			headers: _xtraHeaders,
			sync: _sync,			
			timeout: this._timeout,
			handleAs: type,
			load: function(response, ioArgs) 
			{
				console.log("tpaeQuery:get loaded - ", url, sync);
				return response;
			},
			error: function(response, ioArgs)
			{
				errHandler(response, ioArgs); 
				return response;
			}
		});
		return _deferred;
	},
	// Summary:
	//	Same as get, but for xhrPost
	post: function(/*string*/url, /*boolean*/sync, /*object*/data) 
	{
		var _data = {};
		var _url = url;
		var _sync = undefined == sync ? true : sync;
		var _xtraHeaders = {};
	
		var useProxy = this.useProxy(_url);
		if(useProxy) {
			_url = this._proxyUrl;
			_xtraHeaders["x-targeturl"] = url;
		}

		if (this.token!=null && this.token!='')  
			_xtraHeaders["__mxtoken"] = this.token;
				 
		if (this.loginid!=null & this.loginid!='')  
			_xtraHeaders["__mxuser"] = this.loginid;

		if( url.match(new RegExp("\\/rest")) ) {
			_data._format = "json";
		}
		else {
			_data.format = "json";
		}
		for(var p in data) {
			_data[p] = data[p];
		}

		if (undefined == _data._compact){
			_data._compact = 1;
		}
		var _deferred = dojo.xhrPost({
			url: _url,
			content: _data,
			headers: _xtraHeaders,
			sync: _sync,
			handleAs: "json",
			load: function(response, ioArgs) 
			{
				console.log("tpaeQuery:post loaded", url);
				return response;
			},
			error: function(response, ioArgs) 
			{
				if("cancel" === response.dojoType) {
					console.log("request canceled");
				}
				else {
					var msg = "ajaxQuery.post failure";
					if(ioArgs && ioArgs.xhr) {
						msg += "(" + ioArgs.xhr.status + "): " + ioArgs.xhr.responseText;
					}
					console.error(msg);
					ibm.tivoli.logger.error("msg: " + msg + "response:" + response);
				}
				return response;
			}
		});
		return _deferred;
	},

	/**
	 * Call a MEA webService sending a raw XML POST request.
	 * The call passes through the proxy servlet, the real WS url is
	 * passed in the x-targeturl header
	 */
	callWebService : function(params){
		var _url = params.wsUrl;
		var headers = {
			"SOAPAction": "urn:action", 
     		"Content-Type": "text/xml; charset=utf-8" 
		};
		var useProxy = this.useProxy(_url);
		if(useProxy) {
			_url = this._proxyUrl;
			headers["x-targeturl"] = params.wsUrl;
		}
		var _deferred = dojo.rawXhrPost({
	          		url		: _url,
	                headers : headers,
	                postData: params.postData,
					handleAs: "text",
					sync    : params.sync,
					load    : function(response, ioArgs) {
								console.log("WS response loaded");							
								return response;
					},
					error   : dojo.hitch(this, this._ajaxError)
					});
		return _deferred;
	},
	
	_ajaxError: function(response, ioArgs)
	{
		if("cancel" === response.dojoType) {
			console.log("request canceled");
		}
		else {
			var msg = "ajaxQuery.get failure: " + response.toString();
			console.error(msg);
			ibm.tivoli.logger.error(msg);
		}
		return response;
	},
	
	/**
	 * summary: 
	 * 	returns the given value if it is defined.  
	 * 	If value is undefined, then returns defaultValue
	 * 	If defaultValue is undefined, then returns ""
	 *  
	 *  Used this function when accessing data fields from data returned from one of our
	 *  REST queries.  Depending on the circumstances, all fields may not be present, and
	 *  this function can be used to safely assign a field value to a variable.
	 *  
	 *  Example:
	 *    var mrlineid = this.safeGetValue(response.CreatePMZHBR1_PMSCMRCREATEResponse.PMZHBR1_PMSCMRCREATESet.PMSCMR.PMSCMRLINE[0].MRLINEID, "0")
	 *    
	 *  Warning:
	 *  	What this function cannot guard against is an undefined intermediate object in the response.  For example, if 
	 *  	response.CreatePMZHBR1_PMSCMRCREATEResponse.PMZHBR1_PMSCMRCREATESet.PMSCMR.PMSCMRLINE[0] is undefined, 
	 *  	response.CreatePMZHBR1_PMSCMRCREATEResponse.PMZHBR1_PMSCMRCREATESet.PMSCMR.PMSCMRLINE[0].MRLINEID will cause an error before
	 *  	safeGetValue is ever called.
	 *   
	 */
	safeGetValue: function(/*String*/value, /*any*/defaultValue) 
	{
		return undefined != value ? value : (undefined != defaultValue ? defaultValue : "");
	}
});
ibm.tivoli.tpae.dojo.data._ajaxquery = null;
ibm.tivoli.tpae.dojo.data.ajaxQuery = function(){
	// summary: returns the singleton query object
	if(!ibm.tivoli.tpae.dojo.data._ajaxquery){
		ibm.tivoli.tpae.dojo.data._ajaxquery = new ibm.tivoli.tpae.dojo.data._ajaxQuery();
	}
	return ibm.tivoli.tpae.dojo.data._ajaxquery;	// Object
};

ibm.tivoli.tpae.dojo.data._runInMaximo = false;    //Don't use separate servlet for config.properties 
ibm.tivoli.tpae.dojo.data._langcode = "";         //language code. If passed in we include it on REST API _lang parm
ibm.tivoli.tpae.dojo.data._configfile = "config.properties";

//properties cache
ibm.tivoli.tpae.dojo.data._propmap = new ibm.tivoli.simplesrm.srm.dojo.data.Cache();

//Get property from cache or retrieve them from server.
//Try config.properties first then try config75.properties
ibm.tivoli.tpae.dojo.data.getConfigProperty = function(pname) {
   var propmap = ibm.tivoli.tpae.dojo.data._propmap;
   if(undefined === propmap.get(pname) && propmap.countKeys()==0){  //Find property in cache
	
	  //If config.properties is in the maximouiweb war	
	  if (ibm.tivoli.tpae.dojo.data._runInMaximo==true) {
		  var context_root = "/maximo";		  
		  var context = window.location.pathname;  // /maximo/ui
		  if (context.indexOf("/")!=0)
			  context = "/" + context;
		  var paths = context.split("/");
		  if (paths.length>=2) {
			  context_root = "/" + paths[1]; 
		  }	   
		  		  
		  dojo.xhrGet({			
			  url: context_root + "/webclient/javascript/com/ibm/ism/pmsc/dojo/" + ibm.tivoli.tpae.dojo.data._configfile,	
			  sync: true,
			  handleAs: "text",
			  load: function(response, ioArgs) {    
			     //split config properties into array of lines
			     //TODO - add all of them to the array
			     var arrayOfLines = response.split(/\r\n|\n|\r/);
			     for(var indx = 0; indx < arrayOfLines.length; indx++){
			        var singleLine = arrayOfLines[indx].trim();
			        if (singleLine!="" && singleLine[0]!= "#") {  //not comment
			           var attrs = singleLine.split("=");
			           if (attrs.length==2) {
	                      var key = attrs[0].trim();
	                      var value = attrs[1].trim();
	                      //ibm.tivoli.tpae.dojo.data._propmap[key] = value;	                      		            			             
                          propmap.put(key,value);
			           }			       
			        }
			     }		    			     				
			     return response;
			     },
			     
			  error: function(response, ioArgs) {				 
			     var msg = "getConfigProperty failure" + ibm.tivoli.tpae.dojo.data._configfile;
				 if(ioArgs && ioArgs.xhr) {
				    msg += "(" + ioArgs.xhr.status + "): " + ioArgs.xhr.responseText;
				 }
				 console.log(msg);				 
				 
				 //Try config75.properties if not already tried
				 if (ibm.tivoli.tpae.dojo.data._configfile!="config75.properties") {
					ibm.tivoli.tpae.dojo.data._configfile = "config75.properties";
				 
				    dojo.xhrGet({			
					     url: context_root + "/webclient/javascript/com/ibm/ism/pmsc/dojo/" +  ibm.tivoli.tpae.dojo.data._configfile,	
					     sync: true,
					     handleAs: "text",
					     load: function(response, ioArgs) {						   
						  
  					        //split config properties into array of lines					    
					        var arrayOfLines = response.split(/\r\n|\n|\r/);
					        for(var indx = 0; indx < arrayOfLines.length; indx++){
					           var singleLine = arrayOfLines[indx].trim();
					           if (singleLine!="" && singleLine[0]!= "#") {  //not comment
					              var attrs = singleLine.split("=");
					              if (attrs.length==2) {
			                         var key = attrs[0].trim();
			                         var value = attrs[1].trim();			                      	                      		            			             
		                             propmap.put(key,value);
					              }			       
					           }
					        }		    			     				
					        return response;
					        },
					     
					     error: function(response, ioArgs) {// no config.properies or config75.properties	 
					       
					        var msg = "getConfigProperty failure" + ibm.tivoli.tpae.dojo.data._configfile;
						    if(ioArgs && ioArgs.xhr) {
						       msg += "(" + ioArgs.xhr.status + "): " + ioArgs.xhr.responseText;
						    }
						    console.error(msg);
						    alert ("config.properties not found");  //Let user know!!
						    ibm.tivoli.logger.error(msg);
						    return response;
				         }   
			         });
				 } else {
					 var msg = "getConfigProperty failure" + ibm.tivoli.tpae.dojo.data._configfile;
					 if(ioArgs && ioArgs.xhr) {
					    msg += "(" + ioArgs.xhr.status + "): " + ioArgs.xhr.responseText;
					 }
					 console.log(msg);
					 return response;					 
				 }
			
		      }   
	      });
		  
	    
	    //If config.properties is in separate war
	  } else { 
		dojo.xhrGet({
			url: "/SRMCommonsWeb/SimpleSrm",
			content: {p: pname},
			sync: true,
			handleAs: "text",
			load: function(response, ioArgs) 
			{
				propmap.put(pname,response.trim());
				return response;
			},
			error: function(response, ioArgs) 
			{
				var msg = "getConfigProperty failure";
				if(ioArgs && ioArgs.xhr) {
					msg += "(" + ioArgs.xhr.status + "): " + ioArgs.xhr.responseText;
				}
				console.error(msg);
				ibm.tivoli.logger.error(msg);
				return response;
			}
	      });
		}
	}
	return propmap.get(pname);
};
 

//******* tpaeQuery ******
dojo.declare("ibm.tivoli.tpae.dojo.data._tpaeQuery", null,
{
	baseRestUrl: "",
	restOS: "maximo/rest/srm/",  //default context root
	restMbo: "maximo/rest/mbo/",	 
	rest_context_root: "maximo",  

	baseWSUrl: "",

   cache: {
       general : new ibm.tivoli.simplesrm.srm.dojo.data.Cache(),
       domain : new ibm.tivoli.simplesrm.srm.dojo.data.Cache(),
       domainSynonyms: new ibm.tivoli.simplesrm.srm.dojo.data.Cache(),		
       clear: function(){
          var property = null;
          for(property in this){
             if(this[property].clear){
                this[property].clear();
             }
          }			
       }
    },
	
	constructor: function()
	{
		dojo.mixin(this, ibm.tivoli.tpae.dojo.data.ajaxQuery());

		val = ibm.tivoli.tpae.dojo.data.getConfigProperty("maxURL");
		this.baseRestUrl = (val==null || val.length == 0) ? window.location.protocol + "//" +window.location.host+"/" : val;  
		this.baseWSUrl = this.baseRestUrl + "meaweb/services/";
				 		
		var context = window.location.pathname;  // /maximo/ui
		  if (context.indexOf("/")!=0)
			  context = "/" + context;
		  var paths = context.split("/");
		  if (paths.length>=2) {
			  this.rest_context_root = paths[1]; 
		  }
		  
		  this.restOS = this.rest_context_root + "/rest/srm/";
		  this.restMbo = this.rest_context_root + "/rest/mbo/";	
				
	},
	// TODO: maybe I should get rid of this function
	_getLocaleDebugString: function()
	{
		var bdebug = window.location.search.search("debug=(1|true)") > 0;
		var blocale = window.location.search.search("locale=es") > 0;
		return bdebug && blocale ? "$$$ " : "";
	},
	normalizeOSResults: function(results)
	{
		var i;
		for(i in results) {
		    console.log(i);
		    results.Query_Response = results[i];
		    //delete results[i];
		    for(var j in results.Query_Response) {
		    	if(/Set$/.test(j)) {
		        	results.Query_Response.Set = results.Query_Response[j];
		            //delete results.Query_Response[j];
		            break;
		        }
		    }    
		}
		return results;
	},
	
	getObjectStructure: function(os, args)
	{
		console.log("srmQuery.getObjectStructure", os, args);

		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		
		var _url = this.baseRestUrl + this.restOS + os;
		var _sync = false;
		var _args = {};
		if(undefined != args) {
			if(undefined != args.id) {
				_url += "/" + args.id;
			}
			if(undefined != args.sync) {
				_sync = args.sync;
			}
		}
		if("object" == typeof args) {
			for(var a in args) {
				if("id" != a && "sync" != a){
					_args[a] = args[a];
				}
			}
		}
		if(undefined == _args._compact) {
			_args._compact = 1;
		}
		if(undefined == _args._exactmatch) {
			_args._exactmatch = 1;
		}
		return this.get(_url, _sync, _args);
	},
	
	postToObjectStructure: function(os, sync, data)	{
		var _url = this.baseRestUrl + this.restOS + os;
		var _data = {};
		if(undefined != data) {
			if(undefined != data.id) {
				_url += "/" + data.id;
			}
		}
		if("object" == typeof data) {
			for(var a in data) {
				if("id" != a){
					_data[a] = data[a];
				}
			}
		}
		return this.post(_url, sync, _data);
	},
	

	//Get Mbo
	getMbo: function(mbo, args) {  
		console.log("srmQuery.getMbo", mbo, args);	
		
		var _url = this.baseRestUrl + this.restMbo + mbo;  		 
		var _sync = false;
		var _args = {};
		if(undefined != args) {
			if(undefined != args.id) {
				_url += "/" + args.id;
			}
			if(undefined != args.sync) {
				_sync = args.sync;
			}
		}
		if("object" == typeof args) {
			for(var a in args) {
				if("id" != a && "sync" != a){
					_args[a] = args[a];
				}
			}
		}
		if(undefined == _args._compact) {
			_args._compact = 1;
		}
		if(undefined == _args._exactmatch) {
			_args._exactmatch = 1;
		}
		return this.get(_url, _sync, _args);
	},
	
	
	/**
	 * retrieve Maximo global properties
	 * @return {Deferred}
	 */
	getMaxPropValue: function(){
		//url = this.baseRestUrl + this.rest_context_root + "/rest/mbo/MAXPROPVALUE";
		url = this.baseRestUrl + this.restMbo + "MAXPROPVALUE";
		
		var params = {};
		params._exactmatch=1;
		return this.get(url,false,params);
	},
	
	 
	/**
	 * Get MAXVARS
	 * varnamep:  name of varvalue to retrieve
	 */
	getMaxVarValue: function(varnamep){
		var params = {};
		if (varnamep)
		   params = {varname:varnamep};
		params._exactmatch=1;		
		
		var url = this.baseRestUrl + this.restMbo + "MAXVARS"; 
		 
		return this.get(url,true,params);
	},
	
	/**
	 * REST Logout
	 * 
	 */
	logout: function(){
		var params = {};		 				
		var url = this.baseRestUrl +  this.rest_context_root + "/rest/logout";		 
		return this.get(url,true,params);
	},
	
	/**
	 * Get Catalogs
	 * 	  
	 */
	getCatalogs: function(){
	 var value = null;
		var params = {};		 
		params._exactmatch=1;
		params._compact=1;
		params.sync = true;
		params._includecols="itemnum,itemsetid,status";
				
		//var url = this.baseRestUrl + this.rest_context_root + "/rest/mbo/PMSCCATALOG";
		var url = this.baseRestUrl + this.restMbo + "PMSCCATALOG";
		
		var d=  this.get(url,true,params);		 			 
		d.addCallback(dojo.hitch(this, function(response) 	{
			var values = response.PMSCCATALOGMboSet.PMSCCATALOG;
			if (values.length >0) {				
			    var general = this.cache.general;
			    general.put("catalogs", values);
			}
		}));						
	},
	
	/**
	 * Get MAXMESSAGES value
	 * msggroupp:  message group to retrieve
	 * msgkeyp:    message key to retrieve	  
	 */
	getMaxMessage: function(msggroupp, msgkeyp){
	 var value = null;
		var params = {};
		if (msggroupp)
		   params.msggroup = msggroupp;
		if (msgkeyp)
			   params.msgkey = msgkeyp;
		params._exactmatch=1;
		params._maxItems=1;
		params._compact=1;
		params.sync = true;
		params._includecols='MSGKEY,VALUE';
		
		//var url = this.baseRestUrl + this.rest_context_root + "/rest/mbo/MAXMESSAGES";
		var url = this.baseRestUrl + this.restMbo + "MAXMESSAGES";
		
		var d=  this.get(url,true,params);		 			 
		d.addCallback(dojo.hitch(this, function(response) 	{
			values = response.MAXMESSAGESMboSet.MAXMESSAGES;
			if (values.length >0)
				value = values[0].VALUE;
		}));
		return value;				
	},
	
	/**
	 * Get list of MAXMESSAGES 
	 * msggroupp:  message group to retrieve
	 * msgkeyp:    message key to retrieve	  
	 */
	getMaxMessages: function(msggroupp, msgkeyp){
        var value = null;
		var params = {};
		if (msggroupp)
		   params.msggroup = msggroupp;
		if (msgkeyp)
			   params.msgkey = msgkeyp;		
	
		params._exactmatch=1;
		params._compact=1;
		params._includecols='MSGKEY,VALUE';
		params.sync = true;
		//params._maxItems=1;
		
		//var url = this.baseRestUrl +  this.rest_context_root + "/rest/mbo/MAXMESSAGES";
		var url = this.baseRestUrl + this.restMbo + "MAXMESSAGES";
		return  this.get(url,true,params);
	},
	
	/**
	 * get the list of users
	 * if params.id is specified, return that specific user  
	 */
	getUsers: function(params)
	{
		return this.getObjectStructure("MBS_MAXUSER", params);
	},

	/**
	 * similar to getUsers, but more data
	 */
	getUserDetails: function(params)
	{
		if (ibm.tivoli.tpae.dojo.data._runInMaximo==true)
			return this.getObjectStructure("SRM_MAXUSERDET", params);
		else
		   return this.getObjectStructure("MBS_MAXUSERDET", params);
	},
	/**
	 * return the user record for the logged in user
	 */
	//_loggedInUser: null,
	getLoggedInUser: function() {
		//If running in Maximo, the userid is passed in on the srmPageInit control		 
		
		var d = null,
			res = null,
			general = this.cache.general;
      if(undefined === general.get("_loggedInUser")) {
			// returnes the logged in user.
			// works in the dev environment, because the proxy will add a MAXAUTH header
			if (ibm.tivoli.tpae.dojo.data._runInMaximo==true)
				 d = this.getUserDetails({sync: true, _verbose:"false"});
			     //d = this.getUserDetails({USERID:this.loginid, sync: true, _verbose:"false"});
			else 	
		       d = this.getUserDetails({_fd:"PMZHBT_LOGGEDONUSR", sync: true});

			d.addCallbacks(function(response){
				if(ibm.tivoli.tpae.dojo.data._runInMaximo==true &&  response.QuerySRM_MAXUSERDETResponse.rsCount >= 1) {	
					var loggedInUser = response.QuerySRM_MAXUSERDETResponse.SRM_MAXUSERDETSet.MAXUSER[0];
					general.put("_loggedInUser",loggedInUser);
					ibm.tivoli.tpae.data.loggedInUsername = loggedInUser.USERID;
			    }
				else if(response.QueryMBS_MAXUSERDETResponse.rsCount >= 1) {	// TODO: changed == to >= to cope with bug in query
					var loggedInUser = response.QueryMBS_MAXUSERDETResponse.MBS_MAXUSERDETSet.MAXUSER[0];
					general.put("_loggedInUser",loggedInUser);
					ibm.tivoli.tpae.data.loggedInUsername = loggedInUser.USERID;
				}
				else { 
					ibm.tivoli.tpae.data.loggedInUsername = "";
				}
			},
			function(response)
			{
				console.warn("Failed getting logged in user: ", response);
				ibm.tivoli.tpae.data.loggedInUsername = "";
			});
		}
		res = general.get("_loggedInUser");
		return res;
	},


	getLoggedInUsername: function(){
		var res = this.getLoggedInUser();
		return res ? res.USERID : "";
	},

	/**
	 * get the list of user groups
	 * if params.id is specified, return that specific group
	 */
	getGroups: function(params)
	{
		return this.getObjectStructure("MBS_MAXGROUP", params);
	},

	getCurrentUserRole: function()
	{
		var params = {_fd: "PMZHBT_CLOUDROLE",sync: true};
		var d = this.getObjectStructure("MBS_GROUPUSER",params);
		var roleitem = null;
		d.addCallback(dojo.hitch(this, function(response)
		{
			if(response.QueryPMZHBR1_GROUPUSERResponse.rsCount > 0){
				roleitem = response.QueryPMZHBR1_GROUPUSERResponse.PMZHBR1_GROUPUSERSet.GROUPUSER[0];
			}
		}));
		return roleitem;
	},
	getUserRole: function(params)
	{
		if (undefined == params){
			params = {};
		}
		params.sync = true;
		params._fd="PMZHBT_CLUSERROLE";
		var d = this.getObjectStructure("MBS_GROUPUSER",params);
		var roleitem;
		d.addCallback(dojo.hitch(this, function(response)
		{
			roleitem = response.QueryMBS_GROUPUSERResponse.MBS_GROUPUSERSet.GROUPUSER[0];
		}));
		return roleitem;
	},
	 
	//_domainCache: {},	// cache the results by DOMAINID
	
	
	//Get a domain or a list of domains
	getDomain: function(params) {
		var d = null,
		domain = this.cache.domain;
		
		params._verbose=false;		 
		var	os = "MXDOMAIN";		
		
		if(undefined != params.DOMAINID && (dojo.isArray(params.DOMAINID) ||  undefined === domain.get(params.DOMAINID) )   ) {     
			d = this.getObjectStructure(os, params);
			d.addCallback(function(response){
				var os_root = response.QueryMXDOMAINResponse;
				
				if(os_root.rsCount > 0) {
					for (var i=0;i<os_root.rsCount;i++) {
                      var MAXDOMAIN = os_root.MXDOMAINSet.MAXDOMAIN[i];
                      var domainid = MAXDOMAIN.DOMAINID;                      
					  domain.put(domainid,MAXDOMAIN);					    
				   }
				}
				return response;
			});
		} else {
			d = new dojo.Deferred();
			d.callback(domain.get(params.DOMAINID) ? domain.get(params.DOMAINID) : new Error(params.DOMAINID));
		}
		d.addErrback(function(response){
			console.error("tpeaQuery().getDomain has failed: ", response);
			return response;
		});

		return d;
	},

	//we could also pass an array of domains to get them all at once
	getDomainSynonymTable: function(domainid) {
		//console.log("_srmQuery.getDomainSynonymTable - " + domainid);		
		var synonyms = null,
		domainSynonyms = this.cache.domainSynonyms,  
		domain = this.cache.domain;
		
		//If passed array get all at once
		if(dojo.isArray(domainid)){
			var params = {sync:true};
			
			var domainids = [];
			dojo.forEach(domainid, dojo.hitch(this,function(domain){
				domainids.push(domain);				 
			}));
			
			 params.DOMAINID=domainids;
             params["DOMAINID.ormode"]=1;
             params._exactmatch=0;
			 this.getDomain(params);  //Get list of domains
			
			 //Cache domains
			 dojo.forEach(domainid, dojo.hitch(this,function(d){
			    var synonyms = domain.get(d).SYNONYMDOMAIN;
			    //var synonyms = domain.get(domain).QueryMXDOMAINResponse.MXDOMAINSet.MAXDOMAIN[0].SYNONYMDOMAIN; 
				domainSynonyms.put(d,new ibm.tivoli.tpae.dojo.data.SynonymDomain(synonyms));	
			 }));
			 return;			
		} 
		
		if(undefined === domainSynonyms.get(domainid)) {
			if(undefined === domain.get(domainid)){
				// don't have the data yet. Get it now.
				console.log("_srmQuery.getDomainSynonymTable - " + domainid);	
				this.getDomain({DOMAINID: domainid, sync: true});
			}			
                       
			//cache it
            var synonyms = domain.get(domainid).SYNONYMDOMAIN;
            //var synonyms = domain.get(domainid).QueryMXDOMAINResponse.MXDOMAINSet.MAXDOMAIN[0].SYNONYMDOMAIN;        
			domainSynonyms.put(domainid,new ibm.tivoli.tpae.dojo.data.SynonymDomain(synonyms));			
		}
		
		return domainSynonyms.get(domainid);
	},


	getLanguageTable: function(params)
	{
		console.log("_srmQuery.getLanguageTable");
		if (undefined == params){
			params = {};
		}
		params.ENABLED = "true";
		return this.getObjectStructure("MBS_LANGUAGE", params);
	}	
});
ibm.tivoli.tpae.dojo.data._tpaequery = null;
ibm.tivoli.tpae.dojo.data.tpaeQuery = function(){
	// summary: returns the singleton query object
	if(!ibm.tivoli.tpae.dojo.data._tpaequery){
		ibm.tivoli.tpae.dojo.data._tpaequery = new ibm.tivoli.tpae.dojo.data._tpaeQuery();
	}
	return ibm.tivoli.tpae.dojo.data._tpaequery;	// Object
};
//-------------------------
dojo.declare("ibm.tivoli.tpae.dojo.data.SynonymDomain", null,
{
	synonyms: null,
	length: 0,
	
	constructor: function(synonyms) 
	{
		this.synonyms = synonyms;
		if(this.synonyms) {
			this.length = this.synonyms.length;
		} 
	},
	descriptionByValue: function(value)
	{
		var desc = this.fieldByKey("VALUE", "DESCRIPTION", value);
		if(undefined == desc){
			desc = value;
		}
		return desc;
	},
	valueByMaxvalue: function(maxvalue)
	{
		return this.fieldByKey("MAXVALUE", "VALUE", maxvalue);
	},
	fieldByKey: function(keyfield, valfield, keyvalue)
	{
		for(var i = 0; i < this.length; ++i) {
			var s = this.synonyms[i];
			if(keyvalue === s[keyfield]) {
				return s[valfield];
			}
		}
		return null;
	}
});
});

},
'dojo/_base/url':function(){
define("dojo/_base/url", ["./kernel"], function(dojo) {
	// module:
	//		dojo/url
	// summary:
	//		This module contains dojo._Url

	var
		ore = new RegExp("^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$"),
		ire = new RegExp("^((([^\\[:]+):)?([^@]+)@)?(\\[([^\\]]+)\\]|([^\\[:]*))(:([0-9]+))?$"),
		_Url = function(){
			var n = null,
				_a = arguments,
				uri = [_a[0]];
			// resolve uri components relative to each other
			for(var i = 1; i<_a.length; i++){
				if(!_a[i]){ continue; }

				// Safari doesn't support this.constructor so we have to be explicit
				// FIXME: Tracked (and fixed) in Webkit bug 3537.
				//		http://bugs.webkit.org/show_bug.cgi?id=3537
				var relobj = new _Url(_a[i]+""),
					uriobj = new _Url(uri[0]+"");

				if(
					relobj.path == "" &&
					!relobj.scheme &&
					!relobj.authority &&
					!relobj.query
				){
					if(relobj.fragment != n){
						uriobj.fragment = relobj.fragment;
					}
					relobj = uriobj;
				}else if(!relobj.scheme){
					relobj.scheme = uriobj.scheme;

					if(!relobj.authority){
						relobj.authority = uriobj.authority;

						if(relobj.path.charAt(0) != "/"){
							var path = uriobj.path.substring(0,
								uriobj.path.lastIndexOf("/") + 1) + relobj.path;

							var segs = path.split("/");
							for(var j = 0; j < segs.length; j++){
								if(segs[j] == "."){
									// flatten "./" references
									if(j == segs.length - 1){
										segs[j] = "";
									}else{
										segs.splice(j, 1);
										j--;
									}
								}else if(j > 0 && !(j == 1 && segs[0] == "") &&
									segs[j] == ".." && segs[j-1] != ".."){
									// flatten "../" references
									if(j == (segs.length - 1)){
										segs.splice(j, 1);
										segs[j - 1] = "";
									}else{
										segs.splice(j - 1, 2);
										j -= 2;
									}
								}
							}
							relobj.path = segs.join("/");
						}
					}
				}

				uri = [];
				if(relobj.scheme){
					uri.push(relobj.scheme, ":");
				}
				if(relobj.authority){
					uri.push("//", relobj.authority);
				}
				uri.push(relobj.path);
				if(relobj.query){
					uri.push("?", relobj.query);
				}
				if(relobj.fragment){
					uri.push("#", relobj.fragment);
				}
			}

			this.uri = uri.join("");

			// break the uri into its main components
			var r = this.uri.match(ore);

			this.scheme = r[2] || (r[1] ? "" : n);
			this.authority = r[4] || (r[3] ? "" : n);
			this.path = r[5]; // can never be undefined
			this.query = r[7] || (r[6] ? "" : n);
			this.fragment	 = r[9] || (r[8] ? "" : n);

			if(this.authority != n){
				// server based naming authority
				r = this.authority.match(ire);

				this.user = r[3] || n;
				this.password = r[4] || n;
				this.host = r[6] || r[7]; // ipv6 || ipv4
				this.port = r[9] || n;
			}
		};
	_Url.prototype.toString = function(){ return this.uri; };

	return dojo._Url = _Url;
});

},
'dojox/main':function(){
define("dojox/main", ["dojo/_base/kernel"], function(dojo) {
	// module:
	//		dojox/main
	// summary:
	//		The dojox package main module; dojox package is somewhat unusual in that the main module currently just provides an empty object.

	return dojo.dojox;
});
},
'dojo/text':function(){
define("dojo/text", ["./_base/kernel", "require", "./has", "./_base/xhr"], function(dojo, require, has, xhr){
	// module:
	//		dojo/text
	// summary:
	//		This module implements the !dojo/text plugin and the dojo.cache API.
	// description:
	//		We choose to include our own plugin to leverage functionality already contained in dojo
	//		and thereby reduce the size of the plugin compared to various foreign loader implementations.
	//		Also, this allows foreign AMD loaders to be used without their plugins.
	//
	//		CAUTION: this module is designed to optionally function synchronously to support the dojo v1.x synchronous
	//		loader. This feature is outside the scope of the CommonJS plugins specification.

	var getText;
	if(1){
		getText= function(url, sync, load){
			xhr("GET", {url:url, sync:!!sync, load:load});
		};
	}else{
		// TODOC: only works for dojo AMD loader
		if(require.getText){
			getText= require.getText;
		}else{
			console.error("dojo/text plugin failed to load because loader does not support getText");
		}
	}

	var
		theCache= {},

		strip= function(text){
			//Strips <?xml ...?> declarations so that external SVG and XML
			//documents can be added to a document without worry. Also, if the string
			//is an HTML document, only the part inside the body tag is returned.
			if(text){
				text= text.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
				var matches= text.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
				if(matches){
					text= matches[1];
				}
			}else{
				text = "";
			}
			return text;
		},

		notFound = {},

		pending = {},

		result= {
			dynamic:
				// the dojo/text caches it's own resources because of dojo.cache
				true,

			normalize:function(id, toAbsMid){
				// id is something like (path may be relative):
				//
				//	 "path/to/text.html"
				//	 "path/to/text.html!strip"
				var parts= id.split("!"),
					url= parts[0];
				return (/^\./.test(url) ? toAbsMid(url) : url) + (parts[1] ? "!" + parts[1] : "");
			},

			load:function(id, require, load){
				// id is something like (path is always absolute):
				//
				//	 "path/to/text.html"
				//	 "path/to/text.html!strip"
				var
					parts= id.split("!"),
					stripFlag= parts.length>1,
					absMid= parts[0],
					url = require.toUrl(parts[0]),
					text = notFound,
					finish = function(text){
						load(stripFlag ? strip(text) : text);
					};
				if(absMid in theCache){
					text = theCache[absMid];
				}else if(url in require.cache){
					text = require.cache[url];
				}else if(url in theCache){
					text = theCache[url];
				}
				if(text===notFound){
					if(pending[url]){
						pending[url].push(finish);
					}else{
						var pendingList = pending[url] = [finish];
						getText(url, !require.async, function(text){
							theCache[absMid]= theCache[url]= text;
							for(var i = 0; i<pendingList.length;){
								pendingList[i++](text);
							}
							delete pending[url];
						});
					}
				}else{
					finish(text);
				}
			}
		};

	dojo.cache= function(/*String||Object*/module, /*String*/url, /*String||Object?*/value){
		//	 * (string string [value]) => (module, url, value)
		//	 * (object [value])        => (module, value), url defaults to ""
		//
		//	 * if module is an object, then it must be convertable to a string
		//	 * (module, url) module + (url ? ("/" + url) : "") must be a legal argument to require.toUrl
		//	 * value may be a string or an object; if an object then may have the properties "value" and/or "sanitize"
		var key;
		if(typeof module=="string"){
			if(/\//.test(module)){
				// module is a version 1.7+ resolved path
				key = module;
				value = url;
			}else{
				// module is a version 1.6- argument to dojo.moduleUrl
				key = require.toUrl(module.replace(/\./g, "/") + (url ? ("/" + url) : ""));
			}
		}else{
			key = module + "";
			value = url;
		}
		var
			val = (value != undefined && typeof value != "string") ? value.value : value,
			sanitize = value && value.sanitize;

		if(typeof val == "string"){
			//We have a string, set cache value
			theCache[key] = val;
			return sanitize ? strip(val) : val;
		}else if(val === null){
			//Remove cached value
			delete theCache[key];
			return null;
		}else{
			//Allow cache values to be empty strings. If key property does
			//not exist, fetch it.
			if(!(key in theCache)){
				getText(key, true, function(text){
					theCache[key]= text;
				});
			}
			return sanitize ? strip(theCache[key]) : theCache[key];
		}
	};

	return result;

/*=====
dojo.cache = function(module, url, value){
	// summary:
	//		A getter and setter for storing the string content associated with the
	//		module and url arguments.
	// description:
	//		If module is a string that contains slashes, then it is interpretted as a fully
	//		resolved path (typically a result returned by require.toUrl), and url should not be
	//		provided. This is the preferred signature. If module is a string that does not
	//		contain slashes, then url must also be provided and module and url are used to
	//		call `dojo.moduleUrl()` to generate a module URL. This signature is deprecated.
	//		If value is specified, the cache value for the moduleUrl will be set to
	//		that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
	//		in its internal cache and return that cached value for the URL. To clear
	//		a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
	//		the URL contents, only modules on the same domain of the page can use this capability.
	//		The build system can inline the cache values though, to allow for xdomain hosting.
	// module: String||Object
	//		If a String with slashes, a fully resolved path; if a String without slashes, the
	//		module name to use for the base part of the URL, similar to module argument
	//		to `dojo.moduleUrl`. If an Object, something that has a .toString() method that
	//		generates a valid path for the cache item. For example, a dojo._Url object.
	// url: String
	//		The rest of the path to append to the path derived from the module argument. If
	//		module is an object, then this second argument should be the "value" argument instead.
	// value: String||Object?
	//		If a String, the value to use in the cache for the module/url combination.
	//		If an Object, it can have two properties: value and sanitize. The value property
	//		should be the value to use in the cache, and sanitize can be set to true or false,
	//		to indicate if XML declarations should be removed from the value and if the HTML
	//		inside a body tag in the value should be extracted as the real value. The value argument
	//		or the value property on the value argument are usually only used by the build system
	//		as it inlines cache content.
	//	example:
	//		To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
	//		of call is used to avoid an issue with the build system erroneously trying to intern
	//		this example. To get the build system to intern your dojo.cache calls, use the
	//		"dojo.cache" style of call):
	//		| //If template.html contains "<h1>Hello</h1>" that will be
	//		| //the value for the text variable.
	//		| var text = dojo["cache"]("my.module", "template.html");
	//	example:
	//		To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
	//		 (the dojo["cache"] style of call is used to avoid an issue with the build system
	//		erroneously trying to intern this example. To get the build system to intern your
	//		dojo.cache calls, use the "dojo.cache" style of call):
	//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
	//		| //text variable will contain just "<h1>Hello</h1>".
	//		| var text = dojo["cache"]("my.module", "template.html", {sanitize: true});
	//	example:
	//		Same example as previous, but demostrates how an object can be passed in as
	//		the first argument, then the value argument can then be the second argument.
	//		| //If template.html contains "<html><body><h1>Hello</h1></body></html>", the
	//		| //text variable will contain just "<h1>Hello</h1>".
	//		| var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});
	return val; //String
};
=====*/
});


},
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n",
'url:dijit/form/templates/CheckBox.html':"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdata-dojo-attach-point=\"focusNode\"\n\t \tdata-dojo-attach-event=\"onclick:_onClick\"\n/></div>\n",
'ibm/tivoli/simplesrm/srm/dojo/Utilities':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojo/date/locale"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.Utilities");

dojo.require("dojo.date.locale");

String.prototype.htmlencode = function()
{
	return this.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/'/gm, "&#39;").replace(/"/gm, "&#34;");
};
String.prototype.safeencode = function()
{
	//return (this).replace(/\+/g, "%2B");
	return this;
};

String.prototype.htmldecode = function() {
	var tempdiv = document.createElement("div");
	tempdiv.innerHTML = this;
	return tempdiv.childNodes[0].nodeValue;
};

String.prototype.formatISODateString = function(params)
{
	var d = this;
	var isod = this.replace(' ', 'T');
	var dt = dojo.date.stamp.fromISOString(isod);

	var sel = "date";
	if (params && params.sel && params.sel == "datetime") {
		sel = undefined; /* This is weird, I know */
	}
	
	if(dt) {
		//var sel = isod.search("T00:00:00") > 0 ? "date" : ""; // only format date if exactly midnight
	
		d = dojo.date.locale.format(dt, {fullYear:true, selector: sel});
	}
	return d;
};
if(undefined === String.prototype.trim) {
	String.prototype.trim = function()
	{
		return this.replace(/^\s+|\s+$/g, "");
	};
}

});

},
'dojo/cldr/nls/gregorian':function(){
define({ root:

//begin v1.x content
{
	"months-format-narrow": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"quarters-standAlone-narrow": [
		"1",
		"2",
		"3",
		"4"
	],
	"field-weekday": "Day of the Week",
	"dateFormatItem-yQQQ": "y QQQ",
	"dateFormatItem-yMEd": "EEE, y-M-d",
	"dateFormatItem-MMMEd": "E MMM d",
	"eraNarrow": [
		"BCE",
		"CE"
	],
	"dateTimeFormats-appendItem-Day-Of-Week": "{0} {1}",
	"dateFormat-long": "y MMMM d",
	"months-format-wide": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"dateTimeFormat-medium": "{1} {0}",
	"dateFormatItem-EEEd": "d EEE",
	"dayPeriods-format-wide-pm": "PM",
	"dateFormat-full": "EEEE, y MMMM dd",
	"dateFormatItem-Md": "M-d",
	"dayPeriods-format-abbr-am": "AM",
	"dateTimeFormats-appendItem-Second": "{0} ({2}: {1})",
	"field-era": "Era",
	"dateFormatItem-yM": "y-M",
	"months-standAlone-wide": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"timeFormat-short": "HH:mm",
	"quarters-format-wide": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"timeFormat-long": "HH:mm:ss z",
	"field-year": "Year",
	"dateFormatItem-yMMM": "y MMM",
	"dateFormatItem-yQ": "y Q",
	"dateTimeFormats-appendItem-Era": "{0} {1}",
	"field-hour": "Hour",
	"months-format-abbr": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"timeFormat-full": "HH:mm:ss zzzz",
	"dateTimeFormats-appendItem-Week": "{0} ({2}: {1})",
	"field-day-relative+0": "Today",
	"field-day-relative+1": "Tomorrow",
	"dateFormatItem-H": "HH",
	"months-standAlone-abbr": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"quarters-format-abbr": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"quarters-standAlone-wide": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"dateFormatItem-M": "L",
	"days-standAlone-wide": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7"
	],
	"timeFormat-medium": "HH:mm:ss",
	"dateFormatItem-Hm": "HH:mm",
	"quarters-standAlone-abbr": [
		"Q1",
		"Q2",
		"Q3",
		"Q4"
	],
	"eraAbbr": [
		"BCE",
		"CE"
	],
	"field-minute": "Minute",
	"field-dayperiod": "Dayperiod",
	"days-standAlone-abbr": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7"
	],
	"dateFormatItem-d": "d",
	"dateFormatItem-ms": "mm:ss",
	"quarters-format-narrow": [
		"1",
		"2",
		"3",
		"4"
	],
	"field-day-relative+-1": "Yesterday",
	"dateFormatItem-h": "h a",
	"dateTimeFormat-long": "{1} {0}",
	"dayPeriods-format-narrow-am": "AM",
	"dateFormatItem-MMMd": "MMM d",
	"dateFormatItem-MEd": "E, M-d",
	"dateTimeFormat-full": "{1} {0}",
	"field-day": "Day",
	"days-format-wide": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7"
	],
	"field-zone": "Zone",
	"dateTimeFormats-appendItem-Day": "{0} ({2}: {1})",
	"dateFormatItem-y": "y",
	"months-standAlone-narrow": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7",
		"8",
		"9",
		"10",
		"11",
		"12"
	],
	"dateFormatItem-hm": "h:mm a",
	"dateTimeFormats-appendItem-Year": "{0} {1}",
	"dateTimeFormats-appendItem-Hour": "{0} ({2}: {1})",
	"dayPeriods-format-abbr-pm": "PM",
	"days-format-abbr": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7"
	],
	"eraNames": [
		"BCE",
		"CE"
	],
	"days-format-narrow": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7"
	],
	"days-standAlone-narrow": [
		"1",
		"2",
		"3",
		"4",
		"5",
		"6",
		"7"
	],
	"dateFormatItem-MMM": "LLL",
	"field-month": "Month",
	"dateTimeFormats-appendItem-Quarter": "{0} ({2}: {1})",
	"dayPeriods-format-wide-am": "AM",
	"dateTimeFormats-appendItem-Month": "{0} ({2}: {1})",
	"dateTimeFormats-appendItem-Minute": "{0} ({2}: {1})",
	"dateFormat-short": "yyyy-MM-dd",
	"field-second": "Second",
	"dateFormatItem-yMMMEd": "EEE, y MMM d",
	"dateTimeFormats-appendItem-Timezone": "{0} {1}",
	"field-week": "Week",
	"dateFormat-medium": "y MMM d",
	"dayPeriods-format-narrow-pm": "PM",
	"dateTimeFormat-short": "{1} {0}",
	"dateFormatItem-Hms": "HH:mm:ss",
	"dateFormatItem-hms": "h:mm:ss a"
}
//end v1.x content
,
	"aa": true,
	"af": true,
	"ak": true,
	"am": true,
	"ar": true,
	"ar-dz": true,
	"ar-jo": true,
	"ar-lb": true,
	"ar-ma": true,
	"ar-qa": true,
	"ar-sa": true,
	"ar-sy": true,
	"ar-tn": true,
	"ar-ye": true,
	"as": true,
	"asa": true,
	"az": true,
	"az-cyrl": true,
	"be": true,
	"bem": true,
	"bez": true,
	"bg": true,
	"bm": true,
	"bn": true,
	"bn-in": true,
	"bo": true,
	"br": true,
	"brx": true,
	"bs": true,
	"byn": true,
	"ca": true,
	"cgg": true,
	"chr": true,
	"cs": true,
	"cy": true,
	"da": true,
	"dav": true,
	"de": true,
	"de-at": true,
	"de-be": true,
	"dz": true,
	"ebu": true,
	"ee": true,
	"el": true,
	"el-polyton": true,
	"en": true,
	"en-au": true,
	"en-be": true,
	"en-bw": true,
	"en-bz": true,
	"en-ca": true,
	"en-dsrt": true,
	"en-gb": true,
	"en-hk": true,
	"en-ie": true,
	"en-in": true,
	"en-mt": true,
	"en-nz": true,
	"en-pk": true,
	"en-sg": true,
	"en-shaw": true,
	"en-za": true,
	"en-zw": true,
	"eo": true,
	"es": true,
	"es-ar": true,
	"es-cl": true,
	"es-co": true,
	"es-ec": true,
	"es-gt": true,
	"es-hn": true,
	"es-pa": true,
	"es-pe": true,
	"es-pr": true,
	"es-us": true,
	"et": true,
	"eu": true,
	"fa": true,
	"fa-af": true,
	"ff": true,
	"fi": true,
	"fil": true,
	"fo": true,
	"fr": true,
	"fr-be": true,
	"fr-ca": true,
	"fr-ch": true,
	"fur": true,
	"ga": true,
	"gl": true,
	"gsw": true,
	"gu": true,
	"guz": true,
	"gv": true,
	"ha": true,
	"haw": true,
	"he": true,
	"hi": true,
	"hr": true,
	"hu": true,
	"hy": true,
	"id": true,
	"ig": true,
	"ii": true,
	"in": true,
	"is": true,
	"it": true,
	"it-ch": true,
	"iw": true,
	"ja": true,
	"jmc": true,
	"ka": true,
	"kab": true,
	"kam": true,
	"kde": true,
	"kea": true,
	"khq": true,
	"ki": true,
	"kk": true,
	"kl": true,
	"kln": true,
	"km": true,
	"kn": true,
	"ko": true,
	"kok": true,
	"ksb": true,
	"ksh": true,
	"kw": true,
	"lag": true,
	"lg": true,
	"ln": true,
	"lt": true,
	"luo": true,
	"luy": true,
	"lv": true,
	"mas": true,
	"mer": true,
	"mfe": true,
	"mg": true,
	"mk": true,
	"ml": true,
	"mo": true,
	"mr": true,
	"ms": true,
	"ms-bn": true,
	"mt": true,
	"my": true,
	"naq": true,
	"nb": true,
	"nd": true,
	"ne": true,
	"ne-in": true,
	"nl": true,
	"nl-be": true,
	"nn": true,
	"no": true,
	"nyn": true,
	"oc": true,
	"om": true,
	"or": true,
	"pa": true,
	"pa-arab": true,
	"pa-pk": true,
	"pl": true,
	"ps": true,
	"pt": true,
	"pt-pt": true,
	"rm": true,
	"ro": true,
	"rof": true,
	"ru": true,
	"ru-ua": true,
	"rw": true,
	"rwk": true,
	"saq": true,
	"se": true,
	"seh": true,
	"ses": true,
	"sg": true,
	"sh": true,
	"shi": true,
	"shi-tfng": true,
	"si": true,
	"sk": true,
	"sl": true,
	"sn": true,
	"so": true,
	"sq": true,
	"sr": true,
	"sr-ba": true,
	"sr-cyrl-ba": true,
	"sr-latn": true,
	"sr-latn-me": true,
	"sr-me": true,
	"ssy": true,
	"sv": true,
	"sv-fi": true,
	"sw": true,
	"syr": true,
	"ta": true,
	"te": true,
	"teo": true,
	"th": true,
	"ti": true,
	"ti-er": true,
	"tl": true,
	"to": true,
	"tr": true,
	"trv": true,
	"tzm": true,
	"uk": true,
	"ur": true,
	"vi": true,
	"vun": true,
	"xog": true,
	"yo": true,
	"zh": true,
	"zh-hans-sg": true,
	"zh-hant": true,
	"zh-hant-hk": true,
	"zh-hant-mo": true,
	"zh-hk": true,
	"zh-mo": true,
	"zh-sg": true,
	"zh-tw": true,
	"zu": true
});
},
'ibm/tivoli/tip/dijit/TIPTableSearchField':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/tip/dijit/nls/resources","dojo/require!dijit/_Widget,dijit/_Templated,dijit/form/Button,dijit/form/CheckBox,dijit/Dialog,dijit/Menu,dijit/Tooltip"], function(dijit,dojo,dojox){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * 5724-C51
 *
 * (C) Copyright IBM Corp. 2007 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit.form.Button");
dojo.require("dijit.form.CheckBox");
dojo.require("dijit.Dialog");
dojo.require("dijit.Menu");
dojo.require("dijit.Tooltip");

// NLS
dojo.requireLocalization("ibm.tivoli.tip.dijit", "resources");

dojo.provide("ibm.tivoli.tip.dijit.TIPTableSearchField");

dojo.declare("ibm.tivoli.tip.dijit.TIPTableSearchField",
            [ dijit._Widget, dijit._Templated ],
{
  widgetsInTemplate: true,
  
  /* The TIPTable that this search bar is attached to */
  table: null,
  
  _ALL_COLS_NAME: "QF_ALL_COLS",
  
  /** An array of column names that should participate in filtering **/
  columnsToFilterOn: { "QF_ALL_COLS": true },
  
  /** Keeps track of all topic subscriptions to cleanly destroy later **/
  topics: [],
  
  _qf_arrow_src: dojo.moduleUrl("ibm.tivoli.tip.dijit","themes/images/qf_arrow.gif"),
  
  /** Keeps track of all event connections **/
  objectConnections: [],
  
  /** Keeps track of all children widgets in dropdown **/
  childrenWidgets: [],
  
  templateString:"<div class=\"quick-filter\" align=\"right\">\n<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n<tbody>\n<tr>\n<td dojoAttachPoint=\"colFilter\" class=\"qf-lcap\" width=\"20px\" valign=\"top\" dojoAttachEvent='onmouseover:_onHover,onmouseout:_onUnHover'>\n</td>\n<td class=\"qf-mid\" width=\"170\" valign=\"middle\">\n<label style=\"display: none;\" for=\"${id}_searchField\" > ${resources_.SEARCH_TEXT}</label> \n<input id=\"${id}_searchField\" title=\"${resources_.SEARCH_TEXT}\" dojoAttachPoint=\"searchField\" class=\"qf-textfield-label\" type=\"text\" valign=\"middle\" dojoAttachEvent='onfocus:_onFocus,onblur:_onBlur,onkeypress:_onKeyPress' />\n\n</td>\n<td class=\"qf-rcap\" width=\"15\"/>\n</tr>\n</tbody>\n</table>\n</div>\n",

  constructor: function( parms ) 
  {
  	this.resources_ = dojo.i18n.getLocalization("ibm.tivoli.tip.dijit", "resources");    
  },
  
  postCreate: function()
  {
    if ( this.table !== null )
    {
      this.setTable( this.table );
    }        
  },  
   
  /********************************************************************
  * This method must be called to set the underlying table that the 
  * search bar will filter on.  As soon as this method is called
  * the table is queried for its "structure" (columns) and the dropdown
  * column filter dialog is populated
  *********************************************************************/
  setTable: function( table )
  {
  	// Save a reference to the table
  	this.table = table;
  	
  	this.clear(); //ensure that we start with a fresh slate
  	  	
  	var div  = document.createElement( 'DIV' );
  	var div2 = document.createElement( 'DIV' );
  	div2.className="qf-col-filter-title";	  
  
  	div2.appendChild( document.createTextNode( this.resources_.FILTER_ON ) );
  	div.appendChild( div2 );

  	div2 = document.createElement( 'DIV' );
	div2.className="qf-col-chkbox-label-row";
  	
  	var checkbox = new dijit.form.CheckBox( { id     : table.id + this._ALL_COLS_NAME,
  											  pId    : table.id,
  	                                          name   : this._ALL_COLS_NAME,
  	                                          checked: true } );
//  	                                          checked: this.columnsToFilterOn[ this._ALL_COLS_NAME ] } );

	this.childrenWidgets[ checkbox.id ] = checkbox;
	
	checkbox.onColsFilter = function()
	{
		this.setChecked( false );
	};
	
	checkbox.onCheckedEvent = function ()
	{
  		if ( this.checked )
  		{
	  		dojo.publish( this.pId + "_filterOnAll", ["Filter on all rows"] );
  		}
	};  	           
	
  	this.topics[ this._ALL_COLS_NAME ] = dojo.subscribe( table.id + "_filterByCol", checkbox, "onColsFilter" );                                                                         
	this.objectConnections[ this._ALL_COLS_NAME ] = dojo.connect( checkbox, "setChecked", checkbox, "onCheckedEvent" );  	                                          

	var label = document.createElement( 'LABEL' );
	label.className = "qf-col-chkbox-label";
	//label["for"] = checkbox.id; //doesn't work on FF
	dojo.attr(label,"for",checkbox.id);
	label.title = this.resources_.ALL_COLUMNS;
	
	label.appendChild( document.createTextNode( this.resources_.ALL_COLUMNS ) );
	
	div2.appendChild( checkbox.domNode );  	                                         
	div2.appendChild( label );  	                                         

	div.appendChild( div2 );

	var columns = [];
	var i = 0;
	var j = 0;
	
	table.views.forEach( function( view, i )
	{
		if ( view.structure.cells )
		{
			for ( i in view.structure.cells )
			{
				for ( j in view.structure.cells[i] )
				{
					 var v = view.structure.cells[i][j];				
		             if (v.field !== undefined) {
                         columns.push( v );
	                 }
				}			
			}
		}
	});  	
  	  	
  	for ( i in columns )
  	{
	  if ( columns[i].isSearchable === false ) {
	    continue;
	  }
  		div2 = document.createElement( 'DIV' );
  		div2.className="qf-col-chkbox-label-row";
  		
  		checkbox = new dijit.form.CheckBox( { //id     : table.id + columns[i].name,//name can contain chars that are illegal for html id type, default id is better
  											  pId    : table.id,
  											  columnID: columns[i].field,
  	                                          name   : columns[i].name,
  	                                          checked: this.columnsToFilterOn[ columns[i].name ] } );

		this.childrenWidgets[ checkbox.id ] = checkbox;
		
		checkbox.onAllColsFilter = function()
		{
			this.setChecked( false );
		};
		
		checkbox.onCheckedEvent = function ()
		{
	  		if ( this.checked )
	  		{
		  		dojo.publish( this.pId + "_filterByCol", ["Filter on individual columns"] );		
	  		}
		};  	           
		
		this.topics[ columns[i].name ] = dojo.subscribe( table.id + "_filterOnAll", checkbox, "onAllColsFilter" );                               
  	    
		this.objectConnections[ columns[i].name ] = dojo.connect( checkbox, "setChecked", checkbox, "onCheckedEvent" );  	                                          
  	                                          
		div2.appendChild( checkbox.domNode );  	                            

		label = document.createElement( 'LABEL' );
		//label["for"] = checkbox.id;//doesn't work on FF
		dojo.attr(label,"for",checkbox.id);
		label.title = columns[i].name;
		label.className = "qf-col-chkbox-label";
		
		label.appendChild( document.createTextNode( columns[i].name ) );
		
		div2.appendChild( label );  	                                         		             
  		
  		div.appendChild( div2 );  		
  	}
  	  	
  	var button = new dijit.form.Button( { id: table.id + "close_btn",
                                        type: "submit", 
  								       label: this.resources_.OK } );

	this.childrenWidgets[ button.id ] = button;	  								       
  								     
	div.appendChild( button.domNode );  								     
  	
  	var tooltipDialog = new dijit.TooltipDialog( { id: table.id + "gf_tooltipdialog" } );

	this.childrenWidgets[ tooltipDialog.id ] = tooltipDialog;	  								       
  	  	
  	tooltipDialog.containerNode.appendChild( div );
  	
  	/** OVERLOAD to allow our own styling to be added **/
  	tooltipDialog.orient = function(/*Object*/ corner)
  	{
		// summary: configure widget to be displayed in given position relative to the button
// TODO: dojo 1.2.3: corner is a domNode, and doesn't have a charAt method.
//		this.domNode.className="dijitTooltipDialog " +" dijitTooltipAB"+(corner.charAt(1)=='L'?"Left":"Right")+" dijitTooltip"+(corner.charAt(0)=='T' ? "Below" : "Above" ) + " qf-TooltipDialog";
	};  	
  	
  	tooltipDialog.execute = function( args )
  	{  		
  	    this.columnsToFilterOn = [];
  	    
  		for ( var i in args )
  		{
			this.columnsToFilterOn[i] = ( args[i][0] ) ? true : false ;
  		}  	
  	};
  	
	var btn = new dijit.form.DropDownButton( { 	id: table.id + "_coltrigger", 
												dropDown: tooltipDialog,
												label: "",
												baseClass: "qf-col-trigger" } );
												
	this.tooltip_dropdownhelp = new dijit.Tooltip({label:this.resources_.SEARCH_DROP_DOWN_HELP, connectId:[btn.id]}, document.createElement("div"));
												
	
	this.childrenWidgets[ btn.id ] = btn;	  								       

	this.colFilter.appendChild( btn.domNode );
		
	btn.startup();
	
	var downArrowSpan =  dojo.query("span.dijitArrowButtonInner", btn.domNode );	
	
	dojo.query("span.dijitButtonText", btn.domNode ).orphan();
	
	downArrowSpan[0].innerHTML = "";
	dojo.removeClass( downArrowSpan[0], "dijitArrowButtonInner" );
	downArrowSpan[0].style.padding="0px";
	
	var image = dojo.doc.createElement( 'IMG' );	
	image.src = this._qf_arrow_src;
	image.border = 0;
	image.style.padding="1px";
	image.style.margin="2px";
	image.alt = this.resources_.SEARCH_DROP_DOWN_HELP;
	
	downArrowSpan[0].appendChild( image );	

  },
  
  _onFocus: function()
  {
	this.domNode.className="quick-filter-focus";  
  },
  
  _onBlur: function()
  {
	this.domNode.className="quick-filter";
  },
  
  _onKeyPress: function(event)
  {
  	if (event.keyCode == 13) {
	  	event.cancelBubble = true;
  		event.returnValue = false;
  		dojo.publish ("onEnter", [this, event]);
  		dojo.publish (this.id + "searchInvoked", [this, event]);
	}
  },
  
  _onHover: function()
  {
	this.colFilter.className="qf-lcap-over";
  },
  
  _onUnHover: function()
  {
	this.colFilter.className="qf-lcap";
  },
  
  _setFilterCol: function ()
  {  	
  },
  

  getSelectedColumns: function ()
  {
  	var result = [];
  	
  	if (this.childrenWidgets[this.table.id + this._ALL_COLS_NAME].checked) {
	  	for (var x in this.childrenWidgets) {
	  		if (x) {
	  			if (this.childrenWidgets[x].columnID !== undefined ) {
		  			result.push (this.childrenWidgets[x].columnID);
		  		}
  			}
  		}
  	} else {
	  	for (var y in this.childrenWidgets) {
	  		if (y) {
	  			if (this.childrenWidgets[y].checked) {
		  			if (this.childrenWidgets[y].columnID !== undefined ) {
		  				result.push (this.childrenWidgets[y].columnID);
		  			}
	  			}
	  		}
	  	}
  	}
  	
	return (result);
  },
  
  setSelectedColumns: function(/*Array*/ cols)
  {
  	for(var y in this.childrenWidgets) {
  		if(y) {
  			this.childrenWidgets[y].attr("checked", dojo.indexOf(cols, this.childrenWidgets[y].columnID) >= 0 );
  		}
  	}
  },
  
  /*************************************************************
  * Clears the contents of the search drop down to be recreated
  *************************************************************/
  clear: function()
  {
  	/** Destroy all subscriptions **/
  	for ( var i in this.topics )
  	{
  		dojo.unsubscribe( this.topics[i] );
  	}
  	
  	delete this.topics;
  	this.topics = [];

  	/** Destroy all event connections **/
  	for ( i in this.objectConnections )
  	{
  		dojo.disconnect( this.objectConnections[i] );
  	}  	

  	delete this.objectConnections;
  	this.objectConnections = [];
  	
  	/** Destroy all children widgets **/
  	for ( i in this.childrenWidgets )
  	{
  		this.childrenWidgets[i].destroy();
  	}  
  	
  	if ( this.tooltip_dropdownhelp )
  	{
  		this.tooltip_dropdownhelp.destroy();
  	}

  	delete this.childrenWidgets;
  	this.childrenWidgets = [];
  	
  	delete this.columnsToFilterOn;
  	this.columnsToFilterOn = [];
  },
  
  /*************************************************************
  * Destroy this widget -- remove all subscriptions and event
  * connections
  *************************************************************/
  destroy: function()
  {  	
  	this.clear();
  	
  	/** call super **/
  	this.inherited( arguments );
  }
  
});

});

},
'dojo/uacss':function(){
define("dojo/uacss", ["./dom-geometry", "./_base/lang", "./ready", "./_base/sniff", "./_base/window"],
	function(geometry, lang, ready, has, baseWindow){
	// module:
	//		dojo/uacss
	// summary:
	//		Applies pre-set CSS classes to the top-level HTML node, based on:
	//			- browser (ex: dj_ie)
	//			- browser version (ex: dj_ie6)
	//			- box model (ex: dj_contentBox)
	//			- text direction (ex: dijitRtl)
	//
	//		In addition, browser, browser version, and box model are
	//		combined with an RTL flag when browser text is RTL. ex: dj_ie-rtl.

	var
		html = baseWindow.doc.documentElement,
		ie = has("ie"),
		opera = has("opera"),
		maj = Math.floor,
		ff = has("ff"),
		boxModel = geometry.boxModel.replace(/-/,''),

		classes = {
			"dj_ie": ie,
			"dj_ie6": maj(ie) == 6,
			"dj_ie7": maj(ie) == 7,
			"dj_ie8": maj(ie) == 8,
			"dj_ie9": maj(ie) == 9,
			"dj_quirks": has("quirks"),
			"dj_iequirks": ie && has("quirks"),

			// NOTE: Opera not supported by dijit
			"dj_opera": opera,

			"dj_khtml": has("khtml"),

			"dj_webkit": has("webkit"),
			"dj_safari": has("safari"),
			"dj_chrome": has("chrome"),

			"dj_gecko": has("mozilla"),
			"dj_ff3": maj(ff) == 3
		}; // no dojo unsupported browsers

	classes["dj_" + boxModel] = true;

	// apply browser, browser version, and box model class names
	var classStr = "";
	for(var clz in classes){
		if(classes[clz]){
			classStr += clz + " ";
		}
	}
	html.className = lang.trim(html.className + " " + classStr);

	// If RTL mode, then add dj_rtl flag plus repeat existing classes with -rtl extension.
	// We can't run the code below until the <body> tag has loaded (so we can check for dir=rtl).
	// priority is 90 to run ahead of parser priority of 100
	ready(90, function(){
		if(!geometry.isBodyLtr()){
			var rtlClassStr = "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl ");
			html.className = lang.trim(html.className + " " + rtlClassStr + "dj_rtl dijitRtl " + classStr.replace(/ /g, "-rtl "));
		}
	});
	return has;
});

},
'dojo/string':function(){
define("dojo/string", ["./_base/kernel", "./_base/lang"], function(dojo, lang) {
	// module:
	//		dojo/string
	// summary:
	//		TODOC

lang.getObject("string", true, dojo);

/*=====
dojo.string = {
	// summary: String utilities for Dojo
};
=====*/

dojo.string.rep = function(/*String*/str, /*Integer*/num){
	// summary:
	//		Efficiently replicate a string `n` times.
	// str:
	//		the string to replicate
	// num:
	//		number of times to replicate the string

	if(num <= 0 || !str){ return ""; }

	var buf = [];
	for(;;){
		if(num & 1){
			buf.push(str);
		}
		if(!(num >>= 1)){ break; }
		str += str;
	}
	return buf.join("");	// String
};

dojo.string.pad = function(/*String*/text, /*Integer*/size, /*String?*/ch, /*Boolean?*/end){
	// summary:
	//		Pad a string to guarantee that it is at least `size` length by
	//		filling with the character `ch` at either the start or end of the
	//		string. Pads at the start, by default.
	// text:
	//		the string to pad
	// size:
	//		length to provide padding
	// ch:
	//		character to pad, defaults to '0'
	// end:
	//		adds padding at the end if true, otherwise pads at start
	// example:
	//	|	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
	//	|	dojo.string.pad("Dojo", 10, "+", true);

	if(!ch){
		ch = '0';
	}
	var out = String(text),
		pad = dojo.string.rep(ch, Math.ceil((size - out.length) / ch.length));
	return end ? out + pad : pad + out;	// String
};

dojo.string.substitute = function(	/*String*/		template,
									/*Object|Array*/map,
									/*Function?*/	transform,
									/*Object?*/		thisObject){
	// summary:
	//		Performs parameterized substitutions on a string. Throws an
	//		exception if any parameter is unmatched.
	// template:
	//		a string with expressions in the form `${key}` to be replaced or
	//		`${key:format}` which specifies a format function. keys are case-sensitive.
	// map:
	//		hash to search for substitutions
	// transform:
	//		a function to process all parameters before substitution takes
	//		place, e.g. mylib.encodeXML
	// thisObject:
	//		where to look for optional format function; default to the global
	//		namespace
	// example:
	//		Substitutes two expressions in a string from an Array or Object
	//	|	// returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// by providing substitution data in an Array
	//	|	dojo.string.substitute(
	//	|		"File '${0}' is not found in directory '${1}'.",
	//	|		["foo.html","/temp"]
	//	|	);
	//	|
	//	|	// also returns "File 'foo.html' is not found in directory '/temp'."
	//	|	// but provides substitution data in an Object structure.  Dotted
	//	|	// notation may be used to traverse the structure.
	//	|	dojo.string.substitute(
	//	|		"File '${name}' is not found in directory '${info.dir}'.",
	//	|		{ name: "foo.html", info: { dir: "/temp" } }
	//	|	);
	// example:
	//		Use a transform function to modify the values:
	//	|	// returns "file 'foo.html' is not found in directory '/temp'."
	//	|	dojo.string.substitute(
	//	|		"${0} is not found in ${1}.",
	//	|		["foo.html","/temp"],
	//	|		function(str){
	//	|			// try to figure out the type
	//	|			var prefix = (str.charAt(0) == "/") ? "directory": "file";
	//	|			return prefix + " '" + str + "'";
	//	|		}
	//	|	);
	// example:
	//		Use a formatter
	//	|	// returns "thinger -- howdy"
	//	|	dojo.string.substitute(
	//	|		"${0:postfix}", ["thinger"], null, {
	//	|			postfix: function(value, key){
	//	|				return value + " -- howdy";
	//	|			}
	//	|		}
	//	|	);

	thisObject = thisObject || dojo.global;
	transform = transform ?
		lang.hitch(thisObject, transform) : function(v){ return v; };

	return template.replace(/\$\{([^\s\:\}]+)(?:\:([^\s\:\}]+))?\}/g,
		function(match, key, format){
			var value = lang.getObject(key, false, map);
			if(format){
				value = lang.getObject(format, false, thisObject).call(thisObject, value, key);
			}
			return transform(value, key).toString();
		}); // String
};

/*=====
dojo.string.trim = function(str){
	// summary:
	//		Trims whitespace from both sides of the string
	// str: String
	//		String to be trimmed
	// returns: String
	//		Returns the trimmed string
	// description:
	//		This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	//		The short yet performant version of this function is dojo.trim(),
	//		which is part of Dojo base.  Uses String.prototype.trim instead, if available.
	return "";	// String
}
=====*/

dojo.string.trim = String.prototype.trim ?
	lang.trim : // aliasing to the native function
	function(str){
		str = str.replace(/^\s+/, '');
		for(var i = str.length - 1; i >= 0; i--){
			if(/\S/.test(str.charAt(i))){
				str = str.substring(0, i + 1);
				break;
			}
		}
		return str;
	};

return dojo.string;
});

},
'dijit/Tooltip':function(){
require({cache:{
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n></div>\n"}});
define("dijit/Tooltip", [
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/dom", // dom.byId
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.getMarginBox domGeometry.position
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArrayLike
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/window", // win.body
	"./_base/manager",	// manager.defaultDuration
	"./place",
	"./_Widget",
	"./_TemplatedMixin",
	"./BackgroundIframe",
	"dojo/text!./templates/Tooltip.html",
	"."		// sets dijit.showTooltip etc. for back-compat
], function(array, declare, fx, dom, domClass, domGeometry, domStyle, lang, has, win,
			manager, place, _Widget, _TemplatedMixin, BackgroundIframe, template, dijit){

/*=====
	var _Widget = dijit._Widget;
	var BackgroundIframe = dijit.BackgroundIframe;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/Tooltip
	// summary:
	//		Defines dijit.Tooltip widget (to display a tooltip), showTooltip()/hideTooltip(), and _MasterTooltip


	var MasterTooltip = declare("dijit._MasterTooltip", [_Widget, _TemplatedMixin], {
		// summary:
		//		Internal widget that holds the actual tooltip markup,
		//		which occurs once per page.
		//		Called by Tooltip widgets which are just containers to hold
		//		the markup
		// tags:
		//		protected

		// duration: Integer
		//		Milliseconds to fade in/fade out
		duration: manager.defaultDuration,

		templateString: template,

		postCreate: function(){
			win.body().appendChild(this.domNode);

			this.bgIframe = new BackgroundIframe(this.domNode);

			// Setup fade-in and fade-out functions.
			this.fadeIn = fx.fadeIn({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onShow") });
			this.fadeOut = fx.fadeOut({ node: this.domNode, duration: this.duration, onEnd: lang.hitch(this, "_onHide") });
		},

		show: function(innerHTML, aroundNode, position, rtl, textDir){
			// summary:
			//		Display tooltip w/specified contents to right of specified node
			//		(To left if there's no space on the right, or if rtl == true)
			// innerHTML: String
			//		Contents of the tooltip
			// aroundNode: DomNode || dijit.__Rectangle
			//		Specifies that tooltip should be next to this node / area
			// position: String[]?
			//		List of positions to try to position tooltip (ex: ["right", "above"])
			// rtl: Boolean?
			//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
			//		means "rtl"; specifies GUI direction, not text direction.
			// textDir: String?
			//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.


			if(this.aroundNode && this.aroundNode === aroundNode && this.containerNode.innerHTML == innerHTML){
				return;
			}

			// reset width; it may have been set by orient() on a previous tooltip show()
			this.domNode.width = "auto";

			if(this.fadeOut.status() == "playing"){
				// previous tooltip is being hidden; wait until the hide completes then show new one
				this._onDeck=arguments;
				return;
			}
			this.containerNode.innerHTML=innerHTML;
			
			this.set("textDir", textDir);
			this.containerNode.align = rtl? "right" : "left"; //fix the text alignment

			var pos = place.around(this.domNode, aroundNode,
				position && position.length ? position : Tooltip.defaultPosition, !rtl, lang.hitch(this, "orient"));

			// Position the tooltip connector for middle alignment.
			// This could not have been done in orient() since the tooltip wasn't positioned at that time.
			var aroundNodeCoords = pos.aroundNodePos;
			if(pos.corner.charAt(0) == 'M' && pos.aroundCorner.charAt(0) == 'M'){
				this.connectorNode.style.top = aroundNodeCoords.y + ((aroundNodeCoords.h - this.connectorNode.offsetHeight) >> 1) - pos.y + "px";
				this.connectorNode.style.left = "";
			}else if(pos.corner.charAt(1) == 'M' && pos.aroundCorner.charAt(1) == 'M'){
				this.connectorNode.style.left = aroundNodeCoords.x + ((aroundNodeCoords.w - this.connectorNode.offsetWidth) >> 1) - pos.x + "px";
			}

			// show it
			domStyle.set(this.domNode, "opacity", 0);
			this.fadeIn.play();
			this.isShowingNow = true;
			this.aroundNode = aroundNode;
		},

		orient: function(/*DomNode*/ node, /*String*/ aroundCorner, /*String*/ tooltipCorner, /*Object*/ spaceAvailable, /*Object*/ aroundNodeCoords){
			// summary:
			//		Private function to set CSS for tooltip node based on which position it's in.
			//		This is called by the dijit popup code.   It will also reduce the tooltip's
			//		width to whatever width is available
			// tags:
			//		protected
			this.connectorNode.style.top = ""; //reset to default

			//Adjust the spaceAvailable width, without changing the spaceAvailable object
			var tooltipSpaceAvaliableWidth = spaceAvailable.w - this.connectorNode.offsetWidth;

			node.className = "dijitTooltip " +
				{
					"MR-ML": "dijitTooltipRight",
					"ML-MR": "dijitTooltipLeft",
					"TM-BM": "dijitTooltipAbove",
					"BM-TM": "dijitTooltipBelow",
					"BL-TL": "dijitTooltipBelow dijitTooltipABLeft",
					"TL-BL": "dijitTooltipAbove dijitTooltipABLeft",
					"BR-TR": "dijitTooltipBelow dijitTooltipABRight",
					"TR-BR": "dijitTooltipAbove dijitTooltipABRight",
					"BR-BL": "dijitTooltipRight",
					"BL-BR": "dijitTooltipLeft"
				}[aroundCorner + "-" + tooltipCorner];

			// reduce tooltip's width to the amount of width available, so that it doesn't overflow screen
			this.domNode.style.width = "auto";
			var size = domGeometry.getContentBox(this.domNode);

			var width = Math.min((Math.max(tooltipSpaceAvaliableWidth,1)), size.w);
			var widthWasReduced = width < size.w;

			this.domNode.style.width = width+"px";

			//Adjust width for tooltips that have a really long word or a nowrap setting
			if(widthWasReduced){
				this.containerNode.style.overflow = "auto"; //temp change to overflow to detect if our tooltip needs to be wider to support the content
				var scrollWidth = this.containerNode.scrollWidth;
				this.containerNode.style.overflow = "visible"; //change it back
				if(scrollWidth > width){
					scrollWidth = scrollWidth + domStyle.get(this.domNode,"paddingLeft") + domStyle.get(this.domNode,"paddingRight");
					this.domNode.style.width = scrollWidth + "px";
				}
			}

			// Reposition the tooltip connector.
			if(tooltipCorner.charAt(0) == 'B' && aroundCorner.charAt(0) == 'B'){
				var mb = domGeometry.getMarginBox(node);
				var tooltipConnectorHeight = this.connectorNode.offsetHeight;
				if(mb.h > spaceAvailable.h){
					// The tooltip starts at the top of the page and will extend past the aroundNode
					var aroundNodePlacement = spaceAvailable.h - ((aroundNodeCoords.h + tooltipConnectorHeight) >> 1);
					this.connectorNode.style.top = aroundNodePlacement + "px";
					this.connectorNode.style.bottom = "";
				}else{
					// Align center of connector with center of aroundNode, except don't let bottom
					// of connector extend below bottom of tooltip content, or top of connector
					// extend past top of tooltip content
					this.connectorNode.style.bottom = Math.min(
						Math.max(aroundNodeCoords.h/2 - tooltipConnectorHeight/2, 0),
						mb.h - tooltipConnectorHeight) + "px";
					this.connectorNode.style.top = "";
				}
			}else{
				// reset the tooltip back to the defaults
				this.connectorNode.style.top = "";
				this.connectorNode.style.bottom = "";
			}

			return Math.max(0, size.w - tooltipSpaceAvaliableWidth);
		},

		_onShow: function(){
			// summary:
			//		Called at end of fade-in operation
			// tags:
			//		protected
			if(has("ie")){
				// the arrow won't show up on a node w/an opacity filter
				this.domNode.style.filter="";
			}
		},

		hide: function(aroundNode){
			// summary:
			//		Hide the tooltip

			if(this._onDeck && this._onDeck[1] == aroundNode){
				// this hide request is for a show() that hasn't even started yet;
				// just cancel the pending show()
				this._onDeck=null;
			}else if(this.aroundNode === aroundNode){
				// this hide request is for the currently displayed tooltip
				this.fadeIn.stop();
				this.isShowingNow = false;
				this.aroundNode = null;
				this.fadeOut.play();
			}else{
				// just ignore the call, it's for a tooltip that has already been erased
			}
		},

		_onHide: function(){
			// summary:
			//		Called at end of fade-out operation
			// tags:
			//		protected

			this.domNode.style.cssText="";	// to position offscreen again
			this.containerNode.innerHTML="";
			if(this._onDeck){
				// a show request has been queued up; do it now
				this.show.apply(this, this._onDeck);
				this._onDeck=null;
			}
		},
		
		_setAutoTextDir: function(/*Object*/node){
		    // summary:
		    //	    Resolve "auto" text direction for children nodes
		    // tags:
		    //		private

            this.applyTextDir(node, has("ie") ? node.outerText : node.textContent);
            array.forEach(node.children, function(child){this._setAutoTextDir(child); }, this);
		},
		
		_setTextDirAttr: function(/*String*/ textDir){
		    // summary:
		    //		Setter for textDir.
		    // description:
		    //		Users shouldn't call this function; they should be calling
		    //		set('textDir', value)
		    // tags:
		    //		private
	
            this._set("textDir", typeof textDir != 'undefined'? textDir : "");
    	    if (textDir == "auto"){
    	        this._setAutoTextDir(this.containerNode);
    	    }else{
    	        this.containerNode.dir = this.textDir;
    	    }  		             		        
        }
	});

	dijit.showTooltip = function(innerHTML, aroundNode, position, rtl, textDir){
		// summary:
		//		Static method to display tooltip w/specified contents in specified position.
		//		See description of dijit.Tooltip.defaultPosition for details on position parameter.
		//		If position is not specified then dijit.Tooltip.defaultPosition is used.
		// innerHTML: String
		//		Contents of the tooltip
		// aroundNode: dijit.__Rectangle
		//		Specifies that tooltip should be next to this node / area
		// position: String[]?
		//		List of positions to try to position tooltip (ex: ["right", "above"])
		// rtl: Boolean?
		//		Corresponds to `WidgetBase.dir` attribute, where false means "ltr" and true
		//		means "rtl"; specifies GUI direction, not text direction.
		// textDir: String?
		//		Corresponds to `WidgetBase.textdir` attribute; specifies direction of text.
		if(!Tooltip._masterTT){ dijit._masterTT = Tooltip._masterTT = new MasterTooltip(); }
		return Tooltip._masterTT.show(innerHTML, aroundNode, position, rtl, textDir);
	};

	dijit.hideTooltip = function(aroundNode){
		// summary:
		//		Static method to hide the tooltip displayed via showTooltip()
		return Tooltip._masterTT && Tooltip._masterTT.hide(aroundNode);
	};

	var Tooltip = declare("dijit.Tooltip", _Widget, {
		// summary:
		//		Pops up a tooltip (a help message) when you hover over a node.

		// label: String
		//		Text to display in the tooltip.
		//		Specified as innerHTML when creating the widget from markup.
		label: "",

		// showDelay: Integer
		//		Number of milliseconds to wait after hovering over/focusing on the object, before
		//		the tooltip is displayed.
		showDelay: 400,

		// connectId: String|String[]
		//		Id of domNode(s) to attach the tooltip to.
		//		When user hovers over specified dom node, the tooltip will appear.
		connectId: [],

		// position: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on position parameter.
		position: [],

		_setConnectIdAttr: function(/*String|String[]*/ newId){
			// summary:
			//		Connect to specified node(s)

			// Remove connections to old nodes (if there are any)
			array.forEach(this._connections || [], function(nested){
				array.forEach(nested, lang.hitch(this, "disconnect"));
			}, this);

			// Make array of id's to connect to, excluding entries for nodes that don't exist yet, see startup()
			this._connectIds = array.filter(lang.isArrayLike(newId) ? newId : (newId ? [newId] : []),
					function(id){ return dom.byId(id); });

			// Make connections
			this._connections = array.map(this._connectIds, function(id){
				var node = dom.byId(id);
				return [
					this.connect(node, "onmouseenter", "_onHover"),
					this.connect(node, "onmouseleave", "_onUnHover"),
					this.connect(node, "onfocus", "_onHover"),
					this.connect(node, "onblur", "_onUnHover")
				];
			}, this);

			this._set("connectId", newId);
		},

		addTarget: function(/*DOMNODE || String*/ node){
			// summary:
			//		Attach tooltip to specified node if it's not already connected

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node;
			if(array.indexOf(this._connectIds, id) == -1){
				this.set("connectId", this._connectIds.concat(id));
			}
		},

		removeTarget: function(/*DomNode || String*/ node){
			// summary:
			//		Detach tooltip from specified node

			// TODO: remove in 2.0 and just use set("connectId", ...) interface

			var id = node.id || node,	// map from DOMNode back to plain id string
				idx = array.indexOf(this._connectIds, id);
			if(idx >= 0){
				// remove id (modifies original this._connectIds but that's OK in this case)
				this._connectIds.splice(idx, 1);
				this.set("connectId", this._connectIds);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode,"dijitTooltipData");
		},

		startup: function(){
			this.inherited(arguments);

			// If this tooltip was created in a template, or for some other reason the specified connectId[s]
			// didn't exist during the widget's initialization, then connect now.
			var ids = this.connectId;
			array.forEach(lang.isArrayLike(ids) ? ids : [ids], this.addTarget, this);
		},

		_onHover: function(/*Event*/ e){
			// summary:
			//		Despite the name of this method, it actually handles both hover and focus
			//		events on the target node, setting a timer to show the tooltip.
			// tags:
			//		private
			if(!this._showTimer){
				var target = e.target;
				this._showTimer = setTimeout(lang.hitch(this, function(){this.open(target)}), this.showDelay);
			}
		},

		_onUnHover: function(/*Event*/ /*===== e =====*/){
			// summary:
			//		Despite the name of this method, it actually handles both mouseleave and blur
			//		events on the target node, hiding the tooltip.
			// tags:
			//		private

			// keep a tooltip open if the associated element still has focus (even though the
			// mouse moved away)
			if(this._focus){ return; }

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			this.close();
		},

		open: function(/*DomNode*/ target){
 			// summary:
			//		Display the tooltip; usually not called directly.
			// tags:
			//		private

			if(this._showTimer){
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
			Tooltip.show(this.label || this.domNode.innerHTML, target, this.position, !this.isLeftToRight(), this.textDir);

			this._connectNode = target;
			this.onShow(target, this.position);
		},

		close: function(){
			// summary:
			//		Hide the tooltip or cancel timer for show of tooltip
			// tags:
			//		private

			if(this._connectNode){
				// if tooltip is currently shown
				Tooltip.hide(this._connectNode);
				delete this._connectNode;
				this.onHide();
			}
			if(this._showTimer){
				// if tooltip is scheduled to be shown (after a brief delay)
				clearTimeout(this._showTimer);
				delete this._showTimer;
			}
		},

		onShow: function(/*===== target, position =====*/){
			// summary:
			//		Called when the tooltip is shown
			// tags:
			//		callback
		},

		onHide: function(){
			// summary:
			//		Called when the tooltip is hidden
			// tags:
			//		callback
		},

		uninitialize: function(){
			this.close();
			this.inherited(arguments);
		}
	});

	Tooltip._MasterTooltip = MasterTooltip;		// for monkey patching
	Tooltip.show = dijit.showTooltip;		// export function through module return value
	Tooltip.hide = dijit.hideTooltip;		// export function through module return value

	// dijit.Tooltip.defaultPosition: String[]
	//		This variable controls the position of tooltips, if the position is not specified to
	//		the Tooltip widget or *TextBox widget itself.  It's an array of strings with the following values:
	//
	//			* before: places tooltip to the left of the target node/widget, or to the right in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* after: places tooltip to the right of the target node/widget, or to the left in
	//			  the case of RTL scripts like Hebrew and Arabic
	//			* above: tooltip goes above target node
	//			* below: tooltip goes below target node
	//			* top: tooltip goes above target node but centered connector
	//			* bottom: tooltip goes below target node but centered connector
	//
	//		The list is positions is tried, in order, until a position is found where the tooltip fits
	//		within the viewport.
	//
	//		Be careful setting this parameter.  A value of "above" may work fine until the user scrolls
	//		the screen so that there's no room above the target node.   Nodes with drop downs, like
	//		DropDownButton or FilteringSelect, are especially problematic, in that you need to be sure
	//		that the drop down and tooltip don't overlap, even when the viewport is scrolled so that there
	//		is only room below (or above) the target node, but not both.
	Tooltip.defaultPosition = ["after", "before"];


	return Tooltip;
});

},
'dijit/form/_FormValueMixin':function(){
define("dijit/form/_FormValueMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/keys", // keys.ESCAPE
	"dojo/_base/sniff", // has("ie"), has("quirks")
	"./_FormWidgetMixin"
], function(declare, domAttr, keys, has, _FormWidgetMixin){

/*=====
	var _FormWidgetMixin = dijit.form._FormWidgetMixin;
=====*/

	// module:
	//		dijit/form/_FormValueMixin
	// summary:
	//		Mixin for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.

	return declare("dijit.form._FormValueMixin", _FormWidgetMixin, {
		// summary:
		//		Mixin for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
		// description:
		//		Each _FormValueMixin represents a single input value, and has a (possibly hidden) <input> element,
		//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
		//		works as expected.

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,

		_setReadOnlyAttr: function(/*Boolean*/ value){
			domAttr.set(this.focusNode, 'readOnly', value);
			this.focusNode.setAttribute("aria-readonly", value);
			this._set("readOnly", value);
		},

		postCreate: function(){
			this.inherited(arguments);

			if(has("ie")){ // IE won't stop the event with keypress
				this.connect(this.focusNode || this.domNode, "onkeydown", this._onKeyDown);
			}
			// Update our reset value if it hasn't yet been set (because this.set()
			// is only called when there *is* a value)
			if(this._resetValue === undefined){
				this._lastValueReported = this._resetValue = this.value;
			}
		},

		_setValueAttr: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Hook so set('value', value) works.
			// description:
			//		Sets the value of the widget.
			//		If the value has changed, then fire onChange event, unless priorityChange
			//		is specified as null (or false?)
			this._handleOnChange(newValue, priorityChange);
		},

		_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
			// summary:
			//		Called when the value of the widget has changed.  Saves the new value in this.value,
			//		and calls onChange() if appropriate.   See _FormWidget._handleOnChange() for details.
			this._set("value", newValue);
			this.inherited(arguments);
		},

		undo: function(){
			// summary:
			//		Restore the value to the last value passed to onChange
			this._setValueAttr(this._lastValueReported, false);
		},

		reset: function(){
			// summary:
			//		Reset the widget's value to what it was at initialization time
			this._hasBeenBlurred = false;
			this._setValueAttr(this._resetValue, true);
		},

		_onKeyDown: function(e){
			if(e.keyCode == keys.ESCAPE && !(e.ctrlKey || e.altKey || e.metaKey)){
				var te;
				if(has("ie") < 9 || (has("ie") && has("quirks"))){
					e.preventDefault(); // default behavior needs to be stopped here since keypress is too late
					te = document.createEventObject();
					te.keyCode = keys.ESCAPE;
					te.shiftKey = e.shiftKey;
					e.srcElement.fireEvent('onkeypress', te);
				}
			}
		}
	});
});

},
'dijit/form/DropDownButton':function(){
require({cache:{
'url:dijit/form/templates/DropDownButton.html':"<span class=\"dijit dijitReset dijitInline\"\n\t><span class='dijitReset dijitInline dijitButtonNode'\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" data-dojo-attach-point=\"_buttonNode\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"focusNode,titleNode,_arrowWrapperNode\"\n\t\t\trole=\"button\" aria-haspopup=\"true\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\"\n\t\t\t\tdata-dojo-attach-point=\"iconNode\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode,_popupStateNode\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonInner\"></span\n\t\t\t><span class=\"dijitReset dijitInline dijitArrowButtonChar\">&#9660;</span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-point=\"valueNode\"\n/></span>\n"}});
define("dijit/form/DropDownButton", [
	"dojo/_base/declare", // declare
	"dojo/_base/lang",	// hitch
	"dojo/query", // query
	"../registry",	// registry.byNode
	"../popup",		// dijit.popup2.hide
	"./Button",
	"../_Container",
	"../_HasDropDown",
	"dojo/text!./templates/DropDownButton.html"
], function(declare, lang, query, registry, popup, Button, _Container, _HasDropDown, template){

/*=====
	Button = dijit.form.Button;
	_Container = dijit._Container;
	_HasDropDown = dijit._HasDropDown;
=====*/

// module:
//		dijit/form/DropDownButton
// summary:
//		A button with a drop down


return declare("dijit.form.DropDownButton", [Button, _Container, _HasDropDown], {
	// summary:
	//		A button with a drop down
	//
	// example:
	// |	<button data-dojo-type="dijit.form.DropDownButton">
	// |		Hello world
	// |		<div data-dojo-type="dijit.Menu">...</div>
	// |	</button>
	//
	// example:
	// |	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
	// |	win.body().appendChild(button1);
	//

	baseClass : "dijitDropDownButton",

	templateString: template,

	_fillContent: function(){
		// Overrides Button._fillContent().
		//
		// My inner HTML contains both the button contents and a drop down widget, like
		// <DropDownButton>  <span>push me</span>  <Menu> ... </Menu> </DropDownButton>
		// The first node is assumed to be the button content. The widget is the popup.

		if(this.srcNodeRef){ // programatically created buttons might not define srcNodeRef
			//FIXME: figure out how to filter out the widget and use all remaining nodes as button
			//	content, not just nodes[0]
			var nodes = query("*", this.srcNodeRef);
			this.inherited(arguments, [nodes[0]]);

			// save pointer to srcNode so we can grab the drop down widget after it's instantiated
			this.dropDownContainer = this.srcNodeRef;
		}
	},

	startup: function(){
		if(this._started){ return; }

		// the child widget from srcNodeRef is the dropdown widget.  Insert it in the page DOM,
		// make it invisible, and store a reference to pass to the popup code.
		if(!this.dropDown && this.dropDownContainer){
			var dropDownNode = query("[widgetId]", this.dropDownContainer)[0];
			this.dropDown = registry.byNode(dropDownNode);
			delete this.dropDownContainer;
		}
		if(this.dropDown){
			popup.hide(this.dropDown);
		}

		this.inherited(arguments);
	},

	isLoaded: function(){
		// Returns whether or not we are loaded - if our dropdown has an href,
		// then we want to check that.
		var dropDown = this.dropDown;
		return (!!dropDown && (!dropDown.href || dropDown.isLoaded));
	},

	loadDropDown: function(/*Function*/ callback){
		// Default implementation assumes that drop down already exists,
		// but hasn't loaded it's data (ex: ContentPane w/href).
		// App must override if the drop down is lazy-created.
		var dropDown = this.dropDown;
		var handler = dropDown.on("load", lang.hitch(this, function(){
			handler.remove();
			callback();
		}));
		dropDown.refresh();		// tell it to load
	},

	isFocusable: function(){
		// Overridden so that focus is handled by the _HasDropDown mixin, not by
		// the _FormWidget mixin.
		return this.inherited(arguments) && !this._mouseDown;
	}
});

});

},
'dijit/form/_FormWidgetMixin':function(){
define("dijit/form/_FormWidgetMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-style", // domStyle.get
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/mouse", // mouse.isLeft
	"dojo/_base/sniff", // has("webkit")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.scrollIntoView
	"../a11y"	// a11y.hasDefaultTabStop
], function(array, declare, domAttr, domStyle, lang, mouse, has, win, winUtils, a11y){

// module:
//		dijit/form/_FormWidgetMixin
// summary:
//		Mixin for widgets corresponding to native HTML elements such as <checkbox> or <button>,
//		which can be children of a <form> node or a `dijit.form.Form` widget.

return declare("dijit.form._FormWidgetMixin", null, {
	// summary:
	//		Mixin for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	// name: [const] String
	//		Name used when submitting form; same as "name" attribute or plain HTML elements
	name: "",

	// alt: String
	//		Corresponds to the native HTML <input> element's attribute.
	alt: "",

	// value: String
	//		Corresponds to the native HTML <input> element's attribute.
	value: "",

	// type: [const] String
	//		Corresponds to the native HTML <input> element's attribute.
	type: "text",

	// tabIndex: Integer
	//		Order fields are traversed when user hits the tab key
	tabIndex: "0",
	_setTabIndexAttr: "focusNode",	// force copy even when tabIndex default value, needed since Button is <span>

	// disabled: Boolean
	//		Should this widget respond to user input?
	//		In markup, this is specified as "disabled='disabled'", or just "disabled".
	disabled: false,

	// intermediateChanges: Boolean
	//		Fires onChange for each value change or only on demand
	intermediateChanges: false,

	// scrollOnFocus: Boolean
	//		On focus, should this widget scroll into view?
	scrollOnFocus: true,

	// Override _WidgetBase mapping id to this.domNode, needs to be on focusNode so <label> etc.
	// works with screen reader
	_setIdAttr: "focusNode",

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onmousedown", "_onMouseDown");
	},

	_setDisabledAttr: function(/*Boolean*/ value){
		this._set("disabled", value);
		domAttr.set(this.focusNode, 'disabled', value);
		if(this.valueNode){
			domAttr.set(this.valueNode, 'disabled', value);
		}
		this.focusNode.setAttribute("aria-disabled", value);

		if(value){
			// reset these, because after the domNode is disabled, we can no longer receive
			// mouse related events, see #4200
			this._set("hovering", false);
			this._set("active", false);

			// clear tab stop(s) on this widget's focusable node(s)  (ComboBox has two focusable nodes)
			var attachPointNames = "tabIndex" in this.attributeMap ? this.attributeMap.tabIndex :
				("_setTabIndexAttr" in this) ? this._setTabIndexAttr : "focusNode";
			array.forEach(lang.isArray(attachPointNames) ? attachPointNames : [attachPointNames], function(attachPointName){
				var node = this[attachPointName];
				// complex code because tabIndex=-1 on a <div> doesn't work on FF
				if(has("webkit") || a11y.hasDefaultTabStop(node)){	// see #11064 about webkit bug
					node.setAttribute('tabIndex', "-1");
				}else{
					node.removeAttribute('tabIndex');
				}
			}, this);
		}else{
			if(this.tabIndex != ""){
				this.set('tabIndex', this.tabIndex);
			}
		}
	},

	_onFocus: function(e){
		if(this.scrollOnFocus){
			winUtils.scrollIntoView(this.domNode);
		}
		this.inherited(arguments);
	},

	isFocusable: function(){
		// summary:
		//		Tells if this widget is focusable or not.  Used internally by dijit.
		// tags:
		//		protected
		return !this.disabled && this.focusNode && (domStyle.get(this.domNode, "display") != "none");
	},

	focus: function(){
		// summary:
		//		Put focus on this widget
		if(!this.disabled && this.focusNode.focus){
			try{ this.focusNode.focus(); }catch(e){}/*squelch errors from hidden nodes*/
		}
	},

	compare: function(/*anything*/ val1, /*anything*/ val2){
		// summary:
		//		Compare 2 values (as returned by get('value') for this widget).
		// tags:
		//		protected
		if(typeof val1 == "number" && typeof val2 == "number"){
			return (isNaN(val1) && isNaN(val2)) ? 0 : val1 - val2;
		}else if(val1 > val2){
			return 1;
		}else if(val1 < val2){
			return -1;
		}else{
			return 0;
		}
	},

	onChange: function(/*===== newValue =====*/){
		// summary:
		//		Callback when this widget's value is changed.
		// tags:
		//		callback
	},

	// _onChangeActive: [private] Boolean
	//		Indicates that changes to the value should call onChange() callback.
	//		This is false during widget initialization, to avoid calling onChange()
	//		when the initial value is set.
	_onChangeActive: false,

	_handleOnChange: function(/*anything*/ newValue, /*Boolean?*/ priorityChange){
		// summary:
		//		Called when the value of the widget is set.  Calls onChange() if appropriate
		// newValue:
		//		the new value
		// priorityChange:
		//		For a slider, for example, dragging the slider is priorityChange==false,
		//		but on mouse up, it's priorityChange==true.  If intermediateChanges==false,
		//		onChange is only called form priorityChange=true events.
		// tags:
		//		private
		if(this._lastValueReported == undefined && (priorityChange === null || !this._onChangeActive)){
			// this block executes not for a change, but during initialization,
			// and is used to store away the original value (or for ToggleButton, the original checked state)
			this._resetValue = this._lastValueReported = newValue;
		}
		this._pendingOnChange = this._pendingOnChange
			|| (typeof newValue != typeof this._lastValueReported)
			|| (this.compare(newValue, this._lastValueReported) != 0);
		if((this.intermediateChanges || priorityChange || priorityChange === undefined) && this._pendingOnChange){
			this._lastValueReported = newValue;
			this._pendingOnChange = false;
			if(this._onChangeActive){
				if(this._onChangeHandle){
					clearTimeout(this._onChangeHandle);
				}
				// setTimeout allows hidden value processing to run and
				// also the onChange handler can safely adjust focus, etc
				this._onChangeHandle = setTimeout(lang.hitch(this,
					function(){
						this._onChangeHandle = null;
						this.onChange(newValue);
					}), 0); // try to collapse multiple onChange's fired faster than can be processed
			}
		}
	},

	create: function(){
		// Overrides _Widget.create()
		this.inherited(arguments);
		this._onChangeActive = true;
	},

	destroy: function(){
		if(this._onChangeHandle){ // destroy called before last onChange has fired
			clearTimeout(this._onChangeHandle);
			this.onChange(this._lastValueReported);
		}
		this.inherited(arguments);
	},

	_onMouseDown: function(e){
		// If user clicks on the button, even if the mouse is released outside of it,
		// this button should get focus (to mimics native browser buttons).
		// This is also needed on chrome because otherwise buttons won't get focus at all,
		// which leads to bizarre focus restore on Dialog close etc.
		// IE exhibits strange scrolling behavior when focusing a node so only do it when !focused.
		// FF needs the extra help to make sure the mousedown actually gets to the focusNode
		if((!this.focused || !has("ie")) && !e.ctrlKey && mouse.isLeft(e) && this.isFocusable()){ // !e.ctrlKey to ignore right-click on mac
			// Set a global event to handle mouseup, so it fires properly
			// even if the cursor leaves this.domNode before the mouse up event.
			var mouseUpConnector = this.connect(win.body(), "onmouseup", function(){
				if(this.isFocusable()){
					this.focus();
				}
				this.disconnect(mouseUpConnector);
			});
		}
	}
});

});

},
'url:dijit/templates/ProgressBar.html':"<div class=\"dijitProgressBar dijitProgressBarEmpty\" role=\"progressbar\"\n\t><div  data-dojo-attach-point=\"internalProgress\" class=\"dijitProgressBarFull\"\n\t\t><div class=\"dijitProgressBarTile\" role=\"presentation\"></div\n\t\t><span style=\"visibility:hidden\">&#160;</span\n\t></div\n\t><div data-dojo-attach-point=\"labelNode\" class=\"dijitProgressBarLabel\" id=\"${id}_label\"></div\n\t><img data-dojo-attach-point=\"indeterminateHighContrastImage\" class=\"dijitProgressBarIndeterminateHighContrastImage\" alt=\"\"\n/></div>\n",
'ibm/tivoli/simplesrm/srm/dojo/data/Comparator':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.Comparator");


ibm.tivoli.simplesrm.srm.dojo.data.Comparator.intCompare = function(a, b)
{
	if(a && b) {
		var a_int = parseInt(a);
		var b_int = parseInt(b);
		return a_int > b_int ? 1 : a_int < b_int ? -1 : 0;
	}
	return 0;
};

ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare = function(a, b)
{
	if(a && b) {
		return -a.localeCompare(b);
	}
	return 0;
};
});

},
'com/ibm/ism/pmsc/dojo/srmPageInit':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/tpae/dojo/data/tpaeQuery"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

/**
 * This class performs any Self Service App Dojo initialization.
 * It is used in the srmpageinit control and should be the first control in the page.
 * 
 */
dojo.provide("com.ibm.ism.pmsc.dojo.srmPageInit");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.tpae.dojo.data.tpaeQuery");

/**
 *  
 */

com.ibm.ism.pmsc.dojo._SC_installed = true;    //Is SC installed

dojo.declare("com.ibm.ism.pmsc.dojo.srmPageInit", null, 
{	 
	token: '',  //not used in 7.5
	userid: '',
	runInMaximo: true,
		
	constructor: function(userid, runInMaximo, langcode) {
	    console.log("srmPageInit - constructor - entry");	
	    console.log("srmPageInit - user = " + userid + " langcode = " + langcode);	
	    //this.token = token;  //not used in 7.5
	    
		userid = userid.replace("%5c", "\\");
		this.userid = userid;
		
		if (runInMaximo!=null)
		   this.runInMaximo = (runInMaximo == "true" || runInMaximo == "1");		

      if (langcode!=null) 
		   ibm.tivoli.tpae.dojo.data._langcode=langcode;		
		
		//Set whether we use the separate servlet for config.properties				
		ibm.tivoli.tpae.dojo.data._runInMaximo=this.runInMaximo;		
		
	    //prime config.properties		
		ibm.tivoli.tpae.dojo.data.getConfigProperty("RequestsCatalog");
		
		var srmquery = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery();	
		//var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMaxPropValue();
	
		//Set auth token	
		//if (this.token!=null && this.token!='') {			   		
		//	   srmquery.setToken(this.token, this.userid);			   
		//}
		//} else if ((this.token==null || this.token!='') && this.userid!=null && this.userid!='') {  //fpb			   		
		//}

      srmquery.setToken('', this.userid);			     //token not used in 7.5 - we use the maximo context root
		
		//Add simplesrm class to body
		//dojo.addClass(dojo.body(), "simplesrm");
		dojo.addClass(dojo.body(), "srm");
		
      //REST logout to clear any existing REST session
		//srmquery.logout();  //fpb 
		
		//Is SC installed?	
		var deferred = srmquery.getMaxVarValue("DBPMSC_PMP");		
		deferred.addCallback(function(response){
			var maxvars = response.MAXVARSMboSet.MAXVARS;  
			if (maxvars==undefined || maxvars.length==0) { //No SC 
				this.com.ibm.ism.pmsc.dojo._SC_installed = false;
			} else {
				var value = maxvars[0].Attributes.VARVALUE;
				if (value==null || value=="")  //No SC
					this.com.ibm.ism.pmsc.dojo._SC_installed = false;
			}					 
			
		    //get domains
		    var domains = ["ITEMSTATUS", "SRSTATUS", "TKCLASS", "TEMPLATESTATUS", "PMSCCRSTATUS", "SOLUTIONSTATUS"];
			srmquery.getDomainSynonymTable(domains);
		});
		deferred.addErrback( function(){
			console.error("Failed retrieving MAXVARS - DBPMSC_PMP");
			ibm.tivoli.logger.error("Failed retrieving MAXVARS - DBPMSC_PMP");
		});		
		
		//dojo.global.funcname = myfuncname;
		
		console.log("srmPageInit - constructor - exit");
	}
}
);

//Replace maximo version of funcname in library.js which cause an exception in IE
function myfuncname(f) {
 	// var s = f.toString().match(/function (\w*)/)[1];
	var s = f.toString().match(/function (\w*)/);
    if ((s == null) || (s.length == 0)) {
        return "anonymous";
    }    
    
    s = s[1];
    var args = f.arguments;
    if(args.length > 0)
    {
        s += "(";
        for(var i = 0; i < args.length; i ++ )
        {
            if(i > 0)
	            s += ",";
            s += "'"+args[i]+"'";
        }
        s += ")";
    }
    if ((s == null) || (s.length == 0))
    {
        return "anonymous";
    }
    return "&nbsp;&nbsp;" + s;
}
	
	 
	 

	 
	
	 
	 

 

});

},
'dojox/grid/cells':function(){
define("dojox/grid/cells", ["../main", "./cells/_base"], function(dojox){
	return dojox.grid.cells;
});
},
'dojo/date':function(){
define("dojo/date", ["./_base/kernel", "./_base/lang"], function(dojo, lang) {
	// module:
	//		dojo/date
	// summary:
	//		TODOC

lang.getObject("date", true, dojo);

/*=====
dojo.date = {
	// summary: Date manipulation utilities
}
=====*/

dojo.date.getDaysInMonth = function(/*Date*/dateObject){
	//	summary:
	//		Returns the number of days in the month used by dateObject
	var month = dateObject.getMonth();
	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
	if(month == 1 && dojo.date.isLeapYear(dateObject)){ return 29; } // Number
	return days[month]; // Number
};

dojo.date.isLeapYear = function(/*Date*/dateObject){
	//	summary:
	//		Determines if the year of the dateObject is a leap year
	//	description:
	//		Leap years are years with an additional day YYYY-02-29, where the
	//		year number is a multiple of four with the following exception: If
	//		a year is a multiple of 100, then it is only a leap year if it is
	//		also a multiple of 400. For example, 1900 was not a leap year, but
	//		2000 is one.

	var year = dateObject.getFullYear();
	return !(year%400) || (!(year%4) && !!(year%100)); // Boolean
};

// FIXME: This is not localized
dojo.date.getTimezoneName = function(/*Date*/dateObject){
	//	summary:
	//		Get the user's time zone as provided by the browser
	// dateObject:
	//		Needed because the timezone may vary with time (daylight savings)
	//	description:
	//		Try to get time zone info from toString or toLocaleString method of
	//		the Date object -- UTC offset is not a time zone.  See
	//		http://www.twinsun.com/tz/tz-link.htm Note: results may be
	//		inconsistent across browsers.

	var str = dateObject.toString(); // Start looking in toString
	var tz = ''; // The result -- return empty string if nothing found
	var match;

	// First look for something in parentheses -- fast lookup, no regex
	var pos = str.indexOf('(');
	if(pos > -1){
		tz = str.substring(++pos, str.indexOf(')'));
	}else{
		// If at first you don't succeed ...
		// If IE knows about the TZ, it appears before the year
		// Capital letters or slash before a 4-digit year
		// at the end of string
		var pat = /([A-Z\/]+) \d{4}$/;
		if((match = str.match(pat))){
			tz = match[1];
		}else{
		// Some browsers (e.g. Safari) glue the TZ on the end
		// of toLocaleString instead of putting it in toString
			str = dateObject.toLocaleString();
			// Capital letters or slash -- end of string,
			// after space
			pat = / ([A-Z\/]+)$/;
			if((match = str.match(pat))){
				tz = match[1];
			}
		}
	}

	// Make sure it doesn't somehow end up return AM or PM
	return (tz == 'AM' || tz == 'PM') ? '' : tz; // String
};

// Utility methods to do arithmetic calculations with Dates

dojo.date.compare = function(/*Date*/date1, /*Date?*/date2, /*String?*/portion){
	//	summary:
	//		Compare two date objects by date, time, or both.
	//	description:
	//  	Returns 0 if equal, positive if a > b, else negative.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	portion:
	//		A string indicating the "date" or "time" portion of a Date object.
	//		Compares both "date" and "time" by default.  One of the following:
	//		"date", "time", "datetime"

	// Extra step required in copy for IE - see #3112
	date1 = new Date(+date1);
	date2 = new Date(+(date2 || new Date()));

	if(portion == "date"){
		// Ignore times and compare dates.
		date1.setHours(0, 0, 0, 0);
		date2.setHours(0, 0, 0, 0);
	}else if(portion == "time"){
		// Ignore dates and compare times.
		date1.setFullYear(0, 0, 0);
		date2.setFullYear(0, 0, 0);
	}

	if(date1 > date2){ return 1; } // int
	if(date1 < date2){ return -1; } // int
	return 0; // int
};

dojo.date.add = function(/*Date*/date, /*String*/interval, /*int*/amount){
	//	summary:
	//		Add to a Date in intervals of different size, from milliseconds to years
	//	date: Date
	//		Date object to start with
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//	amount:
	//		How much to add to the date.

	var sum = new Date(+date); // convert to Number before copying to accomodate IE (#3112)
	var fixOvershoot = false;
	var property = "Date";

	switch(interval){
		case "day":
			break;
		case "weekday":
			//i18n FIXME: assumes Saturday/Sunday weekend, but this is not always true.  see dojo.cldr.supplemental

			// Divide the increment time span into weekspans plus leftover days
			// e.g., 8 days is one 5-day weekspan / and two leftover days
			// Can't have zero leftover days, so numbers divisible by 5 get
			// a days value of 5, and the remaining days make up the number of weeks
			var days, weeks;
			var mod = amount % 5;
			if(!mod){
				days = (amount > 0) ? 5 : -5;
				weeks = (amount > 0) ? ((amount-5)/5) : ((amount+5)/5);
			}else{
				days = mod;
				weeks = parseInt(amount/5);
			}
			// Get weekday value for orig date param
			var strt = date.getDay();
			// Orig date is Sat / positive incrementer
			// Jump over Sun
			var adj = 0;
			if(strt == 6 && amount > 0){
				adj = 1;
			}else if(strt == 0 && amount < 0){
			// Orig date is Sun / negative incrementer
			// Jump back over Sat
				adj = -1;
			}
			// Get weekday val for the new date
			var trgt = strt + days;
			// New date is on Sat or Sun
			if(trgt == 0 || trgt == 6){
				adj = (amount > 0) ? 2 : -2;
			}
			// Increment by number of weeks plus leftover days plus
			// weekend adjustments
			amount = (7 * weeks) + days + adj;
			break;
		case "year":
			property = "FullYear";
			// Keep increment/decrement from 2/29 out of March
			fixOvershoot = true;
			break;
		case "week":
			amount *= 7;
			break;
		case "quarter":
			// Naive quarter is just three months
			amount *= 3;
			// fallthrough...
		case "month":
			// Reset to last day of month if you overshoot
			fixOvershoot = true;
			property = "Month";
			break;
//		case "hour":
//		case "minute":
//		case "second":
//		case "millisecond":
		default:
			property = "UTC"+interval.charAt(0).toUpperCase() + interval.substring(1) + "s";
	}

	if(property){
		sum["set"+property](sum["get"+property]()+amount);
	}

	if(fixOvershoot && (sum.getDate() < date.getDate())){
		sum.setDate(0);
	}

	return sum; // Date
};

dojo.date.difference = function(/*Date*/date1, /*Date?*/date2, /*String?*/interval){
	//	summary:
	//		Get the difference in a specific unit of time (e.g., number of
	//		months, weeks, days, etc.) between two dates, rounded to the
	//		nearest integer.
	//	date1:
	//		Date object
	//	date2:
	//		Date object.  If not specified, the current Date is used.
	//	interval:
	//		A string representing the interval.  One of the following:
	//			"year", "month", "day", "hour", "minute", "second",
	//			"millisecond", "quarter", "week", "weekday"
	//		Defaults to "day".

	date2 = date2 || new Date();
	interval = interval || "day";
	var yearDiff = date2.getFullYear() - date1.getFullYear();
	var delta = 1; // Integer return value

	switch(interval){
		case "quarter":
			var m1 = date1.getMonth();
			var m2 = date2.getMonth();
			// Figure out which quarter the months are in
			var q1 = Math.floor(m1/3) + 1;
			var q2 = Math.floor(m2/3) + 1;
			// Add quarters for any year difference between the dates
			q2 += (yearDiff * 4);
			delta = q2 - q1;
			break;
		case "weekday":
			var days = Math.round(dojo.date.difference(date1, date2, "day"));
			var weeks = parseInt(dojo.date.difference(date1, date2, "week"));
			var mod = days % 7;

			// Even number of weeks
			if(mod == 0){
				days = weeks*5;
			}else{
				// Weeks plus spare change (< 7 days)
				var adj = 0;
				var aDay = date1.getDay();
				var bDay = date2.getDay();

				weeks = parseInt(days/7);
				mod = days % 7;
				// Mark the date advanced by the number of
				// round weeks (may be zero)
				var dtMark = new Date(date1);
				dtMark.setDate(dtMark.getDate()+(weeks*7));
				var dayMark = dtMark.getDay();

				// Spare change days -- 6 or less
				if(days > 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = -1;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 0;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = -1;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = -2;
							break;
						// Range contains weekend
						case (dayMark + mod) > 5:
							adj = -2;
					}
				}else if(days < 0){
					switch(true){
						// Range starts on Sat
						case aDay == 6:
							adj = 0;
							break;
						// Range starts on Sun
						case aDay == 0:
							adj = 1;
							break;
						// Range ends on Sat
						case bDay == 6:
							adj = 2;
							break;
						// Range ends on Sun
						case bDay == 0:
							adj = 1;
							break;
						// Range contains weekend
						case (dayMark + mod) < 0:
							adj = 2;
					}
				}
				days += adj;
				days -= (weeks*2);
			}
			delta = days;
			break;
		case "year":
			delta = yearDiff;
			break;
		case "month":
			delta = (date2.getMonth() - date1.getMonth()) + (yearDiff * 12);
			break;
		case "week":
			// Truncate instead of rounding
			// Don't use Math.floor -- value may be negative
			delta = parseInt(dojo.date.difference(date1, date2, "day")/7);
			break;
		case "day":
			delta /= 24;
			// fallthrough
		case "hour":
			delta /= 60;
			// fallthrough
		case "minute":
			delta /= 60;
			// fallthrough
		case "second":
			delta /= 1000;
			// fallthrough
		case "millisecond":
			delta *= date2.getTime() - date1.getTime();
	}

	// Round for fractional values and DST leaps
	return Math.round(delta); // Number (integer)
};

return dojo.date;
});

},
'dojox/grid/_Layout':function(){
define("dojox/grid/_Layout", [
	"dojo/_base/kernel",
	"../main",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/dom-geometry",
	"./cells",
	"./_RowSelector"
], function(dojo, dojox, declare, array, lang, domGeometry){

return declare("dojox.grid._Layout", null, {
	// summary:
	//	Controls grid cell layout. Owned by grid and used internally.
	constructor: function(inGrid){
		this.grid = inGrid;
	},
	// flat array of grid cells
	cells: [],
	// structured array of grid cells
	structure: null,
	// default cell width
	defaultWidth: '6em',

	// methods
	moveColumn: function(sourceViewIndex, destViewIndex, cellIndex, targetIndex, before){
		var source_cells = this.structure[sourceViewIndex].cells[0];
		var dest_cells = this.structure[destViewIndex].cells[0];

		var cell = null;
		var cell_ri = 0;
		var target_ri = 0;

		for(var i=0, c; c=source_cells[i]; i++){
			if(c.index == cellIndex){
				cell_ri = i;
				break;
			}
		}
		cell = source_cells.splice(cell_ri, 1)[0];
		cell.view = this.grid.views.views[destViewIndex];

		for(i=0, c=null; c=dest_cells[i]; i++){
			if(c.index == targetIndex){
				target_ri = i;
				break;
			}
		}
		if(!before){
			target_ri += 1;
		}
		dest_cells.splice(target_ri, 0, cell);

		var sortedCell = this.grid.getCell(this.grid.getSortIndex());
		if(sortedCell){
			sortedCell._currentlySorted = this.grid.getSortAsc();
		}

		this.cells = [];
		cellIndex = 0;
		var v;
		for(i=0; v=this.structure[i]; i++){
			for(var j=0, cs; cs=v.cells[j]; j++){
				for(var k=0; c=cs[k]; k++){
					c.index = cellIndex;
					this.cells.push(c);
					if("_currentlySorted" in c){
						var si = cellIndex + 1;
						si *= c._currentlySorted ? 1 : -1;
						this.grid.sortInfo = si;
						delete c._currentlySorted;
					}
					cellIndex++;
				}
			}
		}
		
		//Fix #9481 - reset idx in cell markup
		array.forEach(this.cells, function(c){
			var marks = c.markup[2].split(" ");
			var oldIdx = parseInt(marks[1].substring(5));//get old "idx"
			if(oldIdx != c.index){
				marks[1] = "idx=\"" + c.index + "\"";
				c.markup[2] = marks.join(" ");
			}
		});
		
		this.grid.setupHeaderMenu();
		//this.grid.renderOnIdle();
	},

	setColumnVisibility: function(columnIndex, visible){
		var cell = this.cells[columnIndex];
		if(cell.hidden == visible){
			cell.hidden = !visible;
			var v = cell.view, w = v.viewWidth;
			if(w && w != "auto"){
				v._togglingColumn = domGeometry.getMarginBox(cell.getHeaderNode()).w || 0;
			}
			v.update();
			return true;
		}else{
			return false;
		}
	},
	
	addCellDef: function(inRowIndex, inCellIndex, inDef){
		var self = this;
		var getCellWidth = function(inDef){
			var w = 0;
			if(inDef.colSpan > 1){
				w = 0;
			}else{
				w = inDef.width || self._defaultCellProps.width || self.defaultWidth;

				if(!isNaN(w)){
					w = w + "em";
				}
			}
			return w;
		};

		var props = {
			grid: this.grid,
			subrow: inRowIndex,
			layoutIndex: inCellIndex,
			index: this.cells.length
		};

		if(inDef && inDef instanceof dojox.grid.cells._Base){
			var new_cell = lang.clone(inDef);
			props.unitWidth = getCellWidth(new_cell._props);
			new_cell = lang.mixin(new_cell, this._defaultCellProps, inDef._props, props);
			return new_cell;
		}

		var cell_type = inDef.type || inDef.cellType || this._defaultCellProps.type || this._defaultCellProps.cellType || dojox.grid.cells.Cell;
		if(lang.isString(cell_type)){
			cell_type = lang.getObject(cell_type);
		}

		props.unitWidth = getCellWidth(inDef);
		return new cell_type(lang.mixin({}, this._defaultCellProps, inDef, props));
	},
	
	addRowDef: function(inRowIndex, inDef){
		var result = [];
		var relSum = 0, pctSum = 0, doRel = true;
		for(var i=0, def, cell; (def=inDef[i]); i++){
			cell = this.addCellDef(inRowIndex, i, def);
			result.push(cell);
			this.cells.push(cell);
			// Check and calculate the sum of all relative widths
			if(doRel && cell.relWidth){
				relSum += cell.relWidth;
			}else if(cell.width){
				var w = cell.width;
				if(typeof w == "string" && w.slice(-1) == "%"){
					pctSum += window.parseInt(w, 10);
				}else if(w == "auto"){
					// relative widths doesn't play nice with auto - since we
					// don't have a way of knowing how much space the auto is
					// supposed to take up.
					doRel = false;
				}
			}
		}
		if(relSum && doRel){
			// We have some kind of relWidths specified - so change them to %
			array.forEach(result, function(cell){
				if(cell.relWidth){
					cell.width = cell.unitWidth = ((cell.relWidth / relSum) * (100 - pctSum)) + "%";
				}
			});
		}
		return result;
	
	},

	addRowsDef: function(inDef){
		var result = [];
		if(lang.isArray(inDef)){
			if(lang.isArray(inDef[0])){
				for(var i=0, row; inDef && (row=inDef[i]); i++){
					result.push(this.addRowDef(i, row));
				}
			}else{
				result.push(this.addRowDef(0, inDef));
			}
		}
		return result;
	},
	
	addViewDef: function(inDef){
		this._defaultCellProps = inDef.defaultCell || {};
		if(inDef.width && inDef.width == "auto"){
			delete inDef.width;
		}
		return lang.mixin({}, inDef, {cells: this.addRowsDef(inDef.rows || inDef.cells)});
	},
	
	setStructure: function(inStructure){
		this.fieldIndex = 0;
		this.cells = [];
		var s = this.structure = [];

		if(this.grid.rowSelector){
			var sel = { type: dojox._scopeName + ".grid._RowSelector" };

			if(lang.isString(this.grid.rowSelector)){
				var width = this.grid.rowSelector;

				if(width == "false"){
					sel = null;
				}else if(width != "true"){
					sel['width'] = width;
				}
			}else{
				if(!this.grid.rowSelector){
					sel = null;
				}
			}

			if(sel){
				s.push(this.addViewDef(sel));
			}
		}

		var isCell = function(def){
			return ("name" in def || "field" in def || "get" in def);
		};

		var isRowDef = function(def){
			if(lang.isArray(def)){
				if(lang.isArray(def[0]) || isCell(def[0])){
					return true;
				}
			}
			return false;
		};

		var isView = function(def){
			return (def !== null && lang.isObject(def) &&
					("cells" in def || "rows" in def || ("type" in def && !isCell(def))));
		};

		if(lang.isArray(inStructure)){
			var hasViews = false;
			for(var i=0, st; (st=inStructure[i]); i++){
				if(isView(st)){
					hasViews = true;
					break;
				}
			}
			if(!hasViews){
				s.push(this.addViewDef({ cells: inStructure }));
			}else{
				for(i=0; (st=inStructure[i]); i++){
					if(isRowDef(st)){
						s.push(this.addViewDef({ cells: st }));
					}else if(isView(st)){
						s.push(this.addViewDef(st));
					}
				}
			}
		}else if(isView(inStructure)){
			// it's a view object
			s.push(this.addViewDef(inStructure));
		}

		this.cellCount = this.cells.length;
		this.grid.setupHeaderMenu();
	}
});
});
},
'dijit/layout/_ContentPaneResizeMixin':function(){
define("dijit/layout/_ContentPaneResizeMixin", [
	"dojo/_base/array", // array.filter array.forEach
	"dojo/_base/declare", // declare
	"dojo/dom-attr",	// domAttr.has
	"dojo/dom-class",	// domClass.contains domClass.toggle
	"dojo/dom-geometry",// domGeometry.contentBox domGeometry.marginBox
	"dojo/_base/lang", // lang.mixin
	"dojo/query", // query
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/window", // win.global
	"../registry",	// registry.byId
	"./utils",	// marginBox2contextBox
	"../_Contained"
], function(array, declare, domAttr, domClass, domGeometry, lang, query, has, win,
			registry, layoutUtils, _Contained){

/*=====
var _Contained = dijit._Contained;
=====*/

// module:
//		dijit/layout/_ContentPaneResizeMixin
// summary:
//		Resize() functionality of ContentPane.   If there's a single layout widget
//		child then it will call resize() with the same dimensions as the ContentPane.
//		Otherwise just calls resize on each child.


return declare("dijit.layout._ContentPaneResizeMixin", null, {
	// summary:
	//		Resize() functionality of ContentPane.   If there's a single layout widget
	//		child then it will call resize() with the same dimensions as the ContentPane.
	//		Otherwise just calls resize on each child.
	//
	//		Also implements basic startup() functionality, where starting the parent
	//		will start the children

	// doLayout: Boolean
	//		- false - don't adjust size of children
	//		- true - if there is a single visible child widget, set it's size to
	//				however big the ContentPane is
	doLayout: true,

	// isLayoutContainer: [protected] Boolean
	//		Indicates that this widget will call resize() on it's child widgets
	//		when they become visible.
	isLayoutContainer: true,

	startup: function(){
		// summary:
		//		See `dijit.layout._LayoutWidget.startup` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		if(this._started){ return; }

		var parent = this.getParent();
		this._childOfLayoutWidget = parent && parent.isLayoutContainer;

		// I need to call resize() on my child/children (when I become visible), unless
		// I'm the child of a layout widget in which case my parent will call resize() on me and I'll do it then.
		this._needLayout = !this._childOfLayoutWidget;

		this.inherited(arguments);

		if(this._isShown()){
			this._onShow();
		}

		if(!this._childOfLayoutWidget){
			// If my parent isn't a layout container, since my style *may be* width=height=100%
			// or something similar (either set directly or via a CSS class),
			// monitor when my size changes so that I can re-layout.
			// For browsers where I can't directly monitor when my size changes,
			// monitor when the viewport changes size, which *may* indicate a size change for me.
			this.connect(has("ie") ? this.domNode : win.global, 'onresize', function(){
				// Using function(){} closure to ensure no arguments to resize.
				this._needLayout = !this._childOfLayoutWidget;
				this.resize();
			});
		}
	},

	_checkIfSingleChild: function(){
		// summary:
		//		Test if we have exactly one visible widget as a child,
		//		and if so assume that we are a container for that widget,
		//		and should propagate startup() and resize() calls to it.
		//		Skips over things like data stores since they aren't visible.

		var childNodes = query("> *", this.containerNode).filter(function(node){
				return node.tagName !== "SCRIPT"; // or a regexp for hidden elements like script|area|map|etc..
			}),
			childWidgetNodes = childNodes.filter(function(node){
				return domAttr.has(node, "data-dojo-type") || domAttr.has(node, "dojoType") || domAttr.has(node, "widgetId");
			}),
			candidateWidgets = array.filter(childWidgetNodes.map(registry.byNode), function(widget){
				return widget && widget.domNode && widget.resize;
			});

		if(
			// all child nodes are widgets
			childNodes.length == childWidgetNodes.length &&

			// all but one are invisible (like dojo.data)
			candidateWidgets.length == 1
		){
			this._singleChild = candidateWidgets[0];
		}else{
			delete this._singleChild;
		}

		// So we can set overflow: hidden to avoid a safari bug w/scrollbars showing up (#9449)
		domClass.toggle(this.containerNode, this.baseClass + "SingleChild", !!this._singleChild);
	},

	resize: function(changeSize, resultSize){
		// summary:
		//		See `dijit.layout._LayoutWidget.resize` for description.
		//		Although ContentPane doesn't extend _LayoutWidget, it does implement
		//		the same API.

		// For the TabContainer --> BorderContainer --> ContentPane case, _onShow() is
		// never called, so resize() is our trigger to do the initial href download (see [20099]).
		// However, don't load href for closed TitlePanes.
		if(!this._wasShown && this.open !== false){
			this._onShow();
		}

		this._resizeCalled = true;

		this._scheduleLayout(changeSize, resultSize);
	},

	_scheduleLayout: function(changeSize, resultSize){
		// summary:
		//		Resize myself, and call resize() on each of my child layout widgets, either now
		//		(if I'm currently visible) or when I become visible
		if(this._isShown()){
			this._layout(changeSize, resultSize);
		}else{
			this._needLayout = true;
			this._changeSize = changeSize;
			this._resultSize = resultSize;
		}
	},

	_layout: function(changeSize, resultSize){
		// summary:
		//		Resize myself according to optional changeSize/resultSize parameters, like a layout widget.
		//		Also, since I am a Container widget, each of my children expects me to
		//		call resize() or layout() on them.
		//
		//		Should be called on initialization and also whenever we get new content
		//		(from an href, or from set('content', ...))... but deferred until
		//		the ContentPane is visible

		// Set margin box size, unless it wasn't specified, in which case use current size.
		if(changeSize){
			domGeometry.setMarginBox(this.domNode, changeSize);
		}

		// Compute content box size of containerNode in case we [later] need to size our single child.
		var cn = this.containerNode;
		if(cn === this.domNode){
			// If changeSize or resultSize was passed to this method and this.containerNode ==
			// this.domNode then we can compute the content-box size without querying the node,
			// which is more reliable (similar to LayoutWidget.resize) (see for example #9449).
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {}); // changeSize overrides resultSize
			if(!("h" in mb) || !("w" in mb)){
				mb = lang.mixin(domGeometry.getMarginBox(cn), mb); // just use domGeometry.setMarginBox() to fill in missing values
			}
			this._contentBox = layoutUtils.marginBox2contentBox(cn, mb);
		}else{
			this._contentBox = domGeometry.getContentBox(cn);
		}

		this._layoutChildren();

		delete this._needLayout;
	},

	_layoutChildren: function(){
		// Call _checkIfSingleChild() again in case app has manually mucked w/the content
		// of the ContentPane (rather than changing it through the set("content", ...) API.
		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(this._singleChild && this._singleChild.resize){
			var cb = this._contentBox || domGeometry.getContentBox(this.containerNode);

			// note: if widget has padding this._contentBox will have l and t set,
			// but don't pass them to resize() or it will doubly-offset the child
			this._singleChild.resize({w: cb.w, h: cb.h});
		}else{
			// All my child widgets are independently sized (rather than matching my size),
			// but I still need to call resize() on each child to make it layout.
			array.forEach(this.getChildren(), function(widget){
				if(widget.resize){
					widget.resize();
				}
			});
		}
	},

	_isShown: function(){
		// summary:
		//		Returns true if the content is currently shown.
		// description:
		//		If I am a child of a layout widget then it actually returns true if I've ever been visible,
		//		not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
		//		tree every call, and at least solves the performance problem on page load by deferring loading
		//		hidden ContentPanes until they are first shown

		if(this._childOfLayoutWidget){
			// If we are TitlePane, etc - we return that only *IF* we've been resized
			if(this._resizeCalled && "open" in this){
				return this.open;
			}
			return this._resizeCalled;
		}else if("open" in this){
			return this.open;		// for TitlePane, etc.
		}else{
			var node = this.domNode, parent = this.domNode.parentNode;
			return (node.style.display != 'none') && (node.style.visibility != 'hidden') && !domClass.contains(node, "dijitHidden") &&
					parent && parent.style && (parent.style.display != 'none');
		}
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does layout/resize of child widget(s)

		if(this._needLayout){
			// If a layout has been scheduled for when we become visible, do it now
			this._layout(this._changeSize, this._resultSize);
		}

		this.inherited(arguments);

		// Need to keep track of whether ContentPane has been shown (which is different than
		// whether or not it's currently visible).
		this._wasShown = true;
	}
});

});

},
'dijit/WidgetSet':function(){
define("dijit/WidgetSet", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/declare", // declare
	"dojo/_base/window", // win.global
	"./registry"	// to add functions to dijit.registry
], function(array, declare, win, registry){

	// module:
	//		dijit/WidgetSet
	// summary:
	//		Legacy registry code.   New modules should just use registry.
	//		Will be removed in 2.0.

	var WidgetSet = declare("dijit.WidgetSet", null, {
		// summary:
		//		A set of widgets indexed by id. A default instance of this class is
		//		available as `dijit.registry`
		//
		// example:
		//		Create a small list of widgets:
		//		|	var ws = new dijit.WidgetSet();
		//		|	ws.add(dijit.byId("one"));
		//		| 	ws.add(dijit.byId("two"));
		//		|	// destroy both:
		//		|	ws.forEach(function(w){ w.destroy(); });
		//
		// example:
		//		Using dijit.registry:
		//		|	dijit.registry.forEach(function(w){ /* do something */ });

		constructor: function(){
			this._hash = {};
			this.length = 0;
		},

		add: function(/*dijit._Widget*/ widget){
			// summary:
			//		Add a widget to this list. If a duplicate ID is detected, a error is thrown.
			//
			// widget: dijit._Widget
			//		Any dijit._Widget subclass.
			if(this._hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			this._hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from this WidgetSet. Does not destroy the widget; simply
			//		removes the reference.
			if(this._hash[id]){
				delete this._hash[id];
				this.length--;
			}
		},

		forEach: function(/*Function*/ func, /* Object? */thisObj){
			// summary:
			//		Call specified function for each widget in this set.
			//
			// func:
			//		A callback function to run for each item. Is passed the widget, the index
			//		in the iteration, and the full hash, similar to `array.forEach`.
			//
			// thisObj:
			//		An optional scope parameter
			//
			// example:
			//		Using the default `dijit.registry` instance:
			//		|	dijit.registry.forEach(function(widget){
			//		|		console.log(widget.declaredClass);
			//		|	});
			//
			// returns:
			//		Returns self, in order to allow for further chaining.

			thisObj = thisObj || win.global;
			var i = 0, id;
			for(id in this._hash){
				func.call(thisObj, this._hash[id], i++, this._hash);
			}
			return this;	// dijit.WidgetSet
		},

		filter: function(/*Function*/ filter, /* Object? */thisObj){
			// summary:
			//		Filter down this WidgetSet to a smaller new WidgetSet
			//		Works the same as `array.filter` and `NodeList.filter`
			//
			// filter:
			//		Callback function to test truthiness. Is passed the widget
			//		reference and the pseudo-index in the object.
			//
			// thisObj: Object?
			//		Option scope to use for the filter function.
			//
			// example:
			//		Arbitrary: select the odd widgets in this list
			//		|	dijit.registry.filter(function(w, i){
			//		|		return i % 2 == 0;
			//		|	}).forEach(function(w){ /* odd ones */ });

			thisObj = thisObj || win.global;
			var res = new WidgetSet(), i = 0, id;
			for(id in this._hash){
				var w = this._hash[id];
				if(filter.call(thisObj, w, i++, this._hash)){
					res.add(w);
				}
			}
			return res; // dijit.WidgetSet
		},

		byId: function(/*String*/ id){
			// summary:
			//		Find a widget in this list by it's id.
			// example:
			//		Test if an id is in a particular WidgetSet
			//		| var ws = new dijit.WidgetSet();
			//		| ws.add(dijit.byId("bar"));
			//		| var t = ws.byId("bar") // returns a widget
			//		| var x = ws.byId("foo"); // returns undefined

			return this._hash[id];	// dijit._Widget
		},

		byClass: function(/*String*/ cls){
			// summary:
			//		Reduce this widgetset to a new WidgetSet of a particular `declaredClass`
			//
			// cls: String
			//		The Class to scan for. Full dot-notated string.
			//
			// example:
			//		Find all `dijit.TitlePane`s in a page:
			//		|	dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });

			var res = new WidgetSet(), id, widget;
			for(id in this._hash){
				widget = this._hash[id];
				if(widget.declaredClass == cls){
					res.add(widget);
				}
			 }
			 return res; // dijit.WidgetSet
		},

		toArray: function(){
			// summary:
			//		Convert this WidgetSet into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(dijit.registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in this._hash){
				ar.push(this._hash[id]);
			}
			return ar;	// dijit._Widget[]
		},

		map: function(/* Function */func, /* Object? */thisObj){
			// summary:
			//		Create a new Array from this WidgetSet, following the same rules as `array.map`
			// example:
			//		|	var nodes = dijit.registry.map(function(w){ return w.domNode; });
			//
			// returns:
			//		A new array of the returned values.
			return array.map(this.toArray(), func, thisObj); // Array
		},

		every: function(func, thisObj){
			// summary:
			// 		A synthetic clone of `array.every` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first false return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || win.global;
			var x = 0, i;
			for(i in this._hash){
				if(!func.call(thisObj, this._hash[i], x++, this._hash)){
					return false; // Boolean
				}
			}
			return true; // Boolean
		},

		some: function(func, thisObj){
			// summary:
			// 		A synthetic clone of `array.some` acting explicitly on this WidgetSet
			//
			// func: Function
			//		A callback function run for every widget in this list. Exits loop
			//		when the first true return is encountered.
			//
			// thisObj: Object?
			//		Optional scope parameter to use for the callback

			thisObj = thisObj || win.global;
			var x = 0, i;
			for(i in this._hash){
				if(func.call(thisObj, this._hash[i], x++, this._hash)){
					return true; // Boolean
				}
			}
			return false; // Boolean
		}

	});

	// Add in 1.x compatibility methods to dijit.registry.
	// These functions won't show up in the API doc but since they are deprecated anyway,
	// that's probably for the best.
	array.forEach(["forEach", "filter", "byClass", "map", "every", "some"], function(func){
		registry[func] = WidgetSet.prototype[func];
	});


	return WidgetSet;
});

},
'dijit/nls/loading':function(){
define({ root:
//begin v1.x content
({
	loadingState: "Loading...",
	errorState: "Sorry, an error occurred"
})
//end v1.x content
,
"zh": true,
"zh-tw": true,
"tr": true,
"th": true,
"sv": true,
"sl": true,
"sk": true,
"ru": true,
"ro": true,
"pt": true,
"pt-pt": true,
"pl": true,
"nl": true,
"nb": true,
"ko": true,
"kk": true,
"ja": true,
"it": true,
"hu": true,
"hr": true,
"he": true,
"fr": true,
"fi": true,
"es": true,
"el": true,
"de": true,
"da": true,
"cs": true,
"ca": true,
"az": true,
"ar": true
});

},
'dojo/dnd/Moveable':function(){
define("dojo/dnd/Moveable", ["../main", "../Evented", "../touch", "./Mover"], function(dojo, Evented, touch) {
	// module:
	//		dojo/dnd/Moveable
	// summary:
	//		TODOC


/*=====
dojo.declare("dojo.dnd.__MoveableArgs", [], {
	// handle: Node||String
	//		A node (or node's id), which is used as a mouse handle.
	//		If omitted, the node itself is used as a handle.
	handle: null,

	// delay: Number
	//		delay move by this number of pixels
	delay: 0,

	// skip: Boolean
	//		skip move of form elements
	skip: false,

	// mover: Object
	//		a constructor of custom Mover
	mover: dojo.dnd.Mover
});
=====*/

dojo.declare("dojo.dnd.Moveable", [Evented], {
	// object attributes (for markup)
	handle: "",
	delay: 0,
	skip: false,

	constructor: function(node, params){
		// summary:
		//		an object, which makes a node moveable
		// node: Node
		//		a node (or node's id) to be moved
		// params: dojo.dnd.__MoveableArgs?
		//		optional parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.handle = params.handle ? dojo.byId(params.handle) : null;
		if(!this.handle){ this.handle = this.node; }
		this.delay = params.delay > 0 ? params.delay : 0;
		this.skip  = params.skip;
		this.mover = params.mover ? params.mover : dojo.dnd.Mover;
		this.events = [
			dojo.connect(this.handle, touch.press, this, "onMouseDown"),
			// cancel text selection and text dragging
			dojo.connect(this.handle, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.handle, "onselectstart", this, "onSelectStart")
		];
	},

	// markup methods
	markupFactory: function(params, node, ctor){
		return new ctor(node, params);
	},

	// methods
	destroy: function(){
		// summary:
		//		stops watching for possible move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.events = this.node = this.handle = null;
	},

	// mouse event processors
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown/ontouchstart, creates a Mover for the node
		// e: Event
		//		mouse/touch event
		if(this.skip && dojo.dnd.isFormElement(e)){ return; }
		if(this.delay){
			this.events.push(
				dojo.connect(this.handle, touch.move, this, "onMouseMove"),
				dojo.connect(this.handle, touch.release, this, "onMouseUp")
			);
			this._lastX = e.pageX;
			this._lastY = e.pageY;
		}else{
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove, used only for delayed drags
		// e: Event
		//		mouse/touch event
		if(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay){
			this.onMouseUp(e);
			this.onDragDetected(e);
		}
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup, used only for delayed drags
		// e: Event
		//		mouse event
		for(var i = 0; i < 2; ++i){
			dojo.disconnect(this.events.pop());
		}
		dojo.stopEvent(e);
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skip || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},

	// local events
	onDragDetected: function(/* Event */ e){
		// summary:
		//		called when the drag is detected;
		//		responsible for creation of the mover
		new this.mover(this.node, e, this);
	},
	onMoveStart: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called before every move operation
		dojo.publish("/dnd/move/start", [mover]);
		dojo.addClass(dojo.body(), "dojoMove");
		dojo.addClass(this.node, "dojoMoveItem");
	},
	onMoveStop: function(/* dojo.dnd.Mover */ mover){
		// summary:
		//		called after every move operation
		dojo.publish("/dnd/move/stop", [mover]);
		dojo.removeClass(dojo.body(), "dojoMove");
		dojo.removeClass(this.node, "dojoMoveItem");
	},
	onFirstMove: function(/* dojo.dnd.Mover */ mover, /* Event */ e){
		// summary:
		//		called during the very first move notification;
		//		can be used to initialize coordinates, can be overwritten.

		// default implementation does nothing
	},
	onMove: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop, /* Event */ e){
		// summary:
		//		called during every move notification;
		//		should actually move the node; can be overwritten.
		this.onMoving(mover, leftTop);
		var s = mover.node.style;
		s.left = leftTop.l + "px";
		s.top  = leftTop.t + "px";
		this.onMoved(mover, leftTop);
	},
	onMoving: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called before every incremental move; can be overwritten.

		// default implementation does nothing
	},
	onMoved: function(/* dojo.dnd.Mover */ mover, /* Object */ leftTop){
		// summary:
		//		called after every incremental move; can be overwritten.

		// default implementation does nothing
	}
});

return dojo.dnd.Moveable;
});

},
'dojo/store/util/SimpleQueryEngine':function(){
define("dojo/store/util/SimpleQueryEngine", ["../../_base/array"], function(arrayUtil) {
  //  module:
  //    dojo/store/util/SimpleQueryEngine
  //  summary:
  //    The module defines a simple filtering query engine for object stores. 

return function(query, options){
	// summary:
	//		Simple query engine that matches using filter functions, named filter
	//		functions or objects by name-value on a query object hash
	//
	// description:
	//		The SimpleQueryEngine provides a way of getting a QueryResults through
	//		the use of a simple object hash as a filter.  The hash will be used to
	//		match properties on data objects with the corresponding value given. In
	//		other words, only exact matches will be returned.
	//
	//		This function can be used as a template for more complex query engines;
	//		for example, an engine can be created that accepts an object hash that
	//		contains filtering functions, or a string that gets evaluated, etc.
	//
	//		When creating a new dojo.store, simply set the store's queryEngine
	//		field as a reference to this function.
	//
	// query: Object
	//		An object hash with fields that may match fields of items in the store.
	//		Values in the hash will be compared by normal == operator, but regular expressions
	//		or any object that provides a test() method are also supported and can be
	// 		used to match strings by more complex expressions
	// 		(and then the regex's or object's test() method will be used to match values).
	//
	// options: dojo.store.util.SimpleQueryEngine.__queryOptions?
	//		An object that contains optional information such as sort, start, and count.
	//
	// returns: Function
	//		A function that caches the passed query under the field "matches".  See any
	//		of the "query" methods on dojo.stores.
	//
	// example:
	//		Define a store with a reference to this engine, and set up a query method.
	//
	//	|	var myStore = function(options){
	//	|		//	...more properties here
	//	|		this.queryEngine = dojo.store.util.SimpleQueryEngine;
	//	|		//	define our query method
	//	|		this.query = function(query, options){
	//	|			return dojo.store.util.QueryResults(this.queryEngine(query, options)(this.data));
	//	|		};
	//	|	};

	// create our matching query function
	switch(typeof query){
		default:
			throw new Error("Can not query with a " + typeof query);
		case "object": case "undefined":
			var queryObject = query;
			query = function(object){
				for(var key in queryObject){
					var required = queryObject[key];
					if(required && required.test){
						if(!required.test(object[key])){
							return false;
						}
					}else if(required != object[key]){
						return false;
					}
				}
				return true;
			};
			break;
		case "string":
			// named query
			if(!this[query]){
				throw new Error("No filter function " + query + " was found in store");
			}
			query = this[query];
			// fall through
		case "function":
			// fall through
	}
	function execute(array){
		// execute the whole query, first we filter
		var results = arrayUtil.filter(array, query);
		// next we sort
		if(options && options.sort){
			results.sort(function(a, b){
				for(var sort, i=0; sort = options.sort[i]; i++){
					var aValue = a[sort.attribute];
					var bValue = b[sort.attribute];
					if (aValue != bValue) {
						return !!sort.descending == aValue > bValue ? -1 : 1;
					}
				}
				return 0;
			});
		}
		// now we paginate
		if(options && (options.start || options.count)){
			var total = results.length;
			results = results.slice(options.start || 0, (options.start || 0) + (options.count || Infinity));
			results.total = total;
		}
		return results;
	}
	execute.matches = query;
	return execute;
};
});

},
'dojo/cldr/nls/number':function(){
define({ root:

//begin v1.x content
{
	"scientificFormat": "#E0",
	"currencySpacing-afterCurrency-currencyMatch": "[:letter:]",
	"infinity": "∞",
	"list": ";",
	"percentSign": "%",
	"minusSign": "-",
	"currencySpacing-beforeCurrency-surroundingMatch": "[:digit:]",
	"decimalFormat-short": "000T",
	"currencySpacing-afterCurrency-insertBetween": " ",
	"nan": "NaN",
	"nativeZeroDigit": "0",
	"plusSign": "+",
	"currencySpacing-afterCurrency-surroundingMatch": "[:digit:]",
	"currencySpacing-beforeCurrency-currencyMatch": "[:letter:]",
	"currencyFormat": "¤ #,##0.00",
	"perMille": "‰",
	"group": ",",
	"percentFormat": "#,##0%",
	"decimalFormat": "#,##0.###",
	"decimal": ".",
	"patternDigit": "#",
	"currencySpacing-beforeCurrency-insertBetween": " ",
	"exponential": "E"
}
//end v1.x content
,
	"af": true,
	"af-na": true,
	"ak": true,
	"am": true,
	"ar": true,
	"ar-qa": true,
	"ar-sa": true,
	"ar-sy": true,
	"ar-tn": true,
	"ar-ye": true,
	"as": true,
	"asa": true,
	"az": true,
	"az-cyrl": true,
	"be": true,
	"bem": true,
	"bez": true,
	"bg": true,
	"bm": true,
	"bn": true,
	"bo": true,
	"brx": true,
	"bs": true,
	"ca": true,
	"cgg": true,
	"chr": true,
	"cs": true,
	"da": true,
	"dav": true,
	"de": true,
	"de-at": true,
	"de-ch": true,
	"de-li": true,
	"ebu": true,
	"ee": true,
	"el": true,
	"el-cy": true,
	"en": true,
	"en-au": true,
	"en-be": true,
	"en-bw": true,
	"en-bz": true,
	"en-gb": true,
	"en-ie": true,
	"en-in": true,
	"en-jm": true,
	"en-mt": true,
	"en-na": true,
	"en-nz": true,
	"en-tt": true,
	"en-us-posix": true,
	"en-za": true,
	"en-zw": true,
	"eo": true,
	"es": true,
	"es-419": true,
	"es-cl": true,
	"es-do": true,
	"es-ec": true,
	"es-gt": true,
	"es-hn": true,
	"es-mx": true,
	"es-ni": true,
	"es-pa": true,
	"es-pe": true,
	"es-pr": true,
	"es-py": true,
	"es-sv": true,
	"es-us": true,
	"es-uy": true,
	"es-ve": true,
	"et": true,
	"eu": true,
	"fa": true,
	"fa-af": true,
	"ff": true,
	"fi": true,
	"fil": true,
	"fo": true,
	"fr": true,
	"fr-be": true,
	"fr-ca": true,
	"fr-ch": true,
	"fr-lu": true,
	"ga": true,
	"gl": true,
	"gsw": true,
	"gu": true,
	"guz": true,
	"gv": true,
	"ha": true,
	"haw": true,
	"he": true,
	"hi": true,
	"hr": true,
	"hu": true,
	"hy": true,
	"id": true,
	"ig": true,
	"ii": true,
	"in": true,
	"is": true,
	"it": true,
	"it-ch": true,
	"iw": true,
	"ja": true,
	"jmc": true,
	"ka": true,
	"kab": true,
	"kam": true,
	"kde": true,
	"kea": true,
	"khq": true,
	"ki": true,
	"kk": true,
	"kl": true,
	"kln": true,
	"km": true,
	"kn": true,
	"ko": true,
	"kok": true,
	"ksb": true,
	"kw": true,
	"lg": true,
	"lt": true,
	"luo": true,
	"luy": true,
	"lv": true,
	"mas": true,
	"mer": true,
	"mfe": true,
	"mg": true,
	"mk": true,
	"ml": true,
	"mo": true,
	"mr": true,
	"ms": true,
	"ms-bn": true,
	"mt": true,
	"my": true,
	"naq": true,
	"nb": true,
	"nd": true,
	"ne": true,
	"nl": true,
	"nl-be": true,
	"nn": true,
	"no": true,
	"nr": true,
	"nso": true,
	"nyn": true,
	"om": true,
	"or": true,
	"pa": true,
	"pl": true,
	"ps": true,
	"pt": true,
	"pt-pt": true,
	"rm": true,
	"ro": true,
	"rof": true,
	"ru": true,
	"rw": true,
	"rwk": true,
	"saq": true,
	"seh": true,
	"ses": true,
	"sg": true,
	"sh": true,
	"shi": true,
	"shi-tfng": true,
	"si": true,
	"sk": true,
	"sl": true,
	"sn": true,
	"so": true,
	"sq": true,
	"sr": true,
	"sr-latn-me": true,
	"sr-me": true,
	"ss": true,
	"st": true,
	"sv": true,
	"sw": true,
	"sw-ke": true,
	"ta": true,
	"te": true,
	"teo": true,
	"th": true,
	"ti": true,
	"tl": true,
	"tn": true,
	"tr": true,
	"ts": true,
	"tzm": true,
	"uk": true,
	"ur": true,
	"ur-in": true,
	"uz-af": true,
	"uz-arab": true,
	"ve": true,
	"vi": true,
	"vun": true,
	"xh": true,
	"xog": true,
	"yo": true,
	"zh": true,
	"zh-hant": true,
	"zh-hant-hk": true,
	"zh-hk": true,
	"zu": true
});
},
'ibm/tivoli/simplesrm/srm/dijit/nls/uiNavigatorStringTable':function(){
define({ root:
{ 
	TestKey: "Test Key value",

	dummy_: ""
} 
 
});

},
'dojox/color/_base':function(){
define("dojox/color/_base", ["dojo/_base/kernel", "../main", "dojo/_base/lang", "dojo/_base/Color", "dojo/colors"], 
	function(dojo, dojox, lang, Color, colors){

var cx = lang.getObject("dojox.color", true);
/*===== cx = dojox.color =====*/
		
//	alias all the dojo.Color mechanisms
cx.Color=Color;
cx.blend=Color.blendColors;
cx.fromRgb=Color.fromRgb;
cx.fromHex=Color.fromHex;
cx.fromArray=Color.fromArray;
cx.fromString=Color.fromString;

//	alias the dojo.colors mechanisms
cx.greyscale=colors.makeGrey;

lang.mixin(cx,{
	fromCmy: function(/* Object|Array|int */cyan, /*int*/magenta, /*int*/yellow){
		//	summary
		//	Create a dojox.color.Color from a CMY defined color.
		//	All colors should be expressed as 0-100 (percentage)
	
		if(lang.isArray(cyan)){
			magenta=cyan[1], yellow=cyan[2], cyan=cyan[0];
		} else if(lang.isObject(cyan)){
			magenta=cyan.m, yellow=cyan.y, cyan=cyan.c;
		}
		cyan/=100, magenta/=100, yellow/=100;
	
		var r=1-cyan, g=1-magenta, b=1-yellow;
		return new Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	},
	
	fromCmyk: function(/* Object|Array|int */cyan, /*int*/magenta, /*int*/yellow, /*int*/black){
		//	summary
		//	Create a dojox.color.Color from a CMYK defined color.
		//	All colors should be expressed as 0-100 (percentage)
	
		if(lang.isArray(cyan)){
			magenta=cyan[1], yellow=cyan[2], black=cyan[3], cyan=cyan[0];
		} else if(lang.isObject(cyan)){
			magenta=cyan.m, yellow=cyan.y, black=cyan.b, cyan=cyan.c;
		}
		cyan/=100, magenta/=100, yellow/=100, black/=100;
		var r,g,b;
		r = 1-Math.min(1, cyan*(1-black)+black);
		g = 1-Math.min(1, magenta*(1-black)+black);
		b = 1-Math.min(1, yellow*(1-black)+black);
		return new Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	},
		
	fromHsl: function(/* Object|Array|int */hue, /* int */saturation, /* int */luminosity){
		//	summary
		//	Create a dojox.color.Color from an HSL defined color.
		//	hue from 0-359 (degrees), saturation and luminosity 0-100.
	
		if(lang.isArray(hue)){
			saturation=hue[1], luminosity=hue[2], hue=hue[0];
		} else if(lang.isObject(hue)){
			saturation=hue.s, luminosity=hue.l, hue=hue.h;
		}
		saturation/=100;
		luminosity/=100;
	
		while(hue<0){ hue+=360; }
		while(hue>=360){ hue-=360; }
		
		var r, g, b;
		if(hue<120){
			r=(120-hue)/60, g=hue/60, b=0;
		} else if (hue<240){
			r=0, g=(240-hue)/60, b=(hue-120)/60;
		} else {
			r=(hue-240)/60, g=0, b=(360-hue)/60;
		}
		
		r=2*saturation*Math.min(r, 1)+(1-saturation);
		g=2*saturation*Math.min(g, 1)+(1-saturation);
		b=2*saturation*Math.min(b, 1)+(1-saturation);
		if(luminosity<0.5){
			r*=luminosity, g*=luminosity, b*=luminosity;
		}else{
			r=(1-luminosity)*r+2*luminosity-1;
			g=(1-luminosity)*g+2*luminosity-1;
			b=(1-luminosity)*b+2*luminosity-1;
		}
		return new Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
	}
});
	
cx.fromHsv = function(/* Object|Array|int */hue, /* int */saturation, /* int */value){
	//	summary
	//	Create a dojox.color.Color from an HSV defined color.
	//	hue from 0-359 (degrees), saturation and value 0-100.

	if(lang.isArray(hue)){
		saturation=hue[1], value=hue[2], hue=hue[0];
	} else if (lang.isObject(hue)){
		saturation=hue.s, value=hue.v, hue=hue.h;
	}
	
	if(hue==360){ hue=0; }
	saturation/=100;
	value/=100;
	
	var r, g, b;
	if(saturation==0){
		r=value, b=value, g=value;
	}else{
		var hTemp=hue/60, i=Math.floor(hTemp), f=hTemp-i;
		var p=value*(1-saturation);
		var q=value*(1-(saturation*f));
		var t=value*(1-(saturation*(1-f)));
		switch(i){
			case 0:{ r=value, g=t, b=p; break; }
			case 1:{ r=q, g=value, b=p; break; }
			case 2:{ r=p, g=value, b=t; break; }
			case 3:{ r=p, g=q, b=value; break; }
			case 4:{ r=t, g=p, b=value; break; }
			case 5:{ r=value, g=p, b=q; break; }
		}
	}
	return new Color({ r:Math.round(r*255), g:Math.round(g*255), b:Math.round(b*255) });	//	dojox.color.Color
};
lang.extend(Color,{
	toCmy: function(){
		//	summary
		//	Convert this Color to a CMY definition.
		var cyan=1-(this.r/255), magenta=1-(this.g/255), yellow=1-(this.b/255);
		return { c:Math.round(cyan*100), m:Math.round(magenta*100), y:Math.round(yellow*100) };		//	Object
	},
		
	toCmyk: function(){
		//	summary
		//	Convert this Color to a CMYK definition.
		var cyan, magenta, yellow, black;
		var r=this.r/255, g=this.g/255, b=this.b/255;
		black = Math.min(1-r, 1-g, 1-b);
		cyan = (1-r-black)/(1-black);
		magenta = (1-g-black)/(1-black);
		yellow = (1-b-black)/(1-black);
		return { c:Math.round(cyan*100), m:Math.round(magenta*100), y:Math.round(yellow*100), b:Math.round(black*100) };	//	Object
	},
		
	toHsl: function(){
		//	summary
		//	Convert this Color to an HSL definition.
		var r=this.r/255, g=this.g/255, b=this.b/255;
		var min = Math.min(r, b, g), max = Math.max(r, g, b);
		var delta = max-min;
		var h=0, s=0, l=(min+max)/2;
		if(l>0 && l<1){
			s = delta/((l<0.5)?(2*l):(2-2*l));
		}
		if(delta>0){
			if(max==r && max!=g){
				h+=(g-b)/delta;
			}
			if(max==g && max!=b){
				h+=(2+(b-r)/delta);
			}
			if(max==b && max!=r){
				h+=(4+(r-g)/delta);
			}
			h*=60;
		}
		return { h:h, s:Math.round(s*100), l:Math.round(l*100) };	//	Object
	},
	
	toHsv: function(){
		//	summary
		//	Convert this Color to an HSV definition.
		var r=this.r/255, g=this.g/255, b=this.b/255;
		var min = Math.min(r, b, g), max = Math.max(r, g, b);
		var delta = max-min;
		var h = null, s = (max==0)?0:(delta/max);
		if(s==0){
			h = 0;
		}else{
			if(r==max){
				h = 60*(g-b)/delta;
			}else if(g==max){
				h = 120 + 60*(b-r)/delta;
			}else{
				h = 240 + 60*(r-g)/delta;
			}
	
			if(h<0){ h+=360; }
		}
		return { h:h, s:Math.round(s*100), v:Math.round(max*100) };	//	Object
	}
});

return cx;
});

},
'dojox/grid/_View':function(){
require({cache:{
'url:dojox/grid/resources/View.html':"<div class=\"dojoxGridView\" role=\"presentation\">\n\t<div class=\"dojoxGridHeader\" dojoAttachPoint=\"headerNode\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"headerNodeContainer\" style=\"width:9000em\" role=\"presentation\">\n\t\t\t<div dojoAttachPoint=\"headerContentNode\" role=\"row\"></div>\n\t\t</div>\n\t</div>\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" dojoAttachPoint=\"hiddenFocusNode\" role=\"presentation\" />\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" role=\"presentation\" />\n\t<div class=\"dojoxGridScrollbox\" dojoAttachPoint=\"scrollboxNode\" role=\"presentation\">\n\t\t<div class=\"dojoxGridContent\" dojoAttachPoint=\"contentNode\" hidefocus=\"hidefocus\" role=\"presentation\"></div>\n\t</div>\n</div>\n"}});
define("dojox/grid/_View", [
	"dojo",
	"dijit/registry",
	"../main",
	"dojo/_base/declare",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/connect",
	"dojo/_base/sniff",
	"dojo/query",
	"dojo/_base/window",
	"dojo/text!./resources/View.html",
	"dojo/dnd/Source",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dojox/html/metrics",
	"./util",
	"dojo/_base/html",
	"./_Builder",
	"dojo/dnd/Avatar",
	"dojo/dnd/Manager"
], function(dojo, dijit, dojox, declare, array, lang, connect, has, query,
	win, template, Source, _Widget, _TemplatedMixin, metrics, util, html, _Builder, Avatar){

	// a private function
	var getStyleText = function(inNode, inStyleText){
		return inNode.style.cssText == undefined ? inNode.getAttribute("style") : inNode.style.cssText;
	};

	// some public functions
	var _View = declare('dojox.grid._View', [_Widget, _TemplatedMixin], {
		// summary:
		//		A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
		//		Grid creates views automatically based on grid's layout structure.
		//		Users should typically not need to access individual views directly.
		//
		// defaultWidth: String
		//		Default width of the view
		defaultWidth: "18em",

		// viewWidth: String
		// 		Width for the view, in valid css unit
		viewWidth: "",

		templateString: template,
		
		themeable: false,
		classTag: 'dojoxGrid',
		marginBottom: 0,
		rowPad: 2,

		// _togglingColumn: int
		//		Width of the column being toggled (-1 for none)
		_togglingColumn: -1,
		
		// _headerBuilderClass: Object
		//		The class to use for our header builder
		_headerBuilderClass: _Builder._HeaderBuilder,
		
		// _contentBuilderClass: Object
		//		The class to use for our content builder
		_contentBuilderClass: _Builder._ContentBuilder,
		
		postMixInProperties: function(){
			this.rowNodes = {};
		},

		postCreate: function(){
			this.connect(this.scrollboxNode,"onscroll","doscroll");
			util.funnelEvents(this.contentNode, this, "doContentEvent", [ 'mouseover', 'mouseout', 'click', 'dblclick', 'contextmenu', 'mousedown' ]);
			util.funnelEvents(this.headerNode, this, "doHeaderEvent", [ 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'click', 'contextmenu' ]);
			this.content = new this._contentBuilderClass(this);
			this.header = new this._headerBuilderClass(this);
			//BiDi: in RTL case, style width='9000em' causes scrolling problem in head node
			if(!this.grid.isLeftToRight()){
				this.headerNodeContainer.style.width = "";
			}
		},

		destroy: function(){
			html.destroy(this.headerNode);
			delete this.headerNode;
			for(var i in this.rowNodes){
				this._cleanupRowWidgets(this.rowNodes[i]);
				html.destroy(this.rowNodes[i]);
			}
			this.rowNodes = {};
			if(this.source){
				this.source.destroy();
			}
			this.inherited(arguments);
		},

		// focus
		focus: function(){
			if(has("ie") || has("webkit") || has("opera")){
				this.hiddenFocusNode.focus();
			}else{
				this.scrollboxNode.focus();
			}
		},

		setStructure: function(inStructure){
			var vs = (this.structure = inStructure);
			// FIXME: similar logic is duplicated in layout
			if(vs.width && !isNaN(vs.width)){
				this.viewWidth = vs.width + 'em';
			}else{
				this.viewWidth = vs.width || (vs.noscroll ? 'auto' : this.viewWidth); //|| this.defaultWidth;
			}
			this._onBeforeRow = vs.onBeforeRow||function(){};
			this._onAfterRow = vs.onAfterRow||function(){};
			this.noscroll = vs.noscroll;
			if(this.noscroll){
				this.scrollboxNode.style.overflow = "hidden";
			}
			this.simpleStructure = Boolean(vs.cells.length == 1);
			// bookkeeping
			this.testFlexCells();
			// accomodate new structure
			this.updateStructure();
		},
		
		_cleanupRowWidgets: function(inRowNode){
			// Summary:
			//		Cleans up the widgets for the given row node so that
			//		we can reattach them if needed
			if(inRowNode){
				array.forEach(query("[widgetId]", inRowNode).map(dijit.byNode), function(w){
					if(w._destroyOnRemove){
						w.destroy();
						delete w;
					}else if(w.domNode && w.domNode.parentNode){
						w.domNode.parentNode.removeChild(w.domNode);
					}
				});
			}
		},
		
		onBeforeRow: function(inRowIndex, cells){
			this._onBeforeRow(inRowIndex, cells);
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
		},
		
		onAfterRow: function(inRowIndex, cells, inRowNode){
			this._onAfterRow(inRowIndex, cells, inRowNode);
			var g = this.grid;
			array.forEach(query(".dojoxGridStubNode", inRowNode), function(n){
				if(n && n.parentNode){
					var lw = n.getAttribute("linkWidget");
					var cellIdx = window.parseInt(html.attr(n, "cellIdx"), 10);
					var cellDef = g.getCell(cellIdx);
					var w = dijit.byId(lw);
					if(w){
						n.parentNode.replaceChild(w.domNode, n);
						if(!w._started){
							w.startup();
						}
						dojo.destroy(n);
					}else{
						n.innerHTML = "";
					}
				}
			}, this);
		},

		testFlexCells: function(){
			// FIXME: cheater, this function does double duty as initializer and tester
			this.flexCells = false;
			for(var j=0, row; (row=this.structure.cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.view = this;
					this.flexCells = this.flexCells || cell.isFlex();
				}
			}
			return this.flexCells;
		},

		updateStructure: function(){
			// header builder needs to update table map
			this.header.update();
			// content builder needs to update markup cache
			this.content.update();
		},

		getScrollbarWidth: function(){
			var hasScrollSpace = this.hasVScrollbar();
			var overflow = html.style(this.scrollboxNode, "overflow");
			if(this.noscroll || !overflow || overflow == "hidden"){
				hasScrollSpace = false;
			}else if(overflow == "scroll"){
				hasScrollSpace = true;
			}
			return (hasScrollSpace ? metrics.getScrollbar().w : 0); // Integer
		},

		getColumnsWidth: function(){
			var h = this.headerContentNode;
			return h && h.firstChild ? h.firstChild.offsetWidth : 0; // Integer
		},

		setColumnsWidth: function(width){
			this.headerContentNode.firstChild.style.width = width + 'px';
			if(this.viewWidth){
				this.viewWidth = width + 'px';
			}
		},

		getWidth: function(){
			return this.viewWidth || (this.getColumnsWidth()+this.getScrollbarWidth()) +'px'; // String
		},

		getContentWidth: function(){
			return Math.max(0, html._getContentBox(this.domNode).w - this.getScrollbarWidth()) + 'px'; // String
		},

		render: function(){
			this.scrollboxNode.style.height = '';
			this.renderHeader();
			if(this._togglingColumn >= 0){
				this.setColumnsWidth(this.getColumnsWidth() - this._togglingColumn);
				this._togglingColumn = -1;
			}
			var cells = this.grid.layout.cells;
			var getSibling = lang.hitch(this, function(node, before){
				!this.grid.isLeftToRight() && (before = !before);
				var inc = before?-1:1;
				var idx = this.header.getCellNodeIndex(node) + inc;
				var cell = cells[idx];
				while(cell && cell.getHeaderNode() && cell.getHeaderNode().style.display == "none"){
					idx += inc;
					cell = cells[idx];
				}
				if(cell){
					return cell.getHeaderNode();
				}
				return null;
			});
			if(this.grid.columnReordering && this.simpleStructure){
				if(this.source){
					this.source.destroy();
				}
				
				// Create the top and bottom markers
				var bottomMarkerId = "dojoxGrid_bottomMarker";
				var topMarkerId = "dojoxGrid_topMarker";
				if(this.bottomMarker){
					html.destroy(this.bottomMarker);
				}
				this.bottomMarker = html.byId(bottomMarkerId);
				if(this.topMarker){
					html.destroy(this.topMarker);
				}
				this.topMarker = html.byId(topMarkerId);
				if (!this.bottomMarker) {
					this.bottomMarker = html.create("div", {
						"id": bottomMarkerId,
						"class": "dojoxGridColPlaceBottom"
					}, win.body());
					this._hide(this.bottomMarker);

					
					this.topMarker = html.create("div", {
						"id": topMarkerId,
						"class": "dojoxGridColPlaceTop"
					}, win.body());
					this._hide(this.topMarker);
				}
				this.arrowDim = html.contentBox(this.bottomMarker);

				var headerHeight = html.contentBox(this.headerContentNode.firstChild.rows[0]).h;
				
				this.source = new Source(this.headerContentNode.firstChild.rows[0], {
					horizontal: true,
					accept: [ "gridColumn_" + this.grid.id ],
					viewIndex: this.index,
					generateText: false,
					onMouseDown: lang.hitch(this, function(e){
						this.header.decorateEvent(e);
						if((this.header.overRightResizeArea(e) || this.header.overLeftResizeArea(e)) &&
							this.header.canResize(e) && !this.header.moveable){
							this.header.beginColumnResize(e);
						}else{
							if(this.grid.headerMenu){
								this.grid.headerMenu.onCancel(true);
							}
							// IE reports a left click as 1, where everything else reports 0
							if(e.button === (has("ie") < 9 ? 1 : 0)){
								Source.prototype.onMouseDown.call(this.source, e);
							}
						}
					}),
					onMouseOver: lang.hitch(this, function(e){
						var src = this.source;
						if(src._getChildByEvent(e)){
							Source.prototype.onMouseOver.apply(src, arguments);
						}
					}),
					_markTargetAnchor: lang.hitch(this, function(before){
						var src = this.source;
						if(src.current == src.targetAnchor && src.before == before){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						Source.prototype._markTargetAnchor.call(src, before);
						
						var target = before ? src.targetAnchor : getSibling(src.targetAnchor, src.before);
						var endAdd = 0;

						if (!target) {
							target = src.targetAnchor;
							endAdd = html.contentBox(target).w + this.arrowDim.w/2 + 2;
						}

						var pos = html.position(target, true);
						var left = Math.floor(pos.x - this.arrowDim.w/2 + endAdd);

						html.style(this.bottomMarker, "visibility", "visible");
						html.style(this.topMarker, "visibility", "visible");
						html.style(this.bottomMarker, {
							"left": left + "px",
							"top" : (headerHeight + pos.y) + "px"
						});

						html.style(this.topMarker, {
							"left": left + "px",
							"top" : (pos.y - this.arrowDim.h) + "px"
						});

						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._addItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
					}),
					_unmarkTargetAnchor: lang.hitch(this, function(){
						var src = this.source;
						if(!src.targetAnchor){ return; }
						if(src.targetAnchor && getSibling(src.targetAnchor, src.before)){
							src._removeItemClass(getSibling(src.targetAnchor, src.before), src.before ? "After" : "Before");
						}
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
						Source.prototype._unmarkTargetAnchor.call(src);
					}),
					destroy: lang.hitch(this, function(){
						connect.disconnect(this._source_conn);
						connect.unsubscribe(this._source_sub);
						Source.prototype.destroy.call(this.source);
						if(this.bottomMarker){
							html.destroy(this.bottomMarker);
							delete this.bottomMarker;
						}
						if(this.topMarker){
							html.destroy(this.topMarker);
							delete this.topMarker;
						}
					}),
					onDndCancel: lang.hitch(this, function(){
						Source.prototype.onDndCancel.call(this.source);
						this._hide(this.bottomMarker);
						this._hide(this.topMarker);
					})
				});

				this._source_conn = connect.connect(this.source, "onDndDrop", this, "_onDndDrop");
				this._source_sub = connect.subscribe("/dnd/drop/before", this, "_onDndDropBefore");
				this.source.startup();
			}
		},
		
		_hide: function(node){
			html.style(node, {
				top: "-10000px",
				"visibility": "hidden"
			});
		},

		_onDndDropBefore: function(source, nodes, copy){
			if(dojo.dnd.manager().target !== this.source){
				return;
			}
			this.source._targetNode = this.source.targetAnchor;
			this.source._beforeTarget = this.source.before;
			var views = this.grid.views.views;
			var srcView = views[source.viewIndex];
			var tgtView = views[this.index];
			if(tgtView != srcView){
				srcView.convertColPctToFixed();
				tgtView.convertColPctToFixed();
			}
		},

		_onDndDrop: function(source, nodes, copy){
			if(dojo.dnd.manager().target !== this.source){
				if(dojo.dnd.manager().source === this.source){
					this._removingColumn = true;
				}
				return;
			}
			this._hide(this.bottomMarker);
			this._hide(this.topMarker);

			var getIdx = function(n){
				return n ? html.attr(n, "idx") : null;
			};
			var w = html.marginBox(nodes[0]).w;
			if(source.viewIndex !== this.index){
				var views = this.grid.views.views;
				var srcView = views[source.viewIndex];
				var tgtView = views[this.index];
				if(srcView.viewWidth && srcView.viewWidth != "auto"){
					srcView.setColumnsWidth(srcView.getColumnsWidth() - w);
				}
				if(tgtView.viewWidth && tgtView.viewWidth != "auto"){
					tgtView.setColumnsWidth(tgtView.getColumnsWidth());
				}
			}
			var stn = this.source._targetNode;
			var stb = this.source._beforeTarget;
			!this.grid.isLeftToRight() && (stb = !stb);
			var layout = this.grid.layout;
			var idx = this.index;
			delete this.source._targetNode;
			delete this.source._beforeTarget;
			
			layout.moveColumn(
				source.viewIndex,
				idx,
				getIdx(nodes[0]),
				getIdx(stn),
				stb);
		},

		renderHeader: function(){
			this.headerContentNode.innerHTML = this.header.generateHtml(this._getHeaderContent);
			if(this.flexCells){
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			util.fire(this, "onAfterRow", [-1, this.structure.cells, this.headerContentNode]);
		},

		// note: not called in 'view' context
		_getHeaderContent: function(inCell){
			var n = inCell.name || inCell.grid.getCellName(inCell);
			if(/^\s+$/.test(n)){
				n = '&nbsp;'//otherwise arrow styles will be messed up
			}
			var ret = [ '<div class="dojoxGridSortNode' ];
			
			if(inCell.index != inCell.grid.getSortIndex()){
				ret.push('">');
			}else{
				ret = ret.concat([ ' ',
							inCell.grid.sortInfo > 0 ? 'dojoxGridSortUp' : 'dojoxGridSortDown',
							'"><div class="dojoxGridArrowButtonChar">',
							inCell.grid.sortInfo > 0 ? '&#9650;' : '&#9660;',
							'</div><div class="dojoxGridArrowButtonNode" role="presentation"></div>',
							'<div class="dojoxGridColCaption">']);
			}
			ret = ret.concat([n, '</div></div>']);
			return ret.join('');
		},

		resize: function(){
			this.adaptHeight();
			this.adaptWidth();
		},

		hasHScrollbar: function(reset){
			var hadScroll = this._hasHScroll||false;
			if(this._hasHScroll == undefined || reset){
				if(this.noscroll){
					this._hasHScroll = false;
				}else{
					var style = html.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasHScroll = false;
					}else if(style == "scroll"){
						this._hasHScroll = true;
					}else{
						this._hasHScroll = (this.scrollboxNode.offsetWidth - this.getScrollbarWidth() < this.contentNode.offsetWidth );
					}
				}
			}
			if(hadScroll !== this._hasHScroll){
				this.grid.update();
			}
			return this._hasHScroll; // Boolean
		},

		hasVScrollbar: function(reset){
			var hadScroll = this._hasVScroll||false;
			if(this._hasVScroll == undefined || reset){
				if(this.noscroll){
					this._hasVScroll = false;
				}else{
					var style = html.style(this.scrollboxNode, "overflow");
					if(style == "hidden"){
						this._hasVScroll = false;
					}else if(style == "scroll"){
						this._hasVScroll = true;
					}else{
						this._hasVScroll = (this.scrollboxNode.scrollHeight > this.scrollboxNode.clientHeight);
					}
				}
			}
			if(hadScroll !== this._hasVScroll){
				this.grid.update();
			}
			return this._hasVScroll; // Boolean
		},
		
		convertColPctToFixed: function(){
			// Fix any percentage widths to be pixel values
			var hasPct = false;
			this.grid.initialWidth = "";
			var cellNodes = query("th", this.headerContentNode);
			var fixedWidths = array.map(cellNodes, function(c, vIdx){
				var w = c.style.width;
				html.attr(c, "vIdx", vIdx);
				if(w && w.slice(-1) == "%"){
					hasPct = true;
				}else if(w && w.slice(-2) == "px"){
					return window.parseInt(w, 10);
				}
				return html.contentBox(c).w;
			});
			if(hasPct){
				array.forEach(this.grid.layout.cells, function(cell, idx){
					if(cell.view == this){
						var cellNode = cell.view.getHeaderCellNode(cell.index);
						if(cellNode && html.hasAttr(cellNode, "vIdx")){
							var vIdx = window.parseInt(html.attr(cellNode, "vIdx"));
							this.setColWidth(idx, fixedWidths[vIdx]);
							html.removeAttr(cellNode, "vIdx");
						}
					}
				}, this);
				return true;
			}
			return false;
		},

		adaptHeight: function(minusScroll){
			if(!this.grid._autoHeight){
				var h = (this.domNode.style.height && parseInt(this.domNode.style.height.replace(/px/,''), 10)) || this.domNode.clientHeight;
				var self = this;
				var checkOtherViewScrollers = function(){
					var v;
					for(var i in self.grid.views.views){
						v = self.grid.views.views[i];
						if(v !== self && v.hasHScrollbar()){
							return true;
						}
					}
					return false;
				};
				if(minusScroll || (this.noscroll && checkOtherViewScrollers())){
					h -= metrics.getScrollbar().h;
				}
				util.setStyleHeightPx(this.scrollboxNode, h);
			}
			this.hasVScrollbar(true);
		},

		adaptWidth: function(){
			if(this.flexCells){
				// the view content width
				this.contentWidth = this.getContentWidth();
				this.headerContentNode.firstChild.style.width = this.contentWidth;
			}
			// FIXME: it should be easier to get w from this.scrollboxNode.clientWidth,
			// but clientWidth seemingly does not include scrollbar width in some cases
			var w = this.scrollboxNode.offsetWidth - this.getScrollbarWidth();
			if(!this._removingColumn){
				w = Math.max(w, this.getColumnsWidth()) + 'px';
			}else{
				w = Math.min(w, this.getColumnsWidth()) + 'px';
				this._removingColumn = false;
			}
			var cn = this.contentNode;
			cn.style.width = w;
			this.hasHScrollbar(true);
		},

		setSize: function(w, h){
			var ds = this.domNode.style;
			var hs = this.headerNode.style;

			if(w){
				ds.width = w;
				hs.width = w;
			}
			ds.height = (h >= 0 ? h + 'px' : '');
		},

		renderRow: function(inRowIndex){
			var rowNode = this.createRowNode(inRowIndex);
			this.buildRow(inRowIndex, rowNode);
			//this.grid.edit.restore(this, inRowIndex);
			return rowNode;
		},

		createRowNode: function(inRowIndex){
			var node = document.createElement("div");
			node.className = this.classTag + 'Row';
			if (this instanceof dojox.grid._RowSelector){
				html.attr(node,"role","presentation");
			}else{
				html.attr(node,"role","row");
				if (this.grid.selectionMode != "none") {
					node.setAttribute("aria-selected", "false"); //rows can be selected so add aria-selected prop
				}
			}
			node[util.gridViewTag] = this.id;
			node[util.rowIndexTag] = inRowIndex;
			this.rowNodes[inRowIndex] = node;
			return node;
		},

		buildRow: function(inRowIndex, inRowNode){
			
			this.buildRowContent(inRowIndex, inRowNode);
		  	
			this.styleRow(inRowIndex, inRowNode);
		  
		 
		},

		buildRowContent: function(inRowIndex, inRowNode){
			inRowNode.innerHTML = this.content.generateHtml(inRowIndex, inRowIndex);
			if(this.flexCells && this.contentWidth){
				// FIXME: accessing firstChild here breaks encapsulation
				inRowNode.firstChild.style.width = this.contentWidth;
			}
			util.fire(this, "onAfterRow", [inRowIndex, this.structure.cells, inRowNode]);
		},

		rowRemoved:function(inRowIndex){
			if(inRowIndex >= 0){
				this._cleanupRowWidgets(this.getRowNode(inRowIndex));
			}
			this.grid.edit.save(this, inRowIndex);
			delete this.rowNodes[inRowIndex];
		},

		getRowNode: function(inRowIndex){
			return this.rowNodes[inRowIndex];
		},

		getCellNode: function(inRowIndex, inCellIndex){
			var row = this.getRowNode(inRowIndex);
			if(row){
				return this.content.getCellNode(row, inCellIndex);
			}
		},

		getHeaderCellNode: function(inCellIndex){
			if(this.headerContentNode){
				return this.header.getCellNode(this.headerContentNode, inCellIndex);
			}
		},

		// styling
		styleRow: function(inRowIndex, inRowNode){
			inRowNode._style = getStyleText(inRowNode);
			this.styleRowNode(inRowIndex, inRowNode);
		},

		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.doStyleRowNode(inRowIndex, inRowNode);
			}
		},

		doStyleRowNode: function(inRowIndex, inRowNode){
			this.grid.styleRowNode(inRowIndex, inRowNode);
		},

		// updating
		updateRow: function(inRowIndex){
			var rowNode = this.getRowNode(inRowIndex);
			if(rowNode){
				rowNode.style.height = '';
				this.buildRow(inRowIndex, rowNode);
			}
			return rowNode;
		},

		updateRowStyles: function(inRowIndex){
			this.styleRowNode(inRowIndex, this.getRowNode(inRowIndex));
		},

		// scrolling
		lastTop: 0,
		firstScroll:0,

		doscroll: function(inEvent){
			//var s = dojo.marginBox(this.headerContentNode.firstChild);
			var isLtr = this.grid.isLeftToRight();
			if(this.firstScroll < 2){
				if((!isLtr && this.firstScroll == 1) || (isLtr && this.firstScroll === 0)){
					var s = html.marginBox(this.headerNodeContainer);
					if(has("ie")){
						this.headerNodeContainer.style.width = s.w + this.getScrollbarWidth() + 'px';
					}else if(has("mozilla")){
						//TODO currently only for FF, not sure for safari and opera
						this.headerNodeContainer.style.width = s.w - this.getScrollbarWidth() + 'px';
						//this.headerNodeContainer.style.width = s.w + 'px';
						//set scroll to right in FF
						this.scrollboxNode.scrollLeft = isLtr ?
							this.scrollboxNode.clientWidth - this.scrollboxNode.scrollWidth :
							this.scrollboxNode.scrollWidth - this.scrollboxNode.clientWidth;
					}
				}
				this.firstScroll++;
			}
			this.headerNode.scrollLeft = this.scrollboxNode.scrollLeft;
			// 'lastTop' is a semaphore to prevent feedback-loop with setScrollTop below
			var top = this.scrollboxNode.scrollTop;
			if(top !== this.lastTop){
				this.grid.scrollTo(top);
			}
		},

		setScrollTop: function(inTop){
			// 'lastTop' is a semaphore to prevent feedback-loop with doScroll above
			this.lastTop = inTop;
			this.scrollboxNode.scrollTop = inTop;
			return this.scrollboxNode.scrollTop;
		},

		// event handlers (direct from DOM)
		doContentEvent: function(e){
			if(this.content.decorateEvent(e)){
				this.grid.onContentEvent(e);
			}
		},

		doHeaderEvent: function(e){
			if(this.header.decorateEvent(e)){
				this.grid.onHeaderEvent(e);
			}
		},

		// event dispatch(from Grid)
		dispatchContentEvent: function(e){
			return this.content.dispatchEvent(e);
		},

		dispatchHeaderEvent: function(e){
			return this.header.dispatchEvent(e);
		},

		// column resizing
		setColWidth: function(inIndex, inWidth){
			this.grid.setCellWidth(inIndex, inWidth + 'px');
		},

		update: function(){
			if(!this.domNode){
				return;
			}
			this.content.update();
			this.grid.update();
			//get scroll after update or scroll left setting goes wrong on IE.
			//See trac: #8040
			var left = this.scrollboxNode.scrollLeft;
			this.scrollboxNode.scrollLeft = left;
			this.headerNode.scrollLeft = left;
		}
	});

	var _GridAvatar = declare("dojox.grid._GridAvatar", Avatar, {
		construct: function(){
			var dd = win.doc;

			var a = dd.createElement("table");
			a.cellPadding = a.cellSpacing = "0";
			a.className = "dojoxGridDndAvatar";
			a.style.position = "absolute";
			a.style.zIndex = 1999;
			a.style.margin = "0px"; // to avoid dojo.marginBox() problems with table's margins
			var b = dd.createElement("tbody");
			var tr = dd.createElement("tr");
			var td = dd.createElement("td");
			var img = dd.createElement("td");
			tr.className = "dojoxGridDndAvatarItem";
			img.className = "dojoxGridDndAvatarItemImage";
			img.style.width = "16px";
			var source = this.manager.source, node;
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[0].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[0].cloneNode(true);
				var table, tbody;
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					tbody.appendChild(node);
					table.appendChild(tbody);
					node = table;
				}else if(node.tagName.toLowerCase() == "th"){
					// insert extra table nodes
					table = dd.createElement("table");
					tbody = dd.createElement("tbody");
					var r = dd.createElement("tr");
					table.cellPadding = table.cellSpacing = "0";
					r.appendChild(node);
					tbody.appendChild(r);
					table.appendChild(tbody);
					node = table;
				}
			}
			node.id = "";
			td.appendChild(node);
			tr.appendChild(img);
			tr.appendChild(td);
			html.style(tr, "opacity", 0.9);
			b.appendChild(tr);

			a.appendChild(b);
			this.node = a;

			var m = dojo.dnd.manager();
			this.oldOffsetY = m.OFFSET_Y;
			m.OFFSET_Y = 1;
		},
		destroy: function(){
			dojo.dnd.manager().OFFSET_Y = this.oldOffsetY;
			this.inherited(arguments);
		}
	});

	var oldMakeAvatar = dojo.dnd.manager().makeAvatar;
	dojo.dnd.manager().makeAvatar = function(){
		var src = this.source;
		if(src.viewIndex !== undefined && !html.hasClass(win.body(),"dijit_a11y")){
			return new _GridAvatar(this);
		}
		return oldMakeAvatar.call(dojo.dnd.manager());
	};

	return _View;

});
},
'dojox/collections/Dictionary':function(){
define("dojox/collections/Dictionary", ["dojo/_base/kernel", "dojo/_base/array", "./_base"], function(dojo, darray, dxc){
/*=====
var dxc = dojox.collections;
=====*/
	dxc.Dictionary=function(/* dojox.collections.Dictionary? */dictionary){
		//	summary
		//	Returns an object of type dojox.collections.Dictionary
		var items={};
		this.count=0;

		//	comparator for property addition and access.
		var testObject={};

		this.add=function(/* string */k, /* object */v){
			//	summary
			//	Add a new item to the Dictionary.
			var b=(k in items);
			items[k]=new dxc.DictionaryEntry(k,v);
			if(!b){
				this.count++;
			}
		};
		this.clear=function(){
			//	summary
			//	Clears the internal dictionary.
			items={};
			this.count=0;
		};
		this.clone=function(){
			//	summary
			//	Returns a new instance of dojox.collections.Dictionary; note the the dictionary is a clone but items might not be.
			return new dxc.Dictionary(this);	//	dojox.collections.Dictionary
		};
		this.contains=this.containsKey=function(/* string */k){
			//	summary
			//	Check to see if the dictionary has an entry at key "k".
			if(testObject[k]){
				return false;			// bool
			}
			return (items[k]!=null);	//	bool
		};
		this.containsValue=function(/* object */v){
			//	summary
			//	Check to see if the dictionary has an entry with value "v".
			var e=this.getIterator();
			while(e.get()){
				if(e.element.value==v){
					return true;	//	bool
				}
			}
			return false;	//	bool
		};
		this.entry=function(/* string */k){
			//	summary
			//	Accessor method; similar to dojox.collections.Dictionary.item but returns the actual Entry object.
			return items[k];	//	dojox.collections.DictionaryEntry
		};
		this.forEach=function(/* function */ fn, /* object? */ scope){
			//	summary
			//	functional iterator, following the mozilla spec.
			var a=[];	//	Create an indexing array
			for(var p in items) {
				if(!testObject[p]){
					a.push(items[p]);	//	fill it up
				}
			}
			dojo.forEach(a, fn, scope);
		};
		this.getKeyList=function(){
			//	summary
			//	Returns an array of the keys in the dictionary.
			return (this.getIterator()).map(function(entry){
				return entry.key;
			});	//	array
		};
		this.getValueList=function(){
			//	summary
			//	Returns an array of the values in the dictionary.
			return (this.getIterator()).map(function(entry){
				return entry.value;
			});	//	array
		};
		this.item=function(/* string */k){
			//	summary
			//	Accessor method.
			if(k in items){
				return items[k].valueOf();	//	object
			}
			return undefined;	//	object
		};
		this.getIterator=function(){
			//	summary
			//	Gets a dojox.collections.DictionaryIterator for iteration purposes.
			return new dxc.DictionaryIterator(items);	//	dojox.collections.DictionaryIterator
		};
		this.remove=function(/* string */k){
			//	summary
			//	Removes the item at k from the internal collection.
			if(k in items && !testObject[k]){
				delete items[k];
				this.count--;
				return true;	//	bool
			}
			return false;	//	bool
		};

		if (dictionary){
			var e=dictionary.getIterator();
			while(e.get()) {
				 this.add(e.element.key, e.element.value);
			}
		}
	};
	return dxc.Dictionary;
});

},
'ibm/tivoli/simplesrm/srm/dojo/data/TemplatesTree':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.TemplatesTree");

dojo.declare("ibm.tivoli.simplesrm.srm.dojo.data.TemplatesTree",
			 null,
{

	_tree : null,
	_noParents : false,

	/**
	 * Produces an empty object that will be the Templates tree.
	 */
	constructor : function() {
		this._tree = new Array();
	},
	
	addTemplate : function(template) {
		//console.log("solutionTree.addsolution() entry", solution);
		var lastParent = null;
		
		/* include the parents in the tree */
		var parents = template.CLASSSTRUCTURE;
		//debugger;
		if (parents != undefined && !this._noParents) {

         //Using parent and classstructureid, we can put the items in order.
         var _parent = null;
         var sorted_parents = new Array();

         for (var i = 0; i < parents.length; i++) {  //find top
            var clst = parents[i];
            if (clst.PARENT == undefined) {
               sorted_parents.push(clst);
               _parent = clst.CLASSSTRUCTUREID;
               break;	        		
            }   
         }
         if (_parent!=null) {  //now follow parent to put in order
            var found = true;
            while (found) {	        		
              found= false;
                for (var i = 0; i < parents.length; i++) {
                   var clst = parents[i];
                   if (clst.PARENT == _parent) {
                      sorted_parents.push(clst);
                      _parent = clst.CLASSSTRUCTUREID;
                      found = true;
                      break;
                   }   
                }
            }
            if (sorted_parents.length>0)
               parents = sorted_parents;
         } //end of manual ordering      		        

			for (var i = 0; i < parents.length; i++) {
				if (lastParent == null) {
					/* We're at top level */
					lastParent = this.addElt(this._tree, parents[i]);
				} else {
					//debugger;
					if (lastParent.Category == undefined) {
						lastParent.Category = new Array();
					}
					lastParent = this.addElt(lastParent.Category, parents[i]);
				}
			}
		}
		
		/* then the template itself */
		if (lastParent != undefined) {
			if (lastParent.Offering == undefined) {
				lastParent.Offering = new Array();
			}
			this.addElt(lastParent.Offering, template);
		} else {
			this.addElt(this._tree, template);
		}

		//debugger;
		//console.log("solutionTree.addsolution() exit", this._tree);
	},
	
	addElt : function(array, elt) {
		/* search for elt in array */
		var found = false;
		var leaf = null;
		for (var i = 0; i < array.length; i++) {
			//console.log("comparing ", array[i], " & " , elt);
			if (((elt.CLASSSTRUCTUREUID !== undefined)&& (array[i].ClassStructureID == elt.CLASSSTRUCTUREUID))){				
				found = true;
				leaf = array[i];
			}
		}
		/* not found, add it */
		if (found === false) {
			leaf = { 	
					 Description : elt.DESCRIPTION,
					 ClassStructureID : elt.CLASSSTRUCTUREUID,
					 //ClassificationID : elt.CLASSSTRUCTUREID,  
					 ID : elt.TKTEMPLATEID,
					 Template : elt.TEMPLATEID,
					 Score : elt.SCORE
				};
			
			if (elt.LONGDESCRIPTION != undefined) {
				leaf.LongDescription = elt.LONGDESCRIPTION[0].LDTEXT;
			} 
			if (elt.LONGDESCRIPTION == undefined && elt.DESCRIPTION_LONGDESCRIPTION != undefined) {
				leaf.LongDescription = elt.DESCRIPTION_LONGDESCRIPTION;
			}
			if (elt.IMGLIB != undefined) {
				leaf.ImageName = elt.IMGLIB[0].IMAGENAME;
			}
			if (elt.TKTEMPLATEID==null &&  elt.CLASSSTRUCTUREUID!=null)  //classification item
				leaf.ID =  elt.CLASSSTRUCTUREUID;

			//if (elt.CLASSIFICATIONID != undefined) {
			//	leaf.ClassificationID = elt.CLASSIFICATIONID;
			//}			 
			
			if (leaf.Description == undefined) {				
				leaf.Description = leaf.ClassStructureID.toString();
			} 
			 
			array.push(leaf);
		}
		return leaf;
	},
	
	clean : function() {
		this._tree = new Array();
	}

});

});

},
'dojox/gfx':function(){
define("dojox/gfx", ["dojo/_base/lang", "./gfx/_base", "./gfx/renderer!"], 
  function(lang, gfxBase, renderer){
	// module:
	//		dojox/gfx
	// summary:
	//		This the root of the Dojo Graphics package
	gfxBase.switchTo(renderer);
	return gfxBase;
});

},
'dijit/MenuItem':function(){
require({cache:{
'url:dijit/templates/MenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitem\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">\n\t\t<div data-dojo-attach-point=\"arrowWrapper\" style=\"visibility: hidden\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuExpand\"/>\n\t\t\t<span class=\"dijitMenuExpandA11y\">+</span>\n\t\t</div>\n\t</td>\n</tr>\n"}});
define("dijit/MenuItem", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/event", // event.stop
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/sniff", // has("ie")
	"./_Widget",
	"./_TemplatedMixin",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/MenuItem.html"
], function(declare, dom, domAttr, domClass, event, kernel, has,
			_Widget, _TemplatedMixin, _Contained, _CssStateMixin, template){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _Contained = dijit._Contained;
	var _CssStateMixin = dijit._CssStateMixin;
=====*/

	// module:
	//		dijit/MenuItem
	// summary:
	//		A line item in a Menu Widget


	return declare("dijit.MenuItem",
		[_Widget, _TemplatedMixin, _Contained, _CssStateMixin],
		{
		// summary:
		//		A line item in a Menu Widget

		// Make 3 columns
		// icon, label, and expand arrow (BiDi-dependent) indicating sub-menu
		templateString: template,

		baseClass: "dijitMenuItem",

		// label: String
		//		Menu text
		label: '',
		_setLabelAttr: { node: "containerNode", type: "innerHTML" },

		// iconClass: String
		//		Class to apply to DOMNode to make it display an icon.
		iconClass: "dijitNoIcon",
		_setIconClassAttr: { node: "iconNode", type: "class" },

		// accelKey: String
		//		Text for the accelerator (shortcut) key combination.
		//		Note that although Menu can display accelerator keys there
		//		is no infrastructure to actually catch and execute these
		//		accelerators.
		accelKey: "",

		// disabled: Boolean
		//		If true, the menu item is disabled.
		//		If false, the menu item is enabled.
		disabled: false,

		_fillContent: function(/*DomNode*/ source){
			// If button label is specified as srcNodeRef.innerHTML rather than
			// this.params.label, handle it here.
			if(source && !("label" in this.params)){
				this.set('label', source.innerHTML);
			}
		},

		buildRendering: function(){
			this.inherited(arguments);
			var label = this.id+"_text";
			domAttr.set(this.containerNode, "id", label);
			if(this.accelKeyNode){
				domAttr.set(this.accelKeyNode, "id", this.id + "_accel");
				label += " " + this.id + "_accel";
			}
			this.domNode.setAttribute("aria-labelledby", label);
			dom.setSelectable(this.domNode, false);
		},

		_onHover: function(){
			// summary:
			//		Handler when mouse is moved onto menu item
			// tags:
			//		protected
			this.getParent().onItemHover(this);
		},

		_onUnhover: function(){
			// summary:
			//		Handler when mouse is moved off of menu item,
			//		possibly to a child menu, or maybe to a sibling
			//		menuitem or somewhere else entirely.
			// tags:
			//		protected

			// if we are unhovering the currently selected item
			// then unselect it
			this.getParent().onItemUnhover(this);

			// When menu is hidden (collapsed) due to clicking a MenuItem and having it execute,
			// FF and IE don't generate an onmouseout event for the MenuItem.
			// So, help out _CssStateMixin in this case.
			this._set("hovering", false);
		},

		_onClick: function(evt){
			// summary:
			//		Internal handler for click events on MenuItem.
			// tags:
			//		private
			this.getParent().onItemClick(this, evt);
			event.stop(evt);
		},

		onClick: function(/*Event*/){
			// summary:
			//		User defined function to handle clicks
			// tags:
			//		callback
		},

		focus: function(){
			// summary:
			//		Focus on this MenuItem
			try{
				if(has("ie") == 8){
					// needed for IE8 which won't scroll TR tags into view on focus yet calling scrollIntoView creates flicker (#10275)
					this.containerNode.focus();
				}
				this.focusNode.focus();
			}catch(e){
				// this throws on IE (at least) in some scenarios
			}
		},

		_onFocus: function(){
			// summary:
			//		This is called by the focus manager when focus
			//		goes to this MenuItem or a child menu.
			// tags:
			//		protected
			this._setSelected(true);
			this.getParent()._onItemFocus(this);

			this.inherited(arguments);
		},

		_setSelected: function(selected){
			// summary:
			//		Indicate that this node is the currently selected one
			// tags:
			//		private

			/***
			 * TODO: remove this method and calls to it, when _onBlur() is working for MenuItem.
			 * Currently _onBlur() gets called when focus is moved from the MenuItem to a child menu.
			 * That's not supposed to happen, but the problem is:
			 * In order to allow dijit.popup's getTopPopup() to work,a sub menu's popupParent
			 * points to the parent Menu, bypassing the parent MenuItem... thus the
			 * MenuItem is not in the chain of active widgets and gets a premature call to
			 * _onBlur()
			 */

			domClass.toggle(this.domNode, "dijitMenuItemSelected", selected);
		},

		setLabel: function(/*String*/ content){
			// summary:
			//		Deprecated.   Use set('label', ...) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.MenuItem.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
			this.set("label", content);
		},

		setDisabled: function(/*Boolean*/ disabled){
			// summary:
			//		Deprecated.   Use set('disabled', bool) instead.
			// tags:
			//		deprecated
			kernel.deprecated("dijit.Menu.setDisabled() is deprecated.  Use set('disabled', bool) instead.", "", "2.0");
			this.set('disabled', disabled);
		},
		_setDisabledAttr: function(/*Boolean*/ value){
			// summary:
			//		Hook for attr('disabled', ...) to work.
			//		Enable or disable this menu item.

			this.focusNode.setAttribute('aria-disabled', value ? 'true' : 'false');
			this._set("disabled", value);
		},
		_setAccelKeyAttr: function(/*String*/ value){
			// summary:
			//		Hook for attr('accelKey', ...) to work.
			//		Set accelKey on this menu item.

			this.accelKeyNode.style.display=value?"":"none";
			this.accelKeyNode.innerHTML=value;
			//have to use colSpan to make it work in IE
			domAttr.set(this.containerNode,'colSpan',value?"1":"2");

			this._set("accelKey", value);
		}
	});
});

},
'dijit/layout/TabController':function(){
require({cache:{
'url:dijit/layout/templates/_TabButton.html':"<div role=\"presentation\" data-dojo-attach-point=\"titleNode\" data-dojo-attach-event='onclick:onClick'>\n    <div role=\"presentation\" class='dijitTabInnerDiv' data-dojo-attach-point='innerDiv'>\n        <div role=\"presentation\" class='dijitTabContent' data-dojo-attach-point='tabContent'>\n        \t<div role=\"presentation\" data-dojo-attach-point='focusNode'>\n\t\t        <img src=\"${_blankGif}\" alt=\"\" class=\"dijitIcon dijitTabButtonIcon\" data-dojo-attach-point='iconNode' />\n\t\t        <span data-dojo-attach-point='containerNode' class='tabLabel'></span>\n\t\t        <span class=\"dijitInline dijitTabCloseButton dijitTabCloseIcon\" data-dojo-attach-point='closeNode'\n\t\t        \t\tdata-dojo-attach-event='onclick: onClickCloseButton' role=\"presentation\">\n\t\t            <span data-dojo-attach-point='closeText' class='dijitTabCloseText'>[x]</span\n\t\t        ></span>\n\t\t\t</div>\n        </div>\n    </div>\n</div>\n"}});
define("dijit/layout/TabController", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/dom-attr", // domAttr.attr
	"dojo/dom-class", // domClass.toggle
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/lang", // lang.hitch lang.trim
	"./StackController",
	"../Menu",
	"../MenuItem",
	"dojo/text!./templates/_TabButton.html",
	"dojo/i18n!../nls/common"
], function(declare, dom, domAttr, domClass, i18n, lang, StackController, Menu, MenuItem, template){

/*=====
	var StackController = dijit.layout.StackController;
	var Menu = dijit.Menu;
	var MenuItem = dijit.MenuItem;
=====*/

	// module:
	//		dijit/layout/TabController
	// summary:
	// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	//		Used internally by `dijit.layout.TabContainer`.

	var TabButton = declare("dijit.layout._TabButton", StackController.StackButton, {
		// summary:
		//		A tab (the thing you click to select a pane).
		// description:
		//		Contains the title of the pane, and optionally a close-button to destroy the pane.
		//		This is an internal widget and should not be instantiated directly.
		// tags:
		//		private

		// baseClass: String
		//		The CSS class applied to the domNode.
		baseClass: "dijitTab",

		// Apply dijitTabCloseButtonHover when close button is hovered
		cssStateNodes: {
			closeNode: "dijitTabCloseButton"
		},

		templateString: template,

		// Override _FormWidget.scrollOnFocus.
		// Don't scroll the whole tab container into view when the button is focused.
		scrollOnFocus: false,

		buildRendering: function(){
			this.inherited(arguments);

			dom.setSelectable(this.containerNode, false);
		},

		startup: function(){
			this.inherited(arguments);
			var n = this.domNode;

			// Required to give IE6 a kick, as it initially hides the
			// tabs until they are focused on.
			setTimeout(function(){
				n.className = n.className;
			}, 1);
		},

		_setCloseButtonAttr: function(/*Boolean*/ disp){
			// summary:
			//		Hide/show close button
			this._set("closeButton", disp);
			domClass.toggle(this.innerDiv, "dijitClosable", disp);
			this.closeNode.style.display = disp ? "" : "none";
			if(disp){
				var _nlsResources = i18n.getLocalization("dijit", "common");
				if(this.closeNode){
					domAttr.set(this.closeNode,"title", _nlsResources.itemClose);
				}
				// add context menu onto title button
				this._closeMenu = new Menu({
					id: this.id+"_Menu",
					dir: this.dir,
					lang: this.lang,
					textDir: this.textDir,
					targetNodeIds: [this.domNode]
				});

				this._closeMenu.addChild(new MenuItem({
					label: _nlsResources.itemClose,
					dir: this.dir,
					lang: this.lang,
					textDir: this.textDir,
					onClick: lang.hitch(this, "onClickCloseButton")
				}));
			}else{
				if(this._closeMenu){
					this._closeMenu.destroyRecursive();
					delete this._closeMenu;
				}
			}
		},
		_setLabelAttr: function(/*String*/ content){
			// summary:
			//		Hook for set('label', ...) to work.
			// description:
			//		takes an HTML string.
			//		Inherited ToggleButton implementation will Set the label (text) of the button;
			//		Need to set the alt attribute of icon on tab buttons if no label displayed
			this.inherited(arguments);
			if(!this.showLabel && !this.params.title){
				this.iconNode.alt = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
			}
		},

		destroy: function(){
			if(this._closeMenu){
				this._closeMenu.destroyRecursive();
				delete this._closeMenu;
			}
			this.inherited(arguments);
		}
	});

	var TabController = declare("dijit.layout.TabController", StackController, {
		// summary:
		// 		Set of tabs (the things with titles and a close button, that you click to show a tab panel).
		//		Used internally by `dijit.layout.TabContainer`.
		// description:
		//		Lets the user select the currently shown pane in a TabContainer or StackContainer.
		//		TabController also monitors the TabContainer, and whenever a pane is
		//		added or deleted updates itself accordingly.
		// tags:
		//		private

		baseClass: "dijitTabController",

		templateString: "<div role='tablist' data-dojo-attach-event='onkeypress:onkeypress'></div>",

		// tabPosition: String
		//		Defines where tabs go relative to the content.
		//		"top", "bottom", "left-h", "right-h"
		tabPosition: "top",

		// buttonWidget: Constructor
		//		The tab widget to create to correspond to each page
		buttonWidget: TabButton,

		_rectifyRtlTabList: function(){
			// summary:
			//		For left/right TabContainer when page is RTL mode, rectify the width of all tabs to be equal, otherwise the tab widths are different in IE

			if(0 >= this.tabPosition.indexOf('-h')){ return; }
			if(!this.pane2button){ return; }

			var maxWidth = 0;
			for(var pane in this.pane2button){
				var ow = this.pane2button[pane].innerDiv.scrollWidth;
				maxWidth = Math.max(maxWidth, ow);
			}
			//unify the length of all the tabs
			for(pane in this.pane2button){
				this.pane2button[pane].innerDiv.style.width = maxWidth + 'px';
			}
		}
	});

	TabController.TabButton = TabButton;	// for monkey patching

	return TabController;
});

},
'dojo/cldr/supplemental':function(){
define("dojo/cldr/supplemental", ["../_base/kernel", "../_base/lang", "../i18n"], function(dojo, lang) {
	// module:
	//		dojo/cldr/supplemental
	// summary:
	//		TODOC

lang.getObject("cldr.supplemental", true, dojo);

dojo.cldr.supplemental.getFirstDayOfWeek = function(/*String?*/locale){
// summary: Returns a zero-based index for first day of the week
// description:
//		Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
//		e.g. Sunday (returns 0), or Monday (returns 1)

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/firstDay
	var firstDay = {/*default is 1=Monday*/
		mv:5,
		ae:6,af:6,bh:6,dj:6,dz:6,eg:6,er:6,et:6,iq:6,ir:6,jo:6,ke:6,kw:6,
		ly:6,ma:6,om:6,qa:6,sa:6,sd:6,so:6,sy:6,tn:6,ye:6,
		ar:0,as:0,az:0,bw:0,ca:0,cn:0,fo:0,ge:0,gl:0,gu:0,hk:0,
		il:0,'in':0,jm:0,jp:0,kg:0,kr:0,la:0,mh:0,mn:0,mo:0,mp:0,
		mt:0,nz:0,ph:0,pk:0,sg:0,th:0,tt:0,tw:0,um:0,us:0,uz:0,
		vi:0,zw:0
// variant. do not use?		gb:0,
	};

	var country = dojo.cldr.supplemental._region(locale);
	var dow = firstDay[country];
	return (dow === undefined) ? 1 : dow; /*Number*/
};

dojo.cldr.supplemental._region = function(/*String?*/locale){
	locale = dojo.i18n.normalizeLocale(locale);
	var tags = locale.split('-');
	var region = tags[1];
	if(!region){
		// IE often gives language only (#2269)
		// Arbitrary mappings of language-only locales to a country:
		region = {de:"de", en:"us", es:"es", fi:"fi", fr:"fr", he:"il", hu:"hu", it:"it",
			ja:"jp", ko:"kr", nl:"nl", pt:"br", sv:"se", zh:"cn"}[tags[0]];
	}else if(region.length == 4){
		// The ISO 3166 country code is usually in the second position, unless a
		// 4-letter script is given. See http://www.ietf.org/rfc/rfc4646.txt
		region = tags[2];
	}
	return region;
};

dojo.cldr.supplemental.getWeekend = function(/*String?*/locale){
// summary: Returns a hash containing the start and end days of the weekend
// description:
//		Returns a hash containing the start and end days of the weekend according to local custom using locale,
//		or by default in the user's locale.
//		e.g. {start:6, end:0}

	// from http://www.unicode.org/cldr/data/common/supplemental/supplementalData.xml:supplementalData/weekData/weekend{Start,End}
	var weekendStart = {/*default is 6=Saturday*/
		'in':0,
		af:4,dz:4,ir:4,om:4,sa:4,ye:4,
		ae:5,bh:5,eg:5,il:5,iq:5,jo:5,kw:5,ly:5,ma:5,qa:5,sd:5,sy:5,tn:5
	};

	var weekendEnd = {/*default is 0=Sunday*/
		af:5,dz:5,ir:5,om:5,sa:5,ye:5,
		ae:6,bh:5,eg:6,il:6,iq:6,jo:6,kw:6,ly:6,ma:6,qa:6,sd:6,sy:6,tn:6
	};

	var country = dojo.cldr.supplemental._region(locale);
	var start = weekendStart[country];
	var end = weekendEnd[country];
	if(start === undefined){start=6;}
	if(end === undefined){end=0;}
	return {start:start, end:end}; /*Object {start,end}*/
};

return dojo.cldr.supplemental;
});

},
'dijit/layout/_LayoutWidget':function(){
define("dijit/layout/_LayoutWidget", [
	"dojo/_base/lang", // lang.mixin
	"../_Widget",
	"../_Container",
	"../_Contained",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/window" // win.global
], function(lang, _Widget, _Container, _Contained,
	declare, domClass, domGeometry, domStyle, has, win){

/*=====
	var _Widget = dijit._Widget;
	var _Container = dijit._Container;
	var _Contained = dijit._Contained;
=====*/

	// module:
	//		dijit/layout/_LayoutWidget
	// summary:
	//		_LayoutWidget Base class for a _Container widget which is responsible for laying out its children.
	//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.


	return declare("dijit.layout._LayoutWidget", [_Widget, _Container, _Contained], {
		// summary:
		//		Base class for a _Container widget which is responsible for laying out its children.
		//		Widgets which mixin this code must define layout() to manage placement and sizing of the children.

		// baseClass: [protected extension] String
		//		This class name is applied to the widget's domNode
		//		and also may be used to generate names for sub nodes,
		//		for example dijitTabContainer-content.
		baseClass: "dijitLayoutContainer",

		// isLayoutContainer: [protected] Boolean
		//		Indicates that this widget is going to call resize() on its
		//		children widgets, setting their size, when they become visible.
		isLayoutContainer: true,

		buildRendering: function(){
			this.inherited(arguments);
			domClass.add(this.domNode, "dijitContainer");
		},

		startup: function(){
			// summary:
			//		Called after all the widgets have been instantiated and their
			//		dom nodes have been inserted somewhere under win.doc.body.
			//
			//		Widgets should override this method to do any initialization
			//		dependent on other widgets existing, and then call
			//		this superclass method to finish things off.
			//
			//		startup() in subclasses shouldn't do anything
			//		size related because the size of the widget hasn't been set yet.

			if(this._started){ return; }

			// Need to call inherited first - so that child widgets get started
			// up correctly
			this.inherited(arguments);

			// If I am a not being controlled by a parent layout widget...
			var parent = this.getParent && this.getParent();
			if(!(parent && parent.isLayoutContainer)){
				// Do recursive sizing and layout of all my descendants
				// (passing in no argument to resize means that it has to glean the size itself)
				this.resize();

				// Since my parent isn't a layout container, and my style *may be* width=height=100%
				// or something similar (either set directly or via a CSS class),
				// monitor when viewport size changes so that I can re-layout.
				this.connect(win.global, 'onresize', function(){
					// Using function(){} closure to ensure no arguments passed to resize().
					this.resize();
				});
			}
		},

		resize: function(changeSize, resultSize){
			// summary:
			//		Call this to resize a widget, or after its size has changed.
			// description:
			//		Change size mode:
			//			When changeSize is specified, changes the marginBox of this widget
			//			and forces it to relayout its contents accordingly.
			//			changeSize may specify height, width, or both.
			//
			//			If resultSize is specified it indicates the size the widget will
			//			become after changeSize has been applied.
			//
			//		Notification mode:
			//			When changeSize is null, indicates that the caller has already changed
			//			the size of the widget, or perhaps it changed because the browser
			//			window was resized.  Tells widget to relayout its contents accordingly.
			//
			//			If resultSize is also specified it indicates the size the widget has
			//			become.
			//
			//		In either mode, this method also:
			//			1. Sets this._borderBox and this._contentBox to the new size of
			//				the widget.  Queries the current domNode size if necessary.
			//			2. Calls layout() to resize contents (and maybe adjust child widgets).
			//
			// changeSize: Object?
			//		Sets the widget to this margin-box size and position.
			//		May include any/all of the following properties:
			//	|	{w: int, h: int, l: int, t: int}
			//
			// resultSize: Object?
			//		The margin-box size of this widget after applying changeSize (if
			//		changeSize is specified).  If caller knows this size and
			//		passes it in, we don't need to query the browser to get the size.
			//	|	{w: int, h: int}

			var node = this.domNode;

			// set margin box size, unless it wasn't specified, in which case use current size
			if(changeSize){
				domGeometry.setMarginBox(node, changeSize);
			}

			// If either height or width wasn't specified by the user, then query node for it.
			// But note that setting the margin box and then immediately querying dimensions may return
			// inaccurate results, so try not to depend on it.
			var mb = resultSize || {};
			lang.mixin(mb, changeSize || {});	// changeSize overrides resultSize
			if( !("h" in mb) || !("w" in mb) ){
				mb = lang.mixin(domGeometry.getMarginBox(node), mb);	// just use domGeometry.marginBox() to fill in missing values
			}

			// Compute and save the size of my border box and content box
			// (w/out calling domGeometry.getContentBox() since that may fail if size was recently set)
			var cs = domStyle.getComputedStyle(node);
			var me = domGeometry.getMarginExtents(node, cs);
			var be = domGeometry.getBorderExtents(node, cs);
			var bb = (this._borderBox = {
				w: mb.w - (me.w + be.w),
				h: mb.h - (me.h + be.h)
			});
			var pe = domGeometry.getPadExtents(node, cs);
			this._contentBox = {
				l: domStyle.toPixelValue(node, cs.paddingLeft),
				t: domStyle.toPixelValue(node, cs.paddingTop),
				w: bb.w - pe.w,
				h: bb.h - pe.h
			};

			// Callback for widget to adjust size of its children
			this.layout();
		},

		layout: function(){
			// summary:
			//		Widgets override this method to size and position their contents/children.
			//		When this is called this._contentBox is guaranteed to be set (see resize()).
			//
			//		This is called after startup(), and also when the widget's size has been
			//		changed.
			// tags:
			//		protected extension
		},

		_setupChild: function(/*dijit._Widget*/child){
			// summary:
			//		Common setup for initial children and children which are added after startup
			// tags:
			//		protected extension

			var cls = this.baseClass + "-child "
				+ (child.baseClass ? this.baseClass + "-" + child.baseClass : "");
			domClass.add(child.domNode, cls);
		},

		addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
			// Overrides _Container.addChild() to call _setupChild()
			this.inherited(arguments);
			if(this._started){
				this._setupChild(child);
			}
		},

		removeChild: function(/*dijit._Widget*/ child){
			// Overrides _Container.removeChild() to remove class added by _setupChild()
			var cls = this.baseClass + "-child"
					+ (child.baseClass ?
						" " + this.baseClass + "-" + child.baseClass : "");
			domClass.remove(child.domNode, cls);

			this.inherited(arguments);
		}
	});
});

},
'ibm/tivoli/simplesrm/srm/dijit/Overview/AssetsPod':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!ibm/tivoli/simplesrm/srm/dijit/Overview/Pod,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,dojo/DeferredList,ibm/tivoli/simplesrm/srm/dijit/BaguetteChart,ibm/tivoli/simplesrm/srm/dijit/MyAssetsGrid"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.AssetsPod");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.AssetsView");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.AssetDetails");

dojo.require("ibm.tivoli.simplesrm.srm.dijit.Overview.Pod");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("dojo.DeferredList");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.BaguetteChart");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyAssetsGrid");
//dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyCatalogRequestsGrid");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.AssetsPod", ibm.tivoli.simplesrm.srm.dijit.Overview.Pod,
{
	viewType: "ibm.tivoli.simplesrm.srm.dijit.Overview.AssetsView",
	detailsType: "ibm.tivoli.simplesrm.srm.dijit.Overview.AssetDetails",
	autoRefreshProperty:  "AssetsAutoRefresh",
	//configurable Pod parms
	os: 'MXASSET',   
    sr_object: 'ASSET',   
	fd: '',
	view_dialog: 'srmssviewasset',	
	label: "",
	
	postMixInProperties: function()
	{		
		console.log("Overview.AssetsPod.postMixInProperties os = " + this.os + " fd = "+ this.fd + " view_dialog = " + this.view_dialog + " ticket_object = " + this.sr_object );
		try {
		   //Get Pod headings from bundle
		   var key = 'AssetsPodHeading'; //default bundle key = SRRequestPodHeading
		   this.heading = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable")[key];
		   
		   var key = 'ShowMyAssetsLink';  
		   this.detailsLinkLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable")[key];
		   this.detailsUrl = "#requests";
		} catch(ex) {
			 console.log("Overview.AssetsPod.postMixInProperties - " + ex);
			 //Use control label as heading as last resort 
			 if ((this.heading==null || this.heading=="") && this.label!=null && this.label.length>0)
			     this.heading = this.label;
			 else
				 this.heading = "My Assets";
			 this.detailsLinkLabel = "Show All My Assets...";
		}
		
		this.inherited(arguments);
	},

	constructor: function()
	{
		console.log("Overview.AssetsPod.constructor ");
		if(invalidAssetGridColumnName != "")
		{
			//alert("Columns : "+invalidRequestGridColumnName+", configured for the 'Show All My Requests' dialog in the My Requests Pod do not exist. Edit the Self Service Center application and correct the columns property.");
			var invalidCol1 = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").InvalidColumn1;
			var invalidCol2 = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").InvalidColumn2;
			console.error(invalidCol1 +" "+invalidAssetGridColumnName +", "+invalidCol2);
			//alert(invalidCol1 +" "+invalidAssetGridColumnName +", "+invalidCol2);
		}
		dojo.subscribe("refreshpod", this, "_poll");
	},

	postCreate: function()
	{
		this.refresh();
		this.inherited(arguments);
	},
	
	/**
	 * Requery my asset data and update my UI
	 */
	refresh: function()
	{
		this._cancelPoll();
		var params = {};
		if (this.fd!=null && this.fd!='')
		   params._fd = this.fd;  //filtering domain
		params.os = this.os;   //OS name
		params.sr_object = this.sr_object;  //Main object

		var dq = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getAssets(params);
		dq.addCallbacks(dojo.hitch(this, this._updateData), dojo.hitch(this, this._refreshError));
	},

	/**
	 * Update the UI, given a new data set
	 */
	_firstStatusDate : null,      //used in polling
	_updateData: function(response)
	{
		try {
			this._cancelPoll();
			this._refreshErrorCount = 0;
			var requests = response.Requests;
			if(this._detailsData === requests){
				return;
			}
			requests.sort(function(a, b) 
			{
				// sort descending
				return a.CHANGEDATE < b.CHANGEDATE ? 1 : a.CHANGEDATE > b.CHANGEDATE ? -1 : 0;
			});
			//save newest status date
			if (requests.length>0) {
				var dt = dojo.date.stamp.fromISOString(requests[0].CHANGEDATE);
				if(dt) {
					this._mostRecent = dt.getTime();
					dt.setTime(this._mostRecent+60000);		//add a minute so polling gets only newest 				
					this._firstStatusDate = dojo.date.stamp.toISOString(dt); 				 
				}				
			}		 
			 				
			
			this._detailsData = requests;
			this._view.setData(requests);
			this._onDataReady();
		}
		catch(ex) {
			ibm.tivoli.logger.error("Overview.AssetsPod._updateData failure",ex);
		}
		finally {
			this._resetPoll();
		}
	},
	
	//Check if any assets have a more recent changedate 
	_poll: function()
	{
		//may need a better approach to seeing if anything changed.
		var params = {};
		if (this.fd && this.fd!='')
		   params._fd = this.fd;  //Pod properties
		params.os = this.os;
		params.sr_object = this.sr_object;

		if(this._firstStatusDate != null)			
		    params.changedate = "~gt~" +this._firstStatusDate; 		
		var dq = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getAssets(params);
		dq.addCallbacks(dojo.hitch(this, this._checkUpdateAssets), dojo.hitch(this, this.__refreshError));
	},
	
	//If any assets have a newer status date, then refresh the pod
	_checkUpdateAssets: function(response) 	{
		this._cancelPoll();
		var requests = response.Requests;
		if(requests.length > 0) 
			this.refresh();
		else
			this._resetPoll();		
	},
	
	_onDataReady: function()
	{
		this.inherited(arguments);
	},

	//called when yuo click Show All My Assets
	onShowDetails: function()
	{
		var bNeedsConnect = undefined == this._details;
		this.inherited(arguments);
		if(bNeedsConnect && this._details) {	// only connect once
			this.connect(this._details.detailsWidget, "onRefresh", this._updateData);
		}
		//pass view dialog and ObjectStructure parms to Grid 
		if (this._details && this._details.detailsWidget._setViewDialog) { 
			this._details.detailsWidget._setViewDialog(this.view_dialog);
			this._details.detailsWidget._setFD(this.fd);
			this._details.detailsWidget._setOS(this.os);
			this._details.detailsWidget._setTicketObject(this.sr_object);						 
		}
	}
});

//Handles the main view of the top 5 items.
//Contains BaguetteChart, Overview.DataTable
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.AssetsView", 
		[ibm.tivoli.simplesrm.srm.dijit.Overview.View, ibm.tivoli.simplesrm.srm.dijit.ShowRequestDetails],
{
	widgetsInTemplate: true,
	templateString: '<div>\n' +
					'	<div dojoType="ibm.tivoli.simplesrm.srm.dijit.BaguetteChart" barHeight="15" captionHeight="13" captionFontSize="10"\n' + 
					'			showTotal="true" totalLegend="${totalStr}"\n' + 
					'		dojoAttachPoint="baguetteChart" style="overflow:hidden; margin-bottom: 10px;"></div>\n' +
					'	<div dojoType="ibm.tivoli.simplesrm.srm.dijit.Overview.DataTable" dojoAttachPoint="dataTable" heading="${tableCaption}"></div>\n' +
					'</div>\n',
	tableCaption: "",
	totalStr: "Total",
	showDetais: "Show details",
	view_dialog: "srmssviewsr",  //TODO
	constructor: function()
	{
		console.log("Overview.AssetsView.ctor");
	},
	
	postMixInProperties: function()
	{
		console.log("Overview.AssetsView.postMixInProperties");
		this.tableCaption = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").AssetActivity;
		this.totalStr =     dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Total;
		this.showDetails =	dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").ShowDetails;
		this.inherited(arguments);
	},
	
	//Add top 5 rows based on status date
	setData: function(requests)
	{
		this.clear();
		this._detailsData = requests;
		var status_stats = {srm_status_count: [], srm_unique_stati: 0};
		var l = requests.length;
		var maxoverview =  Math.min(5, l);
		for(var i = 0; i < l; ++i) {
			var cmr = requests[i];
			var status = cmr.StatusString;
			if(i < maxoverview) {
				var link = "<a href='#req_"+ cmr.id +"' title='"+this.showDetails.htmlencode()+"'>" +(cmr.ASSETNUM ? cmr.ASSETNUM.htmlencode() : '...')+ "</a>";
				//var link = "<a href='#req_"+ cmr.id +"' title='"+this.showDetails.htmlencode()+"'>" +(cmr.DESCRIPTION ? cmr.DESCRIPTION.htmlencode() : '...')+ "</a>";
				this.dataTable.addRow(link, status);
			}
			if('number' == typeof status_stats.srm_status_count[status]) {
				++status_stats.srm_status_count[status];
			}
			else {
				status_stats.srm_status_count[status] = 1;
				++status_stats.srm_unique_stati;
			}
		}
		if(l > 0) {
			var links = dojo.query("a", this.dataTable.domNode);
			for(var i = 0; i < links.length; ++i) {
				this.connect(links[i], "onclick", this._showRequestDetails);
			}
		}
		if(l > 0){
			this._refreshBaguetteChart(status_stats);
		}
		else{ 
			this.dataTable.addRow(dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").NoAssetsAssigned, "");
		}
	},

	
	//launch View asset dialog 
	_viewAsset: function(assetID)  
	{ 
		console.log("Overview.AssetsView._viewAsset: launch dialog - " + this.view_dialog + " ticketUID = ",assetID);		
		arguments.caller=null; //running into a IE bug in stacktrace()
		
	    var navid = "mx107";
	    var nav = dojo.query("div.srmnavigator");  		
	    if (nav.length>0)
		    navid = nav[0].id;
	    sendEvent(this.view_dialog,  navid,  assetID);
	},
	
	//clear table
	clear: function()
	{
		this.dataTable.clear();
		if(this.baguetteChart){
			this.baguetteChart.setData([]);
		}
	},
	
	_refreshBaguetteChart: function(status_stats)
	{
		if(!this.baguetteChart){
			return;
		}

		console.log("Overview.AssetsView._refreshBaguetteChart: refreshing");

		var counts = status_stats.srm_status_count;
		counts.sort();
		// set stripe graph data using colors generated by walking around the color wheel
		var stripeData = [];
		for(var s in counts) {
			stripeData.push({name: s, value: counts[s], color: ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.getDefaultColor(s)});
		}
		this.baguetteChart.setData(stripeData);
	},
	
	//Called when you click a row in the table to display the asset dialog
	_showRequestDetails: function(evt)
	{
		console.log(evt);
		try {
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			var href = evt.target.href;
			var reqid = href.substring(href.lastIndexOf("_")+1);
			console.log("Overview.AssetsView._showRequestDetails(%s)", reqid);
			for(var i = 0; i < this._detailsData.length; ++i) {
				var req = this._detailsData[i];
				if(reqid == req.id) {
					console.log("Overview.AssetsView._showRequestDetails reqid = ", req.id);					
					this._viewAsset(reqid);					
					break;
				}
			}
		}
		catch(ex){
			console.warn(ex);
		}
	}
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.AssetDetails", ibm.tivoli.simplesrm.srm.dijit.Overview.Details,
{
	headingText: "Manage Requests",
	detailsType: "ibm.tivoli.simplesrm.srm.dijit.MyAssetsGrid",
	
	_cshKey: "",
	
	constructor: function()
	{
		//TODO 
		var key = "MyAssets";
		//var key = this.sr_object + "MyRequests";
		try {			  
		    this.headingText = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable")[key];
		} catch(ex) {
			console.log("Overview.AssetDetails.constructor - " + ex);
			this.headingText = "My Assets";
		}
		if (this.headingText==undefined) {
			console.log("Overview.AssetDetails.constructor:  undefined key - " + key);
			this.headingText = "My Assets";
			
		}

		var localText = dojo.locale;
		var localMatch = localText.match(/-/gi);
		if(localMatch != null)
		{
			localText = localText.split('-')[0];
		}
		
      this._cshKey = "/help/index.jsp?topic=/com.ibm.sccd.doc/selfserv/c_my_assets_pod.html";
		//this._cshKey = "/maximohelp/"+localText+"/mergedProjects/srmssctr/helpmyrequestpodgrid.htm";
	},
	
	refresh: function(data_set)
	{
	     //fpb - startup not called in dojo 1.4!  added this code 		
		if (this.detailsWidget && this.detailsWidget._initialization_complete!=undefined && this.detailsWidget._initialization_complete!= true) {
			console.log("Overview.AssetDetails.refresh - start AssetsGrid");
			this.detailsWidget.startup();
		}
		
		if(data_set) {
			this._detailsData = data_set;
			this.detailsWidget.clearGrid();
			this.detailsWidget._loadGrid(this._detailsData);
		}
		else {
			this.inherited(arguments);	// will refresh detailsWidget
		}
	},
	resize: function()
	{
		this.inherited(arguments);
		//var containerSz = dojo.contentBox(this.containerNode)
		//dojo.style(this.detailsWidget.id + "_grid_container", "height", containerSz.h + "px");
		this.detailsWidget.simpleGrid.resize();
		this.detailsWidget.baguetteChart.resize();
	}
});


});

},
'dijit/_base/manager':function(){
define("dijit/_base/manager", [
	"dojo/_base/array",
	"dojo/_base/config", // defaultDuration
	"../registry",
	".."	// for setting exports to dijit namespace
], function(array, config, registry, dijit){

	// module:
	//		dijit/_base/manager
	// summary:
	//		Shim to methods on registry, plus a few other declarations.
	//		New code should access dijit/registry directly when possible.

	/*=====
	dijit.byId = function(id){
		// summary:
		//		Returns a widget by it's id, or if passed a widget, no-op (like dom.byId())
		// id: String|dijit._Widget
		return registry.byId(id); // dijit._Widget
	};

	dijit.getUniqueId = function(widgetType){
		// summary:
		//		Generates a unique id for a given widgetType
		// widgetType: String
		return registry.getUniqueId(widgetType); // String
	};

	dijit.findWidgets = function(root){
		// summary:
		//		Search subtree under root returning widgets found.
		//		Doesn't search for nested widgets (ie, widgets inside other widgets).
		// root: DOMNode
		return registry.findWidgets(root);
	};

	dijit._destroyAll = function(){
		// summary:
		//		Code to destroy all widgets and do other cleanup on page unload

		return registry._destroyAll();
	};

	dijit.byNode = function(node){
		// summary:
		//		Returns the widget corresponding to the given DOMNode
		// node: DOMNode
		return registry.byNode(node); // dijit._Widget
	};

	dijit.getEnclosingWidget = function(node){
		// summary:
		//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
		//		the node is not contained within the DOM tree of any widget
		// node: DOMNode
		return registry.getEnclosingWidget(node);
	};
	=====*/
	array.forEach(["byId", "getUniqueId", "findWidgets", "_destroyAll", "byNode", "getEnclosingWidget"], function(name){
		dijit[name] = registry[name];
	});

	/*=====
	dojo.mixin(dijit, {
		// defaultDuration: Integer
		//		The default fx.animation speed (in ms) to use for all Dijit
		//		transitional fx.animations, unless otherwise specified
		//		on a per-instance basis. Defaults to 200, overrided by
		//		`djConfig.defaultDuration`
		defaultDuration: 200
	});
	=====*/
	dijit.defaultDuration = config["defaultDuration"] || 200;

	return dijit;
});

},
'dijit/popup':function(){
define("dijit/popup", [
	"dojo/_base/array", // array.forEach array.some
	"dojo/aspect",
	"dojo/_base/connect",	// connect._keypress
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.isDescendant
	"dojo/dom-attr", // domAttr.set
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy
	"dojo/dom-geometry", // domGeometry.isBodyLtr
	"dojo/dom-style", // domStyle.set
	"dojo/_base/event", // event.stop
	"dojo/keys",
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/_base/sniff", // has("ie") has("mozilla")
	"dojo/_base/window", // win.body
	"./place",
	"./BackgroundIframe",
	"."	// dijit (defining dijit.popup to match API doc)
], function(array, aspect, connect, declare, dom, domAttr, domConstruct, domGeometry, domStyle, event, keys, lang, on, has, win,
			place, BackgroundIframe, dijit){

	// module:
	//		dijit/popup
	// summary:
	//		Used to show drop downs (ex: the select list of a ComboBox)
	//		or popups (ex: right-click context menus)


	/*=====
	dijit.popup.__OpenArgs = function(){
		// popup: Widget
		//		widget to display
		// parent: Widget
		//		the button etc. that is displaying this popup
		// around: DomNode
		//		DOM node (typically a button); place popup relative to this node.  (Specify this *or* "x" and "y" parameters.)
		// x: Integer
		//		Absolute horizontal position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		// y: Integer
		//		Absolute vertical position (in pixels) to place node at.  (Specify this *or* "around" parameter.)
		// orient: Object|String
		//		When the around parameter is specified, orient should be a list of positions to try, ex:
		//	|	[ "below", "above" ]
		//		For backwards compatibility it can also be an (ordered) hash of tuples of the form
		//		(around-node-corner, popup-node-corner), ex:
		//	|	{ "BL": "TL", "TL": "BL" }
		//		where BL means "bottom left" and "TL" means "top left", etc.
		//
		//		dijit.popup.open() tries to position the popup according to each specified position, in order,
		//		until the popup appears fully within the viewport.
		//
		//		The default value is ["below", "above"]
		//
		//		When an (x,y) position is specified rather than an around node, orient is either
		//		"R" or "L".  R (for right) means that it tries to put the popup to the right of the mouse,
		//		specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
		//		fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
		//		and the top-right corner.
		// onCancel: Function
		//		callback when user has canceled the popup by
		//			1. hitting ESC or
		//			2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
		//			   i.e. whenever popupWidget.onCancel() is called, args.onCancel is called
		// onClose: Function
		//		callback whenever this popup is closed
		// onExecute: Function
		//		callback when user "executed" on the popup/sub-popup by selecting a menu choice, etc. (top menu only)
		// padding: dijit.__Position
		//		adding a buffer around the opening position. This is only useful when around is not set.
		this.popup = popup;
		this.parent = parent;
		this.around = around;
		this.x = x;
		this.y = y;
		this.orient = orient;
		this.onCancel = onCancel;
		this.onClose = onClose;
		this.onExecute = onExecute;
		this.padding = padding;
	}
	=====*/

	/*=====
	dijit.popup = {
		// summary:
		//		Used to show drop downs (ex: the select list of a ComboBox)
		//		or popups (ex: right-click context menus).
		//
		//		Access via require(["dijit/popup"], function(popup){ ... }).

		moveOffScreen: function(widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.
			// widget: dijit._WidgetBase
			//		The widget
		},

		hide: function(widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			// 		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.
			// widget: dijit._WidgetBase
			//		The widget
		},

		open: function(args){
			// summary:
			//		Popup the widget at the specified position
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.
			// args: dijit.popup.__OpenArgs
			//		Parameters
			return {};	// Object specifying which position was chosen
		},

		close: function(popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.
			// widget: dijit._WidgetBase?
			//		The widget, optional
		}
	};
	=====*/

	var PopupManager = declare(null, {
		// _stack: dijit._Widget[]
		//		Stack of currently popped up widgets.
		//		(someone opened _stack[0], and then it opened _stack[1], etc.)
		_stack: [],

		// _beginZIndex: Number
		//		Z-index of the first popup.   (If first popup opens other
		//		popups they get a higher z-index.)
		_beginZIndex: 1000,

		_idGen: 1,

		_createWrapper: function(/*Widget*/ widget){
			// summary:
			//		Initialization for widgets that will be used as popups.
			//		Puts widget inside a wrapper DIV (if not already in one),
			//		and returns pointer to that wrapper DIV.

			var wrapper = widget._popupWrapper,
				node = widget.domNode;

			if(!wrapper){
				// Create wrapper <div> for when this widget [in the future] will be used as a popup.
				// This is done early because of IE bugs where creating/moving DOM nodes causes focus
				// to go wonky, see tests/robot/Toolbar.html to reproduce
				wrapper = domConstruct.create("div",{
					"class":"dijitPopup",
					style:{ display: "none"},
					role: "presentation"
				}, win.body());
				wrapper.appendChild(node);

				var s = node.style;
				s.display = "";
				s.visibility = "";
				s.position = "";
				s.top = "0px";

				widget._popupWrapper = wrapper;
				aspect.after(widget, "destroy", function(){
					domConstruct.destroy(wrapper);
					delete widget._popupWrapper;
				});
			}

			return wrapper;
		},

		moveOffScreen: function(/*Widget*/ widget){
			// summary:
			//		Moves the popup widget off-screen.
			//		Do not use this method to hide popups when not in use, because
			//		that will create an accessibility issue: the offscreen popup is
			//		still in the tabbing order.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			domStyle.set(wrapper, {
				visibility: "hidden",
				top: "-9999px",		// prevent transient scrollbar causing misalign (#5776), and initial flash in upper left (#10111)
				display: ""
			});
		},

		hide: function(/*Widget*/ widget){
			// summary:
			//		Hide this popup widget (until it is ready to be shown).
			//		Initialization for widgets that will be used as popups
			//
			// 		Also puts widget inside a wrapper DIV (if not already in one)
			//
			//		If popup widget needs to layout it should
			//		do so when it is made visible, and popup._onShow() is called.

			// Create wrapper if not already there
			var wrapper = this._createWrapper(widget);

			domStyle.set(wrapper, "display", "none");
		},

		getTopPopup: function(){
			// summary:
			//		Compute the closest ancestor popup that's *not* a child of another popup.
			//		Ex: For a TooltipDialog with a button that spawns a tree of menus, find the popup of the button.
			var stack = this._stack;
			for(var pi=stack.length-1; pi > 0 && stack[pi].parent === stack[pi-1].widget; pi--){
				/* do nothing, just trying to get right value for pi */
			}
			return stack[pi];
		},

		open: function(/*dijit.popup.__OpenArgs*/ args){
			// summary:
			//		Popup the widget at the specified position
			//
			// example:
			//		opening at the mouse position
			//		|		popup.open({popup: menuWidget, x: evt.pageX, y: evt.pageY});
			//
			// example:
			//		opening the widget as a dropdown
			//		|		popup.open({parent: this, popup: menuWidget, around: this.domNode, onClose: function(){...}});
			//
			//		Note that whatever widget called dijit.popup.open() should also listen to its own _onBlur callback
			//		(fired from _base/focus.js) to know that focus has moved somewhere else and thus the popup should be closed.

			var stack = this._stack,
				widget = args.popup,
				orient = args.orient || ["below", "below-alt", "above", "above-alt"],
				ltr = args.parent ? args.parent.isLeftToRight() : domGeometry.isBodyLtr(),
				around = args.around,
				id = (args.around && args.around.id) ? (args.around.id+"_dropdown") : ("popup_"+this._idGen++);

			// If we are opening a new popup that isn't a child of a currently opened popup, then
			// close currently opened popup(s).   This should happen automatically when the old popups
			// gets the _onBlur() event, except that the _onBlur() event isn't reliable on IE, see [22198].
			while(stack.length && (!args.parent || !dom.isDescendant(args.parent.domNode, stack[stack.length-1].widget.domNode))){
				this.close(stack[stack.length-1].widget);
			}

			// Get pointer to popup wrapper, and create wrapper if it doesn't exist
			var wrapper = this._createWrapper(widget);


			domAttr.set(wrapper, {
				id: id,
				style: {
					zIndex: this._beginZIndex + stack.length
				},
				"class": "dijitPopup " + (widget.baseClass || widget["class"] || "").split(" ")[0] +"Popup",
				dijitPopupParent: args.parent ? args.parent.id : ""
			});

			if(has("ie") || has("mozilla")){
				if(!widget.bgIframe){
					// setting widget.bgIframe triggers cleanup in _Widget.destroy()
					widget.bgIframe = new BackgroundIframe(wrapper);
				}
			}

			// position the wrapper node and make it visible
			var best = around ?
				place.around(wrapper, around, orient, ltr, widget.orient ? lang.hitch(widget, "orient") : null) :
				place.at(wrapper, args, orient == 'R' ? ['TR','BR','TL','BL'] : ['TL','BL','TR','BR'], args.padding);

			wrapper.style.display = "";
			wrapper.style.visibility = "visible";
			widget.domNode.style.visibility = "visible";	// counteract effects from _HasDropDown

			var handlers = [];

			// provide default escape and tab key handling
			// (this will work for any widget, not just menu)
			handlers.push(on(wrapper, connect._keypress, lang.hitch(this, function(evt){
				if(evt.charOrCode == keys.ESCAPE && args.onCancel){
					event.stop(evt);
					args.onCancel();
				}else if(evt.charOrCode === keys.TAB){
					event.stop(evt);
					var topPopup = this.getTopPopup();
					if(topPopup && topPopup.onCancel){
						topPopup.onCancel();
					}
				}
			})));

			// watch for cancel/execute events on the popup and notify the caller
			// (for a menu, "execute" means clicking an item)
			if(widget.onCancel && args.onCancel){
				handlers.push(widget.on("cancel", args.onCancel));
			}

			handlers.push(widget.on(widget.onExecute ? "execute" : "change", lang.hitch(this, function(){
				var topPopup = this.getTopPopup();
				if(topPopup && topPopup.onExecute){
					topPopup.onExecute();
				}
			})));

			stack.push({
				widget: widget,
				parent: args.parent,
				onExecute: args.onExecute,
				onCancel: args.onCancel,
				onClose: args.onClose,
				handlers: handlers
			});

			if(widget.onOpen){
				// TODO: in 2.0 standardize onShow() (used by StackContainer) and onOpen() (used here)
				widget.onOpen(best);
			}

			return best;
		},

		close: function(/*Widget?*/ popup){
			// summary:
			//		Close specified popup and any popups that it parented.
			//		If no popup is specified, closes all popups.

			var stack = this._stack;

			// Basically work backwards from the top of the stack closing popups
			// until we hit the specified popup, but IIRC there was some issue where closing
			// a popup would cause others to close too.  Thus if we are trying to close B in [A,B,C]
			// closing C might close B indirectly and then the while() condition will run where stack==[A]...
			// so the while condition is constructed defensively.
			while((popup && array.some(stack, function(elem){return elem.widget == popup;})) ||
				(!popup && stack.length)){
				var top = stack.pop(),
					widget = top.widget,
					onClose = top.onClose;

				if(widget.onClose){
					// TODO: in 2.0 standardize onHide() (used by StackContainer) and onClose() (used here)
					widget.onClose();
				}

				var h;
				while(h = top.handlers.pop()){ h.remove(); }

				// Hide the widget and it's wrapper unless it has already been destroyed in above onClose() etc.
				if(widget && widget.domNode){
					this.hide(widget);
				}

				if(onClose){
					onClose();
				}
			}
		}
	});

	return (dijit.popup = new PopupManager());
});

},
'dijit/layout/StackController':function(){
define("dijit/layout/StackController", [
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/sniff", // has("ie")
	"../focus",		// focus.focus()
	"../registry",	// registry.byId
	"../_Widget",
	"../_TemplatedMixin",
	"../_Container",
	"../form/ToggleButton",
	"dojo/i18n!../nls/common"
], function(array, declare, event, keys, lang, has,
			focus, registry, _Widget, _TemplatedMixin, _Container, ToggleButton){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _Container = dijit._Container;
	var ToggleButton = dijit.form.ToggleButton;
=====*/

	// module:
	//		dijit/layout/StackController
	// summary:
	//		Set of buttons to select a page in a `dijit.layout.StackContainer`

	var StackButton = declare("dijit.layout._StackButton", ToggleButton, {
		// summary:
		//		Internal widget used by StackContainer.
		// description:
		//		The button-like or tab-like object you click to select or delete a page
		// tags:
		//		private

		// Override _FormWidget.tabIndex.
		// StackContainer buttons are not in the tab order by default.
		// Probably we should be calling this.startupKeyNavChildren() instead.
		tabIndex: "-1",

		// closeButton: Boolean
		//		When true, display close button for this tab
		closeButton: false,
		
		_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
			this.inherited(arguments);
			this.focusNode.removeAttribute("aria-pressed");
		},

		buildRendering: function(/*Event*/ evt){
			this.inherited(arguments);
			(this.focusNode || this.domNode).setAttribute("role", "tab");
		},

		onClick: function(/*Event*/ /*===== evt =====*/){
			// summary:
			//		This is for TabContainer where the tabs are <span> rather than button,
			//		so need to set focus explicitly (on some browsers)
			//		Note that you shouldn't override this method, but you can connect to it.
			focus.focus(this.focusNode);

			// ... now let StackController catch the event and tell me what to do
		},

		onClickCloseButton: function(/*Event*/ evt){
			// summary:
			//		StackContainer connects to this function; if your widget contains a close button
			//		then clicking it should call this function.
			//		Note that you shouldn't override this method, but you can connect to it.
			evt.stopPropagation();
		}
	});


	var StackController = declare("dijit.layout.StackController", [_Widget, _TemplatedMixin, _Container], {
		// summary:
		//		Set of buttons to select a page in a `dijit.layout.StackContainer`
		// description:
		//		Monitors the specified StackContainer, and whenever a page is
		//		added, deleted, or selected, updates itself accordingly.

		baseClass: "dijitStackController",

		templateString: "<span role='tablist' data-dojo-attach-event='onkeypress'></span>",

		// containerId: [const] String
		//		The id of the page container that I point to
		containerId: "",

		// buttonWidget: [const] Constructor
		//		The button widget to create to correspond to each page
		buttonWidget: StackButton,

		constructor: function(){
			this.pane2button = {};		// mapping from pane id to buttons
			this.pane2connects = {};	// mapping from pane id to this.connect() handles
			this.pane2watches = {};		// mapping from pane id to watch() handles
		},

		postCreate: function(){
			this.inherited(arguments);

			// Listen to notifications from StackContainer
			this.subscribe(this.containerId+"-startup", "onStartup");
			this.subscribe(this.containerId+"-addChild", "onAddChild");
			this.subscribe(this.containerId+"-removeChild", "onRemoveChild");
			this.subscribe(this.containerId+"-selectChild", "onSelectChild");
			this.subscribe(this.containerId+"-containerKeyPress", "onContainerKeyPress");
		},

		onStartup: function(/*Object*/ info){
			// summary:
			//		Called after StackContainer has finished initializing
			// tags:
			//		private
			array.forEach(info.children, this.onAddChild, this);
			if(info.selected){
				// Show button corresponding to selected pane (unless selected
				// is null because there are no panes)
				this.onSelectChild(info.selected);
			}
		},

		destroy: function(){
			for(var pane in this.pane2button){
				this.onRemoveChild(registry.byId(pane));
			}
			this.inherited(arguments);
		},

		onAddChild: function(/*dijit._Widget*/ page, /*Integer?*/ insertIndex){
			// summary:
			//		Called whenever a page is added to the container.
			//		Create button corresponding to the page.
			// tags:
			//		private

			// create an instance of the button widget
			// (remove typeof buttonWidget == string support in 2.0)
			var cls = lang.isString(this.buttonWidget) ? lang.getObject(this.buttonWidget) : this.buttonWidget;
			var button = new cls({
				id: this.id + "_" + page.id,
				label: page.title,
				dir: page.dir,
				lang: page.lang,
				textDir: page.textDir,
				showLabel: page.showTitle,
				iconClass: page.iconClass,
				closeButton: page.closable,
				title: page.tooltip
			});
			button.focusNode.setAttribute("aria-selected", "false");


			// map from page attribute to corresponding tab button attribute
			var pageAttrList = ["title", "showTitle", "iconClass", "closable", "tooltip"],
				buttonAttrList = ["label", "showLabel", "iconClass", "closeButton", "title"];

			// watch() so events like page title changes are reflected in tab button
			this.pane2watches[page.id] = array.map(pageAttrList, function(pageAttr, idx){
				return page.watch(pageAttr, function(name, oldVal, newVal){
					button.set(buttonAttrList[idx], newVal);
				});
			});

			// connections so that clicking a tab button selects the corresponding page
			this.pane2connects[page.id] = [
				this.connect(button, 'onClick', lang.hitch(this,"onButtonClick", page)),
				this.connect(button, 'onClickCloseButton', lang.hitch(this,"onCloseButtonClick", page))
			];

			this.addChild(button, insertIndex);
			this.pane2button[page.id] = button;
			page.controlButton = button;	// this value might be overwritten if two tabs point to same container
			if(!this._currentChild){ // put the first child into the tab order
				button.focusNode.setAttribute("tabIndex", "0");
				button.focusNode.setAttribute("aria-selected", "true");
				this._currentChild = page;
			}
			// make sure all tabs have the same length
			if(!this.isLeftToRight() && has("ie") && this._rectifyRtlTabList){
				this._rectifyRtlTabList();
			}
		},

		onRemoveChild: function(/*dijit._Widget*/ page){
			// summary:
			//		Called whenever a page is removed from the container.
			//		Remove the button corresponding to the page.
			// tags:
			//		private

			if(this._currentChild === page){ this._currentChild = null; }

			// disconnect/unwatch connections/watches related to page being removed
			array.forEach(this.pane2connects[page.id], lang.hitch(this, "disconnect"));
			delete this.pane2connects[page.id];
			array.forEach(this.pane2watches[page.id], function(w){ w.unwatch(); });
			delete this.pane2watches[page.id];

			var button = this.pane2button[page.id];
			if(button){
				this.removeChild(button);
				delete this.pane2button[page.id];
				button.destroy();
			}
			delete page.controlButton;
		},

		onSelectChild: function(/*dijit._Widget*/ page){
			// summary:
			//		Called when a page has been selected in the StackContainer, either by me or by another StackController
			// tags:
			//		private

			if(!page){ return; }

			if(this._currentChild){
				var oldButton=this.pane2button[this._currentChild.id];
				oldButton.set('checked', false);
				oldButton.focusNode.setAttribute("aria-selected", "false");
				oldButton.focusNode.setAttribute("tabIndex", "-1");
			}

			var newButton=this.pane2button[page.id];
			newButton.set('checked', true);
			newButton.focusNode.setAttribute("aria-selected", "true");
			this._currentChild = page;
			newButton.focusNode.setAttribute("tabIndex", "0");
			var container = registry.byId(this.containerId);
			container.containerNode.setAttribute("aria-labelledby", newButton.id);
		},

		onButtonClick: function(/*dijit._Widget*/ page){
			// summary:
			//		Called whenever one of my child buttons is pressed in an attempt to select a page
			// tags:
			//		private

			if(this._currentChild.id === page.id) {
				//In case the user clicked the checked button, keep it in the checked state because it remains to be the selected stack page.
				var button=this.pane2button[page.id];
				button.set('checked', true);
			}
			var container = registry.byId(this.containerId);
			container.selectChild(page);
		},

		onCloseButtonClick: function(/*dijit._Widget*/ page){
			// summary:
			//		Called whenever one of my child buttons [X] is pressed in an attempt to close a page
			// tags:
			//		private

			var container = registry.byId(this.containerId);
			container.closeChild(page);
			if(this._currentChild){
				var b = this.pane2button[this._currentChild.id];
				if(b){
					focus.focus(b.focusNode || b.domNode);
				}
			}
		},

		// TODO: this is a bit redundant with forward, back api in StackContainer
		adjacent: function(/*Boolean*/ forward){
			// summary:
			//		Helper for onkeypress to find next/previous button
			// tags:
			//		private

			if(!this.isLeftToRight() && (!this.tabPosition || /top|bottom/.test(this.tabPosition))){ forward = !forward; }
			// find currently focused button in children array
			var children = this.getChildren();
			var current = array.indexOf(children, this.pane2button[this._currentChild.id]);
			// pick next button to focus on
			var offset = forward ? 1 : children.length - 1;
			return children[ (current + offset) % children.length ]; // dijit._Widget
		},

		onkeypress: function(/*Event*/ e){
			// summary:
			//		Handle keystrokes on the page list, for advancing to next/previous button
			//		and closing the current page if the page is closable.
			// tags:
			//		private

			if(this.disabled || e.altKey ){ return; }
			var forward = null;
			if(e.ctrlKey || !e._djpage){
				switch(e.charOrCode){
					case keys.LEFT_ARROW:
					case keys.UP_ARROW:
						if(!e._djpage){ forward = false; }
						break;
					case keys.PAGE_UP:
						if(e.ctrlKey){ forward = false; }
						break;
					case keys.RIGHT_ARROW:
					case keys.DOWN_ARROW:
						if(!e._djpage){ forward = true; }
						break;
					case keys.PAGE_DOWN:
						if(e.ctrlKey){ forward = true; }
						break;
					case keys.HOME:
					case keys.END:
						var children = this.getChildren();
						if(children && children.length){
							children[e.charOrCode == keys.HOME ? 0 : children.length-1].onClick();
						}
						event.stop(e);
						break;
					case keys.DELETE:
						if(this._currentChild.closable){
							this.onCloseButtonClick(this._currentChild);
						}
						event.stop(e);
						break;
					default:
						if(e.ctrlKey){
							if(e.charOrCode === keys.TAB){
								this.adjacent(!e.shiftKey).onClick();
								event.stop(e);
							}else if(e.charOrCode == "w"){
								if(this._currentChild.closable){
									this.onCloseButtonClick(this._currentChild);
								}
								event.stop(e); // avoid browser tab closing.
							}
						}
				}
				// handle next/previous page navigation (left/right arrow, etc.)
				if(forward !== null){
					this.adjacent(forward).onClick();
					event.stop(e);
				}
			}
		},

		onContainerKeyPress: function(/*Object*/ info){
			// summary:
			//		Called when there was a keypress on the container
			// tags:
			//		private
			info.e._djpage = info.page;
			this.onkeypress(info.e);
		}
	});

	StackController.StackButton = StackButton;	// for monkey patching

	return StackController;
});

},
'ibm/tivoli/tip/dijit/Widget':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/tip/dijit/nls/resources","dojo/require!dijit/_Widget,ibm/tivoli/tip/dijit/Tooltip,ibm/tivoli/tip/dijit/Images"], function(dijit,dojo,dojox){
dojo.provide("ibm.tivoli.tip.dijit.Widget"); 

dojo.require("dijit._Widget");
dojo.require("ibm.tivoli.tip.dijit.Tooltip");
dojo.require("ibm.tivoli.tip.dijit.Images");
dojo.requireLocalization("ibm.tivoli.tip.dijit", "resources");

/**
 * Widget base class. 
 * 
 * Provides the basic functionalities for a widget and defines 
 * some template methods that must be implemented by inheriting widgets.
 * 
 * The basic functionalities provided by such class are:
 *   
 *      - resources: the labels catalog is already loaded and can be accessed
 *        using the (protected) _resources property.
 *      - tooltip message: the widget shows a tooltip message depending 
 *        on the widget status. Inheriting widgets can specify a DOM node 
 *        (_tooltipNode) which will be used to show the tooltip. If not
 *        specified the widget root DOM node is used.
 *      - status: the widget L&F can be set using the setStatus method.
 *      - focus/blur: inheriting widgets can be notified by focus/blur
 *        events by overriding onFocus/onBlur methods.
 *      - focus node: inheriting widgets can specify a DOM node (_focusNode)
 *        which be used to determine if the widget has got or lost the focus.
 *        If not specified the widget root DOM node is used.
 *      - disabling: the widget can be disabled/enabled by calling the 
 *        setDisabled method. Inheriting widgets can override this method
 *        to add their behaviour.
 * 
 * The template methods are:
 * 
 *      - getValue: returns the widget value
 *      - setValue: sets the widget value
 *      - isEmpty: returns true if the widget's value is empty
 *      - setRequired: sets required the widget's value 
 *      - isRequired: returns true if the widget's value is required
 *      - onValueChanged: called when the widget's value is changed
 *      - onStatusChanged: called when the widget's status is changed
 *      - onFocus: called when the widget has got the focus
 *      - onBlur: called when the widget has lost the focus
 *
 * @author: Marco Lerro (marco.lerro@it.ibm.com)    
 */
dojo.declare(
    "ibm.tivoli.tip.dijit.Widget",
    dijit._Widget,
    {
        /** widget constants */
        constants: {
            // default view state
            DEFAULT:  0,   
            // required view state
            REQUIRED: 1,   
            // error view state
            ERROR:    2
        },

        /** editable attribute */
        editable: "true",
        /** true if the tooltip is shown if needed */
        useTooltip: "true", 
        
        /** true if the widget can be editable */
        _editable: true,
        /** the node which gives the focus to the whole widget */
        _focusNode: null,
        /** the node used to attach the tooltip message */
        _tooltipNode: null,
        /** true if the widget has focus */
        _hasFocus: false,
        /** the widget message (tooltip) */
        _tooltip: null,       
        /** the widget display status */
        _status: null,
        /** true if the widget is disabled */
        _disabled: false,
        /** widget connections */
        _connections: null,
        /** true if the widget value is wrong */
        _isInError: false,
        /** the focus node tab index */
        _tabIndex: 0,
        /** resources */
        _resources: null,
        /** images */
        _images: null,
       
        /**
         * Constructor
         */
        constructor: function()
        {
            // get the labels
            this._resources = dojo.i18n.getLocalization("ibm.tivoli.tip.dijit", "resources");
            // get the image
            this._images = ibm.tivoli.tip.dijit.Images.get();
        },
        
        /**
         * Starts-up the widget.
         */
        startup: function()
        {
            // call the superclass's method
            this.inherited(arguments);
            
            // create the tooltip message
            this._tooltip = new ibm.tivoli.tip.dijit.Tooltip({enabled:this.useTooltip === "true"});
            this._tooltip.startup();
            this._tooltip.setNode(this._tooltipNode || this.domNode);
           
            // set default widget status
            this.setStatus({ state: this.constants.DEFAULT, message: "" }); 

            // set the focus node
            if ( this._focusNode === null ) {
                // no focus node provided, use the root node
                this._focusNode = this.domNode;
            }
            // get the focus node tabindex
            this._tabIndex = this._focusNode.tabIndex;
            
            // connect callbacks
            this._connections = [];
            this._connections[this._connections.length] = dojo.connect(this._focusNode, "onfocus", this, "_onFocusEvent");
            this._connections[this._connections.length] = dojo.connect(this._focusNode, "onblur", this, "_onBlurEvent");
            
            // set the editable state
            if ( this.editable !== "" ) {
                this.setEditable(this.editable === "true" ? true : false);    
            }            
        },
        
        /**
         * Destroys the widget.
         */
        destroy: function()
        {
            // destroy the tooltip message
            this._tooltip.destroy();
            // disconnect callbacks
            for ( var i = 0; i < this._connections.length; i++ ) {
                dojo.disconnect(this._connections[i]);
            }
            // call the superclass's method
            this.inherited(arguments);
        },
        
        /**
         * Enables/disables the widget. 
         */
        setDisabled: function(isDisabled)
        {
            if ( isDisabled != this._disabled ) {
                // update the message
                if ( isDisabled === true ) {
                    // the widget is disabled, hide the message
                    this._tooltip.hide();
                }
                else if ( this._status.state !== this.constants.DEFAULT && this._hasFocus ) {
                    // the widget is in error and has focus                    
                    this._tooltip.show(this._status.message);
                }
                // store the enablement status
                this._disabled = isDisabled;
            }
        },
        
        /**
         * Returns true if the object is disabled.
         */
        isDisabled: function()
        {
            return this._disabled;
        },
        
        /**
         * Enables the widget for editing. 
         */
        setEditable: function(isEditable)
        {
            // store the editable status
            this._editable = isEditable;
            // update the focus node tabindex according to the editable state
            this._focusNode.tabIndex = isEditable ? this._tabIndex : -1;
            // manage the new status
            if ( this._hasFocus && isEditable === false ) {
                // remove the focus
                this._focusNode.blur();
            }
            else if ( isEditable ){
                // close the tooltip 
                this._tooltip.hide();
            }
        },
        
        /**
         * Returns true if the object is editable.
         */
        isEditable: function()
        {
            return this._editable;
        },
        
        /**
         * Sets the widget status: the status is an object with the
         * following two properties:
         * 
         *  - state: the state of the widget (e.g. constants.ERROR)
         *  - message: the message related to the current state.
         */
        setStatus: function(status)
        {
            
            // update the message
            if ( status.state === this.constants.DEFAULT ) {
                // no error in place, hide the message
                this._tooltip.hide();
            }
            else if ( this._hasFocus ) {
                // there is an error, show the message if no message
                // is currently shown or the currently shown message
                // is different from the current one 
                if ( ! this._tooltip.isShown() || status.message !== this._status.message ) {
                    this._tooltip.show(status.message);
                }                      
            }
            // cache old status
            var oldStatus = this._status;
            // set the status            
            this._status = status;
            // notify status changed
            if ( oldStatus && oldStatus.state !== status.state ) {
                this.onStatusChanged(status);    
            }
        },
        
        /**
         * Returns the status object.
         */
        getStatus: function()
        {
            return this._status;
        },
        
        /**        
         * Returns an object which represent the widget value.
         */
        getValue: function()
        {
        },
        
        /**        
         * Sets the widget value.
         */
        setValue: function(value)
        {
        },
        
        /**
         * Returns true if the widget's value is not set.
         */
        isEmpty: function()
        {
        },

        /**
         * Returns true if the widget's value is wrong.
         */
        isInError: function()
        {
            return this._isInError && ! this._disabled;  
        },

        /**
         * Sets the widget required constraint.
         * 
         *  @param required:
         *      true if the value is required, false otherwise.
         */
        setRequired: function(required)
        {
        },
        
        /**
         * Returns true if the widget's value is required.
         */
        isRequired: function()
        {
            return false;
        },
        
        /**
         * Asks the widget to revalidate its value and to set its status accordingly.
         */
        validate: function() 
        {
        },
        
        /**
         * Called by the widget if the widget looses the focus and the 
         * value has changed.
         * 
         *  @param value:
         *      the widget's value (same returned by getValue()). 
         */
        onValueChanged: function(value)
        {
        },
        
        /**
         * Called by the widget if the widget's status changes.
         * 
         *  @param status:
         *      the widget's status (same returned by getStatus()). 
         */
        onStatusChanged: function(status)
        {
        },
        
        /**
         * Returns true if the widget has the focus.
         */
        hasFocus: function()
        {
            return this._hasFocus;    
        },
        
        /**
         * Gives the focus to the widget.
         */
        setFocus: function()
        {
            this.domNode.focus();
        },
         
        /**
         * Called by the widget if the widget has got the focus.
         */
        onFocus: function()
        {
        },
        
        /**
         * Called by the widget if the widget has lost the focus.
         */
        onBlur: function()
        {
        },
        
        /**
         * Sets the tooltip node.
         */
        setTooltipNode: function(node)
        {
            this._tooltip.setNode(node || this.domNode);    
        },        
        
        /**
         * Handles the onfocus event.
         */
        _onFocusEvent: function()
        {
            if ( this._editable ) {
                // the widget is editable give the focus
                this._hasFocus = true;
                // show the message
                this._tooltip.show(this._status.message);
                // notify the event to the superclass
                this.onFocus();
            }
            else {
                // the widget is not editable don't give the focus
                this._tooltip.splash(this._resources.NOT_EDITABLE);
                this._focusNode.blur();
            }
        },
        
        /**
         * Handles the onblur event.
         */
        _onBlurEvent: function()
        {
            this._hasFocus = false;
            if ( this._editable ) {
                // hide the message
                this._tooltip.hide();
                // notify the event to the superclass
                this.onBlur();    
            }
        }
    }
);
});

},
'dojox/grid/_RowManager':function(){
define("dojox/grid/_RowManager", [
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/dom-class"
], function(declare, lang, domClass){

	var setStyleText = function(inNode, inStyleText){
		if(inNode.style.cssText == undefined){
			inNode.setAttribute("style", inStyleText);
		}else{
			inNode.style.cssText = inStyleText;
		}
	};

	return declare("dojox.grid._RowManager", null, {
		//	Stores information about grid rows. Owned by grid and used internally.
		constructor: function(inGrid){
			this.grid = inGrid;
		},
		linesToEms: 2,
		overRow: -2,
		// styles
		prepareStylingRow: function(inRowIndex, inRowNode){
			return {
				index: inRowIndex,
				node: inRowNode,
				odd: Boolean(inRowIndex&1),
				selected: !!this.grid.selection.isSelected(inRowIndex),
				over: this.isOver(inRowIndex),
				customStyles: "",
				customClasses: "dojoxGridRow"
			};
		},
		styleRowNode: function(inRowIndex, inRowNode){
			var row = this.prepareStylingRow(inRowIndex, inRowNode);
			this.grid.onStyleRow(row);
			this.applyStyles(row);
		},
		applyStyles: function(inRow){
			var i = inRow;

			i.node.className = i.customClasses;
			var h = i.node.style.height;
			setStyleText(i.node, i.customStyles + ';' + (i.node._style||''));
			i.node.style.height = h;
		},
		updateStyles: function(inRowIndex){
			this.grid.updateRowStyles(inRowIndex);
		},
		// states and events
		setOverRow: function(inRowIndex){
			var last = this.overRow;
			this.overRow = inRowIndex;
			if((last!=this.overRow)&&(lang.isString(last) || last >= 0)){
				this.updateStyles(last);
			}
			this.updateStyles(this.overRow);
		},
		isOver: function(inRowIndex){
			return (this.overRow == inRowIndex && !domClass.contains(this.grid.domNode, "dojoxGridColumnResizing"));
		}
	});
});
},
'dojo/dnd/Mover':function(){
define("dojo/dnd/Mover", ["../main", "../Evented", "../touch", "./common", "./autoscroll"], function(dojo, Evented, touch) {
	// module:
	//		dojo/dnd/Mover
	// summary:
	//		TODOC


dojo.declare("dojo.dnd.Mover", [Evented], {
	constructor: function(node, e, host){
		// summary:
		//		an object which makes a node follow the mouse, or touch-drag on touch devices.
		//		Used as a default mover, and as a base class for custom movers.
		// node: Node
		//		a node (or node's id) to be moved
		// e: Event
		//		a mouse event, which started the move;
		//		only pageX and pageY properties are used
		// host: Object?
		//		object which implements the functionality of the move,
		//	 	and defines proper events (onMoveStart and onMoveStop)
		this.node = dojo.byId(node);
		this.marginBox = {l: e.pageX, t: e.pageY};
		this.mouseButton = e.button;
		var h = (this.host = host), d = node.ownerDocument;
		this.events = [
			// At the start of a drag, onFirstMove is called, and then the following two
			// connects are disconnected
			dojo.connect(d, touch.move, this, "onFirstMove"),

			// These are called continually during the drag
			dojo.connect(d, touch.move, this, "onMouseMove"),

			// And these are called at the end of the drag
			dojo.connect(d, touch.release,   this, "onMouseUp"),

			// cancel text selection and text dragging
			dojo.connect(d, "ondragstart",   dojo.stopEvent),
			dojo.connect(d.body, "onselectstart", dojo.stopEvent)
		];
		// notify that the move has started
		if(h && h.onMoveStart){
			h.onMoveStart(this);
		}
	},
	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove/ontouchmove
		// e: Event
		//		mouse/touch event
		dojo.dnd.autoScroll(e);
		var m = this.marginBox;
		this.host.onMove(this, {l: m.l + e.pageX, t: m.t + e.pageY}, e);
		dojo.stopEvent(e);
	},
	onMouseUp: function(e){
		if(dojo.isWebKit && dojo.isMac && this.mouseButton == 2 ?
				e.button == 0 : this.mouseButton == e.button){ // TODO Should condition be met for touch devices, too?
			this.destroy();
		}
		dojo.stopEvent(e);
	},
	// utilities
	onFirstMove: function(e){
		// summary:
		//		makes the node absolute; it is meant to be called only once.
		// 		relative and absolutely positioned nodes are assumed to use pixel units
		var s = this.node.style, l, t, h = this.host;
		switch(s.position){
			case "relative":
			case "absolute":
				// assume that left and top values are in pixels already
				l = Math.round(parseFloat(s.left)) || 0;
				t = Math.round(parseFloat(s.top)) || 0;
				break;
			default:
				s.position = "absolute";	// enforcing the absolute mode
				var m = dojo.marginBox(this.node);
				// event.pageX/pageY (which we used to generate the initial
				// margin box) includes padding and margin set on the body.
				// However, setting the node's position to absolute and then
				// doing dojo.marginBox on it *doesn't* take that additional
				// space into account - so we need to subtract the combined
				// padding and margin.  We use getComputedStyle and
				// _getMarginBox/_getContentBox to avoid the extra lookup of
				// the computed style.
				var b = dojo.doc.body;
				var bs = dojo.getComputedStyle(b);
				var bm = dojo._getMarginBox(b, bs);
				var bc = dojo._getContentBox(b, bs);
				l = m.l - (bc.l - bm.l);
				t = m.t - (bc.t - bm.t);
				break;
		}
		this.marginBox.l = l - this.marginBox.l;
		this.marginBox.t = t - this.marginBox.t;
		if(h && h.onFirstMove){
			h.onFirstMove(this, e);
		}

		// Disconnect onmousemove and ontouchmove events that call this function
		dojo.disconnect(this.events.shift());
	},
	destroy: function(){
		// summary:
		//		stops the move, deletes all references, so the object can be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		// undo global settings
		var h = this.host;
		if(h && h.onMoveStop){
			h.onMoveStop(this);
		}
		// destroy objects
		this.events = this.node = this.host = null;
	}
});

return dojo.dnd.Mover;
});

},
'dijit/layout/TabContainer':function(){
define("dijit/layout/TabContainer", [
	"dojo/_base/lang", // lang.getObject
	"dojo/_base/declare", // declare
	"./_TabContainerBase",
	"./TabController",
	"./ScrollingTabController"
], function(lang, declare, _TabContainerBase, TabController, ScrollingTabController){

/*=====
	var _TabContainerBase = dijit.layout._TabContainerBase;
	var TabController = dijit.layout.TabController;
	var ScrollingTabController = dijit.layout.ScrollingTabController;
=====*/

	// module:
	//		dijit/layout/TabContainer
	// summary:
	//		A Container with tabs to select each child (only one of which is displayed at a time).


	return declare("dijit.layout.TabContainer", _TabContainerBase, {
		// summary:
		//		A Container with tabs to select each child (only one of which is displayed at a time).
		// description:
		//		A TabContainer is a container that has multiple panes, but shows only
		//		one pane at a time.  There are a set of tabs corresponding to each pane,
		//		where each tab has the name (aka title) of the pane, and optionally a close button.

		// useMenu: [const] Boolean
		//		True if a menu should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useMenu: true,

		// useSlider: [const] Boolean
		//		True if a slider should be used to select tabs when they are too
		//		wide to fit the TabContainer, false otherwise.
		useSlider: true,

		// controllerWidget: String
		//		An optional parameter to override the widget used to display the tab labels
		controllerWidget: "",

		_makeController: function(/*DomNode*/ srcNode){
			// summary:
			//		Instantiate tablist controller widget and return reference to it.
			//		Callback from _TabContainerBase.postCreate().
			// tags:
			//		protected extension

			var cls = this.baseClass + "-tabs" + (this.doLayout ? "" : " dijitTabNoLayout"),
				TabController = lang.getObject(this.controllerWidget);

			return new TabController({
				id: this.id + "_tablist",
				dir: this.dir,
				lang: this.lang,
				textDir: this.textDir,
				tabPosition: this.tabPosition,
				doLayout: this.doLayout,
				containerId: this.id,
				"class": cls,
				nested: this.nested,
				useMenu: this.useMenu,
				useSlider: this.useSlider,
				tabStripClass: this.tabStrip ? this.baseClass + (this.tabStrip ? "":"No") + "Strip": null
			}, srcNode);
		},

		postMixInProperties: function(){
			this.inherited(arguments);

			// Scrolling controller only works for horizontal non-nested tabs
			if(!this.controllerWidget){
				this.controllerWidget = (this.tabPosition == "top" || this.tabPosition == "bottom") && !this.nested ?
							"dijit.layout.ScrollingTabController" : "dijit.layout.TabController";
			}
		}
	});
});

},
'dijit/BackgroundIframe':function(){
define("dijit/BackgroundIframe", [
	"require",			// require.toUrl
	".",	// to export dijit.BackgroundIframe
	"dojo/_base/config",
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.set
	"dojo/_base/lang", // lang.extend lang.hitch
	"dojo/on",
	"dojo/_base/sniff", // has("ie"), has("mozilla"), has("quirks")
	"dojo/_base/window" // win.doc.createElement
], function(require, dijit, config, domConstruct, domStyle, lang, on, has, win){

	// module:
	//		dijit/BackgroundIFrame
	// summary:
	//		new dijit.BackgroundIframe(node)
	//		Makes a background iframe as a child of node, that fills
	//		area (and position) of node

	// TODO: remove _frames, it isn't being used much, since popups never release their
	// iframes (see [22236])
	var _frames = new function(){
		// summary:
		//		cache of iframes

		var queue = [];

		this.pop = function(){
			var iframe;
			if(queue.length){
				iframe = queue.pop();
				iframe.style.display="";
			}else{
				if(has("ie") < 9){
					var burl = config["dojoBlankHtmlUrl"] || require.toUrl("dojo/resources/blank.html") || "javascript:\"\"";
					var html="<iframe src='" + burl + "' role='presentation'"
						+ " style='position: absolute; left: 0px; top: 0px;"
						+ "z-index: -1; filter:Alpha(Opacity=\"0\");'>";
					iframe = win.doc.createElement(html);
				}else{
					iframe = domConstruct.create("iframe");
					iframe.src = 'javascript:""';
					iframe.className = "dijitBackgroundIframe";
					iframe.setAttribute("role", "presentation");
					domStyle.set(iframe, "opacity", 0.1);
				}
				iframe.tabIndex = -1; // Magic to prevent iframe from getting focus on tab keypress - as style didn't work.
			}
			return iframe;
		};

		this.push = function(iframe){
			iframe.style.display="none";
			queue.push(iframe);
		}
	}();


	dijit.BackgroundIframe = function(/*DomNode*/ node){
		// summary:
		//		For IE/FF z-index schenanigans. id attribute is required.
		//
		// description:
		//		new dijit.BackgroundIframe(node)
		//			Makes a background iframe as a child of node, that fills
		//			area (and position) of node

		if(!node.id){ throw new Error("no id"); }
		if(has("ie") || has("mozilla")){
			var iframe = (this.iframe = _frames.pop());
			node.appendChild(iframe);
			if(has("ie")<7 || has("quirks")){
				this.resize(node);
				this._conn = on(node, 'resize', lang.hitch(this, function(){
					this.resize(node);
				}));
			}else{
				domStyle.set(iframe, {
					width: '100%',
					height: '100%'
				});
			}
		}
	};

	lang.extend(dijit.BackgroundIframe, {
		resize: function(node){
			// summary:
			// 		Resize the iframe so it's the same size as node.
			//		Needed on IE6 and IE/quirks because height:100% doesn't work right.
			if(this.iframe){
				domStyle.set(this.iframe, {
					width: node.offsetWidth + 'px',
					height: node.offsetHeight + 'px'
				});
			}
		},
		destroy: function(){
			// summary:
			//		destroy the iframe
			if(this._conn){
				this._conn.remove();
				this._conn = null;
			}
			if(this.iframe){
				_frames.push(this.iframe);
				delete this.iframe;
			}
		}
	});

	return dijit.BackgroundIframe;
});

},
'ibm/tivoli/tip/dijit/Tooltip':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dijit/Tooltip"], function(dijit,dojo,dojox){
dojo.provide("ibm.tivoli.tip.dijit.Tooltip"); 

dojo.require("dijit._Widget");
dojo.require("dijit.Tooltip");

/**
 * Tooltip. 
 *
 * @author: Marco Lerro (marco.lerro@it.ibm.com)    
 */
dojo.declare(
    "ibm.tivoli.tip.dijit.Tooltip",
    [dijit._Widget],
    {
        /** the time (in ms) the tooltip is shown after a splash call */
        splashTime: 2000,
        
        /** the node used to attach the tooltip message */
        _tooltipNode: null,
        /** tooltip widget */
        _tooltip: null,
        /** the close timer (set if a close tooltip has been scheduled) */
        _closeTimer: null,
        /** if true the tooltip must be regularly shown */
        _enabled: true,
       
        constructor: function(params)
        {
        	if(undefined !== params && undefined !== params.enabled)
	            this._enabled = params.enabled;
        },
        
        /**
         * Starts-up the widget.
         */
        startup: function()
        {
            this._tooltip = new dijit.Tooltip();
            this._tooltip.startup();
        },
        
        /**
         * Destroys the widget.
         */
        destroy: function()
        {
            // destroy the tooltip
            this.hide();
            this._tooltip.destroy();
            // call the superclass's method
            this.inherited(arguments);
        },
        
        /**
         * Sets the tooltip node.
         */
        setNode: function(tooltipNode)
        {
            this._tooltipNode = tooltipNode;
        },
        
        /**
         * Shows the message tooltip containing the given message.
         */
        show: function(message)
        {
            // do not show if not enabled
            if ( this._enabled === false ) {
                return;
            }
            // close the previous tooltip (if any)
            if ( this.isShown() ) {
               this.hide();
            }
            if ( message !== "" && this._tooltipNode ) {
                // open the new tooltip
                this._tooltip.label = message;
                this._tooltip.open(this._tooltipNode);
            }
        },
        
        /**
         * Opens the message tooltip and hides it after a while.
         */
        splash: function(message)
        {
            // do not show if not enabled
            if ( this._enabled === false ) {
                return;
            }
            this.show(message);
            this._closeTimer = setTimeout(dojo.hitch(this, this.hide), this.splashTime);
        },
        
        /**
         * Hides the message tooltip.
         */
        hide: function()
        {
            if ( this.isShown() ) {
                if ( this._closeTimer ){
                    clearTimeout(this._closeTimer);
                    delete this._closeTimer;
                }
                this._tooltip.close();
            }
        },
        
        /**
         * Returns true if the message tooltip is currently shown.
         */
        isShown: function()
        {
            return ( !! this._tooltip._connectNode );   
        }
    }
);
});

},
'dojo/dnd/Avatar':function(){
define("dojo/dnd/Avatar", ["../main", "./common"], function(dojo) {
	// module:
	//		dojo/dnd/Avatar
	// summary:
	//		TODOC


dojo.declare("dojo.dnd.Avatar", null, {
	// summary:
	//		Object that represents transferred DnD items visually
	// manager: Object
	//		a DnD manager object

	constructor: function(manager){
		this.manager = manager;
		this.construct();
	},

	// methods
	construct: function(){
		// summary:
		//		constructor function;
		//		it is separate so it can be (dynamically) overwritten in case of need
		this.isA11y = dojo.hasClass(dojo.body(),"dijit_a11y");
		var a = dojo.create("table", {
				"class": "dojoDndAvatar",
				style: {
					position: "absolute",
					zIndex:   "1999",
					margin:   "0px"
				}
			}),
			source = this.manager.source, node,
			b = dojo.create("tbody", null, a),
			tr = dojo.create("tr", null, b),
			td = dojo.create("td", null, tr),
			icon = this.isA11y ? dojo.create("span", {
						id : "a11yIcon",
						innerHTML : this.manager.copy ? '+' : "<"
					}, td) : null,
			span = dojo.create("span", {
				innerHTML: source.generateText ? this._generateText() : ""
			}, td),
			k = Math.min(5, this.manager.nodes.length), i = 0;
		// we have to set the opacity on IE only after the node is live
		dojo.attr(tr, {
			"class": "dojoDndAvatarHeader",
			style: {opacity: 0.9}
		});
		for(; i < k; ++i){
			if(source.creator){
				// create an avatar representation of the node
				node = source._normalizedCreator(source.getItem(this.manager.nodes[i].id).data, "avatar").node;
			}else{
				// or just clone the node and hope it works
				node = this.manager.nodes[i].cloneNode(true);
				if(node.tagName.toLowerCase() == "tr"){
					// insert extra table nodes
					var table = dojo.create("table"),
						tbody = dojo.create("tbody", null, table);
					tbody.appendChild(node);
					node = table;
				}
			}
			node.id = "";
			tr = dojo.create("tr", null, b);
			td = dojo.create("td", null, tr);
			td.appendChild(node);
			dojo.attr(tr, {
				"class": "dojoDndAvatarItem",
				style: {opacity: (9 - i) / 10}
			});
		}
		this.node = a;
	},
	destroy: function(){
		// summary:
		//		destructor for the avatar; called to remove all references so it can be garbage-collected
		dojo.destroy(this.node);
		this.node = false;
	},
	update: function(){
		// summary:
		//		updates the avatar to reflect the current DnD state
		dojo[(this.manager.canDropFlag ? "add" : "remove") + "Class"](this.node, "dojoDndAvatarCanDrop");
		if (this.isA11y){
			var icon = dojo.byId("a11yIcon");
			var text = '+';   // assume canDrop && copy
			if (this.manager.canDropFlag && !this.manager.copy) {
				text = '< '; // canDrop && move
			}else if (!this.manager.canDropFlag && !this.manager.copy) {
				text = "o"; //!canDrop && move
			}else if(!this.manager.canDropFlag){
				text = 'x';  // !canDrop && copy
			}
			icon.innerHTML=text;
		}
		// replace text
		dojo.query(("tr.dojoDndAvatarHeader td span" +(this.isA11y ? " span" : "")), this.node).forEach(
			function(node){
				node.innerHTML = this._generateText();
			}, this);
	},
	_generateText: function(){
		// summary: generates a proper text to reflect copying or moving of items
		return this.manager.nodes.length.toString();
	}
});

return dojo.dnd.Avatar;
});

},
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n",
'ibm/tivoli/simplesrm/srm/dijit/CreateCatalogRequest':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/Dialog,dijit/_Widget,dijit/_Templated,dojo/parser,dojo/date,ibm/tivoli/simplesrm/srm/dijit/WidgetBase,ibm/tivoli/simplesrm/srm/dijit/ProgressSpinner,ibm/tivoli/simplesrm/srm/dijit/PopupDialog,ibm/tivoli/simplesrm/srm/dijit/MessageDialog,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dijit/InlineMessage,ibm/tivoli/simplesrm/srm/dijit/ConfirmationDialog,dijit/layout/BorderContainer,dijit/Tooltip"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

// this file provides the definition of the CreateCatalogRequest class
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.CreateCatalogRequest");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.CreatorPopupDialog");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.CreatorFactory");

// include modules
dojo.require("dijit.Dialog");
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dojo.parser");
dojo.require("dojo.date");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.WidgetBase");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.PopupDialog");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MessageDialog");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.InlineMessage");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ConfirmationDialog");

// the CreateCatalogRequest class is a widget that makes an
// XMLHttpRequest to a proxy servlet to reach an SRM object structure
// web service that can create service catalog requests
// Events:
//	onSrmRequestCreated(null)
//
// TODO: parameterize for the type of request.
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.CreateCatalogRequest",
	[dijit._Widget,
	 dijit._Templated,
	 ibm.tivoli.simplesrm.srm.dijit.WidgetBase],
{
	_requestAttributeCache: [],	// creates a static member
	
	//context sensitive help key. mapped on server side to help topic
	// no key == no csh help 
	cshKey: "",
	
	widgetsInTemplate: true,
	// swizzle this per the type of request we're creating
	templateString: null,
	templatePath: null,
	ALN: "ALN",
	NUMERIC: "NUMERIC",
	TABLE: "MAXTABLE",

	requestName: '',
	headingText: '',
	description: '',
	imagesPath: '',
	requestDetails: null,
	_localized_strings: null,	// will contain the i18n string table for the specific request type
	
	// input parameters
	requestType: '',		// required
	ItemNum: '',			// required
	ObjectType: 'Catalog', 	// required
	ItemSetID: '',		// need this or MRLineID
	MRLineID: '',			// need this or ItemSetID
	readOnly: false,

	_bStarted: false,		// startup will get called when this widget is created, and again when the popup dialog is initialized.
							// derived classes can use this flag to see if they've already been startedW
	
	_inputParams: null,

	constructor: function(/*ojbect*/params, /*DOMNode*/domNode)
	{
		console.log("CreateCatalogRequest.ctor");
		this.imagesPath = this.getRelativePath("images");
		this._inputParams = params;
	},
	/*
	** Default implementation loads i18n strings and sets the templatePath as a function of the requestName
	** If you need to do something different, override.
	*/
	postMixInProperties: function()
	{
		console.log("CreateCatalogRequest.postMixInProperties");
		
		// context sensitive help key is the ItemNum
		this.cshKey = this.ItemNum + ".htm";
		
		if(this.MRLineID) {
			this.requestDetails = this.getRequestDetails(this.MRLineID);
		}
		else {
			this.requestDetails = this.queryRequestTypeDetails(this.ItemNum, this.ItemSetID);
		}
		if( this.requestDetails ) {
			var offStatusMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('ITEMSTATUS');
			var offStatus = offStatusMap.valueByMaxvalue("ACTIVE");
			if(this.requestDetails.Status != offStatus) {   // This can only happen if the request's status has been changed since the user logged on
				var cache_key = this.ItemNum + "_" + this.ItemSetID;
				this._requestAttributeCache[cache_key] = null;
				throw "CTJZH2325E";
			}
			if(undefined === this.requestDetails.Attribute) {
				this.requestDetails.Attribute = [];
			}
			else {
				this.requestDetails.Attribute = this.requestDetails.Attribute.sort(dojo.hitch(this, "_cmpDisplaySequence"));
			}
			this.requestName = this.requestDetails.Description.htmlencode();
			this.headingText = this.requestName.htmldecode();
			this.description = (undefined !== this.requestDetails.LongDescription ? this.requestDetails.LongDescription : this.requestDetails.Description).htmlencode();
			
		} else {
			throw "CTJZH2301E";
		}
      // default templatePath is a function of the request type
		if(!this.templateString && !this.templatePath) {
			var mod = this.declaredClass.substring(0, this.declaredClass.lastIndexOf("."));  
			var typ = this.declaredClass.substring(this.declaredClass.lastIndexOf(".")+1);
			
			this.templatePath = dojo.moduleUrl(mod, "templates/" + typ + ".html"); //create a url relative to a dojo module
			//this.templatePath = dojo.moduleUrl(mod) +  "templates/" + typ + ".html";			 
			console.log("CreateCatalogRequest.postMixInProperties, templatePath = " + this.templatePath.toString());
		}
		this.inherited(arguments);
	},
	buildRendering: function()
	{
		console.log("CreateCatalogRequest.buildRendering");
		
		try {			
			console.log("CreateCatalogRequest.buildRendering, templatePath = " + this.templatePath.toString());
			this.inherited(arguments);
		}
		catch(ex) {
			console.group("Failed generating input form from template");
			console.error(ex);
			console.groupEnd();
			ibm.tivoli.logger.error("",ex);// really have to bail at this point.
		}
		

		if( !this.readOnly ) {
			var the_form = dojo.query("form", this.domNode)[0];
			var d = document.createElement('div');
			var uname = ibm.tivoli.tpae.data.loggedInUsername;
			d.innerHTML = '<input type="hidden" name="srmreq" value="create" >' 
				+ '<input type="hidden" name="user" value="'+uname+'" >'
				+ '<input type="hidden" name="requestedby" value="' + uname + '" >'

				// common attributes
				 + '<input type="hidden" name="csid" value="'+this.requestDetails.ClassStructureID+'" >'
				 + '<input type="hidden" name="CLASSIFICATIONID" value="'+this.requestDetails.ClassificationID+'" >'
				 + '<input type="hidden" name="ItemNum" value="'+this.requestDetails.ItemNum+'" >'
				 + '<input type="hidden" name="ItemSetID" value="'+this.requestDetails.ItemSetID+'" >';
			the_form.appendChild(d);	

//			// attributes may have been added to the offering that aren't in custom forms
//			// guarantee they're not missing.
//			// If you create a custom form, and purposfully want to omit an attribute, create a hidden input
//			// element and mark it disabled.
//			for(var i in this.requestDetails.Attribute) {
//				var attr = this.requestDetails.Attribute[i];
//				if(attr.Mandatory && attr.Description !== "TSAM Substitution Expression") {
//					if(dojo.query("[name="+attr.AssetAttrID+"]", the_form).length == 0 &&
//					  (dojo.isIE && dojo.query("[submitName="+attr.AssetAttrID+"]", the_form).length == 0)) { // WTF?
//						var ipt = document.createElement("input");
//						ipt.type = "hidden";
//						ipt.name = attr.AssetAttrID;
//						ipt.id = this.id + "_" + attr.AssetAttrID;
//						d.appendChild(ipt);
//					}
//				}
//			}				
		}	
	},
	postCreate: function()
	{
		this.inherited(arguments);

	},
	startup: function()
	{
		console.log("CreateCatalogRequest.startup");
		if(this._bStarted){
			return;
		}
		this._bStarted = true;
		this.inherited(arguments);

		var datatypeMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('DATATYPE');
		this.ALN = datatypeMap.valueByMaxvalue("ALN");
		this.NUMERIC = datatypeMap.valueByMaxvalue("NUMERIC");
		this.TABLE = datatypeMap.valueByMaxvalue("MAXTABLE");
		
		if(this.readOnly) {
			this.disableAll(true);
		}

		// set defaults
		// TODO: this doesn't handle when derived classes asyncronously retrieve table value lists
		// that my need to get a default value
		var attributes = this.requestDetails.Attribute;
		for(var i = 0; i < attributes.length; ++i) 
		{
			try {
				var attr = attributes[i];
				var val = this._getAttrValue(attr);
				if("number" === typeof val || ("string" === typeof val && val.length > 0)) {
					var obj_id = this.id + '_' + attr.AssetAttrID;
					var widget = dijit.byId(obj_id);
					if(widget) {
						try {
							if("function" === typeof widget.attr){
								widget.attr("value", val);
							}
							else if("function" === typeof widget.setValue){
								widget.setValue(val);
							}
						}
						catch(ex) {
							console.error("",ex);
						}
					}
					else { 
						var html_obj = dojo.byId(obj_id);
						if(html_obj && "INPUT" === html_obj.tagName.toUpperCase() ) {
							html_obj.value = val;
						}
					}
				}
	
			}
			catch(ex) {
				ibm.tivoli.logger.error("",ex);				
				console.group("Failed setting default on form field for ", attr.AssetAttrID);
				console.error(ex);
				console.groupEnd();
			}
		}
	},
	destroy: function()
	{
		this.disableAll(false);
		this.inherited(arguments);
	},
	reset: function()
	{
		dojo.byId(this.id + "_input_form").reset();
	},
	// query attributes for the given request type
	queryRequestTypeDetails: function(itemnum, itemsetid)
	{
		var cache_key = this.ItemNum + "_" + this.ItemSetID;
		var attrs = this._requestAttributeCache[cache_key];
		if( !attrs ) {
			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequests({ItemNum: this.ItemNum, ItemSetID: this.ItemSetID, sync: true});
			deferred.addCallback(dojo.hitch(this, function(response)
			{
				attrs = response.Request[0];
				// add in common attributes that are not part of the offering proper
				if(undefined === attrs.Attribute) {
					attrs.Attribute = [];
				}
				attrs.Attribute.push({AssetAttrID: "requestedfor", DataType: this.ALN, ALNValue: ibm.tivoli.tpae.data.loggedInUsername, Description: "Requested For", Hidden: "false", Mandatory: "true", ReadOnly: "false"});

				this._requestAttributeCache[cache_key] = attrs;
				return response;
			}));
		}
		return attrs;
	},
	getRequestDetails: function()
	{
		//return this._doGetRequestDetails({MRLineID: this.MRLineID, ObjectType: this.ObjectType});
		var request_details = null;
		var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequests({id: this.MRLineID, ObjectType: this.ObjectType, sync: true});
		deferred.addCallback(function(response)
		{
			try {
				request_details = response.Request[0];
			}
			catch(ex) {
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog("CTJZH2302E")).show();
			}
			return response;
		});
		return request_details;
	},
	// get an attribute's value
	// the value may come from 1 of 2 places
	// 1. it may have been provided to our constructor and is stored in this._inputParams
	// 2. the passed-in attr (from requestDetails) may povide a default value 
	_getAttrValue: function(attr)
	{
		var value = this._inputParams[attr.AssetAttrID];
		if(undefined === value) {
			if(this.ALN === attr.DataType) {
				value = dojo.isString(attr.ALNValue) ? attr.ALNValue : "";
			}
			else if(this.NUMERIC === attr.DataType) {
				value = dojo.isString(attr.NumValue) ? attr.NumValue : "";
			}
			else if(this.TABLE === attr.DataType) {
				value = dojo.isString(attr.TableValue) ? attr.TableValue : "";
			}
			else {
				console.log("Unexpected attribute data type: '%s'", attr.DataType);
			}
		}
		if(this.NUMERIC === attr.DataType) {
			value = parseInt(value,10);
			if(isNaN(value)) {
				value = "";
			}
		}
		return value;	
	},
	_getPostData: function()
	{
		// by default, a creation request sends all the form data.
		// if you need to so something special, override 
		var form_id = this.id + "_input_form";
		return dojo.formToObject(form_id);
	},
	
	// invoke an ajax request to create a request
	createRequest: function()
	{		
		console.log("CreateCatalogRequest.createRequest");

		// the form never actually is submitted, but give subclasses
		// an opportunity to do some last minute processing.
		try {
			var bContinue = this.onSubmit();
			if(!bContinue) {
				//if (this.setStateError) this.setStateError();    Don't do this or the OK button will get disabled, so user won't be able to fix mistake and try again
				return null;
			} else {
				if (this.setStateSubmit) this.setStateSubmit();
			}
		}
		catch(ex){
			ibm.tivoli.logger.warn("",ex);
			console.warn("Derived class onSubmit threw an exception: ", ex);
		}
		
		var deferred = null;
		try {
			var form_id = this.id + "_input_form";
			var post_data = this._getPostData();
			if(post_data !== null) {
				form_id = null;
				for(var k in post_data) {
					// There is a bug in Dojo 1.3.1 fixed by http://trac.dojotoolkit.org/changeset/18030
					// That causes radio buttons to render as arrays with all values after the first one blank
					// However a multi select box or checkbox array can also have multiple values
					// so even when fixed we have to be able to handle array types
					if(post_data.hasOwnProperty(k)){
						var post_datum = post_data[k];
						if ( dojo.isArray(post_datum) ) {
							for (var pdidx = 0; pdidx < post_datum.length; pdidx++) {
								//Todo: remove this if statement hack after upgrading DOJO
								if("" === post_datum[pdidx] ) {
									post_datum.splice(pdidx,1);
									pdidx--;
								} else if ("string" === typeof post_datum[pdidx]) {
									post_datum[pdidx] = post_datum[pdidx].trim().safeencode();
								}
							}
							post_data[k] = post_datum;
						} else if ("string" === typeof post_datum) {
							post_data[k] = post_datum.trim().safeencode();
						}
					}
				}
			}
			console.log("CreateCatalogRequest.createRequest: calling srmQuery.createRequest()");
			deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().createRequest(post_data, this.requestDetails);
			deferred.addCallbacks( dojo.hitch(this, "_processCreateResponse"), dojo.hitch(this, "_processCreateError"));
		}
		catch(ex) {
			ibm.tivoli.logger.error("",ex);
			console.log("CreateCatalogRequest.createRequest: failed miserably");
			console.log(ex);
			if("string" === typeof ex) {
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: ex})).show();
			}
			else {
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2342E"})).show();
			}
		}
		return deferred;
	},
	cancelRequest: function()
	{
		this.disableAll(false);
	},
	onSubmit: function()
	{
		var bValid = false;	// assume the worst
		try{			
			bValid = this.isValid();
			
			console.log("In CreateCatalogRequest.js: bValid is : " + bValid);
			
			if (bValid){
				bValid = dojo.query("input[name]", this.domNode).every(function(in_elem) {
						
							var widget = dijit.getEnclosingWidget(in_elem);
							if(widget) {
								var bValid = true;
								if("function" === typeof widget.isInError) {
									widget.validate();
									if(widget.isInError()) {
										bValid = false;
									}
								}
								else if("function" === typeof widget.isValid) {
									if( !widget.isValid() ) {
										bValid = false;
									}
								}
								if(!bValid) {
									if(widget.declaredClass.match(/^ibm\.tivoli\.tip\.dijit/)) {
										widget.setFocus();
										widget.validate();	// tip widgets have to have focus before it will show error
									} else if("function" === typeof widget.focus){
										widget.focus();
									}
							
						      	/* Not all panels implement the state machine */
							      if (this.setStateError)	this.setStateError();
						      } else {
							     if (this.setStateCorrect) this.setStateCorrect();
						      }
							   return bValid;
							}
						});
									
			}
		}catch(ex){
			ibm.tivoli.logger.warn("CreateCatalogRequest.onSubmit: failed  ", ex);
			console.warn("CreateCatalogRequest.onSubmit: failed  ", ex);
			bValid = false;
		}
		if( !bValid ) {
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2305E"})).show();
		}
		return bValid;

	},
	isValid: function()
	{
		return true;
	},
	_processCreateResponse: function(response)
	{
		var status = -1;
		var bUseRest = Boolean(parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty("CreateViaRest")));
		if(bUseRest) {
			status = 0;
		}
		else {
			// parse the resonse.  just because the request succeeded 
			// doesn't mean the request was created successfully
			var msg = "";
			for(var i = 0; i < response.TEXT.length; ++i) {
				var r = response.TEXT[i];
				if(undefined !== r.Message) {
					msg += "\n" + r.Message;
				}
				if(undefined !== r.ReturnCode) {
					status = parseInt(r.ReturnCode,10);
				}
			}
		}
		if(0 === status) {
			console.log("CreateCatalogRequest: request created:" + msg);
			this._fireSrmRequestCreated();
		}
		else {
			(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2306E"})).show();
			ibm.tivoli.logger.error("",new Error("request failed (" + status + "):" + msg));
		}
	},
	
	_processCreateError: function(create_response) {
		console.group("Error creating catalog request");
		console.log(create_response);
		var me = this;
		var showMessageFromArguments = function(){
			var message = null;
			if (create_response != undefined && create_response.message != undefined){
				message = create_response.message;
			}
			if("string" === typeof message) {
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: message})).show();
			}
			else {
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2335E"})).show();
			}			
		};
		var unblockUI = function(){
			if (me.setState) {	// User could not submit before if button was not enabled, so now
				me.setState();	// it should only be disabled if an inline message is showing
			}
						
		};
		// If the failure is due to the offering being modified so it is no longer available show a specific message
		var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequests({ItemNum: this.ItemNum, ItemSetID: this.ItemSetID, sync:true});
		deferred.addCallback(function(req_response)
		{
			var attrs = req_response.Request[0];
			var offStatusMap = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('ITEMSTATUS');
			var offStatus = offStatusMap.valueByMaxvalue("ACTIVE");
			if( attrs && attrs.Status != offStatus) {
               (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2325E"})).show();
               var cache_key = this.ItemNum + "_" + this.ItemSetID;
               this._requestAttributeCache[cache_key] = null;
            } else {
            	showMessageFromArguments();

            }
			return req_response;
		});
		deferred.addErrback(showMessageFromArguments);
		deferred.addBoth(unblockUI);
      
		console.groupEnd();
	},

	
	// ------------- event handlers -----------------------
	_fireSrmRequestCreated: function() {
		console.log("CreateCatalogRequest._fireSrmRequestCreated()");

		if(undefined === this.iContext) {
			if("function" == typeof this.onSrmRequestCreated) {
				this.onSrmRequestCreated();
			}
		}
		else {
			console.log("CreateCatalogRequest is firing iWidget event SrmRequestCreated");
			this.iContext.iEvents.fireEvent("SrmRequestCreated", "string", "");
		}
	},
	onSrmRequestCreated: function()
	{
		console.log("CreateCatalogRequest.onSrmRequestCreated");
		// TODO: figure out why.
		// Sometimes you need to have an event handler function defined in the class (like this one)
		// for dojo.connect to wire external event handlers successfully, and sometimes
		// you don't.  Why?
	},
	
	_disableOkButton: function(){
		console.log("CreateCatalogRequest.disableOKButton");		
	},
	
	_enableOkButton: function(){
		console.log("CreateCatalogRequest.enableOKButton");	
	},
	
	_cmpDisplaySequence: function(a, b)
	{
		var dsa = parseInt(a.DisplaySequence,10);
		var dsb = parseInt(b.DisplaySequence,10);
		var diff = (isNaN(dsa) ? 1000000 : dsa) - (isNaN(dsb) ? 1000000 : dsb);
		return diff;
	},
	_working: function(b)
	{
		if(this.domNode){
			dojo.style(this.domNode, "cursor", b ? "wait" : "default");
		}
	},
	// prevent the user from interacting
	_screen: null,
	disableAll: function(bState)
	{
		try {
			var theform = dojo.query("form", this.domNode)[0];
			if(bState) {
				// disable
				var cw = dojo.query("div.content_wrapper", this.domNode)[0];
				var box = dojo.contentBox(theform);
				if(this._screen === null) {
					this._screen = document.createElement("div");
				}
				dojo.style(theform, "position", "relative");
				dojo.style(this._screen, {
					position: "absolute",
					left: box.l + "px",
					top: box.t + "px",
					width: ((cw.scrollWidth > box.w) ? cw.scrollWidth : box.w) + "px",
					height: ((cw.scrollHeight > box.h) ? cw.scrollHeight : box.h) + "px",
					cursor: "not-allowed",
					margin: "0px",
					padding: "0px",
					zIndex: 1000,
					backgroundColor: "transparent"
				});
				dojo.place(this._screen, theform, "first");
			}
			else {
				// enable
				try {
					if(this._screen){
						theform.removeChild(this._screen);
					}
				}
				catch(ignore){
					console.info("ignore",ignore);
				}
			}
		}
		catch(ex) {
			ibm.tivoli.logger.error("",ex);
			console.log("An exception was thrown in CreateCatalogRequest.disableAll", ex);
		}
	},
	_createMessageHolder: function()
	{
		console.log('CreateCatalogRequest._createMessageHolder');
		var nodes = dojo.query("div.banner", this.domNode);
		this.messageHolder = dojo.place("<div></div>", nodes[0], 'last');
	},
	addMessage: function(/*String*/messageId, /*widget*/ fieldToFocus, /*String*/ val1)
	{
		try {
			console.log('CreateCatalogRequest.addMessage');
			this.removeMessage(messageId, true);
			var d = dojo.place("<div></div>", this.messageHolder, 'last');
			var messageText = this._uiStringTable[messageId];
			if (val1 != undefined && messageText.indexOf("{0}") != -1) {
				messageText = messageText.replace(/\{0\}/g, val1);
			}
			this._messages[messageId] = new ibm.tivoli.simplesrm.srm.dijit.InlineMessage({messageId: messageId,
																						  messageText: messageText}, d);
			this.makeRoomForMessages();
			if(fieldToFocus !== undefined){
				if(fieldToFocus.declaredClass.match(/^ibm\.tivoli\.tip\.dijit/)) {
					console.log("Invoking setFocus() on " + fieldToFocus.id);
					fieldToFocus.setFocus();
				}
				else if("function" === typeof fieldToFocus.focus){
					console.log("Invoking focus() on " + fieldToFocus.id);
					fieldToFocus.focus();
				}
			}
			if (this.setState) this.setState(); /* Seems to provoke trouble with I messages */
			console.log('CreateCatalogRequest.addMessage exit');
			
		}
		catch(ex) {
			console.error("CreateCatalogRequest.addMessage failure: " + ex.message);
		}
		
	},
	removeMessage: function(/*String*/messageId, /*boolean?*/suppressResize)
	{
		var message = this._messages[messageId];
		
		if ((message !== undefined) && (message !== null)) {
			message.destroy();
			delete this._messages[messageId];
			if (this.setState) this.setState();
			if(!suppressResize){
				this.makeRoomForMessages();
			}
		}
		else{
			console.debug('No message with messageId ' + messageId + ' to delete.');
		}
	},
	clearMessages: function()
	{
		for (i in this._messages) {
			if(this._messages.hasOwnProperty(i)){
				var message = this._messages[i];
				message.destroy();
			}
		}
		this.makeRoomForMessages();
		this._messages = [];
	},
	makeRoomForMessages: function()
	{
		var content_wrapper = dojo.query(".content_wrapper", this.domNode)[0];
		var wsz = dojo.contentBox(content_wrapper);
		if(0 === wsz.h){
			return;
		}
		var might_be_my_popup = dijit.getEnclosingWidget(this.messageHolder);
		if("function" === typeof might_be_my_popup._size) {
			might_be_my_popup._size();
		}
	},
	_dummy:null
});

ibm.tivoli.simplesrm.srm.dijit.CreateCatalogRequest.createInstanceOf = function(/*string*/className, params, domNode)
{
	dojo._loadModule(className);
	var cls = dojo.getObject(className);
	return new cls(params, domNode);
};

	
/*****************************************************************************************
**
** CreatorPopupDialog is the popup dialog for displaying CreateCatalogRequest derived objects
*/
dojo.require("dijit.layout.BorderContainer");
dojo.require("dijit.Tooltip");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.CreatorPopupDialog",
			 ibm.tivoli.simplesrm.srm.dijit.PopupDialog,
{
	createRequestButtonLabel: 'OK',
	cancelButtonLabel: 'Cancel',
	progressSpinner: null,

	
	creator: null,		// gets the request creating widget instance
	_connections: [],
	_inputParams: null,
	// possible input parameters
	requestType: '',		// required
	creatorType: "ibm.tivoli.simplesrm.srm.dijit.request.GenericForm",	// required
	ItemNum: null,			// required
	ObjectType: 'Catalog',	// required
	ItemSetID: null,		// need this or MRLineID
	MRLineID: null,			// need this or ItemSetID
	
	constructor: function(params, domNode)
	{
		console.log("CreatorPopupDialog.ctor");
		// cache the incoming params for when we create the creator
		this._inputParams = params;
	},
	postMixInProperties: function()
	{
		console.log("CreatorPopupDialog.postMixInProperties");
		
		// get i18n text
		this.createRequestButtonLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").CreateRequestButtonLabel;
		this.cancelButtonLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").CancelButtonLabel;
		
		this.inherited(arguments);	
	},
	buildRendering: function()
	{
		console.log("CreatorPopupDialog.buildRendering");
 
		this.inherited(arguments);
			
		this.creator = ibm.tivoli.simplesrm.srm.dijit.CreateCatalogRequest.createInstanceOf(this.creatorType, this._inputParams);
		this.connect(this.creator,"onSrmRequestCreated","_disableButtons");
		this.connect(this.creator, 'onSrmRequestCreated', "_handleOnSrmRequestCreated");
		this.connect(this.creator, '_disableOkButton', "_disableOkButton");
		this.connect(this.creator, '_enableOkButton', "_enableOkButton");

		this.title = this.creator.headingText;
		
		// adding a class to the top-level div lets me style this popup differently than the generic dijit.Dialog
		dojo.addClass(this.domNode, "popupCreator");
		console.log("CreatorPopupDialog.buildRendering - exit");
	
	},
	postCreate: function(){	
		console.log("CreatorPopupDialog.postCreate");
		this.inherited(arguments);
		
		// add the footer to the bottom of the dialog
		var footer = document.createElement("div");
		footer.className = "footer";
		footer.innerHTML = "\n		<button id=\""+this.creator.id+"_createButton"+"\" dojoType=\"dijit.form.Button\">"+this.createRequestButtonLabel+"</button>"+
						"\n		<button id=\""+this.creator.id+"_cancelButton"+"\" dojoType=\"dijit.form.Button\">"+this.cancelButtonLabel+"</button>"+
						"\n		<span  id=\""+this.creator.id+"_spinner"+"\"dojoType=\"ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner\" style=\"vertical-align:middle;\"></span>";

		dojo.style(footer, "height", "31px");
		dojo.style(this.titleBar, "height", "25px");
		dojo.parser.parse(footer);
		dojo.place(footer, this.domNode, "last");
		
		// wire up the buttons
		this.connect(dijit.byId(this.creator.id+"_createButton"), "onClick", "_createRequest");
		this.connect(dijit.byId(this.creator.id+"_cancelButton"), "onClick", "_cancelRequest");

		if(this.readOnly) {
			dijit.byId(this.creator.id+"_createButton").setLabel("Close");
			dojo.style(dijit.byId(this.creator.id+"_cancelButton").domNode, "display", "none");
		}
		
		// create a div to hold our content, the creator + the footer
		var content_div = document.createElement("div");
		// add the creator widget 
		dojo.place(this.creator.domNode, content_div, "first");

		// give our content to the popup
		this.attr('content', content_div);		
		
		// move the banner from the creator to the Dialog.
		// TODO: should we move the banner from offering templates and add it here?
		divlist = dojo.query(".banner", this.containerNode);
		var banner = divlist.length > 0 ? divlist[0] : null;
		if(banner) {
			banner.parentNode.removeChild(banner);
			var d = document.createElement("div");
			d.appendChild(banner);
			dojo.place(d, this.titleBar, "after");
		}
		
		//if cshKey was provided add help to this dialog
		if(this.creator.cshKey){
			this.addHelp(this.creator.cshKey);			
		}
	},
	startup: function()
	{
		console.log("CreatorPopupDialog.startup");
		this.inherited(arguments);
		this.progressSpinner = dijit.byId(this.creator.id + "_spinner");
		this._size();
		this._position();
	},
	destroy: function()
	{
		console.log("CreatorPopupDialog.destroy");
		
		if(this.creator) {
			this.creator.destroy();
			this.creator = null;
		}
		var c;
		while(c = this._connections.pop()) {
			dojo.disconnect(c);
		}
		this.inherited(arguments);
	},

	/**
	 * Defines relation for confirmation purposes, request type to post data
	 * field to represent object in confirmation message.
	 * All mentioned requests are needed to be confirmed. 
	 */	
	contentMapping : {
						PMRDP_0253A_72 : "ObjectName",
						PMRDP_0218A_72 : "PMRDPCLCPR_PROJECTNAME", 
						PMRDP_0221A_72 : "ObjectName", 
						PMRDP_0237A_72 : "PMRDPCLCUSR_TEAM_NAME",					
						PMRDP_0233A_72 : "PMRDPCLCUSR_USER_NAMES"
	},
	 
	
	_disableButtons: function()
	{
		this._disableOkButton();
		
		 var cancelButton = dijit.byId(this.creator.id+"_cancelButton");
		 cancelButton.attr("disabled", true);
	},
	
	_disableOkButton: function(text){
		 var okButton = dijit.byId(this.creator.id+"_createButton");
		 okButton.attr("disabled", true);
		 
		 var okDojoButton = dojo.byId(this.creator.id+"_createButton");
		 
		 var tooltip = dijit.byId(this.creator.id+"_createTooltip"); 
		 if (text && !tooltip)
		 {
		  this.addParentTooltip(this.creator.id+"_createButton", text);
		 }
	},
	
	addTooltip: function (node, text) {
		    var tooltip = new dijit.Tooltip({connectId: node, label: text, id: this.creator.id+"_createTooltip"});
	},
	
	addParentTooltip: function(/*string*/id, /*string*/text) {
	    var nodes = dojo.query('[id="' + id + '"]');
	    var parents = dojo.map(nodes, function(node) {
	        return node.parentNode;
	    });
	    this.addTooltip(parents, text);
	},
	
	_enableOkButton: function(){
		 var okButton = dijit.byId(this.creator.id+"_createButton");
		 okButton.attr("disabled", false);	
		 
		 var tooltip = dijit.byId(this.creator.id+"_createTooltip");
		 if (tooltip){
		 tooltip.destroyRecursive();
		 }
		 
	},
	 
	/**
	 * Checks if confirmation dialog is needed, if yes prepares data and shows the dialog. 
	 */ 
	_createRequest: function()
	{						
		if (this.contentMapping[this.requestType]){ 
		//if requires confirmation
			
		var postData = this.creator._getPostData();
		var content = postData[this.contentMapping[this.requestType]];
		confirmation = new ibm.tivoli.simplesrm.srm.dijit.ConfirmationDialog();
		confirmation.show(this.title,
						  this.requestType,
						  content,
						  dojo.hitch(this, this._requestConfirmationCallback));
		} else { 
			//does not require confirmation
			this._requestConfirmationCallback(true);
		}
	},
	
	/**
	 * Depends on decision sends request or not.
	 */
	 _requestConfirmationCallback : function(decision){
		if (decision === true){
			if( this.readOnly ) {
				this.hide();
				this.disableAll(false);
				return;
			}
			this.disableAll(true);
			this.progressSpinner.show();
			this._sendRequest();
		}
	},

	_sendRequest: function() {
		var deferred = this.creator.createRequest();
		if(deferred) {
			deferred.addBoth(dojo.hitch(this, function() { 
				this.progressSpinner.hide();
				this.disableAll(false);
			}));
		}
		else {
			this.progressSpinner.hide();
			this.disableAll(false);
		}
	},

	_cancelRequest: function()
	{
		this.creator.cancelRequest();
		// this is a bit of a hack
		if(dijit._masterTT) {
			// or validation messages get left behind
			dijit.hideTooltip(dijit._masterTT.aroundNode);	
		}
		this.hide();
	},
	/*
	** _handleOnSrmRequestCreated was registered as the CreateCatalogRequest.onRequestCreated
	** event handler.  This funstion is simply thunk that will forward the event on to external handlers
	** listening for CreatorPopupDialog.onSrmRequestCreated
	*/
	_handleOnSrmRequestCreated: function()
	{
		console.log("CreatorPopupDialog._handleOnSrmRequestCreated()");

		if(undefined === this.iContext) {
			this.onSrmRequestCreated();
		}
		else {
			console.log("CreatePopupDialog is firing iWidget event SrmRequestCreated");
			this.iContext.iEvents.fireEvent("SrmRequestCreated", "string", "");
		}	
	},
	onSrmRequestCreated: function()
	{
	}

});	

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.CreatorFactory", null,
{
	createEventHandles: [],		// dojo.connect handles I create wiring in the creator popup
	_popup: null,				// the creator popup
	_overlay: null,				// keep user from clicking while the popup is getting created

	destroy: function()
	{
		this.cleanup();
		if(this._overlay) {
			this._overlay.destroy();
			this._overlay = null;
		}
	},
	createAndShowInputForm: function(record_data, bReadOnly)
	{
		//debugger;
      	console.log("CreateCatalogRequest:createAndShowInputForm - ", record_data, bReadOnly);
		
		this.cleanup();
		
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		//SRM dialogs
		//TODO - add presentation/type/presentationxml to OS.  If presentationtype=custom and presentationxml  starts with Dojo*
		// start Dojo dialog 
		if ((product!=null && product.indexOf("srm")>=0)) { 
			var node = dojo.byId(this.id);			
			//Catalog Offering	
			if(record_data.ItemNum!=undefined)	{
                var value = record_data.ItemNum;
                if(record_data.ItemSetID!=undefined)
                	value = value+","+record_data.ItemSetID;
				console.log("createAndShowInputForm: sendEvent event = launchdialog, item = " +  value+ ", id = " + node.id);
				//arguments.caller=null; //running into a IE bug in stacktrace()
				sendEvent("launchdialog", node.id,  value);
				return;
				//Solution
			} else if (record_data.Solution && record_data.ID!=undefined) {				
				console.log("createAndShowInputForm: sendEvent event = viewsolution, item = " +  record_data.ID + ", id = " + node.id);
				//arguments.caller=null; //running into a IE bug in stacktrace()
				sendEvent("viewsolution", node.id,  record_data.ID);
				return;
    		} else if (record_data.Template && record_data.ID!=undefined) {				
				console.log("createAndShowInputForm: sendEvent event = srmsscreatesr, item = " +  record_data.ID + ", id = " + node.id);
				//arguments.caller=null; //running into a IE bug in stacktrace()
				sendEvent("srmsscreatesr", node.id,  record_data.ID);
				return;
    		} else if (record_data.type=='dialog' && record_data.target!=undefined) {				
				console.log("createAndShowInputForm: sendEvent event dialog, target = " +  record_data.target + ", id = " + node.id);
				//arguments.caller=null; //running into a IE bug in stacktrace()
				//sendEvent("launchdialog", node.id,  record_data.target);
				sendEvent("launchcustdialog", this.nav_node.id,  record_data.target);
				return;
    		} else if (record_data.type=='application' && record_data.target!=undefined) {				
				console.log("createAndShowInputForm: sendEvent event app, target = " +  record_data.target + ", id = " + node.id);
				//arguments.caller=null; //running into a IE bug in stacktrace()
				//sendEvent("launchdialog", node.id,  record_data.target);
				sendEvent("applink", this.nav_node.id,  record_data.target);
				return;
    		} else if (record_data.type=='url' && record_data.target!=undefined) {  //LIC type				
				console.log("createAndShowInputForm: sendEvent event lic = " +  record_data.target + ", id = " + node.id);
				//arguments.caller=null; //running into a IE bug in stacktrace()
				//sendEvent("launchdialog", node.id,  record_data.target);
				sendEvent("liclink", this.nav_node.id,  record_data.target);
				return;
    		}
		}	
		//although all modal panel use dijit._underlay we still need this additional underlay  
		// time between user click and displaying dijit._underlay is long enough to open many panels		
		if(this._overlay === null) {
			this._overlay = new dijit.DialogUnderlay();
			dojo.style(this._overlay.node, "cursor", "wait");
			dojo.style(this._overlay.node, "backgroundColor", "transparent");
		}
		this._overlay.show();
			
		try {
			if(record_data.ItemNum)	{
				try {
					var itemnum = record_data.ItemNum;
					var requestType = itemnum;
					var APPPATH = ibm.tivoli.tpae.dojo.data.getConfigProperty("APP_PATH").split(',');					
					var inputFormFullName = null;
					for(var p in APPPATH) {
						if(APPPATH.hasOwnProperty(p)){
							try {
								var apath = APPPATH[p].trim();
								console.log("looking for %s in %s", requestType, apath);
								module = dojo._loadModule(apath + ".dijit.request." + itemnum);
								if(module) {
									inputFormFullName = apath + ".dijit.request." + itemnum;
									console.log("found ", inputFormFullName);
									break;
								}
							}
							catch(ex) {
								// keep trying
								console.log("nope, not here - " + ex);
							}
						}
					}
					 
					if(!inputFormFullName) {
						// failed loading the custom creator.  Let's go generic	
						requestType = "GenericForm";
						dojo._loadModule("ibm.tivoli.simplesrm.srm.dijit.request.GenericForm");
						inputFormFullName = "ibm.tivoli.simplesrm.srm.dijit.request.GenericForm";
						console.log("using GenericForm");
					}

					try {
						create_params = {
			  			requestType: requestType,
			  			creatorType: inputFormFullName,
			  			readOnly: bReadOnly
						};
						for(var k in record_data) {
							if(record_data){
								create_params[k] = record_data[k];
							}
						}
						this._popup = new ibm.tivoli.simplesrm.srm.dijit.CreatorPopupDialog(create_params);
						console.log("CreatorPopupDialog constructed");
						this.createEventHandles.push( dojo.connect(this._popup, 'onSrmRequestCreated', this, "oncreated") );
						this._popup.startup();
						this._popup.show();	// warning, asynchronous
					}
					catch(ex) {
						ibm.tivoli.logger.error("Failed creating " + itemnum + " editor: ", ex);
						if ("string" === typeof ex) {      // If we have a string it is the message ID to show
							(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: ex})).show();
							console.error("failed creating popup editor:", ex);
						} else {
							(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2301E"})).show();
							console.error("failed creating popup editor:", ex);
						}
						this.cleanup();
					}
					
					}
				catch(ex) {
					ibm.tivoli.logger.error("",ex);
					console.log(requestType + " not found");
					this.cleanup();
				 	(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2308E"})).show();		
				}
			}
			else {
				// if we get here, we don' know what to do
			 	(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2309E"})).show();
			}
		}
		catch(ex)
		{
			ibm.tivoli.logger.error("",ex);
		 	(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2309E"})).show();
		}
		if(this._overlay) {
			this._overlay.hide();
		}
		return this._popup;
	},
	cleanup: function()
	{
		while(handle = this.createEventHandles.pop()) {
			dojo.disconnect(handle);
		}
		if(this._popup !== null) {
			this._popup.destroy();
			this._popup = null;
		}
	},
	oncreated: function()
	{
		if(this._popup){
			this._popup.hide();	// warning: asynchronous
		}
		if(typeof this.onSrmRequestCreated == "function") {
			this.onSrmRequestCreated();
		}			
	},
	_dummy: null
});

});

},
'dijit/form/Button':function(){
require({cache:{
'url:dijit/form/templates/Button.html':"<span class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><span class=\"dijitReset dijitInline dijitButtonNode\"\n\t\tdata-dojo-attach-event=\"ondijitclick:_onClick\" role=\"presentation\"\n\t\t><span class=\"dijitReset dijitStretch dijitButtonContents\"\n\t\t\tdata-dojo-attach-point=\"titleNode,focusNode\"\n\t\t\trole=\"button\" aria-labelledby=\"${id}_label\"\n\t\t\t><span class=\"dijitReset dijitInline dijitIcon\" data-dojo-attach-point=\"iconNode\"></span\n\t\t\t><span class=\"dijitReset dijitToggleButtonIconChar\">&#x25CF;</span\n\t\t\t><span class=\"dijitReset dijitInline dijitButtonText\"\n\t\t\t\tid=\"${id}_label\"\n\t\t\t\tdata-dojo-attach-point=\"containerNode\"\n\t\t\t></span\n\t\t></span\n\t></span\n\t><input ${!nameAttrSetting} type=\"${type}\" value=\"${value}\" class=\"dijitOffScreen\"\n\t\ttabIndex=\"-1\" role=\"presentation\" data-dojo-attach-point=\"valueNode\"\n/></span>\n"}});
define("dijit/form/Button", [
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.trim
	"dojo/ready",
	"./_FormWidget",
	"./_ButtonMixin",
	"dojo/text!./templates/Button.html"
], function(require, declare, domClass, kernel, lang, ready, _FormWidget, _ButtonMixin, template){

/*=====
	var _FormWidget = dijit.form._FormWidget;
	var _ButtonMixin = dijit.form._ButtonMixin;
=====*/

// module:
//		dijit/form/Button
// summary:
//		Button widget

// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/form/DropDownButton", "dijit/form/ComboButton", "dijit/form/ToggleButton"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

return declare("dijit.form.Button", [_FormWidget, _ButtonMixin], {
	// summary:
	//		Basically the same thing as a normal HTML button, but with special styling.
	// description:
	//		Buttons can display a label, an icon, or both.
	//		A label should always be specified (through innerHTML) or the label
	//		attribute.  It can be hidden via showLabel=false.
	// example:
	// |	<button data-dojo-type="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// showLabel: Boolean
	//		Set this to true to hide the label text and display only the icon.
	//		(If showLabel=false then iconClass must be specified.)
	//		Especially useful for toolbars.
	//		If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	//
	//		The exception case is for computers in high-contrast mode, where the label
	//		will still be displayed, since the icon doesn't appear.
	showLabel: true,

	// iconClass: String
	//		Class to apply to DOMNode in button to make it display an icon
	iconClass: "dijitNoIcon",
	_setIconClassAttr: { node: "iconNode", type: "class" },

	baseClass: "dijitButton",

	templateString: template,

	// Map widget attributes to DOMNode attributes.
	_setValueAttr: "valueNode",

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		var ok = this.inherited(arguments);
		if(ok){
			if(this.valueNode){
				this.valueNode.click();
				e.preventDefault(); // cancel BUTTON click and continue with hidden INPUT click
				// leave ok = true so that subclasses can do what they need to do
			}
		}
		return ok;
	},

	_fillContent: function(/*DomNode*/ source){
		// Overrides _Templated._fillContent().
		// If button label is specified as srcNodeRef.innerHTML rather than
		// this.params.label, handle it here.
		// TODO: remove the method in 2.0, parser will do it all for me
		if(source && (!this.params || !("label" in this.params))){
			var sourceLabel = lang.trim(source.innerHTML);
			if(sourceLabel){
				this.label = sourceLabel; // _applyAttributes will be called after buildRendering completes to update the DOM
			}
		}
	},

	_setShowLabelAttr: function(val){
		if(this.containerNode){
			domClass.toggle(this.containerNode, "dijitDisplayNone", !val);
		}
		this._set("showLabel", val);
	},

	setLabel: function(/*String*/ content){
		// summary:
		//		Deprecated.  Use set('label', ...) instead.
		kernel.deprecated("dijit.form.Button.setLabel() is deprecated.  Use set('label', ...) instead.", "", "2.0");
		this.set("label", content);
	},

	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		//		If the label is hidden (showLabel=false) then and no title has
		//		been specified, then label is also set as title attribute of icon.
		this.inherited(arguments);
		if(!this.showLabel && !("title" in this.params)){
			this.titleNode.title = lang.trim(this.containerNode.innerText || this.containerNode.textContent || '');
		}
	}
});


});


},
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n",
'dijit/_WidgetBase':function(){
define("dijit/_WidgetBase", [
	"require",			// require.toUrl
	"dojo/_base/array", // array.forEach array.map
	"dojo/aspect",
	"dojo/_base/config", // config.blankGif
	"dojo/_base/connect", // connect.connect
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.set domAttr.remove
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/dom-construct", // domConstruct.create domConstruct.destroy domConstruct.place
	"dojo/dom-geometry",	// isBodyLtr
	"dojo/dom-style", // domStyle.set, domStyle.get
	"dojo/_base/kernel",
	"dojo/_base/lang", // mixin(), isArray(), etc.
	"dojo/on",
	"dojo/ready",
	"dojo/Stateful", // Stateful
	"dojo/topic",
	"dojo/_base/window", // win.doc.createTextNode
	"./registry"	// registry.getUniqueId(), registry.findWidgets()
], function(require, array, aspect, config, connect, declare,
			dom, domAttr, domClass, domConstruct, domGeometry, domStyle, kernel,
			lang, on, ready, Stateful, topic, win, registry){

/*=====
var Stateful = dojo.Stateful;
=====*/

// module:
//		dijit/_WidgetBase
// summary:
//		Future base class for all Dijit widgets.

// For back-compat, remove in 2.0.
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/_base/manager"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

// Nested hash listing attributes for each tag, all strings in lowercase.
// ex: {"div": {"style": true, "tabindex" true}, "form": { ...
var tagAttrs = {};
function getAttrs(obj){
	var ret = {};
	for(var attr in obj){
		ret[attr.toLowerCase()] = true;
	}
	return ret;
}

function nonEmptyAttrToDom(attr){
	// summary:
	//		Returns a setter function that copies the attribute to this.domNode,
	//		or removes the attribute from this.domNode, depending on whether the
	//		value is defined or not.
	return function(val){
		domAttr[val ? "set" : "remove"](this.domNode, attr, val);
		this._set(attr, val);
	};
}

return declare("dijit._WidgetBase", Stateful, {
	// summary:
	//		Future base class for all Dijit widgets.
	// description:
	//		Future base class for all Dijit widgets.
	//		_Widget extends this class adding support for various features needed by desktop.
	//
	//		Provides stubs for widget lifecycle methods for subclasses to extend, like postMixInProperties(), buildRendering(),
	//		postCreate(), startup(), and destroy(), and also public API methods like set(), get(), and watch().
	//
	//		Widgets can provide custom setters/getters for widget attributes, which are called automatically by set(name, value).
	//		For an attribute XXX, define methods _setXXXAttr() and/or _getXXXAttr().
	//
	//		_setXXXAttr can also be a string/hash/array mapping from a widget attribute XXX to the widget's DOMNodes:
	//
	//		- DOM node attribute
	// |		_setFocusAttr: {node: "focusNode", type: "attribute"}
	// |		_setFocusAttr: "focusNode"	(shorthand)
	// |		_setFocusAttr: ""		(shorthand, maps to this.domNode)
	// 		Maps this.focus to this.focusNode.focus, or (last example) this.domNode.focus
	//
	//		- DOM node innerHTML
	//	|		_setTitleAttr: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		_setTitleAttr: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		_setMyClassAttr: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value of _setXXXAttr is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		If the custom setter is null, no action is performed other than saving the new value
	//		in the widget (in this).
	//
	//		If no custom setter is defined for an attribute, then it will be copied
	//		to this.focusNode (if the widget defines a focusNode), or this.domNode otherwise.
	//		That's only done though for attributes that match DOMNode attributes (title,
	//		alt, aria-labelledby, etc.)

	// id: [const] String
	//		A unique, opaque ID string that can be assigned by users or by the
	//		system. If the developer passes an ID which is known not to be
	//		unique, the specified ID is ignored and the system-generated ID is
	//		used instead.
	id: "",
	_setIdAttr: "domNode",	// to copy to this.domNode even for auto-generated id's

	// lang: [const] String
	//		Rarely used.  Overrides the default Dojo locale used to render this widget,
	//		as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	//		Value must be among the list of locales specified during by the Dojo bootstrap,
	//		formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).
	lang: "",
	// set on domNode even when there's a focus node.   but don't set lang="", since that's invalid.
	_setLangAttr: nonEmptyAttrToDom("lang"),

	// dir: [const] String
	//		Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	//		attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
	//		default direction.
	dir: "",
	// set on domNode even when there's a focus node.   but don't set dir="", since that's invalid.
	_setDirAttr: nonEmptyAttrToDom("dir"),	// to set on domNode even when there's a focus node

	// textDir: String
	//		Bi-directional support,	the main variable which is responsible for the direction of the text.
	//		The text direction can be different than the GUI direction by using this parameter in creation
	//		of a widget.
	// 		Allowed values:
	//			1. "ltr"
	//			2. "rtl"
	//			3. "auto" - contextual the direction of a text defined by first strong letter.
	//		By default is as the page direction.
	textDir: "",

	// class: String
	//		HTML class attribute
	"class": "",
	_setClassAttr: { node: "domNode", type: "class" },

	// style: String||Object
	//		HTML style attributes as cssText string or name/value hash
	style: "",

	// title: String
	//		HTML title attribute.
	//
	//		For form widgets this specifies a tooltip to display when hovering over
	//		the widget (just like the native HTML title attribute).
	//
	//		For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
	//		etc., it's used to specify the tab label, accordion pane title, etc.
	title: "",

	// tooltip: String
	//		When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	//		this specifies the tooltip to appear when the mouse is hovered over that text.
	tooltip: "",

	// baseClass: [protected] String
	//		Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
	//		widget state.
	baseClass: "",

	// srcNodeRef: [readonly] DomNode
	//		pointer to original DOM node
	srcNodeRef: null,

	// domNode: [readonly] DomNode
	//		This is our visible representation of the widget! Other DOM
	//		Nodes may by assigned to other properties, usually through the
	//		template system's data-dojo-attach-point syntax, but the domNode
	//		property is the canonical "top level" node in widget UI.
	domNode: null,

	// containerNode: [readonly] DomNode
	//		Designates where children of the source DOM node will be placed.
	//		"Children" in this case refers to both DOM nodes and widgets.
	//		For example, for myWidget:
	//
	//		|	<div data-dojo-type=myWidget>
	//		|		<b> here's a plain DOM node
	//		|		<span data-dojo-type=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//		|	</div>
	//
	//		containerNode would point to:
	//
	//		|		<b> here's a plain DOM node
	//		|		<span data-dojo-type=subWidget>and a widget</span>
	//		|		<i> and another plain DOM node </i>
	//
	//		In templated widgets, "containerNode" is set via a
	//		data-dojo-attach-point assignment.
	//
	//		containerNode must be defined for any widget that accepts innerHTML
	//		(like ContentPane or BorderContainer or even Button), and conversely
	//		is null for widgets that don't, like TextBox.
	containerNode: null,

/*=====
	// _started: Boolean
	//		startup() has completed.
	_started: false,
=====*/

	// attributeMap: [protected] Object
	//		Deprecated.   Instead of attributeMap, widget should have a _setXXXAttr attribute
	//		for each XXX attribute to be mapped to the DOM.
	//
	//		attributeMap sets up a "binding" between attributes (aka properties)
	//		of the widget and the widget's DOM.
	//		Changes to widget attributes listed in attributeMap will be
	//		reflected into the DOM.
	//
	//		For example, calling set('title', 'hello')
	//		on a TitlePane will automatically cause the TitlePane's DOM to update
	//		with the new title.
	//
	//		attributeMap is a hash where the key is an attribute of the widget,
	//		and the value reflects a binding to a:
	//
	//		- DOM node attribute
	// |		focus: {node: "focusNode", type: "attribute"}
	// 		Maps this.focus to this.focusNode.focus
	//
	//		- DOM node innerHTML
	//	|		title: { node: "titleNode", type: "innerHTML" }
	//		Maps this.title to this.titleNode.innerHTML
	//
	//		- DOM node innerText
	//	|		title: { node: "titleNode", type: "innerText" }
	//		Maps this.title to this.titleNode.innerText
	//
	//		- DOM node CSS class
	// |		myClass: { node: "domNode", type: "class" }
	//		Maps this.myClass to this.domNode.className
	//
	//		If the value is an array, then each element in the array matches one of the
	//		formats of the above list.
	//
	//		There are also some shorthands for backwards compatibility:
	//		- string --> { node: string, type: "attribute" }, for example:
	//	|	"focusNode" ---> { node: "focusNode", type: "attribute" }
	//		- "" --> { node: "domNode", type: "attribute" }
	attributeMap: {},

	// _blankGif: [protected] String
	//		Path to a blank 1x1 image.
	//		Used by <img> nodes in templates that really get their image via CSS background-image.
	_blankGif: config.blankGif || require.toUrl("dojo/resources/blank.gif"),

	//////////// INITIALIZATION METHODS ///////////////////////////////////////

	postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
		// summary:
		//		Kicks off widget instantiation.  See create() for details.
		// tags:
		//		private
		this.create(params, srcNodeRef);
	},

	create: function(/*Object?*/params, /*DomNode|String?*/srcNodeRef){
		// summary:
		//		Kick off the life-cycle of a widget
		// params:
		//		Hash of initialization parameters for widget, including
		//		scalar values (like title, duration etc.) and functions,
		//		typically callbacks like onClick.
		// srcNodeRef:
		//		If a srcNodeRef (DOM node) is specified:
		//			- use srcNodeRef.innerHTML as my contents
		//			- if this is a behavioral widget then apply behavior
		//			  to that srcNodeRef
		//			- otherwise, replace srcNodeRef with my generated DOM
		//			  tree
		// description:
		//		Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
		//		etc.), some of which of you'll want to override. See http://dojotoolkit.org/reference-guide/dijit/_WidgetBase.html
		//		for a discussion of the widget creation lifecycle.
		//
		//		Of course, adventurous developers could override create entirely, but this should
		//		only be done as a last resort.
		// tags:
		//		private

		// store pointer to original DOM tree
		this.srcNodeRef = dom.byId(srcNodeRef);

		// For garbage collection.  An array of listener handles returned by this.connect() / this.subscribe()
		this._connects = [];

		// For widgets internal to this widget, invisible to calling code
		this._supportingWidgets = [];

		// this is here for back-compat, remove in 2.0 (but check NodeList-instantiate.html test)
		if(this.srcNodeRef && (typeof this.srcNodeRef.id == "string")){ this.id = this.srcNodeRef.id; }

		// mix in our passed parameters
		if(params){
			this.params = params;
			lang.mixin(this, params);
		}
		this.postMixInProperties();

		// generate an id for the widget if one wasn't specified
		// (be sure to do this before buildRendering() because that function might
		// expect the id to be there.)
		if(!this.id){
			this.id = registry.getUniqueId(this.declaredClass.replace(/\./g,"_"));
		}
		registry.add(this);

		this.buildRendering();

		if(this.domNode){
			// Copy attributes listed in attributeMap into the [newly created] DOM for the widget.
			// Also calls custom setters for all attributes with custom setters.
			this._applyAttributes();

			// If srcNodeRef was specified, then swap out original srcNode for this widget's DOM tree.
			// For 2.0, move this after postCreate().  postCreate() shouldn't depend on the
			// widget being attached to the DOM since it isn't when a widget is created programmatically like
			// new MyWidget({}).   See #11635.
			var source = this.srcNodeRef;
			if(source && source.parentNode && this.domNode !== source){
				source.parentNode.replaceChild(this.domNode, source);
			}
		}

		if(this.domNode){
			// Note: for 2.0 may want to rename widgetId to dojo._scopeName + "_widgetId",
			// assuming that dojo._scopeName even exists in 2.0
			this.domNode.setAttribute("widgetId", this.id);
		}
		this.postCreate();

		// If srcNodeRef has been processed and removed from the DOM (e.g. TemplatedWidget) then delete it to allow GC.
		if(this.srcNodeRef && !this.srcNodeRef.parentNode){
			delete this.srcNodeRef;
		}

		this._created = true;
	},

	_applyAttributes: function(){
		// summary:
		//		Step during widget creation to copy  widget attributes to the
		//		DOM according to attributeMap and _setXXXAttr objects, and also to call
		//		custom _setXXXAttr() methods.
		//
		//		Skips over blank/false attribute values, unless they were explicitly specified
		//		as parameters to the widget, since those are the default anyway,
		//		and setting tabIndex="" is different than not setting tabIndex at all.
		//
		//		For backwards-compatibility reasons attributeMap overrides _setXXXAttr when
		//		_setXXXAttr is a hash/string/array, but _setXXXAttr as a functions override attributeMap.
		// tags:
		//		private

		// Get list of attributes where this.set(name, value) will do something beyond
		// setting this[name] = value.  Specifically, attributes that have:
		//		- associated _setXXXAttr() method/hash/string/array
		//		- entries in attributeMap.
		var ctor = this.constructor,
			list = ctor._setterAttrs;
		if(!list){
			list = (ctor._setterAttrs = []);
			for(var attr in this.attributeMap){
				list.push(attr);
			}

			var proto = ctor.prototype;
			for(var fxName in proto){
				if(fxName in this.attributeMap){ continue; }
				var setterName = "_set" + fxName.replace(/^[a-z]|-[a-zA-Z]/g, function(c){ return c.charAt(c.length-1).toUpperCase(); }) + "Attr";
				if(setterName in proto){
					list.push(fxName);
				}
			}
		}

		// Call this.set() for each attribute that was either specified as parameter to constructor,
		// or was found above and has a default non-null value.   For correlated attributes like value and displayedValue, the one
		// specified as a parameter should take precedence, so apply attributes in this.params last.
		// Particularly important for new DateTextBox({displayedValue: ...}) since DateTextBox's default value is
		// NaN and thus is not ignored like a default value of "".
		array.forEach(list, function(attr){
			if(this.params && attr in this.params){
				// skip this one, do it below
			}else if(this[attr]){
				this.set(attr, this[attr]);
			}
		}, this);
		for(var param in this.params){
			this.set(param, this[param]);
		}
	},

	postMixInProperties: function(){
		// summary:
		//		Called after the parameters to the widget have been read-in,
		//		but before the widget template is instantiated. Especially
		//		useful to set properties that are referenced in the widget
		//		template.
		// tags:
		//		protected
	},

	buildRendering: function(){
		// summary:
		//		Construct the UI for this widget, setting this.domNode.
		//		Most widgets will mixin `dijit._TemplatedMixin`, which implements this method.
		// tags:
		//		protected

		if(!this.domNode){
			// Create root node if it wasn't created by _Templated
			this.domNode = this.srcNodeRef || domConstruct.create('div');
		}

		// baseClass is a single class name or occasionally a space-separated list of names.
		// Add those classes to the DOMNode.  If RTL mode then also add with Rtl suffix.
		// TODO: make baseClass custom setter
		if(this.baseClass){
			var classes = this.baseClass.split(" ");
			if(!this.isLeftToRight()){
				classes = classes.concat( array.map(classes, function(name){ return name+"Rtl"; }));
			}
			domClass.add(this.domNode, classes);
		}
	},

	postCreate: function(){
		// summary:
		//		Processing after the DOM fragment is created
		// description:
		//		Called after the DOM fragment has been created, but not necessarily
		//		added to the document.  Do not include any operations which rely on
		//		node dimensions or placement.
		// tags:
		//		protected
	},

	startup: function(){
		// summary:
		//		Processing after the DOM fragment is added to the document
		// description:
		//		Called after a widget and its children have been created and added to the page,
		//		and all related widgets have finished their create() cycle, up through postCreate().
		//		This is useful for composite widgets that need to control or layout sub-widgets.
		//		Many layout widgets can use this as a wiring phase.
		if(this._started){ return; }
		this._started = true;
		array.forEach(this.getChildren(), function(obj){
			if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
				obj.startup();
				obj._started = true;
			}
		});
	},

	//////////// DESTROY FUNCTIONS ////////////////////////////////

	destroyRecursive: function(/*Boolean?*/ preserveDom){
		// summary:
		// 		Destroy this widget and its descendants
		// description:
		//		This is the generic "destructor" function that all widget users
		// 		should call to cleanly discard with a widget. Once a widget is
		// 		destroyed, it is removed from the manager object.
		// preserveDom:
		//		If true, this method will leave the original DOM structure
		//		alone of descendant Widgets. Note: This will NOT work with
		//		dijit._Templated widgets.

		this._beingDestroyed = true;
		this.destroyDescendants(preserveDom);
		this.destroy(preserveDom);
	},

	destroy: function(/*Boolean*/ preserveDom){
		// summary:
		// 		Destroy this widget, but not its descendants.
		//		This method will, however, destroy internal widgets such as those used within a template.
		// preserveDom: Boolean
		//		If true, this method will leave the original DOM structure alone.
		//		Note: This will not yet work with _Templated widgets

		this._beingDestroyed = true;
		this.uninitialize();

		// remove this.connect() and this.subscribe() listeners
		var c;
		while(c = this._connects.pop()){
			c.remove();
		}

		// destroy widgets created as part of template, etc.
		var w;
		while(w = this._supportingWidgets.pop()){
			if(w.destroyRecursive){
				w.destroyRecursive();
			}else if(w.destroy){
				w.destroy();
			}
		}

		this.destroyRendering(preserveDom);
		registry.remove(this.id);
		this._destroyed = true;
	},

	destroyRendering: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Destroys the DOM nodes associated with this widget
		// preserveDom:
		//		If true, this method will leave the original DOM structure alone
		//		during tear-down. Note: this will not work with _Templated
		//		widgets yet.
		// tags:
		//		protected

		if(this.bgIframe){
			this.bgIframe.destroy(preserveDom);
			delete this.bgIframe;
		}

		if(this.domNode){
			if(preserveDom){
				domAttr.remove(this.domNode, "widgetId");
			}else{
				domConstruct.destroy(this.domNode);
			}
			delete this.domNode;
		}

		if(this.srcNodeRef){
			if(!preserveDom){
				domConstruct.destroy(this.srcNodeRef);
			}
			delete this.srcNodeRef;
		}
	},

	destroyDescendants: function(/*Boolean?*/ preserveDom){
		// summary:
		//		Recursively destroy the children of this widget and their
		//		descendants.
		// preserveDom:
		//		If true, the preserveDom attribute is passed to all descendant
		//		widget's .destroy() method. Not for use with _Templated
		//		widgets.

		// get all direct descendants and destroy them recursively
		array.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
	},

	uninitialize: function(){
		// summary:
		//		Stub function. Override to implement custom widget tear-down
		//		behavior.
		// tags:
		//		protected
		return false;
	},

	////////////////// GET/SET, CUSTOM SETTERS, ETC. ///////////////////

	_setStyleAttr: function(/*String||Object*/ value){
		// summary:
		//		Sets the style attribute of the widget according to value,
		//		which is either a hash like {height: "5px", width: "3px"}
		//		or a plain string
		// description:
		//		Determines which node to set the style on based on style setting
		//		in attributeMap.
		// tags:
		//		protected

		var mapNode = this.domNode;

		// Note: technically we should revert any style setting made in a previous call
		// to his method, but that's difficult to keep track of.

		if(lang.isObject(value)){
			domStyle.set(mapNode, value);
		}else{
			if(mapNode.style.cssText){
				mapNode.style.cssText += "; " + value;
			}else{
				mapNode.style.cssText = value;
			}
		}

		this._set("style", value);
	},

	_attrToDom: function(/*String*/ attr, /*String*/ value, /*Object?*/ commands){
		// summary:
		//		Reflect a widget attribute (title, tabIndex, duration etc.) to
		//		the widget DOM, as specified by commands parameter.
		//		If commands isn't specified then it's looked up from attributeMap.
		//		Note some attributes like "type"
		//		cannot be processed this way as they are not mutable.
		//
		// tags:
		//		private

		commands = arguments.length >= 3 ? commands : this.attributeMap[attr];

		array.forEach(lang.isArray(commands) ? commands : [commands], function(command){

			// Get target node and what we are doing to that node
			var mapNode = this[command.node || command || "domNode"];	// DOM node
			var type = command.type || "attribute";	// class, innerHTML, innerText, or attribute

			switch(type){
				case "attribute":
					if(lang.isFunction(value)){ // functions execute in the context of the widget
						value = lang.hitch(this, value);
					}

					// Get the name of the DOM node attribute; usually it's the same
					// as the name of the attribute in the widget (attr), but can be overridden.
					// Also maps handler names to lowercase, like onSubmit --> onsubmit
					var attrName = command.attribute ? command.attribute :
						(/^on[A-Z][a-zA-Z]*$/.test(attr) ? attr.toLowerCase() : attr);

					domAttr.set(mapNode, attrName, value);
					break;
				case "innerText":
					mapNode.innerHTML = "";
					mapNode.appendChild(win.doc.createTextNode(value));
					break;
				case "innerHTML":
					mapNode.innerHTML = value;
					break;
				case "class":
					domClass.replace(mapNode, value, this[attr]);
					break;
			}
		}, this);
	},

	get: function(name){
		// summary:
		//		Get a property from a widget.
		//	name:
		//		The property to get.
		// description:
		//		Get a named property from a widget. The property may
		//		potentially be retrieved via a getter method. If no getter is defined, this
		// 		just retrieves the object's property.
		//
		// 		For example, if the widget has properties `foo` and `bar`
		//		and a method named `_getFooAttr()`, calling:
		//		`myWidget.get("foo")` would be equivalent to calling
		//		`widget._getFooAttr()` and `myWidget.get("bar")`
		//		would be equivalent to the expression
		//		`widget.bar2`
		var names = this._getAttrNames(name);
		return this[names.g] ? this[names.g]() : this[name];
	},

	set: function(name, value){
		// summary:
		//		Set a property on a widget
		//	name:
		//		The property to set.
		//	value:
		//		The value to set in the property.
		// description:
		//		Sets named properties on a widget which may potentially be handled by a
		// 		setter in the widget.
		//
		// 		For example, if the widget has properties `foo` and `bar`
		//		and a method named `_setFooAttr()`, calling
		//		`myWidget.set("foo", "Howdy!")` would be equivalent to calling
		//		`widget._setFooAttr("Howdy!")` and `myWidget.set("bar", 3)`
		//		would be equivalent to the statement `widget.bar = 3;`
		//
		//		set() may also be called with a hash of name/value pairs, ex:
		//
		//	|	myWidget.set({
		//	|		foo: "Howdy",
		//	|		bar: 3
		//	|	});
		//
		//	This is equivalent to calling `set(foo, "Howdy")` and `set(bar, 3)`

		if(typeof name === "object"){
			for(var x in name){
				this.set(x, name[x]);
			}
			return this;
		}
		var names = this._getAttrNames(name),
			setter = this[names.s];
		if(lang.isFunction(setter)){
			// use the explicit setter
			var result = setter.apply(this, Array.prototype.slice.call(arguments, 1));
		}else{
			// Mapping from widget attribute to DOMNode attribute/value/etc.
			// Map according to:
			//		1. attributeMap setting, if one exists (TODO: attributeMap deprecated, remove in 2.0)
			//		2. _setFooAttr: {...} type attribute in the widget (if one exists)
			//		3. apply to focusNode or domNode if standard attribute name, excluding funcs like onClick.
			// Checks if an attribute is a "standard attribute" by whether the DOMNode JS object has a similar
			// attribute name (ex: accept-charset attribute matches jsObject.acceptCharset).
			// Note also that Tree.focusNode() is a function not a DOMNode, so test for that.
			var defaultNode = this.focusNode && !lang.isFunction(this.focusNode) ? "focusNode" : "domNode",
				tag = this[defaultNode].tagName,
				attrsForTag = tagAttrs[tag] || (tagAttrs[tag] = getAttrs(this[defaultNode])),
				map =	name in this.attributeMap ? this.attributeMap[name] :
						names.s in this ? this[names.s] :
						((names.l in attrsForTag && typeof value != "function") ||
							/^aria-|^data-|^role$/.test(name)) ? defaultNode : null;
			if(map != null){
				this._attrToDom(name, value, map);
			}
			this._set(name, value);
		}
		return result || this;
	},

	_attrPairNames: {},		// shared between all widgets
	_getAttrNames: function(name){
		// summary:
		//		Helper function for get() and set().
		//		Caches attribute name values so we don't do the string ops every time.
		// tags:
		//		private

		var apn = this._attrPairNames;
		if(apn[name]){ return apn[name]; }
		var uc = name.replace(/^[a-z]|-[a-zA-Z]/g, function(c){ return c.charAt(c.length-1).toUpperCase(); });
		return (apn[name] = {
			n: name+"Node",
			s: "_set"+uc+"Attr",	// converts dashes to camel case, ex: accept-charset --> _setAcceptCharsetAttr
			g: "_get"+uc+"Attr",
			l: uc.toLowerCase()		// lowercase name w/out dashes, ex: acceptcharset
		});
	},

	_set: function(/*String*/ name, /*anything*/ value){
		// summary:
		//		Helper function to set new value for specified attribute, and call handlers
		//		registered with watch() if the value has changed.
		var oldValue = this[name];
		this[name] = value;
		if(this._watchCallbacks && this._created && value !== oldValue){
			this._watchCallbacks(name, oldValue, value);
		}
	},

	on: function(/*String*/ type, /*Function*/ func){
		// summary:
		//		Call specified function when event occurs, ex: myWidget.on("click", function(){ ... }).
		// description:
		//		Call specified function when event `type` occurs, ex: `myWidget.on("click", function(){ ... })`.
		//		Note that the function is not run in any particular scope, so if (for example) you want it to run in the
		//		widget's scope you must do `myWidget.on("click", lang.hitch(myWidget, func))`.

		return aspect.after(this, this._onMap(type), func, true);
	},

	_onMap: function(/*String*/ type){
		// summary:
		//		Maps on() type parameter (ex: "mousemove") to method name (ex: "onMouseMove")
		var ctor = this.constructor, map = ctor._onMap;
		if(!map){
			map = (ctor._onMap = {});
			for(var attr in ctor.prototype){
				if(/^on/.test(attr)){
					map[attr.replace(/^on/, "").toLowerCase()] = attr;
				}
			}
		}
		return map[type.toLowerCase()];	// String
	},

	toString: function(){
		// summary:
		//		Returns a string that represents the widget
		// description:
		//		When a widget is cast to a string, this method will be used to generate the
		//		output. Currently, it does not implement any sort of reversible
		//		serialization.
		return '[Widget ' + this.declaredClass + ', ' + (this.id || 'NO ID') + ']'; // String
	},

	getChildren: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		Does not return nested widgets, nor widgets that are part of this widget's template.
		return this.containerNode ? registry.findWidgets(this.containerNode) : []; // dijit._Widget[]
	},

	getParent: function(){
		// summary:
		//		Returns the parent widget of this widget
		return registry.getEnclosingWidget(this.domNode.parentNode);
	},

	connect: function(
			/*Object|null*/ obj,
			/*String|Function*/ event,
			/*String|Function*/ method){
		// summary:
		//		Connects specified obj/event to specified method of this object
		//		and registers for disconnect() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.connect, except with the
		//		implicit use of this widget as the target object.
		//		Events connected with `this.connect` are disconnected upon
		//		destruction.
		// returns:
		//		A handle that can be passed to `disconnect` in order to disconnect before
		//		the widget is destroyed.
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when foo.bar() is called, call the listener we're going to
		//	|	// provide in the scope of btn
		//	|	btn.connect(foo, "bar", function(){
		//	|		console.debug(this.toString());
		//	|	});
		// tags:
		//		protected

		var handle = connect.connect(obj, event, this, method);
		this._connects.push(handle);
		return handle;		// _Widget.Handle
	},

	disconnect: function(handle){
		// summary:
		//		Disconnects handle created by `connect`.
		//		Also removes handle from this widget's list of connects.
		// tags:
		//		protected
		var i = array.indexOf(this._connects, handle);
		if(i != -1){
			handle.remove();
			this._connects.splice(i, 1);
		}
	},

	subscribe: function(t, method){
		// summary:
		//		Subscribes to the specified topic and calls the specified method
		//		of this object and registers for unsubscribe() on widget destroy.
		// description:
		//		Provide widget-specific analog to dojo.subscribe, except with the
		//		implicit use of this widget as the target object.
		// t: String
		//		The topic
		// method: Function
		//		The callback
		// example:
		//	|	var btn = new dijit.form.Button();
		//	|	// when /my/topic is published, this button changes its label to
		//	|   // be the parameter of the topic.
		//	|	btn.subscribe("/my/topic", function(v){
		//	|		this.set("label", v);
		//	|	});
		// tags:
		//		protected
		var handle = topic.subscribe(t, lang.hitch(this, method));
		this._connects.push(handle);
		return handle;		// _Widget.Handle
	},

	unsubscribe: function(/*Object*/ handle){
		// summary:
		//		Unsubscribes handle created by this.subscribe.
		//		Also removes handle from this widget's list of subscriptions
		// tags:
		//		protected
		this.disconnect(handle);
	},

	isLeftToRight: function(){
		// summary:
		//		Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
		// tags:
		//		protected
		return this.dir ? (this.dir == "ltr") : domGeometry.isBodyLtr(); //Boolean
	},

	isFocusable: function(){
		// summary:
		//		Return true if this widget can currently be focused
		//		and false if not
		return this.focus && (domStyle.get(this.domNode, "display") != "none");
	},

	placeAt: function(/* String|DomNode|_Widget */reference, /* String?|Int? */position){
		// summary:
		//		Place this widget's domNode reference somewhere in the DOM based
		//		on standard domConstruct.place conventions, or passing a Widget reference that
		//		contains and addChild member.
		//
		// description:
		//		A convenience function provided in all _Widgets, providing a simple
		//		shorthand mechanism to put an existing (or newly created) Widget
		//		somewhere in the dom, and allow chaining.
		//
		// reference:
		//		The String id of a domNode, a domNode reference, or a reference to a Widget possessing
		//		an addChild method.
		//
		// position:
		//		If passed a string or domNode reference, the position argument
		//		accepts a string just as domConstruct.place does, one of: "first", "last",
		//		"before", or "after".
		//
		//		If passed a _Widget reference, and that widget reference has an ".addChild" method,
		//		it will be called passing this widget instance into that method, supplying the optional
		//		position index passed.
		//
		// returns:
		//		dijit._Widget
		//		Provides a useful return of the newly created dijit._Widget instance so you
		//		can "chain" this function by instantiating, placing, then saving the return value
		//		to a variable.
		//
		// example:
		// | 	// create a Button with no srcNodeRef, and place it in the body:
		// | 	var button = new dijit.form.Button({ label:"click" }).placeAt(win.body());
		// | 	// now, 'button' is still the widget reference to the newly created button
		// | 	button.on("click", function(e){ console.log('click'); }));
		//
		// example:
		// |	// create a button out of a node with id="src" and append it to id="wrapper":
		// | 	var button = new dijit.form.Button({},"src").placeAt("wrapper");
		//
		// example:
		// |	// place a new button as the first element of some div
		// |	var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");
		//
		// example:
		// |	// create a contentpane and add it to a TabContainer
		// |	var tc = dijit.byId("myTabs");
		// |	new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)

		if(reference.declaredClass && reference.addChild){
			reference.addChild(this, position);
		}else{
			domConstruct.place(this.domNode, reference, position);
		}
		return this;
	},

	getTextDir: function(/*String*/ text,/*String*/ originalDir){
		// summary:
		//		Return direction of the text.
		//		The function overridden in the _BidiSupport module,
		//		its main purpose is to calculate the direction of the
		//		text, if was defined by the programmer through textDir.
		//	tags:
		//		protected.
		return originalDir;
	},

	applyTextDir: function(/*===== element, text =====*/){
		// summary:
		//		The function overridden in the _BidiSupport module,
		//		originally used for setting element.dir according to this.textDir.
		//		In this case does nothing.
		// element: DOMNode
		// text: String
		// tags:
		//		protected.
	}
});

});

},
'dojox/xml/DomParser':function(){
define("dojox/xml/DomParser", [
	"dojo/_base/kernel",// dojo.getObject
	"dojo/_base/array"	// dojo.forEach
], function(dojo){
dojo.getObject("xml", true, dojox);

dojox.xml.DomParser=new (function(){
	/**********************************************************
	 *	The DomParser is a close-to (but not entirely)
	 *	conforming XML parser based on regular
	 *	expressions.  It will take any XML fragment
	 *	and return a lightweight JS structure that is
	 *	similar to (but not exactly) the DOM specification.
	 *
	 *	Getter and setter methods are NOT available; the goal
	 *	was to keep the resulting object model entirely JS-like.
	 *
	 *	All node types but document fragments are supported;
	 *	all nodes support getElementsByTagName and
	 *	getElementsByTagNameNS (with short names byName and
	 *	byNameNS).  The document node supports getElementById
	 *	(byId), and all nodes support a supplimental
	 *	childrenByName/childrenByNameNS method as well.
	 *
	 *	The object model is intended to be a READONLY format;
	 *	mutation events are NOT supported, and though you
	 *	can change properties on a node-by-node basis, certain
	 *	operations are not supported (such as changing the ID
	 *	of an element).
	 **********************************************************/

	//	internal use only.
	var nodeTypes={ ELEMENT:1, ATTRIBUTE:2, TEXT:3, CDATA_SECTION:4, PROCESSING_INSTRUCTION:7, COMMENT:8, DOCUMENT:9 };

	//	compile the regular expressions once.
	var reTags=/<([^>\/\s+]*)([^>]*)>([^<]*)/g;
	var reAttr=/([^=]*)=(("([^"]*)")|('([^']*)'))/g;	//	patch from tdedischew AT gmail, with additional grouping
	var reEntity=/<!ENTITY\s+([^"]*)\s+"([^"]*)">/g;
	var reCData=/<!\[CDATA\[([\u0001-\uFFFF]*?)\]\]>/g;
	var reComments=/<!--([\u0001-\uFFFF]*?)-->/g;
	var trim=/^\s+|\s+$/g;
	var normalize=/\s+/g;
	var egt=/\&gt;/g;
	var elt=/\&lt;/g;
	var equot=/\&quot;/g;
	var eapos=/\&apos;/g;
	var eamp=/\&amp;/g;
	var dNs="_def_";

	//	create a root node.
	function _doc(){
		return new (function(){
			var all={};
			this.nodeType=nodeTypes.DOCUMENT;
			this.nodeName="#document";
			this.namespaces={};
			this._nsPaths={};
			this.childNodes=[];
			this.documentElement=null;

			//	any element with an ID attribute will be added to the internal hashtable.
			this._add=function(obj){
				if(typeof(obj.id)!="undefined"){ all[obj.id]=obj; }
			};
			this._remove=function(id){
				if(all[id]){ delete all[id]; }
			};

			this.byId=this.getElementById=function(id){ return all[id]; };
			this.byName=this.getElementsByTagName=byName;
			this.byNameNS=this.getElementsByTagNameNS=byNameNS;
			this.childrenByName=childrenByName;
			this.childrenByNameNS=childrenByNameNS;
		})();
	}

	//	functions attached to element nodes
	function byName(name){
		//	return all descendants with name.  Fully qualified (i.e. svg:svg)
		function __(node, name, arr){
			dojo.forEach(node.childNodes, function(c){
				if(c.nodeType==nodeTypes.ELEMENT){
					if(name=="*"){ arr.push(c); }
					else if(c.nodeName==name){ arr.push(c); }
					__(c, name, arr);
				}
			});
		}
		var a=[];
		__(this, name, a);
		return a;
	}
	function byNameNS(name, ns){
		//	return all descendants with name by namespace.  If no namespace passed, the default is used.
		function __(node, name, ns, arr){
			dojo.forEach(node.childNodes, function(c){
				if(c.nodeType==nodeTypes.ELEMENT){
					if(name=="*"&&c.ownerDocument._nsPaths[ns]==c.namespace){ arr.push(c); }
					else if(c.localName==name&&c.ownerDocument._nsPaths[ns]==c.namespace){ arr.push(c); }
					__(c, name, ns, arr);
				}
			});
		}
		if(!ns){ ns=dNs; }
		var a=[];
		__(this, name, ns, a);
		return a;
	}
	//	Only child nodes with name.
	function childrenByName(name){
		var a=[];
		dojo.forEach(this.childNodes, function(c){
			if(c.nodeType==nodeTypes.ELEMENT){
				if(name=="*"){ a.push(c); }
				else if(c.nodeName==name){ a.push(c); }
			}
		});
		return a;
	}

	function childrenByNameNS(name, ns){
		var a=[];
		dojo.forEach(this.childNodes, function(c){
			if(c.nodeType==nodeTypes.ELEMENT){
				if(name=="*"&&c.ownerDocument._nsPaths[ns]==c.namespace){ a.push(c); }
				else if(c.localName==name&&c.ownerDocument._nsPaths[ns]==c.namespace){ a.push(c); }
			}
		});
		return a;
	}

	function _createTextNode(v){
		return {
			nodeType:nodeTypes.TEXT,
			nodeName:"#text",
			nodeValue:v.replace(normalize," ").replace(egt,">").replace(elt,"<").replace(eapos,"'").replace(equot,'"').replace(eamp,"&")
		};
	}

	//	attribute functions
	function getAttr(name){
		for(var i=0; i<this.attributes.length; i++){
			if(this.attributes[i].nodeName==name){
				return this.attributes[i].nodeValue;
			}
		}
		return null;
	}
	function getAttrNS(name, ns){
		for(var i=0; i<this.attributes.length; i++){
			if(this.ownerDocument._nsPaths[ns]==this.attributes[i].namespace
				&&this.attributes[i].localName==name
			){
				return this.attributes[i].nodeValue;
			}
		}
		return null;
	}
	//	note that you can only swap IDs using setAttribute, NOT with setAttributeNS.
	function setAttr(name, val){
		var old=null;
		for(var i=0; i<this.attributes.length; i++){
			if(this.attributes[i].nodeName==name){
				old=this.attributes[i].nodeValue;
				this.attributes[i].nodeValue=val;
				break;
			}
		}
		if(name=="id"){
			if(old!=null){ this.ownerDocument._remove(old); }
			this.ownerDocument._add(this);
		}
	}
	function setAttrNS(name, val, ns){
		for(var i=0; i<this.attributes.length; i++){
			if(this.ownerDocument._nsPaths[ns]==this.attributes[i].namespace
				&&this.attributes[i].localName==name
			){
				this.attributes[i].nodeValue=val;
				return;
			}
		}
	}

	//	navigation
	function prev(){
		var p=this.parentNode;
		if(p){
			for(var i=0;i<p.childNodes.length;i++){
				if(p.childNodes[i]==this&&i>0){
					return p.childNodes[i-1];
				}
			}
		}
		return null;
	}
	function next(){
		var p=this.parentNode;
		if(p){
			for(var i=0;i<p.childNodes.length;i++){
				if(p.childNodes[i]==this&&(i+1)<p.childNodes.length){
					return p.childNodes[i+1];
				}
			}
		}
		return null;
	}

	//	the main method.
	this.parse=function(/* String */str){
		var root=_doc();
		if(str==null){ return root; }
		if(str.length==0){ return root; }

		//	preprocess custom entities
		if(str.indexOf("<!ENTITY")>0){
			var entity, eRe=[];
			if(reEntity.test(str)){
				reEntity.lastIndex=0;
				//	match entities
				while((entity=reEntity.exec(str))!=null){
					eRe.push({
						entity:"&"+entity[1].replace(trim,"")+";",
						expression:entity[2]
					});
				}
				//	replace instances in the document.
				for(var i=0; i<eRe.length; i++){
					str=str.replace(new RegExp(eRe[i].entity, "g"), eRe[i].expression);
				}
			}
		}

		//	pre-parse for CData, and tokenize.
		var cdSections=[], cdata;
		while((cdata=reCData.exec(str))!=null){ cdSections.push(cdata[1]); }
		for(var i=0; i<cdSections.length; i++){ str=str.replace(cdSections[i], i); }
		
		//	pre-parse for comments, and tokenize.
		var comments=[], comment;
		while((comment=reComments.exec(str))!=null){ comments.push(comment[1]); }
		for(i=0; i<comments.length; i++){ str=str.replace(comments[i], i); }

		//	parse the document
		var res, obj=root;
		while((res=reTags.exec(str))!=null){
			//	closing tags.
			if(res[2].charAt(0)=="/" && res[2].replace(trim, "").length>1){
				if(obj.parentNode){
					obj=obj.parentNode;
				}
				var text=(res[3]||"").replace(trim, "");
				if(text.length>0) {
					obj.childNodes.push(_createTextNode(text));
				}
			}

			//	open tags.
			else if(res[1].length>0){
				//	figure out the type of node.
				if(res[1].charAt(0)=="?"){
					//	processing instruction
					var name=res[1].substr(1);
					var target=res[2].substr(0,res[2].length-2);
					obj.childNodes.push({
						nodeType:nodeTypes.PROCESSING_INSTRUCTION,
						nodeName:name,
						nodeValue:target
					});
				}
				else if(res[1].charAt(0)=="!"){
					//	CDATA; skip over any declaration elements.
					if(res[1].indexOf("![CDATA[")==0){
						var val=parseInt(res[1].replace("![CDATA[","").replace("]]",""));
						obj.childNodes.push({
							nodeType:nodeTypes.CDATA_SECTION,
							nodeName:"#cdata-section",
							nodeValue:cdSections[val]
						});
					}
					//	Comments.
					else if(res[1].substr(0,3)=="!--"){
						var val=parseInt(res[1].replace("!--","").replace("--",""));
						obj.childNodes.push({
							nodeType:nodeTypes.COMMENT,
							nodeName:"#comment",
							nodeValue:comments[val]
						});
					}
				}
				else {
					//	Elements (with attribute and text)
					var name=res[1].replace(trim,"");
					var o={
						nodeType:nodeTypes.ELEMENT,
						nodeName:name,
						localName:name,
						namespace:dNs,
						ownerDocument:root,
						attributes:[],
						parentNode:null,
						childNodes:[]
					};

					//	check to see if it's namespaced.
					if(name.indexOf(":")>-1){
						var t=name.split(":");
						o.namespace=t[0];
						o.localName=t[1];
					}

					//	set the function references.
					o.byName=o.getElementsByTagName=byName;
					o.byNameNS=o.getElementsByTagNameNS=byNameNS;
					o.childrenByName=childrenByName;
					o.childrenByNameNS=childrenByNameNS;
					o.getAttribute=getAttr;
					o.getAttributeNS=getAttrNS;
					o.setAttribute=setAttr;
					o.setAttributeNS=setAttrNS;
					o.previous=o.previousSibling=prev;
					o.next=o.nextSibling=next;

					//	parse the attribute string.
					var attr;
					while((attr=reAttr.exec(res[2]))!=null){
						if(attr.length>0){
							var name=attr[1].replace(trim,"");
							var val=(attr[4]||attr[6]||"").replace(normalize," ")
								.replace(egt,">")
								.replace(elt,"<")
								.replace(eapos,"'")
								.replace(equot,'"')
								.replace(eamp,"&");
							if(name.indexOf("xmlns")==0){
								if(name.indexOf(":")>0){
									var ns=name.split(":");
									root.namespaces[ns[1]]=val;
									root._nsPaths[val]=ns[1];
								} else {
									root.namespaces[dNs]=val;
									root._nsPaths[val]=dNs;
								}
							} else {
								var ln=name;
								var ns=dNs;
								if(name.indexOf(":")>0){
									var t=name.split(":");
									ln=t[1];
									ns=t[0];
								}
								o.attributes.push({
									nodeType:nodeTypes.ATTRIBUTE,
									nodeName:name,
									localName:ln,
									namespace:ns,
									nodeValue:val
								});

								//	only add id as a property.
								if(ln=="id"){ o.id=val; }
							}
						}
					}
					root._add(o);

					if(obj){
						obj.childNodes.push(o);
						o.parentNode=obj;
						//	if it's not a self-closing node.
						if(res[2].charAt(res[2].length-1)!="/"){
							obj=o;
						}
					}
					var text=res[3];
					if(text.length>0){
						obj.childNodes.push(_createTextNode(text));
					}
				}
			}
		}

		//	set the document element
		for(var i=0; i<root.childNodes.length; i++){
			var e=root.childNodes[i];
			if(e.nodeType==nodeTypes.ELEMENT){
				root.documentElement=e;
				break;
			}
		}
		return root;
	};
})();
return dojox.xml.DomParser;
});

},
'dijit/form/Form':function(){
define("dijit/form/Form", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/event", // event.stop
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/sniff", // has("ie")
	"../_Widget",
	"../_TemplatedMixin",
	"./_FormMixin",
	"../layout/_ContentPaneResizeMixin"
], function(declare, domAttr, event, kernel, has, _Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _FormMixin = dijit.form._FormMixin;
	var _ContentPaneResizeMixin = dijit.layout._ContentPaneResizeMixin;
=====*/

	// module:
	//		dijit/form/Form
	// summary:
	//		Widget corresponding to HTML form tag, for validation and serialization


	return declare("dijit.form.Form", [_Widget, _TemplatedMixin, _FormMixin, _ContentPaneResizeMixin], {
		// summary:
		//		Widget corresponding to HTML form tag, for validation and serialization
		//
		// example:
		//	|	<form data-dojo-type="dijit.form.Form" id="myForm">
		//	|		Name: <input type="text" name="name" />
		//	|	</form>
		//	|	myObj = {name: "John Doe"};
		//	|	dijit.byId('myForm').set('value', myObj);
		//	|
		//	|	myObj=dijit.byId('myForm').get('value');

		// HTML <FORM> attributes

		// name: String?
		//		Name of form for scripting.
		name: "",

		// action: String?
		//		Server-side form handler.
		action: "",

		// method: String?
		//		HTTP method used to submit the form, either "GET" or "POST".
		method: "",

		// encType: String?
		//		Encoding type for the form, ex: application/x-www-form-urlencoded.
		encType: "",

		// accept-charset: String?
		//		List of supported charsets.
		"accept-charset": "",

		// accept: String?
		//		List of MIME types for file upload.
		accept: "",

		// target: String?
		//		Target frame for the document to be opened in.
		target: "",

		templateString: "<form data-dojo-attach-point='containerNode' data-dojo-attach-event='onreset:_onReset,onsubmit:_onSubmit' ${!nameAttrSetting}></form>",

		postMixInProperties: function(){
			// Setup name=foo string to be referenced from the template (but only if a name has been specified)
			// Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8660
			this.nameAttrSetting = this.name ? ("name='" + this.name + "'") : "";
			this.inherited(arguments);
		},

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Deprecated: use submit()
			// tags:
			//		deprecated
		},

		onExecute: function(){
			// summary:
			//		Deprecated: use onSubmit()
			// tags:
			//		deprecated
		},

		_setEncTypeAttr: function(/*String*/ value){
			this.encType = value;
			domAttr.set(this.domNode, "encType", value);
			if(has("ie")){ this.domNode.encoding = value; }
		},

		reset: function(/*Event?*/ e){
			// summary:
			//		restores all widget values back to their init values,
			//		calls onReset() which can cancel the reset by returning false

			// create fake event so we can know if preventDefault() is called
			var faux = {
				returnValue: true, // the IE way
				preventDefault: function(){ // not IE
							this.returnValue = false;
						},
				stopPropagation: function(){},
				currentTarget: e ? e.target : this.domNode,
				target: e ? e.target : this.domNode
			};
			// if return value is not exactly false, and haven't called preventDefault(), then reset
			if(!(this.onReset(faux) === false) && faux.returnValue){
				this.inherited(arguments, []);
			}
		},

		onReset: function(/*Event?*/ /*===== e =====*/){
			// summary:
			//		Callback when user resets the form. This method is intended
			//		to be over-ridden. When the `reset` method is called
			//		programmatically, the return value from `onReset` is used
			//		to compute whether or not resetting should proceed
			// tags:
			//		callback
			return true; // Boolean
		},

		_onReset: function(e){
			this.reset(e);
			event.stop(e);
			return false;
		},

		_onSubmit: function(e){
			var fp = this.constructor.prototype;
			// TODO: remove this if statement beginning with 2.0
			if(this.execute != fp.execute || this.onExecute != fp.onExecute){
				kernel.deprecated("dijit.form.Form:execute()/onExecute() are deprecated. Use onSubmit() instead.", "", "2.0");
				this.onExecute();
				this.execute(this.getValues());
			}
			if(this.onSubmit(e) === false){ // only exactly false stops submit
				event.stop(e);
			}
		},

		onSubmit: function(/*Event?*/ /*===== e =====*/){
			// summary:
			//		Callback when user submits the form.
			// description:
			//		This method is intended to be over-ridden, but by default it checks and
			//		returns the validity of form elements. When the `submit`
			//		method is called programmatically, the return value from
			//		`onSubmit` is used to compute whether or not submission
			//		should proceed
			// tags:
			//		extension

			return this.isValid(); // Boolean
		},

		submit: function(){
			// summary:
			//		programmatically submit form if and only if the `onSubmit` returns true
			if(!(this.onSubmit() === false)){
				this.containerNode.submit();
			}
		}
	});
});

},
'dijit/layout/_TabContainerBase':function(){
require({cache:{
'url:dijit/layout/templates/TabContainer.html':"<div class=\"dijitTabContainer\">\n\t<div class=\"dijitTabListWrapper\" data-dojo-attach-point=\"tablistNode\"></div>\n\t<div data-dojo-attach-point=\"tablistSpacer\" class=\"dijitTabSpacer ${baseClass}-spacer\"></div>\n\t<div class=\"dijitTabPaneWrapper ${baseClass}-container\" data-dojo-attach-point=\"containerNode\"></div>\n</div>\n"}});
define("dijit/layout/_TabContainerBase", [
	"dojo/text!./templates/TabContainer.html",
	"./StackContainer",
	"./utils",	// marginBox2contextBox, layoutChildren
	"../_TemplatedMixin",
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add
	"dojo/dom-geometry", // domGeometry.contentBox
	"dojo/dom-style" // domStyle.style
], function(template, StackContainer, layoutUtils, _TemplatedMixin, declare, domClass, domGeometry, domStyle){


/*=====
	var StackContainer = dijit.layout.StackContainer;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

// module:
//		dijit/layout/_TabContainerBase
// summary:
//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
//		and return the widget that displays the tab labels


return declare("dijit.layout._TabContainerBase", [StackContainer, _TemplatedMixin], {
	// summary:
	//		Abstract base class for TabContainer.   Must define _makeController() to instantiate
	//		and return the widget that displays the tab labels
	// description:
	//		A TabContainer is a container that has multiple panes, but shows only
	//		one pane at a time.  There are a set of tabs corresponding to each pane,
	//		where each tab has the name (aka title) of the pane, and optionally a close button.

	// tabPosition: String
	//		Defines where tabs go relative to tab content.
	//		"top", "bottom", "left-h", "right-h"
	tabPosition: "top",

	baseClass: "dijitTabContainer",

	// tabStrip: [const] Boolean
	//		Defines whether the tablist gets an extra class for layouting, putting a border/shading
	//		around the set of tabs.   Not supported by claro theme.
	tabStrip: false,

	// nested: [const] Boolean
	//		If true, use styling for a TabContainer nested inside another TabContainer.
	//		For tundra etc., makes tabs look like links, and hides the outer
	//		border since the outer TabContainer already has a border.
	nested: false,

	templateString: template,

	postMixInProperties: function(){
		// set class name according to tab position, ex: dijitTabContainerTop
		this.baseClass += this.tabPosition.charAt(0).toUpperCase() + this.tabPosition.substr(1).replace(/-.*/, "");

		this.srcNodeRef && domStyle.set(this.srcNodeRef, "visibility", "hidden");

		this.inherited(arguments);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Create the tab list that will have a tab (a.k.a. tab button) for each tab panel
		this.tablist = this._makeController(this.tablistNode);

		if(!this.doLayout){ domClass.add(this.domNode, "dijitTabContainerNoLayout"); }

		if(this.nested){
			/* workaround IE's lack of support for "a > b" selectors by
			 * tagging each node in the template.
			 */
			domClass.add(this.domNode, "dijitTabContainerNested");
			domClass.add(this.tablist.containerNode, "dijitTabContainerTabListNested");
			domClass.add(this.tablistSpacer, "dijitTabContainerSpacerNested");
			domClass.add(this.containerNode, "dijitTabPaneWrapperNested");
		}else{
			domClass.add(this.domNode, "tabStrip-" + (this.tabStrip ? "enabled" : "disabled"));
		}
	},

	_setupChild: function(/*dijit._Widget*/ tab){
		// Overrides StackContainer._setupChild().
		domClass.add(tab.domNode, "dijitTabPane");
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }

		// wire up the tablist and its tabs
		this.tablist.startup();

		this.inherited(arguments);
	},

	layout: function(){
		// Overrides StackContainer.layout().
		// Configure the content pane to take up all the space except for where the tabs are

		if(!this._contentBox || typeof(this._contentBox.l) == "undefined"){return;}

		var sc = this.selectedChildWidget;

		if(this.doLayout){
			// position and size the titles and the container node
			var titleAlign = this.tabPosition.replace(/-h/, "");
			this.tablist.layoutAlign = titleAlign;
			var children = [this.tablist, {
				domNode: this.tablistSpacer,
				layoutAlign: titleAlign
			}, {
				domNode: this.containerNode,
				layoutAlign: "client"
			}];
			layoutUtils.layoutChildren(this.domNode, this._contentBox, children);

			// Compute size to make each of my children.
			// children[2] is the margin-box size of this.containerNode, set by layoutChildren() call above
			this._containerContentBox = layoutUtils.marginBox2contentBox(this.containerNode, children[2]);

			if(sc && sc.resize){
				sc.resize(this._containerContentBox);
			}
		}else{
			// just layout the tab controller, so it can position left/right buttons etc.
			if(this.tablist.resize){
				//make the tabs zero width so that they don't interfere with width calc, then reset
				var s = this.tablist.domNode.style;
				s.width="0";
				var width = domGeometry.getContentBox(this.domNode).w;
				s.width="";
				this.tablist.resize({w: width});
			}

			// and call resize() on the selected pane just to tell it that it's been made visible
			if(sc && sc.resize){
				sc.resize();
			}
		}
	},

	destroy: function(){
		if(this.tablist){
			this.tablist.destroy();
		}
		this.inherited(arguments);
	}
});

});

},
'dojo/store/Memory':function(){
define("dojo/store/Memory", ["../_base/declare", "./util/QueryResults", "./util/SimpleQueryEngine"], function(declare, QueryResults, SimpleQueryEngine) {
  //  module:
  //    dojo/store/Memory
  //  summary:
  //    The module defines an in-memory object store.


return declare("dojo.store.Memory", null, {
	// summary:
	//		This is a basic in-memory object store. It implements dojo.store.api.Store.
	constructor: function(/*dojo.store.Memory*/ options){
		// summary:
		//		Creates a memory object store.
		// options:
		//		This provides any configuration information that will be mixed into the store.
		// 		This should generally include the data property to provide the starting set of data.
		for(var i in options){
			this[i] = options[i];
		}
		this.setData(this.data || []);
	},
	// data: Array
	//		The array of all the objects in the memory store
	data:null,

	// idProperty: String
	//		Indicates the property to use as the identity property. The values of this
	//		property should be unique.
	idProperty: "id",

	// index: Object
	//		An index of data indices into the data array by id
	index:null,

	// queryEngine: Function
	//		Defines the query engine to use for querying the data store
	queryEngine: SimpleQueryEngine,
	get: function(id){
		//	summary:
		//		Retrieves an object by its identity
		//	id: Number
		//		The identity to use to lookup the object
		//	returns: Object
		//		The object in the store that matches the given id.
		return this.data[this.index[id]];
	},
	getIdentity: function(object){
		// 	summary:
		//		Returns an object's identity
		// 	object: Object
		//		The object to get the identity from
		//	returns: Number
		return object[this.idProperty];
	},
	put: function(object, options){
		// 	summary:
		//		Stores an object
		// 	object: Object
		//		The object to store.
		// 	options: dojo.store.api.Store.PutDirectives??
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		//	returns: Number
		var data = this.data,
			index = this.index,
			idProperty = this.idProperty;
		var id = (options && "id" in options) ? options.id : idProperty in object ? object[idProperty] : Math.random();
		if(id in index){
			// object exists
			if(options && options.overwrite === false){
				throw new Error("Object already exists");
			}
			// replace the entry in data
			data[index[id]] = object;
		}else{
			// add the new object
			index[id] = data.push(object) - 1;
		}
		return id;
	},
	add: function(object, options){
		// 	summary:
		//		Creates an object, throws an error if the object already exists
		// 	object: Object
		//		The object to store.
		// 	options: dojo.store.api.Store.PutDirectives??
		//		Additional metadata for storing the data.  Includes an "id"
		//		property if a specific id is to be used.
		//	returns: Number
		(options = options || {}).overwrite = false;
		// call put with overwrite being false
		return this.put(object, options);
	},
	remove: function(id){
		// 	summary:
		//		Deletes an object by its identity
		// 	id: Number
		//		The identity to use to delete the object
		// returns: Boolean
		// 		Returns true if an object was removed, falsy (undefined) if no object matched the id
		var index = this.index;
		var data = this.data;
		if(id in index){
			data.splice(index[id], 1);
			// now we have to reindex
			this.setData(data);
			return true;
		}
	},
	query: function(query, options){
		// 	summary:
		//		Queries the store for objects.
		// 	query: Object
		//		The query to use for retrieving objects from the store.
		//	options: dojo.store.api.Store.QueryOptions?
		//		The optional arguments to apply to the resultset.
		//	returns: dojo.store.api.Store.QueryResults
		//		The results of the query, extended with iterative methods.
		//
		// 	example:
		// 		Given the following store:
		//
		// 	|	var store = new dojo.store.Memory({
		// 	|		data: [
		// 	|			{id: 1, name: "one", prime: false },
		//	|			{id: 2, name: "two", even: true, prime: true},
		//	|			{id: 3, name: "three", prime: true},
		//	|			{id: 4, name: "four", even: true, prime: false},
		//	|			{id: 5, name: "five", prime: true}
		//	|		]
		//	|	});
		//
		//	...find all items where "prime" is true:
		//
		//	|	var results = store.query({ prime: true });
		//
		//	...or find all items where "even" is true:
		//
		//	|	var results = store.query({ even: true });
		return QueryResults(this.queryEngine(query, options)(this.data));
	},
	setData: function(data){
		// 	summary:
		//		Sets the given data as the source for this store, and indexes it
		//	data: Object[]
		//		An array of objects to use as the source of data.
		if(data.items){
			// just for convenience with the data format IFRS expects
			this.idProperty = data.identifier;
			data = this.data = data.items;
		}else{
			this.data = data;
		}
		this.index = {};
		for(var i = 0, l = data.length; i < l; i++){
			this.index[data[i][this.idProperty]] = i;
		}
	}
});

});

},
'ibm/tivoli/simplesrm/srm/dijit/ToolbarButton':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/form/_FormWidget"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ToolbarButton");

dojo.require("dijit.form._FormWidget");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ToolbarButton", 
	dijit.form._FormWidget,
{	
	templateString : "<div title='${tooltip}' class='srm_button dijit dijitLeft dijitInline dijitButton'  dojoAttachPoint='focusNode' dojoAttachEvent='onclick:_onButtonClick,onmouseover:_onMouse,onmouseout:_onMouse,onmousedown:_onMouse,onkeypress:_onKeyPress'><div class='${iconClass}'></div></div>",
	iconClass: '',
	tooltip: '',
	
	constructor: function() 
	{
		console.log("Button.ctor");
	},
	postMixInProperties: function()
	{
		console.log("Buton.postMixInProperties");
		this.inherited(arguments);
	},
	buildRendering: function()
	{
		console.log("Button.buildRendering");
		this.inherited(arguments);
		console.log("domNode; ", this.domNode);
	},
	startup: function()
	{
		console.log("Button.startup");
		this.inherited(arguments);
	},
	_onButtonClick: function(evt)
	{
		dojo.stopEvent(evt);
		if(this.disabled){ return false; }
		if(typeof this.onClick == "function"){
			return this.onClick(evt); // user click actions
		}
		else{ 
			return false;
		}
	},
	_onKeyPress: function(/* Event */ evt)
	{
		if(evt.type == 'keypress' && evt.keyCode == dojo.keys.ENTER) {
			// TODO: is this really what I want to do?
			this.onClick(evt);
		}
	},
	onClick: function(/*Event*/ e){
		// summary: user callback for when button is clicked
		//      if type="submit", return value != false to perform submit
		return true;
	},
	_dummy:null
});
});

},
'ibm/tivoli/simplesrm/srm/dojo/data/FormattedDataReadStore':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dojox/data/AndOrReadStore"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore");

dojo.require("dojox.data.AndOrReadStore");

dojo.declare("ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore", dojox.data.AndOrReadStore, 
{
	formatterMap: null,
	
	setStructure: function(structure)
	{
		this.formatterMap = {};
		for(var i in structure) {
			var col = structure[i];
			if(col.formatter) {
				this.formatterMap[col.field] = col.formatter;
			}
		}
	},
	_containsValue: function(	/* item */ item, 
								/* attribute-name-string */ attribute, 
								/* anything */ value,
								/* RegExp?*/ regexp)
	{
		//	summary: 
		//		Internal function for looking at the values contained by the item.
		//	description: 
		//		Internal function for looking at the values contained by the item.  This 
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//	
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:	
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		var vals = this.getValues(item, attribute);
		if(this.formatterMap[attribute]) {
			vals = dojo.map(vals, dojo.hitch(this, function(v) 
			{
				return this.formatterMap[attribute](v);
			}));
		}
		// the rest of this code is verbatim from AndOrReadStore._containsValue
		return dojo.some(vals, function(possibleValue){
		
			if(possibleValue !== null && !dojo.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
			
	}
});
});

},
'ibm/tivoli/simplesrm/srm/dijit/Overview/BBoardPod':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!ibm/tivoli/simplesrm/srm/dijit/Overview/Pod,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dijit/MyBBoardMessagesGrid"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardPod");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardView");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardDetails");

dojo.require("ibm.tivoli.simplesrm.srm.dijit.Overview.Pod");

dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyBBoardMessagesGrid");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable"); 

//contains all messages the current user can see
ibm.tivoli.simplesrm.srm.dijit.Overview.personMessages = [];

//contains all groups current user belongs to
ibm.tivoli.simplesrm.srm.dijit.Overview.personGroups = [];

//contains all sites the current user has access to
ibm.tivoli.simplesrm.srm.dijit.Overview.personOrgsSites = [];

// Tracking messages
ibm.tivoli.simplesrm.srm.dijit.Overview.isTracking = "1";


/*
 * BBoardPod
 * Loads bulletin board messages targeted for logged in user
*/

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardPod", ibm.tivoli.simplesrm.srm.dijit.Overview.Pod,
{
	viewType: "ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardView",
	detailsType: "ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardDetails",
	autoRefreshProperty: "MessageAutoRefresh",
	
	constructor: function()
	{
		console.log("Overview.BBoardPod.ctor");
		ibm.tivoli.simplesrm.srm.dijit.Overview.bboardpod = this;
	
	    // Load Org, Site, Person Group Data
	    // Note: This will only be loaded during initialization to improve performance 	
		var dq_personGroups = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getPersonGroups();
		dq_personGroups.addCallbacks(dojo.hitch(this, this._updatePersonGroups), dojo.hitch(this, this._refreshError));

		var dq_personOrgsSites = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getPersonOrgsSites();
		dq_personOrgsSites.addCallbacks(dojo.hitch(this, this._updatePersonOrgsSites), dojo.hitch(this, this._refreshError));

		
	},
	
	postMixInProperties: function()
	{
		console.log("Overview.BBoardPod.postMixInProperties");
		this.heading = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").MyNewsHeading;
		this.detailsLinkLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").ManageMyNewsLink;
		this.detailsUrl = "#requests";
		
		this.inherited(arguments);
	},
	postCreate: function()
	{
		this.refresh();
		this.inherited(arguments);
	},
	refresh: function()
	{
		console.log("Overview.BBoardPod.refresh");
		this._cancelPoll();

		// Load messages
		var dq = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getBBoardMessages();
		dq.addCallbacks(dojo.hitch(this, this._updatePersonMessages), dojo.hitch(this, this._refreshError));
		
	},

   	// Update personMessages
	_updatePersonMessages: function(response)
	{
		try {
   		    this._processMessages(response.Requests);
   		    this._updateData(personMessages);
		}
		catch(ex) {
			ibm.tivoli.logger.error("BBoardPod._updatePersonMessages failure",ex);
		}
	},
	
	// Update personGroups
	_updatePersonGroups: function(response)
	{
		try {
		    personGroups = response.Requests;
		}
		catch(ex) {
			ibm.tivoli.logger.error("BBoardPod._updatePersonGroups failure",ex);
		}
	},
		
	
	// Update personOrgsSites
	_updatePersonOrgsSites: function(response)
	{
		try {
		    personOrgsSites = response.Requests;
		}
		catch(ex) {
			ibm.tivoli.logger.error("BBoardPod._updatePersonOrgs failure",ex);
		}
	},
	
	
	// Process messages
	_processMessages: function(response)
	{
		console.log("Overview.BBoardPod._processMessages");
		try {
		
			personMessages = response;
			var msgid = [];
			var count = 0;
   			console.log("Number of messages before:" + personMessages.length);
   			
   			var authallsites = personOrgsSites[0].AUTHALLSITES;
   			
   			// Iterate over the list of messages and remove those that should not be displayed
			for(var i = 0; i < personMessages.length; ++i) {
		    
				var id = personMessages[i].key;
		    
				// Remove messages targeted to a particular audience that should not be displayed
				// for this user
			    
				var del = false;

				// Remove Messages that are not targeted for the user's org
				if (undefined != personMessages[i].MSGORGID && authallsites == false) {

					var orgCtr = 0;
					for(var j=0; j < personOrgsSites.length; ++j) {
						var orgid = personOrgsSites[j].ORGID;
						if (personMessages[i].MSGORGID == orgid) { 	
							orgCtr++;
						}
					}
					if(orgCtr == 0) {
						del=true;
						console.log("Deleting message because it is not targeted for user's orgid. bulletinid: " + personMessages[i].key);
					}
				}

				// Remove Messages that are not targeted for the user's site
				if (undefined != personMessages[i].MSGSITEID && del == false && authallsites == false) {
			    
					var siteCtr = 0;
					for(var k=0; k < personOrgsSites.length; ++k) {
   						var siteid = personOrgsSites[k].SITEID;		    
						if (personMessages[i].MSGSITEID == siteid) { 	  	  			    
							siteCtr++;
						}
					}
					if(siteCtr == 0) {
						del=true;
						console.log("Deleting message because it is not targeted for user's siteid. bulletinid: " + personMessages[i].key);
					}
   	  		    	
				}
			    
				// Remove Messages that are not targeted for the user's persongroup
				if (undefined != personMessages[i].PERSONGROUP && del == false) {
	
					var found = false;
					var pCtr = 0;
					for(var l=0; l < personGroups.length; ++l) {
						var pg = personGroups[l];
						var group = pg.PERSONGROUP;
						if (personMessages[i].PERSONGROUP == group) {
							pCtr++;
							break;
						}
					}
					if(pCtr == 0) {
						del=true;
					}
				}
				      	
				if(del == true) {
		    		msgid.push(i);
		    		count++;
				}
			}
			
			console.log("Deleting messages.  Count: " + count);		
			for(var p = msgid.length-1; p >= 0; --p) {
				var dm = msgid[p];
				personMessages.splice(dm,1);
			}
			return personMessages;
		}
		catch(ex) {
			ibm.tivoli.logger.error("BBoardPod._processMessages failure",ex);
		}
	},
				
	_updateData: function(response)
	{
		console.log("Overview.BBoardPod._updateData");
		try {

			this._cancelPoll();
			this._refreshErrorCount = 0;
		
			var requests=response;
			if (response.Requests)
			   requests = response.Requests;
						 
			var messages = requests.slice();

			if(this._detailsData === requests){
				return;
			}
				
			if (messages.length > 0)
			{
				ibm.tivoli.simplesrm.srm.dijit.Overview.isTracking = messages[0].ISTRACKING;
			}
			if (ibm.tivoli.simplesrm.srm.dijit.Overview.isTracking == 1)
			{
				for(var j = messages.length-1; j >= 0; --j) {			    
				       var YES = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Yes;
				       if (messages[j].ISVIEWED == YES ) {
						messages.splice(j,1);
					}
				}
			}			
			
			messages.sort(function(b, a) 
			{
				// sort descending
				return a.POSTDATE > b.POSTDATE ? 1 : a.POSTDATE < b.POSTDATE ? -1 : 0;
			});
			for(var i = 0; i < messages.length; ++i) {
				var dt = dojo.date.stamp.fromISOString(messages[0].POSTDATE);
				if(dt) {
					this._mostRecent = dt.getTime();
					break;
				}
			}
			this._detailsData = requests; 
			this._view.setData(messages);
			this._onDataReady();
		}
		catch(ex) {
			ibm.tivoli.logger.error("BBoardPod._updateData failure",ex);
		}
		finally {
			this._resetPoll();
		}
	},
	_poll: function()
	{
	/*  Let user manually refresh to improve performance
		var dq = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getBBoardMessages();
		dq.addCallback(dojo.hitch(this, function(response) {
			var messages = response.Requests;
			if(messages.length > 0) {
				this.refresh();
			}
			else {
				this._resetPoll();
			}

		}));
	*/		
	},
	_onDataReady: function()
	{
		this.inherited(arguments);
	},
	onShowDetails: function()
	{
		var bNeedsConnect = undefined == this._details;
		this.inherited(arguments);
		if(bNeedsConnect && this._details) {	// only connect once
			this.connect(this._details.detailsWidget, "onRefresh", this._updateData);
		}
	}
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardView", 
		[ibm.tivoli.simplesrm.srm.dijit.Overview.View, ibm.tivoli.simplesrm.srm.dijit.ShowMessageDetails],
{
	widgetsInTemplate: true,
	templateString: '<div>\n' +
					'	<div dojoType="ibm.tivoli.simplesrm.srm.dijit.Overview.DataTable" dojoAttachPoint="dataTable" heading="${tableCaption}"></div>\n' +
					'</div>\n',
	tableCaption: "",
	totalStr: "Total",
	showDetails: "Show details",
	constructor: function()
	{
		console.log("Overview.BBoardView.ctor");
	},
	postMixInProperties: function()
	{
		console.log("Overview.BBoardView.postMixInProperties");
		this.tableCaption = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").RecentActivity;
		this.totalStr =     dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Total;
		this.showDetails =	dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").ShowDetails;
		this.inherited(arguments);
	},
	setData: function(messages)
	{
		console.log("Overview.BBoardView.setData");
		this.clear();
		this._detailsData = messages;
		var status_stats = {srm_status_count: [], srm_unique_stati: 0};
		var l = messages.length;
		var maxoverview =  Math.min(5, l);
		
		if(l <= 0){
			this.dataTable.addRow(dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").NoRecentActivity, "");
		}
		else {
			for(var i = 0; i < l; ++i) {
				var cmr = messages[i];
				var status = cmr.StatusString;
				var dueDate = this._formatDate(cmr.POSTDATE);
				
				if(i < maxoverview) {
					var subj = cmr.SUBJECT;
					if (subj) {
						subj = dojo.trim(subj);
						if (subj.length > 200)  //truncate at 200. I beleive field len is 200
						   subj = subj.substring(0,200) + "...";
					}
					var newsubj = subj; 
						//If no spaces, then we add one so html will wrap
					if (subj && subj.length> 50 && (subj.indexOf(" ")<0 || subj.indexOf(" ")>50 ) ) {		   
						   newsubj = subj.substring(0,50) + "- " + subj.substring(50);
						   subj = newsubj;
					}
					if (subj && subj.length> 100 && (subj.indexOf(" ",52)<0 || subj.indexOf(" ",52)>100 ) ) {		   
						   newsubj = subj.substring(0,100) + "- " + subj.substring(100);	
						   subj = newsubj;
					}
					if (subj && subj.length> 150 && (subj.indexOf(" ",105)<0) ) {		   
						   newsubj = subj.substring(0,150) + "- " + subj.substring(150);	
						   subj = newsubj;
					}
					
					
					var link = "<a href='#req_"+ cmr.id +"' title='"+this.showDetails.htmlencode()+"'>" +(newsubj ? newsubj.htmlencode() : '...')+ "</a>";
					this.dataTable.addRow(link, dueDate);
				}
			}
			if(l > 0) {
				var links = dojo.query("a", this.dataTable.domNode);
				for(var i = 0; i < links.length; ++i) {
					this.connect(links[i], "onclick", this._showMessageDetails);
				}
			}			
		}
	},

	//launch My News dialog 
	_viewNews: function(bbUID)  
	{ 
		console.log("BBoardPod._viewNews - launch dialog  bbUID = ",bbUID);
		//var node = dojo.byId(this.id);
		arguments.caller=null; //running into a IE bug in stacktrace()
		
		var navid = "mx107";
	    var nav = dojo.query("div.srmnavigator");  //use id of navigator
	    if (nav.length>0)
		    navid = nav[0].id;	    
	    sendEvent("srmssviewmynews",  navid,  bbUID);		
	}, 
	clear: function()
	{
		this.dataTable.clear();
	},	
	_showMessageDetails: function(evt)
	{
		console.log("Overview.BBoardView._showMessageDetails:" + evt);
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		try {
			var href = evt.target.href;
			var reqid = href.substring(href.lastIndexOf("_")+1);

			for(var i = 0; i < this._detailsData.length; ++i) {
				var req = this._detailsData[i];
				if(reqid == req.id) 
				{
					if (product!=null && product.indexOf("srm")>=0)
						this._viewNews(reqid);
					else
					{
						this.setApprContext(true);
						this.showRecordDetails(req);
					}
					break;
				}
			}
		}
		catch(ex){
			console.warn(ex);
		}
	}, 
	_formatDate: function(d) {
		if(d) {
			if(d.search("9999") === 0) {
				d = this._uiStringTable.ForeverLabel;
			}
			else {
				var isod = d.replace(' ', 'T');
				var format_opts = {fullYear:true, selector: "date"};
				var dt = dojo.date.stamp.fromISOString(isod);
				if(dt) {
					d = dojo.date.locale.format(dt, format_opts);
				}
			}
		}
		return d;
	}
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardDetails", ibm.tivoli.simplesrm.srm.dijit.Overview.Details,
{
	headingText: "My News",
	detailsType: "ibm.tivoli.simplesrm.srm.dijit.MyBBoardMessagesGrid",
	
	//TODO: _cshKey identifies help...identify valid file
	_cshKey: "",
	
	constructor: function()
	{
		console.log("Overview.BBoardDetails.ctor");
		this.headingText = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").ManageMyNews;

		var localText = dojo.locale;
		var localMatch = localText.match(/-/gi);
		if(localMatch != null)
		{
			localText = localText.split('-')[0];
		}

      this._cshKey = "/help/index.jsp?topic=/com.ibm.sccd.doc/selfserv/c_my_news_pod.html";
		//this._cshKey = "/maximohelp/"+localText+"/mergedProjects/srmssctr/helpmynewspodgrid.htm";
	},
	refresh: function(data_set)
	{
		console.log("Overview.BBoardDetails.refresh");
		if (this.detailsWidget && this.detailsWidget._initialization_complete!=undefined && this.detailsWidget._initialization_complete!=true) {
			console.log("Overview.BBoardDetails.refresh- start MyMessagesGrid");
			this.detailsWidget.startup();
		}
		
		if(data_set) {
			this._detailsData = data_set;
			this.detailsWidget.clearGrid();
			this.detailsWidget._loadGrid(this._detailsData);
		}
		else {
			this.inherited(arguments);	// will refresh detailsWidget
		} 
	},
	resize: function()
	{
		this.inherited(arguments);
		this.detailsWidget.simpleGrid.resize();
	}
});

ibm.tivoli.simplesrm.srm.dijit.Overview.bboardpod = null;
ibm.tivoli.simplesrm.srm.dijit.Overview._BBoardPod = function(){
	// summary: returns the singleton bulletin board object
	if(!ibm.tivoli.simplesrm.srm.dijit.Overview.bboardpod){
		ibm.tivoli.simplesrm.srm.dijit.Overview.bboardpod = new ibm.tivoli.simplesrm.srm.dijit.Overview.BBoardPod(); 
	}
	return ibm.tivoli.simplesrm.srm.dijit.Overview.bboardpod;	// Object
};
ibm.tivoli.simplesrm.srm.dijit.Overview._BBoardPodTracking = function(){
	return ibm.tivoli.simplesrm.srm.dijit.Overview.isTracking;
};
});

},
'url:dijit/templates/Tooltip.html':"<div class=\"dijitTooltip dijitTooltipLeft\" id=\"dojoTooltip\"\n\t><div class=\"dijitTooltipContainer dijitTooltipContents\" data-dojo-attach-point=\"containerNode\" role='alert'></div\n\t><div class=\"dijitTooltipConnector\" data-dojo-attach-point=\"connectorNode\"></div\n></div>\n",
'dojox/grid/_Grid':function(){
require({cache:{
'url:dojox/grid/resources/_Grid.html':"<div hidefocus=\"hidefocus\" role=\"grid\" dojoAttachEvent=\"onmouseout:_mouseOut\">\n\t<div class=\"dojoxGridMasterHeader\" dojoAttachPoint=\"viewsHeaderNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterView\" dojoAttachPoint=\"viewsNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterMessages\" style=\"display: none;\" dojoAttachPoint=\"messagesNode\"></div>\n\t<span dojoAttachPoint=\"lastFocusNode\" tabindex=\"0\"></span>\n</div>\n"}});
define("dojox/grid/_Grid", [
	"dojo/_base/kernel",
	"../main",
	"dojo/_base/declare",
	"./_Events",
	"./_Scroller",
	"./_Layout",
	"./_View",
	"./_ViewManager",
	"./_RowManager",
	"./_FocusManager",
	"./_EditManager",
	"./Selection",
	"./_RowSelector",
	"./util",
	"dijit/_Widget",
	"dijit/_TemplatedMixin",
	"dijit/CheckedMenuItem",
	"dojo/text!./resources/_Grid.html",
	"dojo/string",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/sniff",
	"dojox/html/metrics",
	"dojo/_base/html",
	"dojo/query",
	"dojo/dnd/common",
	"dojo/i18n!dijit/nls/loading"
], function(dojo, dojox, declare, _Events, _Scroller, _Layout, _View, _ViewManager,
	_RowManager, _FocusManager, _EditManager, Selection, _RowSelector, util, _Widget,
	 _TemplatedMixin, CheckedMenuItem, template, string, array, lang, has, metrics, html, query){

	// NOTE: this is for backwards compatibility with Dojo 1.3
	if(!dojo.isCopyKey){
		dojo.isCopyKey = dojo.dnd.getCopyKeyState;
	}
	/*=====
	dojox.grid.__CellDef = function(){
		//	name: String?
		//		The text to use in the header of the grid for this cell.
		//	get: Function?
		//		function(rowIndex){} rowIndex is of type Integer.  This
		//		function will be called when a cell	requests data.  Returns the
		//		unformatted data for the cell.
		//	value: String?
		//		If "get" is not specified, this is used as the data for the cell.
		//	defaultValue: String?
		//		If "get" and "value" aren't specified or if "get" returns an undefined
		//		value, this is used as the data for the cell.  "formatter" is not run
		//		on this if "get" returns an undefined value.
		//	formatter: Function?
		//		function(data, rowIndex){} data is of type anything, rowIndex
		//		is of type Integer.  This function will be called after the cell
		//		has its data but before it passes it back to the grid to render.
		//		Returns the formatted version of the cell's data.
		//	type: dojox.grid.cells._Base|Function?
		//		TODO
		//	editable: Boolean?
		//		Whether this cell should be editable or not.
		//	hidden: Boolean?
		//		If true, the cell will not be displayed.
		//	noresize: Boolean?
		//		If true, the cell will not be able to be resized.
		//	width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's.
		//	colSpan: Integer?
		//		How many columns to span this cell.  Will not work in the first
		//		sub-row of cells.
		//	rowSpan: Integer?
		//		How many sub-rows to span this cell.
		//	styles: String?
		//		A string of styles to apply to both the header cell and main
		//		grid cells.  Must end in a ';'.
		//	headerStyles: String?
		//		A string of styles to apply to just the header cell.  Must end
		//		in a ';'
		//	cellStyles: String?
		//		A string of styles to apply to just the main grid cells.  Must
		//		end in a ';'
		//	classes: String?
		//		A space separated list of classes to apply to both the header
		//		cell and the main grid cells.
		//	headerClasses: String?
		//		A space separated list of classes to apply to just the header
		//		cell.
		//	cellClasses: String?
		//		A space separated list of classes to apply to just the main
		//		grid cells.
		//	attrs: String?
		//		A space separated string of attribute='value' pairs to add to
		//		the header cell element and main grid cell elements.
		this.name = name;
		this.value = value;
		this.get = get;
		this.formatter = formatter;
		this.type = type;
		this.editable = editable;
		this.hidden = hidden;
		this.width = width;
		this.colSpan = colSpan;
		this.rowSpan = rowSpan;
		this.styles = styles;
		this.headerStyles = headerStyles;
		this.cellStyles = cellStyles;
		this.classes = classes;
		this.headerClasses = headerClasses;
		this.cellClasses = cellClasses;
		this.attrs = attrs;
	}
	=====*/

	/*=====
	dojox.grid.__ViewDef = function(){
		//	noscroll: Boolean?
		//		If true, no scrollbars will be rendered without scrollbars.
		//	width: Integer|String?
		//		A CSS size.  If it's an Integer, the width will be in em's. If
		//		"noscroll" is true, this value is ignored.
		//	cells: dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]?
		//		The structure of the cells within this grid.
		//	type: String?
		//		A string containing the constructor of a subclass of
		//		dojox.grid._View.  If this is not specified, dojox.grid._View
		//		is used.
		//	defaultCell: dojox.grid.__CellDef?
		//		A cell definition with default values for all cells in this view.  If
		//		a property is defined in a cell definition in the "cells" array and
		//		this property, the cell definition's property will override this
		//		property's property.
		//	onBeforeRow: Function?
		//		function(rowIndex, cells){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]].  This function is called
		//		before each row of data is rendered.  Before the header is
		//		rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		//	onAfterRow: Function?
		//		function(rowIndex, cells, rowNode){} rowIndex is of type Integer, cells
		//		is of type Array[dojox.grid.__CellDef[]], rowNode is of type DOMNode.
		//		This function is called	after each row of data is rendered.  After the
		//		header is rendered, rowIndex will be -1.  "cells" is a reference to the
		//		internal structure of this view's cells so any changes you make to
		//		it will persist between calls.
		this.noscroll = noscroll;
		this.width = width;
		this.cells = cells;
		this.type = type;
		this.defaultCell = defaultCell;
		this.onBeforeRow = onBeforeRow;
		this.onAfterRow = onAfterRow;
	}
	=====*/

	var _Grid = declare('dojox.grid._Grid',
		[ _Widget, _TemplatedMixin, _Events ],
		{
		// summary:
		// 		A grid widget with virtual scrolling, cell editing, complex rows,
		// 		sorting, fixed columns, sizeable columns, etc.
		//
		//	description:
		//		_Grid provides the full set of grid features without any
		//		direct connection to a data store.
		//
		//		The grid exposes a get function for the grid, or optionally
		//		individual columns, to populate cell contents.
		//
		//		The grid is rendered based on its structure, an object describing
		//		column and cell layout.
		//
		//	example:
		//		A quick sample:
		//
		//		define a get function
		//	|	function get(inRowIndex){ // called in cell context
		//	|		return [this.index, inRowIndex].join(', ');
		//	|	}
		//
		//		define the grid structure:
		//	|	var structure = [ // array of view objects
		//	|		{ cells: [// array of rows, a row is an array of cells
		//	|			[
		//	|				{ name: "Alpha", width: 6 },
		//	|				{ name: "Beta" },
		//	|				{ name: "Gamma", get: get }]
		//	|		]}
		//	|	];
		//
		//	|	<div id="grid"
		//	|		rowCount="100" get="get"
		//	|		structure="structure"
		//	|		dojoType="dojox.grid._Grid"></div>

		templateString: template,

		// classTag: String
		// 		CSS class applied to the grid's domNode
		classTag: 'dojoxGrid',

		// settings
		// rowCount: Integer
		//		Number of rows to display.
		rowCount: 5,

		// keepRows: Integer
		//		Number of rows to keep in the rendering cache.
		keepRows: 75,

		// rowsPerPage: Integer
		//		Number of rows to render at a time.
		rowsPerPage: 25,

		// autoWidth: Boolean
		//		If autoWidth is true, grid width is automatically set to fit the data.
		autoWidth: false,
		
		// initialWidth: String
		//		A css string to use to set our initial width (only used if autoWidth
		//		is true).  The first rendering of the grid will be this width, any
		//		resizing of columns, etc will result in the grid switching to
		//		autoWidth mode.  Note, this width will override any styling in a
		//		stylesheet or directly on the node.
		initialWidth: "",

		// autoHeight: Boolean|Integer
		//		If autoHeight is true, grid height is automatically set to fit the data.
		//		If it is an integer, the height will be automatically set to fit the data
		//		if there are fewer than that many rows - and the height will be set to show
		//		that many rows if there are more
		autoHeight: '',

		// rowHeight: Integer
		//		If rowHeight is set to a positive number, it will define the height of the rows
		//		in pixels. This can provide a significant performance advantage, since it
		//		eliminates the need to measure row sizes during rendering, which is one
		// 		the primary bottlenecks in the DataGrid's performance.
		rowHeight: 0,
		
		// autoRender: Boolean
		//		If autoRender is true, grid will render itself after initialization.
		autoRender: true,

		// defaultHeight: String
		//		default height of the grid, measured in any valid css unit.
		defaultHeight: '15em',
		
		// height: String
		//		explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
		//		if the height: css attribute exists on the source node.
		height: '',

		// structure: dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]
		//		View layout defintion.
		structure: null,

		// elasticView: Integer
		//	Override defaults and make the indexed grid view elastic, thus filling available horizontal space.
		elasticView: -1,

		// singleClickEdit: boolean
		//		Single-click starts editing. Default is double-click
		singleClickEdit: false,

		// selectionMode: String
		//		Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
		//		or 'extended'.  Default is 'extended'.
		selectionMode: 'extended',

		// rowSelector: Boolean|String
		// 		If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
		// 		a row selector of that width to this grid.
		rowSelector: '',

		// columnReordering: Boolean
		// 		If set to true, will add drag and drop reordering to views with one row of columns.
		columnReordering: false,

		// headerMenu: dijit.Menu
		// 		If set to a dijit.Menu, will use this as a context menu for the grid headers.
		headerMenu: null,

		// placeholderLabel: String
		// 		Label of placeholders to search for in the header menu to replace with column toggling
		// 		menu items.
		placeholderLabel: "GridColumns",
		
		// selectable: Boolean
		//		Set to true if you want to be able to select the text within the grid.
		selectable: false,
		
		// Used to store the last two clicks, to ensure double-clicking occurs based on the intended row
		_click: null,
		
		// loadingMessage: String
		//  Message that shows while the grid is loading
		loadingMessage: "<span class='dojoxGridLoading'>${loadingState}</span>",

		// errorMessage: String
		//  Message that shows when the grid encounters an error loading
		errorMessage: "<span class='dojoxGridError'>${errorState}</span>",

		// noDataMessage: String
		//  Message that shows if the grid has no data - wrap it in a
		//  span with class 'dojoxGridNoData' if you want it to be
		//  styled similar to the loading and error messages
		noDataMessage: "",
		
		// escapeHTMLInData: Boolean
		//		This will escape HTML brackets from the data to prevent HTML from
		// 		user-inputted data being rendered with may contain JavaScript and result in
		// 		XSS attacks. This is true by default, and it is recommended that it remain
		// 		true. Setting this to false will allow data to be displayed in the grid without
		// 		filtering, and should be only used if it is known that the data won't contain
		// 		malicious scripts. If HTML is needed in grid cells, it is recommended that
		// 		you use the formatter function to generate the HTML (the output of
		// 		formatter functions is not filtered, even with escapeHTMLInData set to true).
		escapeHTMLInData: true,
		
		// formatterScope: Object
		//		An object to execute format functions within.  If not set, the
		//		format functions will execute within the scope of the cell that
		//		has a format function.
		formatterScope: null,
		
		// editable: boolean
		// indicates if the grid contains editable cells, default is false
		// set to true if editable cell encountered during rendering
		editable: false,
		
		// private
		sortInfo: 0,
		themeable: true,
		_placeholders: null,

		// _layoutClass: Object
		//	The class to use for our layout - can be overridden by grid subclasses
		_layoutClass: _Layout,

		// initialization
		buildRendering: function(){
			this.inherited(arguments);
			if(!this.domNode.getAttribute('tabIndex')){
				this.domNode.tabIndex = "0";
			}
			this.createScroller();
			this.createLayout();
			this.createViews();
			this.createManagers();

			this.createSelection();

			this.connect(this.selection, "onSelected", "onSelected");
			this.connect(this.selection, "onDeselected", "onDeselected");
			this.connect(this.selection, "onChanged", "onSelectionChanged");

			metrics.initOnFontResize();
			this.connect(metrics, "onFontResize", "textSizeChanged");
			util.funnelEvents(this.domNode, this, 'doKeyEvent', util.keyEvents);
			if (this.selectionMode != "none") {
				this.domNode.setAttribute("aria-multiselectable", this.selectionMode == "single" ? "false" : "true");
			}

			html.addClass(this.domNode, this.classTag);
			if(!this.isLeftToRight()){
				html.addClass(this.domNode, this.classTag+"Rtl");
			}
		},
		
		postMixInProperties: function(){
			this.inherited(arguments);
			var messages = dojo.i18n.getLocalization("dijit", "loading", this.lang);
			this.loadingMessage = string.substitute(this.loadingMessage, messages);
			this.errorMessage = string.substitute(this.errorMessage, messages);
			if(this.srcNodeRef && this.srcNodeRef.style.height){
				this.height = this.srcNodeRef.style.height;
			}
			// Call this to update our autoheight to start out
			this._setAutoHeightAttr(this.autoHeight, true);
			this.lastScrollTop = this.scrollTop = 0;
		},
		
		postCreate: function(){
			this._placeholders = [];
			this._setHeaderMenuAttr(this.headerMenu);
			this._setStructureAttr(this.structure);
			this._click = [];
			this.inherited(arguments);
			if(this.domNode && this.autoWidth && this.initialWidth){
				this.domNode.style.width = this.initialWidth;
			}
			if (this.domNode && !this.editable){
				// default value for aria-readonly is false, set to true if grid is not editable
				html.attr(this.domNode,"aria-readonly", "true");
			}
		},

		destroy: function(){
			this.domNode.onReveal = null;
			this.domNode.onSizeChange = null;

			// Fixes IE domNode leak
			delete this._click;

			if(this.scroller){
				this.scroller.destroy();
				delete this.scroller;
			}
			this.edit.destroy();
			delete this.edit;
			this.views.destroyViews();
			if(this.focus){
				this.focus.destroy();
				delete this.focus;
			}
			if(this.headerMenu&&this._placeholders.length){
				array.forEach(this._placeholders, function(p){ p.unReplace(true); });
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.inherited(arguments);
		},

		_setAutoHeightAttr: function(ah, skipRender){
			// Calculate our autoheight - turn it into a boolean or an integer
			if(typeof ah == "string"){
				if(!ah || ah == "false"){
					ah = false;
				}else if (ah == "true"){
					ah = true;
				}else{
					ah = window.parseInt(ah, 10);
				}
			}
			if(typeof ah == "number"){
				if(isNaN(ah)){
					ah = false;
				}
				// Autoheight must be at least 1, if it's a number.  If it's
				// less than 0, we'll take that to mean "all" rows (same as
				// autoHeight=true - if it is equal to zero, we'll take that
				// to mean autoHeight=false
				if(ah < 0){
					ah = true;
				}else if (ah === 0){
					ah = false;
				}
			}
			this.autoHeight = ah;
			if(typeof ah == "boolean"){
				this._autoHeight = ah;
			}else if(typeof ah == "number"){
				this._autoHeight = (ah >= this.get('rowCount'));
			}else{
				this._autoHeight = false;
			}
			if(this._started && !skipRender){
				this.render();
			}
		},

		_getRowCountAttr: function(){
			return this.updating && this.invalidated && this.invalidated.rowCount != undefined ?
				this.invalidated.rowCount : this.rowCount;
		},
		
		textSizeChanged: function(){
			this.render();
		},

		sizeChange: function(){
			this.update();
		},

		createManagers: function(){
			// summary:
			//		create grid managers for various tasks including rows, focus, selection, editing

			// row manager
			this.rows = new _RowManager(this);
			// focus manager
			this.focus = new _FocusManager(this);
			// edit manager
			this.edit = new _EditManager(this);
		},

		createSelection: function(){
			// summary:	Creates a new Grid selection manager.

			// selection manager
			this.selection = new Selection(this);
		},

		createScroller: function(){
			// summary: Creates a new virtual scroller
			this.scroller = new _Scroller();
			this.scroller.grid = this;
			this.scroller.renderRow = lang.hitch(this, "renderRow");
			this.scroller.removeRow = lang.hitch(this, "rowRemoved");
		},

		createLayout: function(){
			// summary: Creates a new Grid layout
			this.layout = new this._layoutClass(this);
			this.connect(this.layout, "moveColumn", "onMoveColumn");
		},

		onMoveColumn: function(){
			this.render();
		},
		
		onResizeColumn: function(/*int*/ cellIdx){
			// Called when a column is resized.
		},

		// views
		createViews: function(){
			this.views = new _ViewManager(this);
			this.views.createView = lang.hitch(this, "createView");
		},

		createView: function(inClass, idx){
			var c = lang.getObject(inClass);
			var view = new c({ grid: this, index: idx });
			this.viewsNode.appendChild(view.domNode);
			this.viewsHeaderNode.appendChild(view.headerNode);
			this.views.addView(view);
			html.attr(this.domNode, "align", this.isLeftToRight() ? 'left' : 'right');
			return view;
		},

		buildViews: function(){
			for(var i=0, vs; (vs=this.layout.structure[i]); i++){
				this.createView(vs.type || dojox._scopeName + ".grid._View", i).setStructure(vs);
			}
			this.scroller.setContentNodes(this.views.getContentNodes());
		},

		_setStructureAttr: function(structure){
			var s = structure;
			if(s && lang.isString(s)){
				dojo.deprecated("dojox.grid._Grid.set('structure', 'objVar')", "use dojox.grid._Grid.set('structure', objVar) instead", "2.0");
				s=lang.getObject(s);
			}
			this.structure = s;
			if(!s){
				if(this.layout.structure){
					s = this.layout.structure;
				}else{
					return;
				}
			}
			this.views.destroyViews();
			this.focus.focusView = null;
			if(s !== this.layout.structure){
				this.layout.setStructure(s);
			}
			this._structureChanged();
		},

		setStructure: function(/* dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]] */ inStructure){
			// summary:
			//		Install a new structure and rebuild the grid.
			dojo.deprecated("dojox.grid._Grid.setStructure(obj)", "use dojox.grid._Grid.set('structure', obj) instead.", "2.0");
			this._setStructureAttr(inStructure);
		},
		
		getColumnTogglingItems: function(){
			// Summary: returns an array of dijit.CheckedMenuItem widgets that can be
			//		added to a menu for toggling columns on and off.
			var items, checkedItems = [];
			items = array.map(this.layout.cells, function(cell){
				if(!cell.menuItems){ cell.menuItems = []; }

				var self = this;
				var item = new CheckedMenuItem({
					label: cell.name,
					checked: !cell.hidden,
					_gridCell: cell,
					onChange: function(checked){
						if(self.layout.setColumnVisibility(this._gridCell.index, checked)){
							var items = this._gridCell.menuItems;
							if(items.length > 1){
								array.forEach(items, function(item){
									if(item !== this){
										item.setAttribute("checked", checked);
									}
								}, this);
							}
							checked = array.filter(self.layout.cells, function(c){
								if(c.menuItems.length > 1){
									array.forEach(c.menuItems, "item.set('disabled', false);");
								}else{
									c.menuItems[0].set('disabled', false);
								}
								return !c.hidden;
							});
							if(checked.length == 1){
								array.forEach(checked[0].menuItems, "item.set('disabled', true);");
							}
						}
					},
					destroy: function(){
						var index = array.indexOf(this._gridCell.menuItems, this);
						this._gridCell.menuItems.splice(index, 1);
						delete this._gridCell;
						CheckedMenuItem.prototype.destroy.apply(this, arguments);
					}
				});
				cell.menuItems.push(item);
				if(!cell.hidden) {
					checkedItems.push(item);
				}
				return item;
			}, this); // dijit.CheckedMenuItem[]
			if(checkedItems.length == 1) {
				checkedItems[0].set('disabled', true);
			}
			return items;
		},

		_setHeaderMenuAttr: function(menu){
			if(this._placeholders && this._placeholders.length){
				array.forEach(this._placeholders, function(p){
					p.unReplace(true);
				});
				this._placeholders = [];
			}
			if(this.headerMenu){
				this.headerMenu.unBindDomNode(this.viewsHeaderNode);
			}
			this.headerMenu = menu;
			if(!menu){ return; }

			this.headerMenu.bindDomNode(this.viewsHeaderNode);
			if(this.headerMenu.getPlaceholders){
				this._placeholders = this.headerMenu.getPlaceholders(this.placeholderLabel);
			}
		},

		setHeaderMenu: function(/* dijit.Menu */ menu){
			dojo.deprecated("dojox.grid._Grid.setHeaderMenu(obj)", "use dojox.grid._Grid.set('headerMenu', obj) instead.", "2.0");
			this._setHeaderMenuAttr(menu);
		},
		
		setupHeaderMenu: function(){
			if(this._placeholders && this._placeholders.length){
				array.forEach(this._placeholders, function(p){
					if(p._replaced){
						p.unReplace(true);
					}
					p.replace(this.getColumnTogglingItems());
				}, this);
			}
		},

		_fetch: function(start){
			this.setScrollTop(0);
		},

		getItem: function(inRowIndex){
			return null;
		},
		
		showMessage: function(message){
			if(message){
				this.messagesNode.innerHTML = message;
				this.messagesNode.style.display = "";
			}else{
				this.messagesNode.innerHTML = "";
				this.messagesNode.style.display = "none";
			}
		},

		_structureChanged: function() {
			this.buildViews();
			if(this.autoRender && this._started){
				this.render();
			}
		},

		hasLayout: function() {
			return this.layout.cells.length;
		},

		// sizing
		resize: function(changeSize, resultSize){
			// summary:
			//		Update the grid's rendering dimensions and resize it
			
			// Calling sizeChange calls update() which calls _resize...so let's
			// save our input values, if any, and use them there when it gets
			// called.  This saves us an extra call to _resize(), which can
			// get kind of heavy.
			
			// fixes #11101, should ignore resize when in autoheight mode(IE) to avoid a deadlock
			// e.g when an autoheight editable grid put in dijit.form.Form or other similar containers,
			// grid switch to editing mode --> grid height change --> From height change
			// ---> Form call grid.resize() ---> grid height change  --> deaklock
			if(dojo.isIE && !changeSize && !resultSize && this._autoHeight){
				return;
			}
			this._pendingChangeSize = changeSize;
			this._pendingResultSize = resultSize;
			this.sizeChange();
		},

		_getPadBorder: function() {
			this._padBorder = this._padBorder || html._getPadBorderExtents(this.domNode);
			return this._padBorder;
		},

		_getHeaderHeight: function(){
			var vns = this.viewsHeaderNode.style, t = vns.display == "none" ? 0 : this.views.measureHeader();
			vns.height = t + 'px';
			// header heights are reset during measuring so must be normalized after measuring.
			this.views.normalizeHeaderNodeHeight();
			return t;
		},
		
		_resize: function(changeSize, resultSize){
			// Restore our pending values, if any
			changeSize = changeSize || this._pendingChangeSize;
			resultSize = resultSize || this._pendingResultSize;
			delete this._pendingChangeSize;
			delete this._pendingResultSize;
			// if we have set up everything except the DOM, we cannot resize
			if(!this.domNode){ return; }
			var pn = this.domNode.parentNode;
			if(!pn || pn.nodeType != 1 || !this.hasLayout() || pn.style.visibility == "hidden" || pn.style.display == "none"){
				return;
			}
			// useful measurement
			var padBorder = this._getPadBorder();
			var hh = undefined;
			var h;
			// grid height
			if(this._autoHeight){
				this.domNode.style.height = 'auto';
			}else if(typeof this.autoHeight == "number"){
				h = hh = this._getHeaderHeight();
				h += (this.scroller.averageRowHeight * this.autoHeight);
				this.domNode.style.height = h + "px";
			}else if(this.domNode.clientHeight <= padBorder.h){
				if(pn == document.body){
					this.domNode.style.height = this.defaultHeight;
				}else if(this.height){
					this.domNode.style.height = this.height;
				}else{
					this.fitTo = "parent";
				}
			}
			// if we are given dimensions, size the grid's domNode to those dimensions
			if(resultSize){
				changeSize = resultSize;
			}
			if(!this._autoHeight && changeSize){
				html.marginBox(this.domNode, changeSize);
				this.height = this.domNode.style.height;
				delete this.fitTo;
			}else if(this.fitTo == "parent"){
				h = this._parentContentBoxHeight = this._parentContentBoxHeight || html._getContentBox(pn).h;
				this.domNode.style.height = Math.max(0, h) + "px";
			}
			
			var hasFlex = array.some(this.views.views, function(v){ return v.flexCells; });

			if(!this._autoHeight && (h || html._getContentBox(this.domNode).h) === 0){
				// We need to hide the header, since the Grid is essentially hidden.
				this.viewsHeaderNode.style.display = "none";
			}else{
				// Otherwise, show the header and give it an appropriate height.
				this.viewsHeaderNode.style.display = "block";
				if(!hasFlex && hh === undefined){
					hh = this._getHeaderHeight();
				}
			}
			if(hasFlex){
				hh = undefined;
			}

			// NOTE: it is essential that width be applied before height
			// Header height can only be calculated properly after view widths have been set.
			// This is because flex column width is naturally 0 in Firefox.
			// Therefore prior to width sizing flex columns with spaces are maximally wrapped
			// and calculated to be too tall.
			this.adaptWidth();
			this.adaptHeight(hh);

			this.postresize();
		},

		adaptWidth: function() {
			// private: sets width and position for views and update grid width if necessary
			var doAutoWidth = (!this.initialWidth && this.autoWidth);
			var w = doAutoWidth ? 0 : this.domNode.clientWidth || (this.domNode.offsetWidth - this._getPadBorder().w),
				vw = this.views.arrange(1, w);
			this.views.onEach("adaptWidth");
			if(doAutoWidth){
				this.domNode.style.width = vw + "px";
			}
		},

		adaptHeight: function(inHeaderHeight){
			// private: measures and normalizes header height, then sets view heights, and then updates scroller
			// content extent
			var t = inHeaderHeight === undefined ? this._getHeaderHeight() : inHeaderHeight;
			var h = (this._autoHeight ? -1 : Math.max(this.domNode.clientHeight - t, 0) || 0);
			this.views.onEach('setSize', [0, h]);
			this.views.onEach('adaptHeight');
			if(!this._autoHeight){
				var numScroll = 0, numNoScroll = 0;
				var noScrolls = array.filter(this.views.views, function(v){
					var has = v.hasHScrollbar();
					if(has){ numScroll++; }else{ numNoScroll++; }
					return (!has);
				});
				if(numScroll > 0 && numNoScroll > 0){
					array.forEach(noScrolls, function(v){
						v.adaptHeight(true);
					});
				}
			}
			if(this.autoHeight === true || h != -1 || (typeof this.autoHeight == "number" && this.autoHeight >= this.get('rowCount'))){
				this.scroller.windowHeight = h;
			}else{
				this.scroller.windowHeight = Math.max(this.domNode.clientHeight - t, 0);
			}
		},

		// startup
		startup: function(){
			if(this._started){return;}
			this.inherited(arguments);
			if(this.autoRender){
				this.render();
			}
		},

		// render
		render: function(){
			// summary:
			//	Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
			// scrolling states, see Update.

			if(!this.domNode){return;}
			if(!this._started){return;}

			if(!this.hasLayout()) {
				this.scroller.init(0, this.keepRows, this.rowsPerPage);
				return;
			}
			//
			this.update = this.defaultUpdate;
			this._render();
		},

		_render: function(){
			this.scroller.init(this.get('rowCount'), this.keepRows, this.rowsPerPage);
			this.prerender();
			this.setScrollTop(0);
			this.postrender();
		},

		prerender: function(){
			// if autoHeight, make sure scroller knows not to virtualize; everything must be rendered.
			this.keepRows = this._autoHeight ? 0 : this.keepRows;
			this.scroller.setKeepInfo(this.keepRows);
			this.views.render();
			this._resize();
		},

		postrender: function(){
			this.postresize();
			this.focus.initFocusView();
			// make rows unselectable
			html.setSelectable(this.domNode, this.selectable);
		},

		postresize: function(){
			// views are position absolute, so they do not inflate the parent
			if(this._autoHeight){
				var size = Math.max(this.views.measureContent()) + 'px';
				
				this.viewsNode.style.height = size;
			}
		},

		renderRow: function(inRowIndex, inNodes){
			// summary: private, used internally to render rows
			this.views.renderRow(inRowIndex, inNodes, this._skipRowRenormalize);
		},

		rowRemoved: function(inRowIndex){
			// summary: private, used internally to remove rows
			this.views.rowRemoved(inRowIndex);
		},

		invalidated: null,

		updating: false,

		beginUpdate: function(){
			// summary:
			//		Use to make multiple changes to rows while queueing row updating.
			// NOTE: not currently supporting nested begin/endUpdate calls
			this.invalidated = [];
			this.updating = true;
		},

		endUpdate: function(){
			// summary:
			//		Use after calling beginUpdate to render any changes made to rows.
			this.updating = false;
			var i = this.invalidated, r;
			if(i.all){
				this.update();
			}else if(i.rowCount != undefined){
				this.updateRowCount(i.rowCount);
			}else{
				for(r in i){
					this.updateRow(Number(r));
				}
			}
			this.invalidated = [];
		},

		// update
		defaultUpdate: function(){
			// note: initial update calls render and subsequently this function.
			if(!this.domNode){return;}
			if(this.updating){
				this.invalidated.all = true;
				return;
			}
			//this.edit.saveState(inRowIndex);
			this.lastScrollTop = this.scrollTop;
			this.prerender();
			this.scroller.invalidateNodes();
			this.setScrollTop(this.lastScrollTop);
			this.postrender();
			//this.edit.restoreState(inRowIndex);
		},

		update: function(){
			// summary:
			//		Update the grid, retaining edit and scrolling states.
			this.render();
		},

		updateRow: function(inRowIndex){
			// summary:
			//		Render a single row.
			// inRowIndex: Integer
			//		Index of the row to render
			inRowIndex = Number(inRowIndex);
			if(this.updating){
				this.invalidated[inRowIndex]=true;
			}else{
				this.views.updateRow(inRowIndex);
				this.scroller.rowHeightChanged(inRowIndex);
			}
		},

		updateRows: function(startIndex, howMany){
			// summary:
			//		Render consecutive rows at once.
			// startIndex: Integer
			//		Index of the starting row to render
			// howMany: Integer
			//		How many rows to update.
			startIndex = Number(startIndex);
			howMany = Number(howMany);
			var i;
			if(this.updating){
				for(i=0; i<howMany; i++){
					this.invalidated[i+startIndex]=true;
				}
			}else{
				for(i=0; i<howMany; i++){
					this.views.updateRow(i+startIndex, this._skipRowRenormalize);
				}
				this.scroller.rowHeightChanged(startIndex);
			}
		},

		updateRowCount: function(inRowCount){
			//summary:
			//	Change the number of rows.
			// inRowCount: int
			//	Number of rows in the grid.
			if(this.updating){
				this.invalidated.rowCount = inRowCount;
			}else{
				this.rowCount = inRowCount;
				this._setAutoHeightAttr(this.autoHeight, true);
				if(this.layout.cells.length){
					this.scroller.updateRowCount(inRowCount);
				}
				this._resize();
				if(this.layout.cells.length){
					this.setScrollTop(this.scrollTop);
				}
			}
		},

		updateRowStyles: function(inRowIndex){
			// summary:
			//		Update the styles for a row after it's state has changed.
			this.views.updateRowStyles(inRowIndex);
		},
		getRowNode: function(inRowIndex){
			// summary:
			//		find the rowNode that is not a rowSelector
			if (this.focus.focusView && !(this.focus.focusView instanceof _RowSelector)){
					return this.focus.focusView.rowNodes[inRowIndex];
			}else{ // search through views
				for (var i = 0, cView; (cView = this.views.views[i]); i++) {
					if (!(cView instanceof _RowSelector)) {
						return cView.rowNodes[inRowIndex];
					}
				}
			}
			return null;
		},
		rowHeightChanged: function(inRowIndex){
			// summary:
			//		Update grid when the height of a row has changed. Row height is handled automatically as rows
			//		are rendered. Use this function only to update a row's height outside the normal rendering process.
			// inRowIndex: Integer
			// 		index of the row that has changed height

			this.views.renormalizeRow(inRowIndex);
			this.scroller.rowHeightChanged(inRowIndex);
		},

		// fastScroll: Boolean
		//		flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
		//		scroll performance but more immediate scrolling feedback
		fastScroll: true,

		delayScroll: false,

		// scrollRedrawThreshold: int
		//	pixel distance a user must scroll vertically to trigger grid scrolling.
		scrollRedrawThreshold: (has("ie") ? 100 : 50),

		// scroll methods
		scrollTo: function(inTop){
			// summary:
			//		Vertically scroll the grid to a given pixel position
			// inTop: Integer
			//		vertical position of the grid in pixels
			if(!this.fastScroll){
				this.setScrollTop(inTop);
				return;
			}
			var delta = Math.abs(this.lastScrollTop - inTop);
			this.lastScrollTop = inTop;
			if(delta > this.scrollRedrawThreshold || this.delayScroll){
				this.delayScroll = true;
				this.scrollTop = inTop;
				this.views.setScrollTop(inTop);
				if(this._pendingScroll){
					window.clearTimeout(this._pendingScroll);
				}
				var _this = this;
				this._pendingScroll = window.setTimeout(function(){
					delete _this._pendingScroll;
					_this.finishScrollJob();
				}, 200);
			}else{
				this.setScrollTop(inTop);
			}
		},

		finishScrollJob: function(){
			this.delayScroll = false;
			this.setScrollTop(this.scrollTop);
		},

		setScrollTop: function(inTop){
			this.scroller.scroll(this.views.setScrollTop(inTop));
		},

		scrollToRow: function(inRowIndex){
			// summary:
			//		Scroll the grid to a specific row.
			// inRowIndex: Integer
			// 		grid row index
			this.setScrollTop(this.scroller.findScrollTop(inRowIndex) + 1);
		},

		// styling (private, used internally to style individual parts of a row)
		styleRowNode: function(inRowIndex, inRowNode){
			if(inRowNode){
				this.rows.styleRowNode(inRowIndex, inRowNode);
			}
		},
		
		// called when the mouse leaves the grid so we can deselect all hover rows
		_mouseOut: function(e){
			this.rows.setOverRow(-2);
		},
	
		// cells
		getCell: function(inIndex){
			// summary:
			//		Retrieves the cell object for a given grid column.
			// inIndex: Integer
			// 		Grid column index of cell to retrieve
			// returns:
			//		a grid cell
			return this.layout.cells[inIndex];
		},

		setCellWidth: function(inIndex, inUnitWidth){
			this.getCell(inIndex).unitWidth = inUnitWidth;
		},

		getCellName: function(inCell){
			// summary: Returns the cell name of a passed cell
			return "Cell " + inCell.index; // String
		},

		// sorting
		canSort: function(inSortInfo){
			// summary:
			//		Determines if the grid can be sorted
			// inSortInfo: Integer
			//		Sort information, 1-based index of column on which to sort, positive for an ascending sort
			// 		and negative for a descending sort
			// returns: Boolean
			//		True if grid can be sorted on the given column in the given direction
		},

		sort: function(){
		},

		getSortAsc: function(inSortInfo){
			// summary:
			//		Returns true if grid is sorted in an ascending direction.
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Boolean(inSortInfo > 0); // Boolean
		},

		getSortIndex: function(inSortInfo){
			// summary:
			//		Returns the index of the column on which the grid is sorted
			inSortInfo = inSortInfo == undefined ? this.sortInfo : inSortInfo;
			return Math.abs(inSortInfo) - 1; // Integer
		},

		setSortIndex: function(inIndex, inAsc){
			// summary:
			// 		Sort the grid on a column in a specified direction
			// inIndex: Integer
			// 		Column index on which to sort.
			// inAsc: Boolean
			// 		If true, sort the grid in ascending order, otherwise in descending order
			var si = inIndex +1;
			if(inAsc != undefined){
				si *= (inAsc ? 1 : -1);
			} else if(this.getSortIndex() == inIndex){
				si = -this.sortInfo;
			}
			this.setSortInfo(si);
		},

		setSortInfo: function(inSortInfo){
			if(this.canSort(inSortInfo)){
				this.sortInfo = inSortInfo;
				this.sort();
				this.update();
			}
		},

		// DOM event handler
		doKeyEvent: function(e){
			e.dispatch = 'do' + e.type;
			this.onKeyEvent(e);
		},

		// event dispatch
		//: protected
		_dispatch: function(m, e){
			if(m in this){
				return this[m](e);
			}
			return false;
		},

		dispatchKeyEvent: function(e){
			this._dispatch(e.dispatch, e);
		},

		dispatchContentEvent: function(e){
			this.edit.dispatchEvent(e) || e.sourceView.dispatchContentEvent(e) || this._dispatch(e.dispatch, e);
		},

		dispatchHeaderEvent: function(e){
			e.sourceView.dispatchHeaderEvent(e) || this._dispatch('doheader' + e.type, e);
		},

		dokeydown: function(e){
			this.onKeyDown(e);
		},

		doclick: function(e){
			if(e.cellNode){
				this.onCellClick(e);
			}else{
				this.onRowClick(e);
			}
		},

		dodblclick: function(e){
			if(e.cellNode){
				this.onCellDblClick(e);
			}else{
				this.onRowDblClick(e);
			}
		},

		docontextmenu: function(e){
			if(e.cellNode){
				this.onCellContextMenu(e);
			}else{
				this.onRowContextMenu(e);
			}
		},

		doheaderclick: function(e){
			if(e.cellNode){
				this.onHeaderCellClick(e);
			}else{
				this.onHeaderClick(e);
			}
		},

		doheaderdblclick: function(e){
			if(e.cellNode){
				this.onHeaderCellDblClick(e);
			}else{
				this.onHeaderDblClick(e);
			}
		},

		doheadercontextmenu: function(e){
			if(e.cellNode){
				this.onHeaderCellContextMenu(e);
			}else{
				this.onHeaderContextMenu(e);
			}
		},

		// override to modify editing process
		doStartEdit: function(inCell, inRowIndex){
			this.onStartEdit(inCell, inRowIndex);
		},

		doApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
			this.onApplyCellEdit(inValue, inRowIndex, inFieldIndex);
		},

		doCancelEdit: function(inRowIndex){
			this.onCancelEdit(inRowIndex);
		},

		doApplyEdit: function(inRowIndex){
			this.onApplyEdit(inRowIndex);
		},

		// row editing
		addRow: function(){
			// summary:
			//		Add a row to the grid.
			this.updateRowCount(this.get('rowCount')+1);
		},

		removeSelectedRows: function(){
			// summary:
			//		Remove the selected rows from the grid.
			if(this.allItemsSelected){
				this.updateRowCount(0);
			}else{
				this.updateRowCount(Math.max(0, this.get('rowCount') - this.selection.getSelected().length));
			}
			this.selection.clear();
		}

	});

	_Grid.markupFactory = function(props, node, ctor, cellFunc){
		var widthFromAttr = function(n){
			var w = html.attr(n, "width")||"auto";
			if((w != "auto")&&(w.slice(-2) != "em")&&(w.slice(-1) != "%")){
				w = parseInt(w, 10)+"px";
			}
			return w;
		};
		// if(!props.store){ console.debug("no store!"); }
		// if a structure isn't referenced, do we have enough
		// data to try to build one automatically?
		if(	!props.structure &&
			node.nodeName.toLowerCase() == "table"){

			// try to discover a structure
			props.structure = query("> colgroup", node).map(function(cg){
				var sv = html.attr(cg, "span");
				var v = {
					noscroll: (html.attr(cg, "noscroll") == "true") ? true : false,
					__span: (!!sv ? parseInt(sv, 10) : 1),
					cells: []
				};
				if(html.hasAttr(cg, "width")){
					v.width = widthFromAttr(cg);
				}
				return v; // for vendetta
			});
			if(!props.structure.length){
				props.structure.push({
					__span: Infinity,
					cells: [] // catch-all view
				});
			}
			// check to see if we're gonna have more than one view

			// for each tr in our th, create a row of cells
			query("thead > tr", node).forEach(function(tr, tr_idx){
				var cellCount = 0;
				var viewIdx = 0;
				var lastViewIdx;
				var cView = null;
				query("> th", tr).map(function(th){
					// what view will this cell go into?

					// NOTE:
					//		to prevent extraneous iteration, we start counters over
					//		for each row, incrementing over the surface area of the
					//		structure that colgroup processing generates and
					//		creating cell objects for each <th> to place into those
					//		cell groups.  There's a lot of state-keepking logic
					//		here, but it is what it has to be.
					if(!cView){ // current view book keeping
						lastViewIdx = 0;
						cView = props.structure[0];
					}else if(cellCount >= (lastViewIdx+cView.__span)){
						viewIdx++;
						// move to allocating things into the next view
						lastViewIdx += cView.__span;
						var lastView = cView;
						cView = props.structure[viewIdx];
					}

					// actually define the cell from what markup hands us
					var cell = {
						name: lang.trim(html.attr(th, "name")||th.innerHTML),
						colSpan: parseInt(html.attr(th, "colspan")||1, 10),
						type: lang.trim(html.attr(th, "cellType")||""),
						id: lang.trim(html.attr(th,"id")||"")
					};
					cellCount += cell.colSpan;
					var rowSpan = html.attr(th, "rowspan");
					if(rowSpan){
						cell.rowSpan = rowSpan;
					}
					if(html.hasAttr(th, "width")){
						cell.width = widthFromAttr(th);
					}
					if(html.hasAttr(th, "relWidth")){
						cell.relWidth = window.parseInt(html.attr(th, "relWidth"), 10);
					}
					if(html.hasAttr(th, "hidden")){
						cell.hidden = (html.attr(th, "hidden") == "true" || html.attr(th, "hidden") === true/*always boolean true in Chrome*/);
					}

					if(cellFunc){
						cellFunc(th, cell);
					}

					cell.type = cell.type ? lang.getObject(cell.type) : dojox.grid.cells.Cell;

					if(cell.type && cell.type.markupFactory){
						cell.type.markupFactory(th, cell);
					}

					if(!cView.cells[tr_idx]){
						cView.cells[tr_idx] = [];
					}
					cView.cells[tr_idx].push(cell);
				});
			});
		}

		return new ctor(props, node);
	};

	return _Grid;

});
},
'dojo/cldr/nls/currency':function(){
define({ root:

//begin v1.x content
{
	"USD_symbol": "US$",
	"CAD_symbol": "CA$",
	"GBP_symbol": "£",
	"HKD_symbol": "HK$",
	"JPY_symbol": "JP¥",
	"AUD_symbol": "AU$",
	"CNY_symbol": "CN¥",
	"EUR_symbol": "€"
}
//end v1.x content
,
	"af": true,
	"ak": true,
	"am": true,
	"ar": true,
	"asa": true,
	"az": true,
	"be": true,
	"bez": true,
	"bg": true,
	"bm": true,
	"bn": true,
	"bo": true,
	"br": true,
	"brx": true,
	"bs": true,
	"ca": true,
	"cgg": true,
	"chr": true,
	"cs": true,
	"cy": true,
	"da": true,
	"dav": true,
	"de": true,
	"ebu": true,
	"ee": true,
	"el": true,
	"el-polyton": true,
	"en": true,
	"en-au": true,
	"en-bz": true,
	"en-ca": true,
	"en-hk": true,
	"en-jm": true,
	"en-mt": true,
	"en-na": true,
	"en-nz": true,
	"en-sg": true,
	"en-tt": true,
	"es": true,
	"es-ec": true,
	"es-pr": true,
	"es-us": true,
	"et": true,
	"fa": true,
	"fa-af": true,
	"ff": true,
	"fi": true,
	"fil": true,
	"fr": true,
	"fr-ca": true,
	"ga": true,
	"gl": true,
	"gsw": true,
	"guz": true,
	"ha": true,
	"he": true,
	"hi": true,
	"hr": true,
	"hu": true,
	"is": true,
	"it": true,
	"iw": true,
	"ja": true,
	"jmc": true,
	"ka": true,
	"kab": true,
	"kam": true,
	"kde": true,
	"kea": true,
	"khq": true,
	"ki": true,
	"kln": true,
	"ko": true,
	"ksb": true,
	"lag": true,
	"lg": true,
	"lt": true,
	"luo": true,
	"luy": true,
	"lv": true,
	"mas": true,
	"mer": true,
	"mfe": true,
	"mg": true,
	"mk": true,
	"ml": true,
	"mo": true,
	"mt": true,
	"my": true,
	"naq": true,
	"nb": true,
	"nd": true,
	"ne": true,
	"nl": true,
	"nn": true,
	"no": true,
	"nyn": true,
	"om": true,
	"pa-arab": true,
	"pa-pk": true,
	"pl": true,
	"pt": true,
	"rm": true,
	"ro": true,
	"rof": true,
	"ru": true,
	"rwk": true,
	"saq": true,
	"seh": true,
	"ses": true,
	"sg": true,
	"sh": true,
	"shi": true,
	"shi-tfng": true,
	"sk": true,
	"sl": true,
	"sn": true,
	"so": true,
	"sq": true,
	"sr": true,
	"sr-latn": true,
	"sv": true,
	"sw": true,
	"te": true,
	"teo": true,
	"th": true,
	"ti": true,
	"tl": true,
	"tr": true,
	"tzm": true,
	"uk": true,
	"ur": true,
	"vi": true,
	"vun": true,
	"xog": true,
	"yo": true,
	"zh": true,
	"zh-hans-hk": true,
	"zh-hant": true,
	"zh-hant-hk": true,
	"zh-hk": true,
	"zh-mo": true,
	"zh-tw": true
});
},
'ibm/tivoli/tip/dijit/TIPButton':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/form/Button,dijit/form/_FormWidget,dijit/_Container"], function(dijit,dojo,dojox){
/******************************************************* {COPYRIGHT-TOP-OCO} ***
 * Licensed Materials - Property of IBM
 *
 * (C) Copyright IBM Corp. 2008 All Rights Reserved.
 *
 * US Government Users Restricted Rights - Use, duplication, or
 * disclosure restricted by GSA ADP Schedule Contract with IBM Corp.
 ******************************************************* {COPYRIGHT-END-OCO} ***/

dojo.provide("ibm.tivoli.tip.dijit.TIPButton");
dojo.require("dijit.form.Button");
dojo.require("dijit.form._FormWidget");
dojo.require("dijit._Container");

dojo.declare("ibm.tivoli.tip.dijit.TIPButton",
              dijit.form._FormWidget,
{

	// label: String
	//	text to display in button
	label: "",

	// showLabel: Boolean
	//	whether or not to display the text label in button
	showLabel: true,

	// iconClass: String
	//	class to apply to div in button to make it display an icon
	iconClass: "",

	type: "button",
	baseClass: "dijitButton",
	templateString:"<div class=\"dijit dijitLeft dijitInline dijitButton\"\n\tdojoAttachEvent=\"onclick:_onButtonClick\"\n\t><div class='dijitRight'\n\t\t><button class=\"dijitStretch dijitButtonNode dijitButtonContents\" dojoAttachPoint=\"focusNode,titleNode\"\n\t\t\ttype=\"${type}\" waiRole=\"button\" waiState=\"labelledby-${id}_label\"\n\t\t\t>\n\t\t\t<div dojoAttachPoint=\"buttonDiv\">\n              <table width=\"100%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\">\n               <tr>\n                <td style=\"white-space: nowrap;\">\n\t\t\t\t  <div align=\"center\">\n\t\t\t\t\t<span class=\"dijitInline ${iconClass}\" dojoAttachPoint=\"iconNode\">\n\t \t\t\t\t\t<span class=\"dijitToggleButtonIconChar\">&#10003</span>\n \t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"dijitButtonText\" id=\"${id}_label\" dojoAttachPoint=\"containerNode\">${label}</span>\n\t\t\t\t  </div>\n\t\t\t\t</td>\n               </tr>\n              </table>\n             </div>\t\t\t\n\t\t</button>\n\t</div>\n</div>\n",	

	constructor: function () {
	},
	_onClick: function(/*Event*/ e){
		// summary: internal function to handle click actions
		if(this.disabled){ return false; }
		this._clicked(); // widget click actions
		return this.onClick(e); // user click actions
	},

	_onButtonClick: function(/*Event*/ e){
		// summary: callback when the user mouse clicks the button portion
		dojo.stopEvent(e);
		var okToSubmit = this._onClick(e) !== false; // returning nothing is same as true

		// for some reason type=submit buttons don't automatically submit the form; do it manually
		if(this.type=="submit" && okToSubmit){
			for(var node=this.domNode; node; node=node.parentNode){
				var widget=dijit.byNode(node);
				if(widget && widget._onSubmit){
					widget._onSubmit(e);
					break;
				}
				if(node.tagName.toLowerCase() == "form"){
					if(!node.onsubmit || node.onsubmit()){ node.submit(); }
					break;
				}
			}
		}
	},

	postCreate: function(){
		// summary:
		//	get label and set as title on button icon if necessary
		if (this.showLabel === false){
			var labelText = "";
			this.label = this.containerNode.innerHTML;
			labelText = dojo.trim(this.containerNode.innerText || this.containerNode.textContent);
			// set title attrib on iconNode
			this.titleNode.title=labelText;
			dojo.addClass(this.containerNode,"dijitDisplayNone");
    } else {
        // need to set button div width to 100% because
        // firefox has issues fitting the label into the button
        this.buttonDiv.style.width="100%";
    }
		this.inherited(arguments);
		//this.connectEvents();
	},

	onClick: function(/*Event*/ e){
		// summary: user callback for when button is clicked
		//      if type="submit", return value != false to perform submit
		return true;
	},

	_clicked: function(/*Event*/ e){
		// summary: internal replaceable function for when the button is clicked
	},

	setLabel: function(/*String*/ content){
		// summary: reset the label (text) of the button; takes an HTML string
		this.containerNode.innerHTML = this.label = content;
		if(dojo.isMozilla){ // Firefox has re-render issues with tables
			var oldDisplay = dojo.getComputedStyle(this.domNode).display;
			this.domNode.style.display="none";
			var _this = this;
			setTimeout(function(){_this.domNode.style.display=oldDisplay;},1);
		}
		if (this.showLabel === false){
				this.titleNode.title=dojo.trim(this.containerNode.innerText || this.containerNode.textContent);
		}
	},
	connectEvents: function () {
		dojo.connect (this, "onmousedown", this, this._onMouseDown);
		dojo.connect (this, "onmouseup", this, this._onMouseUp);
		dojo.connect (this, "onkeydown", this, this._onMouseDown);
		dojo.connect (this, "onkeydown", this, this._onMouseUp);
		
		dojo.connect (this, "onmouseover", this, this._onFocus);
		dojo.connect (this, "onmouseout", this, this._onBlur);
		dojo.connect (this, "onfocus", this, this._onFocus);
		dojo.connect (this, "onblur", this, this._onBlur);
		
	},
	_onMouseDown: function () {
		this.buttonDiv.className = "button-down";
	},
	_onMouseUp: function () {
		this.buttonDiv.className = "button-up";
	},
 	_onFocus: function () {
		this.buttonDiv.className = "button-over";
 	},
 	_onBlur: function () {
		this.buttonDiv.className = "button-out";
 	},
 	destroy: function () {
 		console.log ("enter TIPButton.destroy");
 		this.inherited (arguments);
 		console.log ("exit TIPButton.destroy");
 	}

});

});

},
'dojox/collections/_base':function(){
define("dojox/collections/_base", ["dojo/_base/kernel", "dojo/_base/lang", "dojo/_base/array"], 
  function(dojo, lang, arr){
	var collections = lang.getObject("dojox.collections", true);

/*=====
	collections = dojox.collections;
=====*/

	collections.DictionaryEntry=function(/* string */k, /* object */v){
		//	summary
		//	return an object of type dojox.collections.DictionaryEntry
		this.key=k;
		this.value=v;
		this.valueOf=function(){
			return this.value; 	//	object
		};
		this.toString=function(){
			return String(this.value);	//	string
		};
	}

	/*	Iterators
	 *	The collections.Iterators (Iterator and DictionaryIterator) are built to
	 *	work with the Collections included in this module.  However, they *can*
	 *	be used with arrays and objects, respectively, should one choose to do so.
	 */
	collections.Iterator=function(/* array */a){
		//	summary
		//	return an object of type dojox.collections.Iterator
		var position=0;
		this.element=a[position]||null;
		this.atEnd=function(){
			//	summary
			//	Test to see if the internal cursor has reached the end of the internal collection.
			return (position>=a.length);	//	bool
		};
		this.get=function(){
			//	summary
			//	Get the next member in the collection.
			if(this.atEnd()){
				return null;		//	object
			}
			this.element=a[position++];
			return this.element;	//	object
		};
		this.map=function(/* function */fn, /* object? */scope){
			//	summary
			//	Functional iteration with optional scope.
			return arr.map(a, fn, scope);
		};
		this.reset=function(){
			//	summary
			//	reset the internal cursor.
			position=0;
			this.element=a[position];
		};
	}

	/*	Notes:
	 *	The DictionaryIterator no longer supports a key and value property;
	 *	the reality is that you can use this to iterate over a JS object
	 *	being used as a hashtable.
	 */
	collections.DictionaryIterator=function(/* object */obj){
		//	summary
		//	return an object of type dojox.collections.DictionaryIterator
		var a=[];	//	Create an indexing array
		var testObject={};
		for(var p in obj){
			if(!testObject[p]){
				a.push(obj[p]);	//	fill it up
			}
		}
		var position=0;
		this.element=a[position]||null;
		this.atEnd=function(){
			//	summary
			//	Test to see if the internal cursor has reached the end of the internal collection.
			return (position>=a.length);	//	bool
		};
		this.get=function(){
			//	summary
			//	Get the next member in the collection.
			if(this.atEnd()){
				return null;		//	object
			}
			this.element=a[position++];
			return this.element;	//	object
		};
		this.map=function(/* function */fn, /* object? */scope){
			//	summary
			//	Functional iteration with optional scope.
			return arr.map(a, fn, scope);
		};
		this.reset=function() {
			//	summary
			//	reset the internal cursor.
			position=0;
			this.element=a[position];
		};
	};

	return collections;
});

},
'dijit/Toolbar':function(){
define("dijit/Toolbar", [
	"require",
	"dojo/_base/declare", // declare
	"dojo/_base/kernel",
	"dojo/keys", // keys.LEFT_ARROW keys.RIGHT_ARROW
	"dojo/ready",
	"./_Widget",
	"./_KeyNavContainer",
	"./_TemplatedMixin"
], function(require, declare, kernel, keys, ready, _Widget, _KeyNavContainer, _TemplatedMixin){

/*=====
	var _Widget = dijit._Widget;
	var _KeyNavContainer = dijit._KeyNavContainer;
	var _TemplatedMixin = dijit._TemplatedMixin;
=====*/

	// module:
	//		dijit/Toolbar
	// summary:
	//		A Toolbar widget, used to hold things like `dijit.Editor` buttons


	// Back compat w/1.6, remove for 2.0
	if(!kernel.isAsync){
		ready(0, function(){
			var requires = ["dijit/ToolbarSeparator"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.Toolbar", [_Widget, _TemplatedMixin, _KeyNavContainer], {
		// summary:
		//		A Toolbar widget, used to hold things like `dijit.Editor` buttons

		templateString:
			'<div class="dijit" role="toolbar" tabIndex="${tabIndex}" data-dojo-attach-point="containerNode">' +
			'</div>',

		baseClass: "dijitToolbar",

		postCreate: function(){
			this.inherited(arguments);

			this.connectKeyNavHandlers(
				this.isLeftToRight() ? [keys.LEFT_ARROW] : [keys.RIGHT_ARROW],
				this.isLeftToRight() ? [keys.RIGHT_ARROW] : [keys.LEFT_ARROW]
			);
		}
	});
});

},
'ibm/tivoli/simplesrm/srm/dijit/ItemChooserGrid':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dijit/_Templated,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dojo/data/FormattedDataReadStore,ibm/tivoli/tip/dijit/TIPTableToolbar,dojox/grid/DataGrid,ibm/tivoli/simplesrm/srm/dojo/data/Comparator,ibm/tivoli/simplesrm/srm/dijit/ContextButton"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ItemChooserGrid");

dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore");
dojo.require("ibm.tivoli.tip.dijit.TIPTableToolbar");
dojo.require("dojox.grid.DataGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.Comparator");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ContextButton");

// Summary
//	ItemChooserGrid is essentially a very fancy set of radio buttons
//	For now, you have to derive a class from it and
//		1. provide the grid's column definition in this.gridLayout.  For example:
//			this.gridLayout = [
//	      			  {name: "Name",   		 field: 'imageName', width: 'auto',	compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare, formatter: dojo.hitch(this, this._noWrap)},
//	      			  {name: "Platform",     field: 'platform',  width: 'auto', compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.stringCompare},
//	      			  {name: "CPUs",         field: 'cpus',      width: '4.1em',classes: 'numeric', compare: ibm.tivoli.simplesrm.srm.dojo.data.Comparator.intCompare},
//	      		];
//		2. provide the name of the primary key field
//	   		this.keyField = "imageName";
//		3. provide an implementation of queryData 
//			a. must return a dojo.Deferred
//			b. the data set must have an array type called "data" with the grid's data 
//			   for example:
//				queryData: function()
//				{
//					var d = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDiscoveredImages({sync: false});
//					d.addCallback(function(response) {
//						var images = response.QueryTPV01IMGLIBENTRYMSTRResponse.TPV01IMGLIBENTRYMSTRSet.ILIMAGE;
//						response.data = [];
//						for(var i in images) {
//							var img = images[i]; 
//							response.data.push({NAME: img.imagename, platform: img.Platform, cpus: img.cpus);}
//						}
//					});
//					return d;
//				},
//
//	Getting and setting the value is via the standard dijit's attr('value') and attr('value', newvalue)
//		The value returned on get will be the value of the keyField
//		The value set must match a keyField in the data store
//
//	Updating data is done by calling refresh(), which will in turn call your queryData function to get the new data.
//
// Attributes:
//	keyField: Name of the field in your data that is the primary key
//	name: The name is the name on the set of radio buttons, and is the name used to submit data with a form
//	autoHeight: any valid DataGrid autoHeight value.  If 0 or false, you must provide a height in the style.
//	readOnly: if true, the radio buttons are not displayed, and row selection is turned off
//
// Events:
//		onChange is fired when the selected value changes. It is passed the corresponding item object from the grid's data store
//			Accessing the selected row's values must be through ItemFileReadStore's API.
//			For example:
//				function onChange(item)
//				{
//					var c = dijit.byId('my_item_chooser_grid');
//					var name = c.attr('value');
//					var cpu = c.getFieldValue("platform");
//					var mem = c.getFieldValue("cpus");
//				}
//		onDataReady is fired when the grid is loaded with a new data set.
//
//	Markup:
//		<div id='c' dojoType="ibm.tivoli.simplesrm.tsam.dijit.ImageChooserGrid" name="PMRDPCLCSWS_SWSTACKID" 
//			style="width:600px;" autoHeight="5" onChange="onChooserChange"></div>

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ItemChooserGrid", [dijit._Widget, dijit._Templated],
{
	widgetsInTemplate: true,
	templateString: '<div class="ItemChooserGrid"><div id="${id}_toolbar" class="srmtoolbar" dojoAttachPoint="_toolbar" dojoType="ibm.tivoli.tip.dijit.TIPTableToolbar" ></div><div dojoAttachPoint="_griddiv" style="width:100%; height: 100%;"></div></div>',
	_grid: null,
	_searchField: null,
	_dataQuery: null,
	_selectedItem: null,
	contextBtns: null,

	
	gridLayout:  null,		// the grid's column layout, formatters, and such
	keyField: "id",			// your data's key
	name: "",				// you data's name, as you want it posted with the form
	autoHeight: 5,			// a valid DataGrid.autoHeight value
	readOnly: false,		// if readOnly is true, don't show the radio buttons, or do row selection
	contextName: "",		// name for context-specific toolbar buttons
	autoQuery: true,		// should I automatically query for my data on initialization?
	
	
	constructor: function()
	{
		console.log("ItemChooserGrid.ctor");
	},
	postMixInProperties: function()
	{
		console.log("ItemChooserGrid.postMixInProperties");

		this.inherited(arguments);
	},
	buildRendering: function()
	{
		this.inherited(arguments);
		
		// get context specific buttons
	    if(!this.readOnly && this.contextName && this.contextName.length > 0) {
	    	this.contextBtns = new ibm.tivoli.simplesrm.srm.dijit.ContextButtonSet({contextName: this.contextName, toolbar: this.getToolbar()});
	    	this.contextBtns.attr("disabled", true);
	    }
	    if(!this.contextBtns || this.contextBtns.length === 0) {
	    	this.getToolbar().tabIndex = -1;
	    }
	},
	postCreate: function()
	{
		console.log("ItemChooserGrid.postCreate");
		this._searchField = this._toolbar.searchField;
		var select = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Select;
		
		var bReadOnly = this.attr("readOnly");
		if(!bReadOnly) {
			// push a column to the front of what's given to us for the radio button
			this.gridLayout.unshift({name: select,      field: this.keyField,   width: "4em",	classes: 'center', formatter: dojo.hitch(this, this._formatRadioButton), isSearchable: false, editable: true});
		}
		
		this._grid = new dojox.grid.DataGrid({
					structure: this.gridLayout,
					selectionMode: bReadOnly ? "none" : "single",
					autoWidth: false,
					autoHeight: this.autoHeight
				}, this._griddiv);

		if(!bReadOnly) {
			this.connect(this._grid, "onSelected", this._onRowSelected);
		}
		
		this._searchField.setTable(this._grid);
		this._enableFilter();
		
		this.inherited(arguments);
	},
	/**
	 * Call refresh() to update the data in the grid
	 * Will eventually call your queryData() function.
	 * Has the side-effect of reseting the selection to the first row, and clearing the filter
	 */
	refresh: function()
	{
		if(this._dataQuery) {
			this._dataQuery.cancel();
			delete this._dataQuery;
			this._dataQuery = null;
		}
		this._disableFilter();
		this._grid.selection.clear();
		this._selectedItem = null;
		this._grid.setStore(null);

		this._dataQuery = this.queryData();
		this._dataQuery.addCallback(dojo.hitch(this, this.loadData));
	},
	loadData: function(response)
	{
		if(!dojo.isArray(response.data) || response.data.length === 0) {
			return;
		}
		if(this._dataQuery) {
			delete this._dataQuery;
			this._dataQuery = null;
		}
		var newdata = dojo.clone(response.data);
		var store = new ibm.tivoli.simplesrm.srm.dojo.data.FormattedDataReadStore({data: {identifier: this.keyField, items: newdata}});
		store.setStructure(this._grid.structure);
		store.comparatorMap = {};
		var gl = this.gridLayout;
		for(var i in gl) {
			if(undefined !== gl[i].compare) {
				store.comparatorMap[gl[i].field] = gl[i].compare;
			}
		}
		this._grid.attr("autoHeight", this.autoHeight);
		this._grid.setStore(store, null, {ignoreCase: true});
		this._grid.selection.select(0);
		this._enableFilter();
		//window.setTimeout(dojo.hitch(this, this._fixSize), 100);
		this._grid.resize();
		this.onDataReady();
	},
	_fixSize: function()
	{
		var sz = dojo.marginBox(this._grid.domNode);
		dojo.style(this._grid.domNode, "height", sz.h + "px");
		this._grid.attr('autoHeight', false);
	},
	startup: function()
	{
		console.log("ItemChooserGrid.startup");
		this._grid.startup();
		if(this.autoQuery){
			this.refresh();
		}
		this.inherited(arguments);
	},
	destroy: function()
	{
		this._disableFilter();
		if(this._progressSpinner){
			this._progressSpinner.destroy();
		}
	},
	
	_getValueAttr: function()
	{
		var retval = "";
		if(this._selectedItem) {
			retval = this._grid.store.getValue(this._selectedItem, this.keyField);
		}
		return retval;
	},
	// TODO: when the data query is async, then the grid might not be refilled
	// before someone calls .attr('value', val).  Maybe i should see if this._dataQuery exists,
	// and if so, add a callback to set the new value when the query completes.
	// For now, I'm going to make the serverChooserGrid2's query synchronous.
	_setValueAttr: function(newval)
	{
		var q = {};
		q[this.keyField] = newval;
		var item = this._grid.store.fetch({query:q, onComplete: dojo.hitch(this, function(items)
		{
			if(items.length > 0) {
				var r = this._grid.getItemIndex(items[0]);
				this._grid.selection.select(r);
				this._selectedItem = items[0];
				this._setCheck(this._selectedItem, true);
			}
		})});
	},
	_getSelectionAttr: function()
	{
		return this._selectedItem;
	},
	getSelectedItem: function(){
		return this._selectedItem;
	},
	/**
	** pull a field value out of a row of data.
	** a: if an ojbect, is assumed to be an item object from the grid's store.
	**		this may be the item sent out with onChange.
	**	  if a string, is assumed to be the field name, and we pull the value from the
	**		currently selected row
	** b: if a is an item, then b is the field name we want to extract
	**
	** returns:
	**		the value of the requested field, null if it doesn't exist.
	*/
	getFieldValue: function(/*string|object*/ a, /*string?*/ b)
	{
		var retval = null;
		var item = null;
		var name = "";
		if("object" == typeof a) {
			item = a;
			name = b;
		}
		else {
			name = a;
			var row = this._grid.selection.selectedIndex;
			item = this._grid.getItem(row);
		}
		if(null !== item) {
			retval = this._grid.store.getValue(item, name);
		}
		return retval;
	},
	/**
	 * similar to getFieldValue, but returns the field from the currently selected row
	 * and lets you provide a default if the field is undefined.
	 * fieldName: name of the field you want the value of
	 * defaultValue: if provided, returned if the requested field is missing
	 * 
	 * returns:
	 * 		value of the requested field, defaultValue, or null 
	 */
	getSelectedFieldValue: function(/*string*/fieldName, /*string?*/defaultValue)
	{
		var retval = null;
		var row = this._grid.selection.selectedIndex;
		var item = this._grid.getItem(row);
		if(null !== item) {
			retval = this._grid.store.getValue(item, fieldName);
		}
		if(undefined == retval && undefined != defaultValue){ 
			retval = defaultValue;
		}
		return retval;
	},
	_onRowClick: function(evt)
	{
		console.log("MyRecordsGrid._onRowClick");
		this._onRowSelected(evt.rowIndex);
	},
	_onRowSelected: function(rowIndex)
	{
		console.log("ItemChooserGrid._onrowSelected ", rowIndex);
		this._selectedItem = this._grid.getItem(rowIndex);
		this._setCheck();
		if(this.contextBtns) {
			this.contextBtns.attr("disabled", false);	// TODO: Probably depends on state of the selected object too
			// the row's data to the context buttons
			var context = {};
			try {
				context = this.getContext();
			}
			catch(ex) {
				ibm.tivoli.logger.warn("",ex);
			}
			this.contextBtns.setContext(context);	
		}
		this.onChange(this._selectedItem);
	},
	_reSelectSelected: function()
	{
		if(this._selectedItem) {
			var r = this._grid.getItemIndex(this._selectedItem);
			if(r >= 0) {
				this._grid.selection.select(r);
			}
			else {
				if(this.contextBtns){
					this.contextBtns.attr("disabled", true);
				}
				this._selectedItem = null;
				this._grid.selection.clear();
				this.onChange(null);
			}
		}
	},
	_setCheck:function()
	{
		if(null != this._selectedItem) {
			rbkey = this._grid.store.getValue(this._selectedItem, this.keyField);
			rbid = this._radioButtonIdFromKey(rbkey);
			rb = dojo.byId(rbid);
			if(rb){
				rb.checked = true;
			}
		}		
	},
	_onSorted: function()
	{
		if(this._selectedItem) {
			var r = this._grid.getItemIndex(this._selectedItem);
			this._grid.selection.select(r);
			// grid.selection.select doesn't fire onSelection, plus, something after that
			// redraws the grid and looses the check again.
			window.setTimeout(dojo.hitch(this, this._setCheck), 200);
		}
	},
	_radioButtonIdFromKey: function(key)
	{
		return this.id + "_" + key.toString().replace(/\W/g, "");
	},
	// returns an object with data from the selected row pertinant to the grid's datatype
	// derived grids should override if you have any context specific actions
	getContext: function()
	{
		return {};
	},
	onChange: function(selected_item)
	{
		// connect to me
		// selected_item is an item from an ItemFileReadStore
		// if you want values out of it, getFieldValue(selected_item, name)
		// or getFieldValue(name)
	},
	onDataReady: function()
	{
		// connect to me if you want to be notified when the grid has been loaded with new data
	},
	/********* formaters ***********/
	_formatRadioButton: function(datum, rowIndex)
	{
		var selValue = this._getValueAttr();
		var s = "<input id='" + this._radioButtonIdFromKey(datum) + "' type='radio' value='"+ datum +"' name='" + this.name + "'";
		s += (datum == selValue) ? " checked='true'" : "";
		s += ">";
		return s;
	},
	_noWrap: function(v)
	{
		return "<div style='white-space:nowrap;overflow:hidden;' title='"+ v +"'>" + v + "</div>";
	},

	/*********** filtering ****************/
	_onFilterSubscription: null,
	_onFilterKeypressHandle: null,
	_onFilterDelay: 700,		// msecs from time user starts typing, until we automagically filter the data
	_filterTimerID: -1,			// timer for delayed auto-filtering

	_disableFilter: function()
	{
		dojo.unsubscribe ( this._onFilterSubscription );  
		dojo.disconnect(this._onFilterKeypressHandle); 
		this._onFilterSubscription = this._onFilterKeypressHandle = null;
		this._searchField.clear();
	},
	_enableFilter: function()
	{
		this._searchField.setTable(this._grid);
		if(!this._onFilterSubscription) {	// wire it up
			// published on hitting enter
			this._onFilterSubscription = dojo.subscribe ( this._searchField.id + "searchInvoked", this, "_onFilter" );    
			// we also want to automatically filter as the user types
			this._onFilterKeypressHandle = dojo.connect(this._searchField.searchField, "onkeypress", this, "_onSearchKeyPress");
		}
		// if the table was filtered, re-filter with new data
		if(this._searchField.searchField.value.length > 0) {
			this._onFilter();
		}
	},
	_disableFilter: function()
	{
		dojo.unsubscribe ( this._onFilterSubscription );  
		dojo.disconnect(this._onFilterKeypressHandle); 
		this._onFilterSubscription = this._onFilterKeypressHandle = null;
		this._searchField.clear();
	},
	_onSearchKeyPress: function(evt)
	{
		if(evt.keyCode == dojo.keys.ENTER || evt.keyCode == dojo.keys.TAB)  {
			// ENTER is already handled, and TAB just causes field to loose focus
			return;
		}
		//console.log("MyRecordsGrid._onSearchKeyPress");
		if(this._filterTimerID < 0) {
			this._filterTimerID = window.setTimeout(dojo.hitch(this, "_onFilter"), this._onFilterDelay);
		}
	},
	_onFilter: function()
	{
		console.log("ItemChooserGrid._onFilter");
		if(this._filterTimerID >= 0) {
			window.clearTimeout(this._filterTimerID);
			this._filterTimerID = -1;
		}

		this._savedFilterCols = this._searchField.getSelectedColumns();
		var filterString = this._searchField.searchField.value;
 
		
		filterString = filterString.replace(/"/gm, "*");
		
		if ( filterString.length < 1 || /^\s+$/.test(filterString)) {
			this.clearFilter();
		}
		else {
			this.filter( this._savedFilterCols, filterString );
		}
		this._reSelectSelected();	// selections are by rowIndex.  need to redo it to keep the right record selected
		this._searchField.searchField.focus();
	},
	filter: function( fields,        /* array of field names to filter on */
	                  filterString ) /* user entered string */
	{
		// surround the filter string with '*'s so we match substrings
		var t = "*" + filterString + "*";
		
		// create the query by ORing together a query on each of the fields
		var q = "";
		dojo.forEach(fields, function(f) {
			q += f + ":\"" + t + "\" OR ";
		});
		q = q.substring(0, q.lastIndexOf(" OR "));
		this._grid.setQuery({complexQuery: q}, {ignoreCase: true});
	 },
	 clearFilter: function()
	 {
	 	// you can't clear the query with DataGrid.setQuery
	 	this._grid.setQuery(null);
		this._grid.resize();
	 },
	 _progressSpinner:null,
	showProgressSpinner: function() 
	{
		try {
			if(!this._progressSpinner) {
				this._progressSpinner = new ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner({text: this._uiStringTable.Loading + "&nbsp;"});
				var sz = dojo.coords(this.simpleGrid.domNode);
				dojo.style(this._progressSpinner.domNode, {
					height: "1em",
					width: "100%",
					zIndex: "10",
					position: "absolute",
					top: sz.y + "px",
					left: "0px",
					display: "block",
					textAlign: "center"
				});
				dojo.place(this._progressSpinner.domNode, this.domNode, "first");
			}	
			
			this._progressSpinner.show();
		}
		catch(ex) {
			ibm.tivoli.logger.error("Failed rendering MyRecordsGrid's progress spinner: ", ex);
			console.error("Failed rendering MyRecordsGrid's progress spinner: ", ex);
			if(this._progressSpinner) {
				this._progressSpinner.destroyRecursive();
				this._progressSpinner = null;
			}
			window.status = "Retrieving...";
		}
	},
	hideProgressSpinner: function() {
		console.log("MyRecordsGrid.hideProgressSpinner");
		if(this._progressSpinner){
			this._progressSpinner.hide();
		}
		else{
			window.status = "Done.";
		}
	},
	getToolbar: function()
	{
		return this._toolbar.getToolbar();
	}
});
});

},
'url:dojox/grid/resources/_Grid.html':"<div hidefocus=\"hidefocus\" role=\"grid\" dojoAttachEvent=\"onmouseout:_mouseOut\">\n\t<div class=\"dojoxGridMasterHeader\" dojoAttachPoint=\"viewsHeaderNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterView\" dojoAttachPoint=\"viewsNode\" role=\"presentation\"></div>\n\t<div class=\"dojoxGridMasterMessages\" style=\"display: none;\" dojoAttachPoint=\"messagesNode\"></div>\n\t<span dojoAttachPoint=\"lastFocusNode\" tabindex=\"0\"></span>\n</div>\n",
'dijit/layout/StackContainer':function(){
define("dijit/layout/StackContainer", [
	"dojo/_base/array", // array.forEach array.indexOf array.some
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.replace
	"dojo/_base/kernel",	// kernel.isAsync
	"dojo/_base/lang",	// lang.extend
	"dojo/ready",
	"dojo/topic", // publish
	"../registry",	// registry.byId
	"../_WidgetBase",
	"./_LayoutWidget",
	"dojo/i18n!../nls/common"
], function(array, cookie, declare, domClass, kernel, lang, ready, topic,
			registry, _WidgetBase, _LayoutWidget){

/*=====
var _WidgetBase = dijit._WidgetBase;
var _LayoutWidget = dijit.layout._LayoutWidget;
var StackController = dijit.layout.StackController;
=====*/

// module:
//		dijit/layout/StackContainer
// summary:
//		A container that has multiple children, but shows only one child at a time.

// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/layout/StackController"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

// These arguments can be specified for the children of a StackContainer.
// Since any widget can be specified as a StackContainer child, mix them
// into the base widget class.  (This is a hack, but it's effective.)
lang.extend(_WidgetBase, {
	// selected: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		Specifies that this widget should be the initially displayed pane.
	//		Note: to change the selected child use `dijit.layout.StackContainer.selectChild`
	selected: false,

	// closable: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		True if user can close (destroy) this child, such as (for example) clicking the X on the tab.
	closable: false,

	// iconClass: String
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		CSS Class specifying icon to use in label associated with this pane.
	iconClass: "dijitNoIcon",

	// showTitle: Boolean
	//		Parameter for children of `dijit.layout.StackContainer` or subclasses.
	//		When true, display title of this widget as tab label etc., rather than just using
	//		icon specified in iconClass
	showTitle: true
});

return declare("dijit.layout.StackContainer", _LayoutWidget, {
	// summary:
	//		A container that has multiple children, but shows only
	//		one child at a time
	//
	// description:
	//		A container for widgets (ContentPanes, for example) That displays
	//		only one Widget at a time.
	//
	//		Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	//
	//		Can be base class for container, Wizard, Show, etc.

	// doLayout: Boolean
	//		If true, change the size of my currently displayed child to match my size
	doLayout: true,

	// persist: Boolean
	//		Remembers the selected child across sessions
	persist: false,

	baseClass: "dijitStackContainer",

/*=====
	// selectedChildWidget: [readonly] dijit._Widget
	//		References the currently selected child widget, if any.
	//		Adjust selected child with selectChild() method.
	selectedChildWidget: null,
=====*/

	buildRendering: function(){
		this.inherited(arguments);
		domClass.add(this.domNode, "dijitLayoutContainer");
		this.containerNode.setAttribute("role", "tabpanel");
	},

	postCreate: function(){
		this.inherited(arguments);
		this.connect(this.domNode, "onkeypress", this._onKeyPress);
	},

	startup: function(){
		if(this._started){ return; }

		var children = this.getChildren();

		// Setup each page panel to be initially hidden
		array.forEach(children, this._setupChild, this);

		// Figure out which child to initially display, defaulting to first one
		if(this.persist){
			this.selectedChildWidget = registry.byId(cookie(this.id + "_selectedChild"));
		}else{
			array.some(children, function(child){
				if(child.selected){
					this.selectedChildWidget = child;
				}
				return child.selected;
			}, this);
		}
		var selected = this.selectedChildWidget;
		if(!selected && children[0]){
			selected = this.selectedChildWidget = children[0];
			selected.selected = true;
		}

		// Publish information about myself so any StackControllers can initialize.
		// This needs to happen before this.inherited(arguments) so that for
		// TabContainer, this._contentBox doesn't include the space for the tab labels.
		topic.publish(this.id+"-startup", {children: children, selected: selected});

		// Startup each child widget, and do initial layout like setting this._contentBox,
		// then calls this.resize() which does the initial sizing on the selected child.
		this.inherited(arguments);
	},

	resize: function(){
		// Resize is called when we are first made visible (it's called from startup()
		// if we are initially visible). If this is the first time we've been made
		// visible then show our first child.
		if(!this._hasBeenShown){
			this._hasBeenShown = true;
			var selected = this.selectedChildWidget;
			if(selected){
				this._showChild(selected);
			}
		}
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Overrides _LayoutWidget._setupChild()

		this.inherited(arguments);

		domClass.replace(child.domNode, "dijitHidden", "dijitVisible");

		// remove the title attribute so it doesn't show up when i hover
		// over a node
		child.domNode.title = "";
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Overrides _Container.addChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			topic.publish(this.id+"-addChild", child, insertIndex);	// publish

			// in case the tab titles have overflowed from one line to two lines
			// (or, if this if first child, from zero lines to one line)
			// TODO: w/ScrollingTabController this is no longer necessary, although
			// ScrollTabController.resize() does need to get called to show/hide
			// the navigation buttons as appropriate, but that's handled in ScrollingTabController.onAddChild().
			// If this is updated to not layout [except for initial child added / last child removed], update
			// "childless startup" test in StackContainer.html to check for no resize event after second addChild()
			this.layout();

			// if this is the first child, then select it
			if(!this.selectedChildWidget){
				this.selectChild(child);
			}
		}
	},

	removeChild: function(/*dijit._Widget*/ page){
		// Overrides _Container.removeChild() to do layout and publish events

		this.inherited(arguments);

		if(this._started){
			// this will notify any tablists to remove a button; do this first because it may affect sizing
			topic.publish(this.id + "-removeChild", page);	// publish
		}

		// If all our children are being destroyed than don't run the code below (to select another page),
		//  because we are deleting every page one by one
		if(this._descendantsBeingDestroyed){ return; }

		// Select new page to display, also updating TabController to show the respective tab.
		// Do this before layout call because it can affect the height of the TabController.
		if(this.selectedChildWidget === page){
			this.selectedChildWidget = undefined;
			if(this._started){
				var children = this.getChildren();
				if(children.length){
					this.selectChild(children[0]);
				}
			}
		}

		if(this._started){
			// In case the tab titles now take up one line instead of two lines
			// (note though that ScrollingTabController never overflows to multiple lines),
			// or the height has changed slightly because of addition/removal of tab which close icon
			this.layout();
		}
	},

	selectChild: function(/*dijit._Widget|String*/ page, /*Boolean*/ animate){
		// summary:
		//		Show the given widget (which must be one of my children)
		// page:
		//		Reference to child widget or id of child widget

		page = registry.byId(page);

		if(this.selectedChildWidget != page){
			// Deselect old page and select new one
			var d = this._transition(page, this.selectedChildWidget, animate);
			this._set("selectedChildWidget", page);
			topic.publish(this.id+"-selectChild", page);	// publish

			if(this.persist){
				cookie(this.id + "_selectedChild", this.selectedChildWidget.id);
			}
		}

		return d;		// If child has an href, promise that fires when the child's href finishes loading
	},

	_transition: function(newWidget, oldWidget /*===== ,  animate =====*/){
		// summary:
		//		Hide the old widget and display the new widget.
		//		Subclasses should override this.
		// newWidget: dijit._Widget
		//		The newly selected widget.
		// oldWidget: dijit._Widget
		//		The previously selected widget.
		// animate: Boolean
		//		Used by AccordionContainer to turn on/off slide effect.
		// tags:
		//		protected extension
		if(oldWidget){
			this._hideChild(oldWidget);
		}
		var d = this._showChild(newWidget);

		// Size the new widget, in case this is the first time it's being shown,
		// or I have been resized since the last time it was shown.
		// Note that page must be visible for resizing to work.
		if(newWidget.resize){
			if(this.doLayout){
				newWidget.resize(this._containerContentBox || this._contentBox);
			}else{
				// the child should pick it's own size but we still need to call resize()
				// (with no arguments) to let the widget lay itself out
				newWidget.resize();
			}
		}

		return d;	// If child has an href, promise that fires when the child's href finishes loading
	},

	_adjacent: function(/*Boolean*/ forward){
		// summary:
		//		Gets the next/previous child widget in this container from the current selection.
		var children = this.getChildren();
		var index = array.indexOf(children, this.selectedChildWidget);
		index += forward ? 1 : children.length - 1;
		return children[ index % children.length ]; // dijit._Widget
	},

	forward: function(){
		// summary:
		//		Advance to next page.
		return this.selectChild(this._adjacent(true), true);
	},

	back: function(){
		// summary:
		//		Go back to previous page.
		return this.selectChild(this._adjacent(false), true);
	},

	_onKeyPress: function(e){
		topic.publish(this.id+"-containerKeyPress", { e: e, page: this});	// publish
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		var child = this.selectedChildWidget;
		if(child && child.resize){
			if(this.doLayout){
				child.resize(this._containerContentBox || this._contentBox);
			}else{
				child.resize();
			}
		}
	},

	_showChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Show the specified child by changing it's CSS, and call _onShow()/onShow() so
		//		it can do any updates it needs regarding loading href's etc.
		// returns:
		//		Promise that fires when page has finished showing, or true if there's no href
		var children = this.getChildren();
		page.isFirstChild = (page == children[0]);
		page.isLastChild = (page == children[children.length-1]);
		page._set("selected", true);

		domClass.replace(page.domNode, "dijitVisible", "dijitHidden");

		return (page._onShow && page._onShow()) || true;
	},

	_hideChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Hide the specified child by changing it's CSS, and call _onHide() so
		//		it's notified.
		page._set("selected", false);
		domClass.replace(page.domNode, "dijitHidden", "dijitVisible");

		page.onHide && page.onHide();
	},

	closeChild: function(/*dijit._Widget*/ page){
		// summary:
		//		Callback when user clicks the [X] to remove a page.
		//		If onClose() returns true then remove and destroy the child.
		// tags:
		//		private
		var remove = page.onClose(this, page);
		if(remove){
			this.removeChild(page);
			// makes sure we can clean up executeScripts in ContentPane onUnLoad
			page.destroyRecursive();
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		this._descendantsBeingDestroyed = true;
		this.selectedChildWidget = undefined;
		array.forEach(this.getChildren(), function(child){
			if(!preserveDom){
				this.removeChild(child);
			}
			child.destroyRecursive(preserveDom);
		}, this);
		this._descendantsBeingDestroyed = false;
	}
});

});

},
'dojo/regexp':function(){
define("dojo/regexp", ["./_base/kernel", "./_base/lang"], function(dojo, lang) {
	// module:
	//		dojo/regexp
	// summary:
	//		TODOC

lang.getObject("regexp", true, dojo);

/*=====
dojo.regexp = {
	// summary: Regular expressions and Builder resources
};
=====*/

dojo.regexp.escapeString = function(/*String*/str, /*String?*/except){
	//	summary:
	//		Adds escape sequences for special characters in regular expressions
	// except:
	//		a String with special characters to be left unescaped

	return str.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, function(ch){
		if(except && except.indexOf(ch) != -1){
			return ch;
		}
		return "\\" + ch;
	}); // String
};

dojo.regexp.buildGroupRE = function(/*Object|Array*/arr, /*Function*/re, /*Boolean?*/nonCapture){
	//	summary:
	//		Builds a regular expression that groups subexpressions
	//	description:
	//		A utility function used by some of the RE generators. The
	//		subexpressions are constructed by the function, re, in the second
	//		parameter.  re builds one subexpression for each elem in the array
	//		a, in the first parameter. Returns a string for a regular
	//		expression that groups all the subexpressions.
	// arr:
	//		A single value or an array of values.
	// re:
	//		A function. Takes one parameter and converts it to a regular
	//		expression.
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression. Defaults to false

	// case 1: a is a single value.
	if(!(arr instanceof Array)){
		return re(arr); // String
	}

	// case 2: a is an array
	var b = [];
	for(var i = 0; i < arr.length; i++){
		// convert each elem to a RE
		b.push(re(arr[i]));
	}

	 // join the REs as alternatives in a RE group.
	return dojo.regexp.group(b.join("|"), nonCapture); // String
};

dojo.regexp.group = function(/*String*/expression, /*Boolean?*/nonCapture){
	// summary:
	//		adds group match to expression
	// nonCapture:
	//		If true, uses non-capturing match, otherwise matches are retained
	//		by regular expression.
	return "(" + (nonCapture ? "?:":"") + expression + ")"; // String
};

return dojo.regexp;
});

},
'dijit/form/ComboBox':function(){
define("dijit/form/ComboBox", [
	"dojo/_base/declare", // declare
	"./ValidationTextBox",
	"./ComboBoxMixin"
], function(declare, ValidationTextBox, ComboBoxMixin){

/*=====
	var ValidationTextBox = dijit.form.ValidationTextBox;
	var ComboBoxMixin = dijit.form.ComboBoxMixin;
=====*/

	// module:
	//		dijit/form/ComboBox
	// summary:
	//		Auto-completing text box

	return declare("dijit.form.ComboBox", [ValidationTextBox, ComboBoxMixin], {
		// summary:
		//		Auto-completing text box
		//
		// description:
		//		The drop down box's values are populated from an class called
		//		a data provider, which returns a list of values based on the characters
		//		that the user has typed into the input box.
		//		If OPTION tags are used as the data provider via markup,
		//		then the OPTION tag's child text node is used as the widget value
		//		when selected.  The OPTION tag's value attribute is ignored.
		//		To set the default value when using OPTION tags, specify the selected
		//		attribute on 1 of the child OPTION tags.
		//
		//		Some of the options to the ComboBox are actually arguments to the data
		//		provider.
	});
});

},
'dijit/form/_FormMixin':function(){
define("dijit/form/_FormMixin", [
	"dojo/_base/array", // array.every array.filter array.forEach array.indexOf array.map
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch lang.isArray
	"dojo/window" // winUtils.scrollIntoView
], function(array, declare, kernel, lang, winUtils){

	// module:
	//		dijit/form/_FormMixin
	// summary:
	//		Mixin for containers of form widgets (i.e. widgets that represent a single value
	//		and can be children of a <form> node or dijit.form.Form widget)

	return declare("dijit.form._FormMixin", null, {
		// summary:
		//		Mixin for containers of form widgets (i.e. widgets that represent a single value
		//		and can be children of a <form> node or dijit.form.Form widget)
		// description:
		//		Can extract all the form widgets
		//		values and combine them into a single javascript object, or alternately
		//		take such an object and set the values for all the contained
		//		form widgets

	/*=====
		// value: Object
		//		Name/value hash for each child widget with a name and value.
		//		Child widgets without names are not part of the hash.
		//
		//		If there are multiple child widgets w/the same name, value is an array,
		//		unless they are radio buttons in which case value is a scalar (since only
		//		one radio button can be checked at a time).
		//
		//		If a child widget's name is a dot separated list (like a.b.c.d), it's a nested structure.
		//
		//		Example:
		//	|	{ name: "John Smith", interests: ["sports", "movies"] }
	=====*/

		// state: [readonly] String
		//		Will be "Error" if one or more of the child widgets has an invalid value,
		//		"Incomplete" if not all of the required child widgets are filled in.  Otherwise, "",
		//		which indicates that the form is ready to be submitted.
		state: "",

		//	TODO:
		//	* Repeater
		//	* better handling for arrays.  Often form elements have names with [] like
		//	* people[3].sex (for a list of people [{name: Bill, sex: M}, ...])
		//
		//

		_getDescendantFormWidgets: function(/*dijit._WidgetBase[]?*/ children){
			// summary:
			//		Returns all form widget descendants, searching through non-form child widgets like BorderContainer
			var res = [];
			array.forEach(children || this.getChildren(), function(child){
				if("value" in child){
					res.push(child);
				}else{
					res = res.concat(this._getDescendantFormWidgets(child.getChildren()));
				}
			}, this);
			return res;
		},

		reset: function(){
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(widget.reset){
					widget.reset();
				}
			});
		},

		validate: function(){
			// summary:
			//		returns if the form is valid - same as isValid - but
			//		provides a few additional (ui-specific) features.
			//		1 - it will highlight any sub-widgets that are not
			//			valid
			//		2 - it will call focus() on the first invalid
			//			sub-widget
			var didFocus = false;
			return array.every(array.map(this._getDescendantFormWidgets(), function(widget){
				// Need to set this so that "required" widgets get their
				// state set.
				widget._hasBeenBlurred = true;
				var valid = widget.disabled || !widget.validate || widget.validate();
				if(!valid && !didFocus){
					// Set focus of the first non-valid widget
					winUtils.scrollIntoView(widget.containerNode || widget.domNode);
					widget.focus();
					didFocus = true;
				}
	 			return valid;
	 		}), function(item){ return item; });
		},

		setValues: function(val){
			kernel.deprecated(this.declaredClass+"::setValues() is deprecated. Use set('value', val) instead.", "", "2.0");
			return this.set('value', val);
		},
		_setValueAttr: function(/*Object*/ obj){
			// summary:
			//		Fill in form values from according to an Object (in the format returned by get('value'))

			// generate map from name --> [list of widgets with that name]
			var map = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				if(!widget.name){ return; }
				var entry = map[widget.name] || (map[widget.name] = [] );
				entry.push(widget);
			});

			for(var name in map){
				if(!map.hasOwnProperty(name)){
					continue;
				}
				var widgets = map[name],						// array of widgets w/this name
					values = lang.getObject(name, false, obj);	// list of values for those widgets

				if(values === undefined){
					continue;
				}
				if(!lang.isArray(values)){
					values = [ values ];
				}
				if(typeof widgets[0].checked == 'boolean'){
					// for checkbox/radio, values is a list of which widgets should be checked
					array.forEach(widgets, function(w){
						w.set('value', array.indexOf(values, w.value) != -1);
					});
				}else if(widgets[0].multiple){
					// it takes an array (e.g. multi-select)
					widgets[0].set('value', values);
				}else{
					// otherwise, values is a list of values to be assigned sequentially to each widget
					array.forEach(widgets, function(w, i){
						w.set('value', values[i]);
					});
				}
			}

			/***
			 * 	TODO: code for plain input boxes (this shouldn't run for inputs that are part of widgets)

			array.forEach(this.containerNode.elements, function(element){
				if(element.name == ''){return};	// like "continue"
				var namePath = element.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var p=namePath[j - 1];
					// repeater support block
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if

						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
						myObj=myObj[nameA[0]][nameIndex];
						continue;
					} // repeater support ends

					if(typeof(myObj[p]) == "undefined"){
						myObj=undefined;
						break;
					};
					myObj=myObj[p];
				}

				if(typeof(myObj) == "undefined"){
					return;		// like "continue"
				}
				if(typeof(myObj[name]) == "undefined" && this.ignoreNullValues){
					return;		// like "continue"
				}

				// TODO: widget values (just call set('value', ...) on the widget)

				// TODO: maybe should call dojo.getNodeProp() instead
				switch(element.type){
					case "checkbox":
						element.checked = (name in myObj) &&
							array.some(myObj[name], function(val){ return val == element.value; });
						break;
					case "radio":
						element.checked = (name in myObj) && myObj[name] == element.value;
						break;
					case "select-multiple":
						element.selectedIndex=-1;
						array.forEach(element.options, function(option){
							option.selected = array.some(myObj[name], function(val){ return option.value == val; });
						});
						break;
					case "select-one":
						element.selectedIndex="0";
						array.forEach(element.options, function(option){
							option.selected = option.value == myObj[name];
						});
						break;
					case "hidden":
					case "text":
					case "textarea":
					case "password":
						element.value = myObj[name] || "";
						break;
				}
	  		});
	  		*/

			// Note: no need to call this._set("value", ...) as the child updates will trigger onChange events
			// which I am monitoring.
		},

		getValues: function(){
			kernel.deprecated(this.declaredClass+"::getValues() is deprecated. Use get('value') instead.", "", "2.0");
			return this.get('value');
		},
		_getValueAttr: function(){
			// summary:
			// 		Returns Object representing form values.   See description of `value` for details.
			// description:

			// The value is updated into this.value every time a child has an onChange event,
			// so in the common case this function could just return this.value.   However,
			// that wouldn't work when:
			//
			// 1. User presses return key to submit a form.  That doesn't fire an onchange event,
			// and even if it did it would come too late due to the setTimeout(..., 0) in _handleOnChange()
			//
			// 2. app for some reason calls this.get("value") while the user is typing into a
			// form field.   Not sure if that case needs to be supported or not.

			// get widget values
			var obj = { };
			array.forEach(this._getDescendantFormWidgets(), function(widget){
				var name = widget.name;
				if(!name || widget.disabled){ return; }

				// Single value widget (checkbox, radio, or plain <input> type widget)
				var value = widget.get('value');

				// Store widget's value(s) as a scalar, except for checkboxes which are automatically arrays
				if(typeof widget.checked == 'boolean'){
					if(/Radio/.test(widget.declaredClass)){
						// radio button
						if(value !== false){
							lang.setObject(name, value, obj);
						}else{
							// give radio widgets a default of null
							value = lang.getObject(name, false, obj);
							if(value === undefined){
								lang.setObject(name, null, obj);
							}
						}
					}else{
						// checkbox/toggle button
						var ary=lang.getObject(name, false, obj);
						if(!ary){
							ary=[];
							lang.setObject(name, ary, obj);
						}
						if(value !== false){
							ary.push(value);
						}
					}
				}else{
					var prev=lang.getObject(name, false, obj);
					if(typeof prev != "undefined"){
						if(lang.isArray(prev)){
							prev.push(value);
						}else{
							lang.setObject(name, [prev, value], obj);
						}
					}else{
						// unique name
						lang.setObject(name, value, obj);
					}
				}
			});

			/***
			 * code for plain input boxes (see also domForm.formToObject, can we use that instead of this code?
			 * but it doesn't understand [] notation, presumably)
			var obj = { };
			array.forEach(this.containerNode.elements, function(elm){
				if(!elm.name)	{
					return;		// like "continue"
				}
				var namePath = elm.name.split(".");
				var myObj=obj;
				var name=namePath[namePath.length-1];
				for(var j=1,len2=namePath.length;j<len2;++j){
					var nameIndex = null;
					var p=namePath[j - 1];
					var nameA=p.split("[");
					if(nameA.length > 1){
						if(typeof(myObj[nameA[0]]) == "undefined"){
							myObj[nameA[0]]=[ ];
						} // if
						nameIndex=parseInt(nameA[1]);
						if(typeof(myObj[nameA[0]][nameIndex]) == "undefined"){
							myObj[nameA[0]][nameIndex] = { };
						}
					}else if(typeof(myObj[nameA[0]]) == "undefined"){
						myObj[nameA[0]] = { }
					} // if

					if(nameA.length == 1){
						myObj=myObj[nameA[0]];
					}else{
						myObj=myObj[nameA[0]][nameIndex];
					} // if
				} // for

				if((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)){
					if(name == name.split("[")[0]){
						myObj[name]=elm.value;
					}else{
						// can not set value when there is no name
					}
				}else if(elm.type == "checkbox" && elm.checked){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					myObj[name].push(elm.value);
				}else if(elm.type == "select-multiple"){
					if(typeof(myObj[name]) == 'undefined'){
						myObj[name]=[ ];
					}
					for(var jdx=0,len3=elm.options.length; jdx<len3; ++jdx){
						if(elm.options[jdx].selected){
							myObj[name].push(elm.options[jdx].value);
						}
					}
				} // if
				name=undefined;
			}); // forEach
			***/
			return obj;
		},

	 	isValid: function(){
	 		// summary:
	 		//		Returns true if all of the widgets are valid.
			//		Deprecated, will be removed in 2.0.  Use get("state") instead.

			return this.state == "";
		},

		onValidStateChange: function(/*Boolean*/ /*===== isValid =====*/){
			// summary:
			//		Stub function to connect to if you want to do something
			//		(like disable/enable a submit button) when the valid
			//		state changes on the form as a whole.
			//
			//		Deprecated.  Will be removed in 2.0.  Use watch("state", ...) instead.
		},

		_getState: function(){
			// summary:
			//		Compute what this.state should be based on state of children
			var states = array.map(this._descendants, function(w){
				return w.get("state") || "";
			});

			return array.indexOf(states, "Error") >= 0 ? "Error" :
				array.indexOf(states, "Incomplete") >= 0 ? "Incomplete" : "";
		},

		disconnectChildren: function(){
			// summary:
			//		Remove connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			array.forEach(this._childConnections || [], lang.hitch(this, "disconnect"));
			array.forEach(this._childWatches || [], function(w){ w.unwatch(); });
		},

		connectChildren: function(/*Boolean*/ inStartup){
			// summary:
			//		Setup connections to monitor changes to children's value, error state, and disabled state,
			//		in order to update Form.value and Form.state.
			//
			//		You can call this function directly, ex. in the event that you
			//		programmatically add a widget to the form *after* the form has been
			//		initialized.

			var _this = this;

			// Remove old connections, if any
			this.disconnectChildren();

			this._descendants = this._getDescendantFormWidgets();

			// (Re)set this.value and this.state.   Send watch() notifications but not on startup.
			var set = inStartup ? function(name, val){ _this[name] = val; } : lang.hitch(this, "_set");
			set("value", this.get("value"));
			set("state", this._getState());

			// Monitor changes to error state and disabled state in order to update
			// Form.state
			var conns = (this._childConnections = []),
				watches = (this._childWatches = []);
			array.forEach(array.filter(this._descendants,
				function(item){ return item.validate; }
			),
			function(widget){
				// We are interested in whenever the widget changes validity state - or
				// whenever the disabled attribute on that widget is changed.
				array.forEach(["state", "disabled"], function(attr){
					watches.push(widget.watch(attr, function(){
						_this.set("state", _this._getState());
					}));
				});
			});

			// And monitor calls to child.onChange so we can update this.value
			var onChange = function(){
				// summary:
				//		Called when child's value or disabled state changes

				// Use setTimeout() to collapse value changes in multiple children into a single
				// update to my value.   Multiple updates will occur on:
				//	1. Form.set()
				//	2. Form.reset()
				//	3. user selecting a radio button (which will de-select another radio button,
				//		 causing two onChange events)
				if(_this._onChangeDelayTimer){
					clearTimeout(_this._onChangeDelayTimer);
				}
				_this._onChangeDelayTimer = setTimeout(function(){
					delete _this._onChangeDelayTimer;
					_this._set("value", _this.get("value"));
				}, 10);
			};
			array.forEach(
				array.filter(this._descendants, function(item){ return item.onChange; } ),
				function(widget){
					// When a child widget's value changes,
					// the efficient thing to do is to just update that one attribute in this.value,
					// but that gets a little complicated when a checkbox is checked/unchecked
					// since this.value["checkboxName"] contains an array of all the checkboxes w/the same name.
					// Doing simple thing for now.
					conns.push(_this.connect(widget, "onChange", onChange));

					// Disabling/enabling a child widget should remove it's value from this.value.
					// Again, this code could be more efficient, doing simple thing for now.
					watches.push(widget.watch("disabled", onChange));
				}
			);
		},

		startup: function(){
			this.inherited(arguments);

			// Initialize value and valid/invalid state tracking.  Needs to be done in startup()
			// so that children are initialized.
			this.connectChildren(true);

			// Make state change call onValidStateChange(), will be removed in 2.0
			this.watch("state", function(attr, oldVal, newVal){ this.onValidStateChange(newVal == ""); });
		},

		destroy: function(){
			this.disconnectChildren();
			this.inherited(arguments);
		}

	});
});

},
'dijit/DropDownMenu':function(){
require({cache:{
'url:dijit/templates/Menu.html':"<table class=\"dijit dijitMenu dijitMenuPassive dijitReset dijitMenuTable\" role=\"menu\" tabIndex=\"${tabIndex}\" data-dojo-attach-event=\"onkeypress:_onKeyPress\" cellspacing=\"0\">\n\t<tbody class=\"dijitReset\" data-dojo-attach-point=\"containerNode\"></tbody>\n</table>\n"}});
define("dijit/DropDownMenu", [
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/keys", // keys
	"dojo/text!./templates/Menu.html",
	"./_OnDijitClickMixin",
	"./_MenuBase"
], function(declare, event, keys, template, _OnDijitClickMixin, _MenuBase){

/*=====
	var _MenuBase = dijit._MenuBase;
	var _OnDijitClickMixin = dijit._OnDijitClickMixin;
=====*/

	// module:
	//		dijit/DropDownMenu
	// summary:
	//		dijit.DropDownMenu widget

	return declare("dijit.DropDownMenu", [_MenuBase, _OnDijitClickMixin], {
		// summary:
		//		A menu, without features for context menu (Meaning, drop down menu)

		templateString: template,

		baseClass: "dijitMenu",

		postCreate: function(){
			var l = this.isLeftToRight();
			this._openSubMenuKey = l ? keys.RIGHT_ARROW : keys.LEFT_ARROW;
			this._closeSubMenuKey = l ? keys.LEFT_ARROW : keys.RIGHT_ARROW;
			this.connectKeyNavHandlers([keys.UP_ARROW], [keys.DOWN_ARROW]);
		},

		_onKeyPress: function(/*Event*/ evt){
			// summary:
			//		Handle keyboard based menu navigation.
			// tags:
			//		protected

			if(evt.ctrlKey || evt.altKey){ return; }

			switch(evt.charOrCode){
				case this._openSubMenuKey:
					this._moveToPopup(evt);
					event.stop(evt);
					break;
				case this._closeSubMenuKey:
					if(this.parentMenu){
						if(this.parentMenu._isMenuBar){
							this.parentMenu.focusPrev();
						}else{
							this.onCancel(false);
						}
					}else{
						event.stop(evt);
					}
					break;
			}
		}
	});
});

},
'ibm/tivoli/simplesrm/srm/dijit/Breadcrumb':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dijit/_Templated,dijit/_Contained"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Breadcrumb");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Morsel");

dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit._Contained");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Breadcrumb", 
	[dijit._Widget, dijit._Templated, dijit._Container], 
{	
	 
	templateString : "<table style='width:100%'><tbody><tr><td><ul class='bc_list' dojoAttachPoint='containerNode'></ul></td><td align='right' style='vertical-align:top'><img id = '${id}_treeview_nav' src='' alt='m' class='treeview_nav' /></td></tr></tbody></table>",
	
	constructor: function() 
	{
		console.log("Breadcrumb.ctor");
		this.length = 0;
	},
	pushMorsel: function(/*string*/ str, /*ojbect*/ data)
	{
		//Check the breadcrumb for the folder already existing by comparing classstructureid  with the child morsels
		if (data.ClassStructureID) {    //this ListTrees id  //D29365
		   var children = this.getChildren();   //child morsels
		   for(i = 0; i<children.length; i++) {
			   var child = children[i]; //child morsel
			   var lt = child.data;  // morsel's ListTree
			   if (lt && lt.ClassStructureID && lt.ClassStructureID==data.ClassStructureID)
				   return null;  //it's already there		   
		   }
		}
		
		var morsel = new ibm.tivoli.simplesrm.srm.dijit.Morsel({text: str, data: data}, document.createElement('span'));
		
		this.addChild(morsel, "last");
		if(this.getChildren().length == 1) {
			dojo.addClass(morsel.domNode, "first");
		}
		++this.length;
		return morsel;
	},
	popMorsel: function()
	{
		var morsels = this.getChildren();
		if(morsels.length === 0) {
			return;
		}
		var lastMorsel = morsels[morsels.length-1];
		this.removeChild(lastMorsel);
		lastMorsel.destroy();
		--this.length;
	},
	popToMorsel: function(/*Morsel*/morsel) 
	{
		var children = this.getChildren();
		var i,deadMorsel;
		if(typeof morsel == 'object') {
		for(i = children.length-1; i >= 0 ; --i) {
				if(children[i] === morsel){
					break;
				}
				deadMorsel = children[i];
				this.removeChild(deadMorsel);
				deadMorsel.destroy();
			}
		}
		else if(typeof morsel == 'number') {
			for(i = children.length-1; i > morsel; --i) {
				deadMorsel = children[i];
				this.removeChild(deadMorsel);
				deadMorsel.destroy();
			}				
		}
	},
	// events
	// default handler called when any of the morsel's are clicked
	onClick: function(morsel)
	{
		return true;
	},
	
	_dummy:null
});



dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Morsel", 
[dijit._Widget, dijit._Templated, dijit._Contained], 
{	
	templateStringIE : "<li class='breadcrumb_morsel' dojoAttachEvent='ondijitclick:_onclick,onmouseover:_onRollover,onmouseout:_onRollout'><span class='bc_marker'>&#187;</span><span class='breadcrumb_morsel'>${text}</span></li>",
	templateString : "<li class='breadcrumb_morsel' dojoAttachEvent='ondijitclick:_onclick,onmouseover:_onRollover,onmouseout:_onRollout'><span class='breadcrumb_morsel'>${text}</span></li>",
	preamble: function()
	{
	},
	constructor: function() 
	{
		this.text = '';
		this.data = null;
		console.log("morsel.ctor");
	},
	buildRendering: function()
	{
		console.log("morsel.buildRendering(%s)", this.text);
		if(dojo.isIE) {
			this.templateString = this.templateStringIE;
		}
		this.inherited(arguments);
		dojo.attr(this.domNode,"tabindex",0);
	},
	trimRight: function()
	{
		// remove all morsels to the right of me
		this.getParent().popToMorsel(this);
	},
	
	_onRollover: function(evt)
	{
		dojo.addClass(evt.target, 'highlight');
		dojo.style(evt.target, 'cursor', 'pointer');
	},
	_onRollout: function(evt)
	{
		dojo.removeClass(evt.target, 'highlight');
		dojo.style(evt.target, 'cursor', 'default');
	},
	// when user clicks on a morsel
	_onclick: function(evt)
	{
		if(this._isHomeMorsel()) {
			this._onclickhome();
		}
		else if(this.onClick(this)) {
			this.getParent().onClick(this);
		}
	},
	// when user clicks on the "home" morsel
	_onclickhome: function () {
		this.getParent().onClickHome(this);
	},
	onClick: function(morsel) {
		return true;
	},

	
	// ***** helpers ****
	_isHomeMorsel: function() {
		return (this === this.getParent().homeMorsel);
	}
	
});
});

},
'dojo/data/util/simpleFetch':function(){
define("dojo/data/util/simpleFetch", ["dojo/_base/lang", "dojo/_base/window", "./sorter"], 
  function(lang, winUtil, sorter) {
	// module:
	//		dojo/data/util/simpleFetch
	// summary:
	//		TODOC

var simpleFetch = lang.getObject("dojo.data.util.simpleFetch", true);

simpleFetch.fetch = function(/* Object? */ request){
	//	summary:
	//		The simpleFetch mixin is designed to serve as a set of function(s) that can
	//		be mixed into other datastore implementations to accelerate their development.
	//		The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	//		call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	//		is not designed to work for datastores that respond to a fetch() call by incrementally
	//		loading items, or sequentially loading partial batches of the result
	//		set.  For datastores that mixin simpleFetch, simpleFetch
	//		implements a fetch method that automatically handles eight of the fetch()
	//		arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	//		The class mixing in simpleFetch should not implement fetch(),
	//		but should instead implement a _fetchItems() method.  The _fetchItems()
	//		method takes three arguments, the keywordArgs object that was passed
	//		to fetch(), a callback function to be called when the result array is
	//		available, and an error callback to be called if something goes wrong.
	//		The _fetchItems() method should ignore any keywordArgs parameters for
	//		start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	//		The _fetchItems() method needs to correctly handle any other keywordArgs
	//		parameters, including the query parameter and any optional parameters
	//		(such as includeChildren).  The _fetchItems() method should create an array of
	//		result items and pass it to the fetchHandler along with the original request object
	//		-- or, the _fetchItems() method may, if it wants to, create an new request object
	//		with other specifics about the request that are specific to the datastore and pass
	//		that as the request object to the handler.
	//
	//		For more information on this specific function, see dojo.data.api.Read.fetch()
	request = request || {};
	if(!request.store){
		request.store = this;
	}
	var self = this;

	var _errorHandler = function(errorData, requestObject){
		if(requestObject.onError){
			var scope = requestObject.scope || winUtil.global;
			requestObject.onError.call(scope, errorData, requestObject);
		}
	};

	var _fetchHandler = function(items, requestObject){
		var oldAbortFunction = requestObject.abort || null;
		var aborted = false;

		var startIndex = requestObject.start?requestObject.start:0;
		var endIndex = (requestObject.count && (requestObject.count !== Infinity))?(startIndex + requestObject.count):items.length;

		requestObject.abort = function(){
			aborted = true;
			if(oldAbortFunction){
				oldAbortFunction.call(requestObject);
			}
		};

		var scope = requestObject.scope || winUtil.global;
		if(!requestObject.store){
			requestObject.store = self;
		}
		if(requestObject.onBegin){
			requestObject.onBegin.call(scope, items.length, requestObject);
		}
		if(requestObject.sort){
			items.sort(sorter.createSortFunction(requestObject.sort, self));
		}
		if(requestObject.onItem){
			for(var i = startIndex; (i < items.length) && (i < endIndex); ++i){
				var item = items[i];
				if(!aborted){
					requestObject.onItem.call(scope, item, requestObject);
				}
			}
		}
		if(requestObject.onComplete && !aborted){
			var subset = null;
			if(!requestObject.onItem){
				subset = items.slice(startIndex, endIndex);
			}
			requestObject.onComplete.call(scope, subset, requestObject);
		}
	};
	this._fetchItems(request, _fetchHandler, _errorHandler);
	return request;	// Object
};

return simpleFetch;
});

},
'dijit/Menu':function(){
define("dijit/Menu", [
	"require",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/dom", // dom.byId dom.isDescendant
	"dojo/dom-attr", // domAttr.get domAttr.set domAttr.has domAttr.remove
	"dojo/dom-geometry", // domStyle.getComputedStyle domGeometry.position
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/kernel",
	"dojo/keys",	// keys.F10
	"dojo/_base/lang", // lang.hitch
	"dojo/on",
	"dojo/_base/sniff", // has("ie"), has("quirks")
	"dojo/_base/window", // win.body win.doc.documentElement win.doc.frames win.withGlobal
	"dojo/window", // winUtils.get
	"./popup",
	"./DropDownMenu",
	"dojo/ready"
], function(require, array, declare, event, dom, domAttr, domGeometry, domStyle, kernel, keys, lang, on,
			has, win, winUtils, pm, DropDownMenu, ready){

/*=====
	var DropDownMenu = dijit.DropDownMenu;
=====*/

// module:
//		dijit/Menu
// summary:
//		Includes dijit.Menu widget and base class dijit._MenuBase

// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/MenuItem", "dijit/PopupMenuItem", "dijit/CheckedMenuItem", "dijit/MenuSeparator"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

return declare("dijit.Menu", DropDownMenu, {
	// summary:
	//		A context menu you can assign to multiple elements

	constructor: function(){
		this._bindings = [];
	},

	// targetNodeIds: [const] String[]
	//		Array of dom node ids of nodes to attach to.
	//		Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.
	targetNodeIds: [],

	// contextMenuForWindow: [const] Boolean
	//		If true, right clicking anywhere on the window will cause this context menu to open.
	//		If false, must specify targetNodeIds.
	contextMenuForWindow: false,

	// leftClickToOpen: [const] Boolean
	//		If true, menu will open on left click instead of right click, similar to a file menu.
	leftClickToOpen: false,

	// refocus: Boolean
	// 		When this menu closes, re-focus the element which had focus before it was opened.
	refocus: true,

	postCreate: function(){
		if(this.contextMenuForWindow){
			this.bindDomNode(win.body());
		}else{
			// TODO: should have _setTargetNodeIds() method to handle initialization and a possible
			// later set('targetNodeIds', ...) call.  There's also a problem that targetNodeIds[]
			// gets stale after calls to bindDomNode()/unBindDomNode() as it still is just the original list (see #9610)
			array.forEach(this.targetNodeIds, this.bindDomNode, this);
		}
		this.inherited(arguments);
	},

	// thanks burstlib!
	_iframeContentWindow: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns the window reference of the passed iframe
		// tags:
		//		private
		return winUtils.get(this._iframeContentDocument(iframe_el)) ||
			// Moz. TODO: is this available when defaultView isn't?
			this._iframeContentDocument(iframe_el)['__parent__'] ||
			(iframe_el.name && win.doc.frames[iframe_el.name]) || null;	//	Window
	},

	_iframeContentDocument: function(/* HTMLIFrameElement */iframe_el){
		// summary:
		//		Returns a reference to the document object inside iframe_el
		// tags:
		//		protected
		return iframe_el.contentDocument // W3
			|| (iframe_el.contentWindow && iframe_el.contentWindow.document) // IE
			|| (iframe_el.name && win.doc.frames[iframe_el.name] && win.doc.frames[iframe_el.name].document)
			|| null;	//	HTMLDocument
	},

	bindDomNode: function(/*String|DomNode*/ node){
		// summary:
		//		Attach menu to given node
		node = dom.byId(node);

		var cn;	// Connect node

		// Support context menus on iframes.  Rather than binding to the iframe itself we need
		// to bind to the <body> node inside the iframe.
		if(node.tagName.toLowerCase() == "iframe"){
			var iframe = node,
				window = this._iframeContentWindow(iframe);
			cn = win.withGlobal(window, win.body);
		}else{

			// To capture these events at the top level, attach to <html>, not <body>.
			// Otherwise right-click context menu just doesn't work.
			cn = (node == win.body() ? win.doc.documentElement : node);
		}


		// "binding" is the object to track our connection to the node (ie, the parameter to bindDomNode())
		var binding = {
			node: node,
			iframe: iframe
		};

		// Save info about binding in _bindings[], and make node itself record index(+1) into
		// _bindings[] array.  Prefix w/_dijitMenu to avoid setting an attribute that may
		// start with a number, which fails on FF/safari.
		domAttr.set(node, "_dijitMenu" + this.id, this._bindings.push(binding));

		// Setup the connections to monitor click etc., unless we are connecting to an iframe which hasn't finished
		// loading yet, in which case we need to wait for the onload event first, and then connect
		// On linux Shift-F10 produces the oncontextmenu event, but on Windows it doesn't, so
		// we need to monitor keyboard events in addition to the oncontextmenu event.
		var doConnects = lang.hitch(this, function(cn){
			return [
				// TODO: when leftClickToOpen is true then shouldn't space/enter key trigger the menu,
				// rather than shift-F10?
				on(cn, this.leftClickToOpen ? "click" : "contextmenu", lang.hitch(this, function(evt){
					// Schedule context menu to be opened unless it's already been scheduled from onkeydown handler
					event.stop(evt);
					this._scheduleOpen(evt.target, iframe, {x: evt.pageX, y: evt.pageY});
				})),
				on(cn, "keydown", lang.hitch(this, function(evt){
					if(evt.shiftKey && evt.keyCode == keys.F10){
						event.stop(evt);
						this._scheduleOpen(evt.target, iframe);	// no coords - open near target node
					}
				}))
			];
		});
		binding.connects = cn ? doConnects(cn) : [];

		if(iframe){
			// Setup handler to [re]bind to the iframe when the contents are initially loaded,
			// and every time the contents change.
			// Need to do this b/c we are actually binding to the iframe's <body> node.
			// Note: can't use connect.connect(), see #9609.

			binding.onloadHandler = lang.hitch(this, function(){
				// want to remove old connections, but IE throws exceptions when trying to
				// access the <body> node because it's already gone, or at least in a state of limbo

				var window = this._iframeContentWindow(iframe);
					cn = win.withGlobal(window, win.body);
				binding.connects = doConnects(cn);
			});
			if(iframe.addEventListener){
				iframe.addEventListener("load", binding.onloadHandler, false);
			}else{
				iframe.attachEvent("onload", binding.onloadHandler);
			}
		}
	},

	unBindDomNode: function(/*String|DomNode*/ nodeName){
		// summary:
		//		Detach menu from given node

		var node;
		try{
			node = dom.byId(nodeName);
		}catch(e){
			// On IE the dom.byId() call will get an exception if the attach point was
			// the <body> node of an <iframe> that has since been reloaded (and thus the
			// <body> node is in a limbo state of destruction.
			return;
		}

		// node["_dijitMenu" + this.id] contains index(+1) into my _bindings[] array
		var attrName = "_dijitMenu" + this.id;
		if(node && domAttr.has(node, attrName)){
			var bid = domAttr.get(node, attrName)-1, b = this._bindings[bid], h;
			while(h = b.connects.pop()){
				h.remove();
			}

			// Remove listener for iframe onload events
			var iframe = b.iframe;
			if(iframe){
				if(iframe.removeEventListener){
					iframe.removeEventListener("load", b.onloadHandler, false);
				}else{
					iframe.detachEvent("onload", b.onloadHandler);
				}
			}

			domAttr.remove(node, attrName);
			delete this._bindings[bid];
		}
	},

	_scheduleOpen: function(/*DomNode?*/ target, /*DomNode?*/ iframe, /*Object?*/ coords){
		// summary:
		//		Set timer to display myself.  Using a timer rather than displaying immediately solves
		//		two problems:
		//
		//		1. IE: without the delay, focus work in "open" causes the system
		//		context menu to appear in spite of stopEvent.
		//
		//		2. Avoid double-shows on linux, where shift-F10 generates an oncontextmenu event
		//		even after a event.stop(e).  (Shift-F10 on windows doesn't generate the
		//		oncontextmenu event.)

		if(!this._openTimer){
			this._openTimer = setTimeout(lang.hitch(this, function(){
				delete this._openTimer;
				this._openMyself({
					target: target,
					iframe: iframe,
					coords: coords
				});
			}), 1);
		}
	},

	_openMyself: function(args){
		// summary:
		//		Internal function for opening myself when the user does a right-click or something similar.
		// args:
		//		This is an Object containing:
		//		* target:
		//			The node that is being clicked
		//		* iframe:
		//			If an <iframe> is being clicked, iframe points to that iframe
		//		* coords:
		//			Put menu at specified x/y position in viewport, or if iframe is
		//			specified, then relative to iframe.
		//
		//		_openMyself() formerly took the event object, and since various code references
		//		evt.target (after connecting to _openMyself()), using an Object for parameters
		//		(so that old code still works).

		var target = args.target,
			iframe = args.iframe,
			coords = args.coords;

		// Get coordinates to open menu, either at specified (mouse) position or (if triggered via keyboard)
		// then near the node the menu is assigned to.
		if(coords){
			if(iframe){
				// Specified coordinates are on <body> node of an <iframe>, convert to match main document
				var ifc = domGeometry.position(iframe, true),
					window = this._iframeContentWindow(iframe),
					scroll = win.withGlobal(window, "_docScroll", dojo);

				var cs = domStyle.getComputedStyle(iframe),
					tp = domStyle.toPixelValue,
					left = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingLeft)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderLeftWidth) : 0),
					top = (has("ie") && has("quirks") ? 0 : tp(iframe, cs.paddingTop)) + (has("ie") && has("quirks") ? tp(iframe, cs.borderTopWidth) : 0);

				coords.x += ifc.x + left - scroll.x;
				coords.y += ifc.y + top - scroll.y;
			}
		}else{
			coords = domGeometry.position(target, true);
			coords.x += 10;
			coords.y += 10;
		}

		var self=this;
		var prevFocusNode = this._focusManager.get("prevNode");
		var curFocusNode = this._focusManager.get("curNode");
		var savedFocusNode = !curFocusNode || (dom.isDescendant(curFocusNode, this.domNode)) ? prevFocusNode : curFocusNode;

		function closeAndRestoreFocus(){
			// user has clicked on a menu or popup
			if(self.refocus && savedFocusNode){
				savedFocusNode.focus();
			}
			pm.close(self);
		}
		pm.open({
			popup: this,
			x: coords.x,
			y: coords.y,
			onExecute: closeAndRestoreFocus,
			onCancel: closeAndRestoreFocus,
			orient: this.isLeftToRight() ? 'L' : 'R'
		});
		this.focus();

		this._onBlur = function(){
			this.inherited('_onBlur', arguments);
			// Usually the parent closes the child widget but if this is a context
			// menu then there is no parent
			pm.close(this);
			// don't try to restore focus; user has clicked another part of the screen
			// and set focus there
		};
	},

	uninitialize: function(){
 		array.forEach(this._bindings, function(b){ if(b){ this.unBindDomNode(b.node); } }, this);
 		this.inherited(arguments);
	}
});

});

},
'dojox/gfx/arc':function(){
define("dojox/gfx/arc", ["./_base", "dojo/_base/lang", "./matrix"], 
  function(g, lang, m){
/*===== 
	g = dojox.gfx;
	dojox.gfx.arc = {
		// summary:
		//		This module contains the core graphics Arc functions.
	};
  =====*/

	var twoPI = 2 * Math.PI, pi4 = Math.PI / 4, pi8 = Math.PI / 8,
		pi48 = pi4 + pi8, curvePI4 = unitArcAsBezier(pi8);

	function unitArcAsBezier(alpha){
		// summary: return a start point, 1st and 2nd control points, and an end point of
		//		a an arc, which is reflected on the x axis
		// alpha: Number
		//		angle in radians, the arc will be 2 * angle size
		var cosa  = Math.cos(alpha), sina  = Math.sin(alpha),
			p2 = {x: cosa + (4 / 3) * (1 - cosa), y: sina - (4 / 3) * cosa * (1 - cosa) / sina};
		return {	// Object
			s:  {x: cosa, y: -sina},
			c1: {x: p2.x, y: -p2.y},
			c2: p2,
			e:  {x: cosa, y: sina}
		};
	}

	var arc = g.arc = {
		unitArcAsBezier: unitArcAsBezier,
		/*===== 
			unitArcAsBezier: function(alpha) {
			// summary: return a start point, 1st and 2nd control points, and an end point of
			//		a an arc, which is reflected on the x axis
			// alpha: Number
			//		angle in radians, the arc will be 2 * angle size
			},
		=====*/
		curvePI4: curvePI4,
			// curvePI4: Object
			//		an object with properties of an arc around a unit circle from 0 to pi/4
		arcAsBezier: function(last, rx, ry, xRotg, large, sweep, x, y){
			// summary: calculates an arc as a series of Bezier curves
			//	given the last point and a standard set of SVG arc parameters,
			//	it returns an array of arrays of parameters to form a series of
			//	absolute Bezier curves.
			// last: Object
			//		a point-like object as a start of the arc
			// rx: Number
			//		a horizontal radius for the virtual ellipse
			// ry: Number
			//		a vertical radius for the virtual ellipse
			// xRotg: Number
			//		a rotation of an x axis of the virtual ellipse in degrees
			// large: Boolean
			//		which part of the ellipse will be used (the larger arc if true)
			// sweep: Boolean
			//		direction of the arc (CW if true)
			// x: Number
			//		the x coordinate of the end point of the arc
			// y: Number
			//		the y coordinate of the end point of the arc

			// calculate parameters
			large = Boolean(large);
			sweep = Boolean(sweep);
			var xRot = m._degToRad(xRotg),
				rx2 = rx * rx, ry2 = ry * ry,
				pa = m.multiplyPoint(
					m.rotate(-xRot),
					{x: (last.x - x) / 2, y: (last.y - y) / 2}
				),
				pax2 = pa.x * pa.x, pay2 = pa.y * pa.y,
				c1 = Math.sqrt((rx2 * ry2 - rx2 * pay2 - ry2 * pax2) / (rx2 * pay2 + ry2 * pax2));
			if(isNaN(c1)){ c1 = 0; }
			var	ca = {
					x:  c1 * rx * pa.y / ry,
					y: -c1 * ry * pa.x / rx
				};
			if(large == sweep){
				ca = {x: -ca.x, y: -ca.y};
			}
			// the center
			var c = m.multiplyPoint(
				[
					m.translate(
						(last.x + x) / 2,
						(last.y + y) / 2
					),
					m.rotate(xRot)
				],
				ca
			);
			// calculate the elliptic transformation
			var elliptic_transform = m.normalize([
				m.translate(c.x, c.y),
				m.rotate(xRot),
				m.scale(rx, ry)
			]);
			// start, end, and size of our arc
			var inversed = m.invert(elliptic_transform),
				sp = m.multiplyPoint(inversed, last),
				ep = m.multiplyPoint(inversed, x, y),
				startAngle = Math.atan2(sp.y, sp.x),
				endAngle   = Math.atan2(ep.y, ep.x),
				theta = startAngle - endAngle;	// size of our arc in radians
			if(sweep){ theta = -theta; }
			if(theta < 0){
				theta += twoPI;
			}else if(theta > twoPI){
				theta -= twoPI;
			}

			// draw curve chunks
			var alpha = pi8, curve = curvePI4, step  = sweep ? alpha : -alpha,
				result = [];
			for(var angle = theta; angle > 0; angle -= pi4){
				if(angle < pi48){
					alpha = angle / 2;
					curve = unitArcAsBezier(alpha);
					step  = sweep ? alpha : -alpha;
					angle = 0;	// stop the loop
				}
				var c2, e, M = m.normalize([elliptic_transform, m.rotate(startAngle + step)]);
				if(sweep){
					c1 = m.multiplyPoint(M, curve.c1);
					c2 = m.multiplyPoint(M, curve.c2);
					e  = m.multiplyPoint(M, curve.e );
				}else{
					c1 = m.multiplyPoint(M, curve.c2);
					c2 = m.multiplyPoint(M, curve.c1);
					e  = m.multiplyPoint(M, curve.s );
				}
				// draw the curve
				result.push([c1.x, c1.y, c2.x, c2.y, e.x, e.y]);
				startAngle += 2 * step;
			}
			return result;	// Array
		}
	};
	
	return arc;
});

},
'dijit/form/_CheckBoxMixin':function(){
define("dijit/form/_CheckBoxMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/event" // event.stop
], function(declare, domAttr, event){

	// module:
	//		dijit/form/_CheckBoxMixin
	// summary:
	// 		Mixin to provide widget functionality corresponding to an HTML checkbox

	return declare("dijit.form._CheckBoxMixin", null, {
		// summary:
		// 		Mixin to provide widget functionality corresponding to an HTML checkbox
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//

		// type: [private] String
		//		type attribute on <input> node.
		//		Overrides `dijit.form.Button.type`.  Users should not change this value.
		type: "checkbox",

		// value: String
		//		As an initialization parameter, equivalent to value field on normal checkbox
		//		(if checked, the value is passed as the value when form is submitted).
		value: "on",

		// readOnly: Boolean
		//		Should this widget respond to user input?
		//		In markup, this is specified as "readOnly".
		//		Similar to disabled except readOnly form values are submitted.
		readOnly: false,
		
		// aria-pressed for toggle buttons, and aria-checked for checkboxes
		_aria_attr: "aria-checked",

		_setReadOnlyAttr: function(/*Boolean*/ value){
			this._set("readOnly", value);
			domAttr.set(this.focusNode, 'readOnly', value);
			this.focusNode.setAttribute("aria-readonly", value);
		},

		// Override dijit.form.Button._setLabelAttr() since we don't even have a containerNode.
		// Normally users won't try to set label, except when CheckBox or RadioButton is the child of a dojox.layout.TabContainer
		_setLabelAttr: undefined,

		postMixInProperties: function(){
			if(this.value == ""){
				this.value = "on";
			}
			this.inherited(arguments);
		},

		reset: function(){
			this.inherited(arguments);
			// Handle unlikely event that the <input type=checkbox> value attribute has changed
			this._set("value", this.params.value || "on");
			domAttr.set(this.focusNode, 'value', this.value);
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Internal function to handle click actions - need to check
			//		readOnly, since button no longer does that check.
			if(this.readOnly){
				event.stop(e);
				return false;
			}
			return this.inherited(arguments);
		}
	});
});

},
'dijit/layout/ContentPane':function(){
define("dijit/layout/ContentPane", [
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.mixin lang.delegate lang.hitch lang.isFunction lang.isObject
	"../_Widget",
	"./_ContentPaneResizeMixin",
	"dojo/string", // string.substitute
	"dojo/html", // html._ContentSetter html._emptyNode
	"dojo/i18n!../nls/loading",
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.byId
	"dojo/dom-attr", // domAttr.attr
	"dojo/_base/window", // win.body win.doc.createDocumentFragment
	"dojo/_base/xhr", // xhr.get
	"dojo/i18n" // i18n.getLocalization
], function(kernel, lang, _Widget, _ContentPaneResizeMixin, string, html, nlsLoading,
	array, declare, Deferred, dom, domAttr, win, xhr, i18n){

/*=====
	var _Widget = dijit._Widget;
	var _ContentPaneResizeMixin = dijit.layout._ContentPaneResizeMixin;
=====*/

// module:
//		dijit/layout/ContentPane
// summary:
//		A widget containing an HTML fragment, specified inline
//		or by uri.  Fragment may include widgets.


return declare("dijit.layout.ContentPane", [_Widget, _ContentPaneResizeMixin], {
	// summary:
	//		A widget containing an HTML fragment, specified inline
	//		or by uri.  Fragment may include widgets.
	//
	// description:
	//		This widget embeds a document fragment in the page, specified
	//		either by uri, javascript generated markup or DOM reference.
	//		Any widgets within this content are instantiated and managed,
	//		but laid out according to the HTML structure.  Unlike IFRAME,
	//		ContentPane embeds a document fragment as would be found
	//		inside the BODY tag of a full HTML document.  It should not
	//		contain the HTML, HEAD, or BODY tags.
	//		For more advanced functionality with scripts and
	//		stylesheets, see dojox.layout.ContentPane.  This widget may be
	//		used stand alone or as a base class for other widgets.
	//		ContentPane is useful as a child of other layout containers
	//		such as BorderContainer or TabContainer, but note that those
	//		widgets can contain any widget as a child.
	//
	// example:
	//		Some quick samples:
	//		To change the innerHTML: cp.set('content', '<b>new content</b>')
	//
	//		Or you can send it a NodeList: cp.set('content', dojo.query('div [class=selected]', userSelection))
	//
	//		To do an ajax update: cp.set('href', url)

	// href: String
	//		The href of the content that displays now.
	//		Set this at construction if you want to load data externally when the
	//		pane is shown.  (Set preload=true to load it immediately.)
	//		Changing href after creation doesn't have any effect; Use set('href', ...);
	href: "",

	// content: String || DomNode || NodeList || dijit._Widget
	//		The innerHTML of the ContentPane.
	//		Note that the initialization parameter / argument to set("content", ...)
	//		can be a String, DomNode, Nodelist, or _Widget.
	content: "",

	// extractContent: Boolean
	//		Extract visible content from inside of <body> .... </body>.
	//		I.e., strip <html> and <head> (and it's contents) from the href
	extractContent: false,

	// parseOnLoad: Boolean
	//		Parse content and create the widgets, if any.
	parseOnLoad: true,

	// parserScope: String
	//		Flag passed to parser.  Root for attribute names to search for.   If scopeName is dojo,
	//		will search for data-dojo-type (or dojoType).  For backwards compatibility
	//		reasons defaults to dojo._scopeName (which is "dojo" except when
	//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
	parserScope: kernel._scopeName,

	// preventCache: Boolean
	//		Prevent caching of data from href's by appending a timestamp to the href.
	preventCache: false,

	// preload: Boolean
	//		Force load of data on initialization even if pane is hidden.
	preload: false,

	// refreshOnShow: Boolean
	//		Refresh (re-download) content when pane goes from hidden to shown
	refreshOnShow: false,

	// loadingMessage: String
	//		Message that shows while downloading
	loadingMessage: "<span class='dijitContentPaneLoading'><span class='dijitInline dijitIconLoading'></span>${loadingState}</span>",

	// errorMessage: String
	//		Message that shows if an error occurs
	errorMessage: "<span class='dijitContentPaneError'><span class='dijitInline dijitIconError'></span>${errorState}</span>",

	// isLoaded: [readonly] Boolean
	//		True if the ContentPane has data in it, either specified
	//		during initialization (via href or inline content), or set
	//		via set('content', ...) / set('href', ...)
	//
	//		False if it doesn't have any content, or if ContentPane is
	//		still in the process of downloading href.
	isLoaded: false,

	baseClass: "dijitContentPane",

	/*======
	// ioMethod: dojo.xhrGet|dojo.xhrPost
	//		Function that should grab the content specified via href.
	ioMethod: dojo.xhrGet,
	======*/

	// ioArgs: Object
	//		Parameters to pass to xhrGet() request, for example:
	// |	<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="href: './bar', ioArgs: {timeout: 500}">
	ioArgs: {},

	// onLoadDeferred: [readonly] dojo.Deferred
	//		This is the `dojo.Deferred` returned by set('href', ...) and refresh().
	//		Calling onLoadDeferred.addCallback() or addErrback() registers your
	//		callback to be called only once, when the prior set('href', ...) call or
	//		the initial href parameter to the constructor finishes loading.
	//
	//		This is different than an onLoad() handler which gets called any time any href
	//		or content is loaded.
	onLoadDeferred: null,

	// Cancel _WidgetBase's _setTitleAttr because we don't want the title attribute (used to specify
	// tab labels) to be copied to ContentPane.domNode... otherwise a tooltip shows up over the
	// entire pane.
	_setTitleAttr: null,

	// Flag to parser that I'll parse my contents, so it shouldn't.
	stopParser: true,

	// template: [private] Boolean
	//		Flag from the parser that this ContentPane is inside a template
	//		so the contents are pre-parsed.
	// (TODO: this declaration can be commented out in 2.0)
	template: false,

	create: function(params, srcNodeRef){
		// Convert a srcNodeRef argument into a content parameter, so that the original contents are
		// processed in the same way as contents set via set("content", ...), calling the parser etc.
		// Avoid modifying original params object since that breaks NodeList instantiation, see #11906.
		if((!params || !params.template) && srcNodeRef && !("href" in params) && !("content" in params)){
			var df = win.doc.createDocumentFragment();
			srcNodeRef = dom.byId(srcNodeRef);
			while(srcNodeRef.firstChild){
				df.appendChild(srcNodeRef.firstChild);
			}
			params = lang.delegate(params, {content: df});
		}
		this.inherited(arguments, [params, srcNodeRef]);
	},

	postMixInProperties: function(){
		this.inherited(arguments);
		var messages = i18n.getLocalization("dijit", "loading", this.lang);
		this.loadingMessage = string.substitute(this.loadingMessage, messages);
		this.errorMessage = string.substitute(this.errorMessage, messages);
	},

	buildRendering: function(){
		this.inherited(arguments);

		// Since we have no template we need to set this.containerNode ourselves, to make getChildren() work.
		// For subclasses of ContentPane that do have a template, does nothing.
		if(!this.containerNode){
			this.containerNode = this.domNode;
		}

		// remove the title attribute so it doesn't show up when hovering
		// over a node  (TODO: remove in 2.0, no longer needed after #11490)
		this.domNode.title = "";

		if(!domAttr.get(this.domNode,"role")){
			this.domNode.setAttribute("role", "group");
		}
	},

	startup: function(){
		// summary:
		//		Call startup() on all children including non _Widget ones like dojo.dnd.Source objects

		// This starts all the widgets
		this.inherited(arguments);

		// And this catches stuff like dojo.dnd.Source
		if(this._contentSetter){
			array.forEach(this._contentSetter.parseResults, function(obj){
				if(!obj._started && !obj._destroyed && lang.isFunction(obj.startup)){
					obj.startup();
					obj._started = true;
				}
			}, this);
		}
	},

	setHref: function(/*String|Uri*/ href){
		// summary:
		//		Deprecated.   Use set('href', ...) instead.
		kernel.deprecated("dijit.layout.ContentPane.setHref() is deprecated. Use set('href', ...) instead.", "", "2.0");
		return this.set("href", href);
	},
	_setHrefAttr: function(/*String|Uri*/ href){
		// summary:
		//		Hook so set("href", ...) works.
		// description:
		//		Reset the (external defined) content of this pane and replace with new url
		//		Note: It delays the download until widget is shown if preload is false.
		//	href:
		//		url to the page you want to get, must be within the same domain as your mainpage

		// Cancel any in-flight requests (a set('href', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(lang.hitch(this, "onLoad"));

		this._set("href", href);

		// _setHrefAttr() is called during creation and by the user, after creation.
		// Assuming preload == false, only in the second case do we actually load the URL;
		// otherwise it's done in startup(), and only if this widget is shown.
		if(this.preload || (this._created && this._isShown())){
			this._load();
		}else{
			// Set flag to indicate that href needs to be loaded the next time the
			// ContentPane is made visible
			this._hrefChanged = true;
		}

		return this.onLoadDeferred;		// Deferred
	},

	setContent: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Deprecated.   Use set('content', ...) instead.
		kernel.deprecated("dijit.layout.ContentPane.setContent() is deprecated.  Use set('content', ...) instead.", "", "2.0");
		this.set("content", data);
	},
	_setContentAttr: function(/*String|DomNode|Nodelist*/data){
		// summary:
		//		Hook to make set("content", ...) work.
		//		Replaces old content with data content, include style classes from old content
		//	data:
		//		the new Content may be String, DomNode or NodeList
		//
		//		if data is a NodeList (or an array of nodes) nodes are copied
		//		so you can import nodes from another document implicitly

		// clear href so we can't run refresh and clear content
		// refresh should only work if we downloaded the content
		this._set("href", "");

		// Cancel any in-flight requests (a set('content', ...) will cancel any in-flight set('href', ...))
		this.cancel();

		// Even though user is just setting content directly, still need to define an onLoadDeferred
		// because the _onLoadHandler() handler is still getting called from setContent()
		this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
		if(this._created){
			// For back-compat reasons, call onLoad() for set('content', ...)
			// calls but not for content specified in srcNodeRef (ie: <div data-dojo-type=ContentPane>...</div>)
			// or as initialization parameter (ie: new ContentPane({content: ...})
			this.onLoadDeferred.addCallback(lang.hitch(this, "onLoad"));
		}

		this._setContent(data || "");

		this._isDownloaded = false; // mark that content is from a set('content') not a set('href')

		return this.onLoadDeferred; 	// Deferred
	},
	_getContentAttr: function(){
		// summary:
		//		Hook to make get("content") work
		return this.containerNode.innerHTML;
	},

	cancel: function(){
		// summary:
		//		Cancels an in-flight download of content
		if(this._xhrDfd && (this._xhrDfd.fired == -1)){
			this._xhrDfd.cancel();
		}
		delete this._xhrDfd; // garbage collect

		this.onLoadDeferred = null;
	},

	uninitialize: function(){
		if(this._beingDestroyed){
			this.cancel();
		}
		this.inherited(arguments);
	},

	destroyRecursive: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy the ContentPane and its contents

		// if we have multiple controllers destroying us, bail after the first
		if(this._beingDestroyed){
			return;
		}
		this.inherited(arguments);
	},

	_onShow: function(){
		// summary:
		//		Called when the ContentPane is made visible
		// description:
		//		For a plain ContentPane, this is called on initialization, from startup().
		//		If the ContentPane is a hidden pane of a TabContainer etc., then it's
		//		called whenever the pane is made visible.
		//
		//		Does necessary processing, including href download and layout/resize of
		//		child widget(s)

		this.inherited(arguments);

		if(this.href){
			if(!this._xhrDfd && // if there's an href that isn't already being loaded
				(!this.isLoaded || this._hrefChanged || this.refreshOnShow)
			){
				return this.refresh();	// If child has an href, promise that fires when the load is complete
			}
		}
	},

	refresh: function(){
		// summary:
		//		[Re]download contents of href and display
		// description:
		//		1. cancels any currently in-flight requests
		//		2. posts "loading..." message
		//		3. sends XHR to download new data

		// Cancel possible prior in-flight request
		this.cancel();

		this.onLoadDeferred = new Deferred(lang.hitch(this, "cancel"));
		this.onLoadDeferred.addCallback(lang.hitch(this, "onLoad"));
		this._load();
		return this.onLoadDeferred;		// If child has an href, promise that fires when refresh is complete
	},

	_load: function(){
		// summary:
		//		Load/reload the href specified in this.href

		// display loading message
		this._setContent(this.onDownloadStart(), true);

		var self = this;
		var getArgs = {
			preventCache: (this.preventCache || this.refreshOnShow),
			url: this.href,
			handleAs: "text"
		};
		if(lang.isObject(this.ioArgs)){
			lang.mixin(getArgs, this.ioArgs);
		}

		var hand = (this._xhrDfd = (this.ioMethod || xhr.get)(getArgs));

		hand.addCallback(function(html){
			try{
				self._isDownloaded = true;
				self._setContent(html, false);
				self.onDownloadEnd();
			}catch(err){
				self._onError('Content', err); // onContentError
			}
			delete self._xhrDfd;
			return html;
		});

		hand.addErrback(function(err){
			if(!hand.canceled){
				// show error message in the pane
				self._onError('Download', err); // onDownloadError
			}
			delete self._xhrDfd;
			return err;
		});

		// Remove flag saying that a load is needed
		delete this._hrefChanged;
	},

	_onLoadHandler: function(data){
		// summary:
		//		This is called whenever new content is being loaded
		this._set("isLoaded", true);
		try{
			this.onLoadDeferred.callback(data);
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onLoad code: ' + e.message);
		}
	},

	_onUnloadHandler: function(){
		// summary:
		//		This is called whenever the content is being unloaded
		this._set("isLoaded", false);
		try{
			this.onUnload();
		}catch(e){
			console.error('Error '+this.widgetId+' running custom onUnload code: ' + e.message);
		}
	},

	destroyDescendants: function(/*Boolean*/ preserveDom){
		// summary:
		//		Destroy all the widgets inside the ContentPane and empty containerNode

		// Make sure we call onUnload (but only when the ContentPane has real content)
		if(this.isLoaded){
			this._onUnloadHandler();
		}

		// Even if this.isLoaded == false there might still be a "Loading..." message
		// to erase, so continue...

		// For historical reasons we need to delete all widgets under this.containerNode,
		// even ones that the user has created manually.
		var setter = this._contentSetter;
		array.forEach(this.getChildren(), function(widget){
			if(widget.destroyRecursive){
				widget.destroyRecursive(preserveDom);
			}
		});
		if(setter){
			// Most of the widgets in setter.parseResults have already been destroyed, but
			// things like Menu that have been moved to <body> haven't yet
			array.forEach(setter.parseResults, function(widget){
				if(widget.destroyRecursive && widget.domNode && widget.domNode.parentNode == win.body()){
					widget.destroyRecursive(preserveDom);
				}
			});
			delete setter.parseResults;
		}

		// And then clear away all the DOM nodes
		if(!preserveDom){
			html._emptyNode(this.containerNode);
		}

		// Delete any state information we have about current contents
		delete this._singleChild;
	},

	_setContent: function(/*String|DocumentFragment*/ cont, /*Boolean*/ isFakeContent){
		// summary:
		//		Insert the content into the container node

		// first get rid of child widgets
		this.destroyDescendants();

		// html.set will take care of the rest of the details
		// we provide an override for the error handling to ensure the widget gets the errors
		// configure the setter instance with only the relevant widget instance properties
		// NOTE: unless we hook into attr, or provide property setters for each property,
		// we need to re-configure the ContentSetter with each use
		var setter = this._contentSetter;
		if(! (setter && setter instanceof html._ContentSetter)){
			setter = this._contentSetter = new html._ContentSetter({
				node: this.containerNode,
				_onError: lang.hitch(this, this._onError),
				onContentError: lang.hitch(this, function(e){
					// fires if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV
					var errMess = this.onContentError(e);
					try{
						this.containerNode.innerHTML = errMess;
					}catch(e){
						console.error('Fatal '+this.id+' could not change content due to '+e.message, e);
					}
				})/*,
				_onError */
			});
		}

		var setterParams = lang.mixin({
			cleanContent: this.cleanContent,
			extractContent: this.extractContent,
			parseContent: !cont.domNode && this.parseOnLoad,
			parserScope: this.parserScope,
			startup: false,
			dir: this.dir,
			lang: this.lang,
			textDir: this.textDir
		}, this._contentSetterParams || {});

		setter.set( (lang.isObject(cont) && cont.domNode) ? cont.domNode : cont, setterParams );

		// setter params must be pulled afresh from the ContentPane each time
		delete this._contentSetterParams;

		if(this.doLayout){
			this._checkIfSingleChild();
		}

		if(!isFakeContent){
			if(this._started){
				// Startup each top level child widget (and they will start their children, recursively)
				delete this._started;
				this.startup();

				// Call resize() on each of my child layout widgets,
				// or resize() on my single child layout widget...
				// either now (if I'm currently visible) or when I become visible
				this._scheduleLayout();
			}

			this._onLoadHandler(cont);
		}
	},

	_onError: function(type, err, consoleText){
		this.onLoadDeferred.errback(err);

		// shows user the string that is returned by on[type]Error
		// override on[type]Error and return your own string to customize
		var errText = this['on' + type + 'Error'].call(this, err);
		if(consoleText){
			console.error(consoleText, err);
		}else if(errText){// a empty string won't change current content
			this._setContent(errText, true);
		}
	},

	// EVENT's, should be overide-able
	onLoad: function(/*===== data =====*/){
		// summary:
		//		Event hook, is called after everything is loaded and widgetified
		// tags:
		//		callback
	},

	onUnload: function(){
		// summary:
		//		Event hook, is called before old content is cleared
		// tags:
		//		callback
	},

	onDownloadStart: function(){
		// summary:
		//		Called before download starts.
		// description:
		//		The string returned by this function will be the html
		//		that tells the user we are loading something.
		//		Override with your own function if you want to change text.
		// tags:
		//		extension
		return this.loadingMessage;
	},

	onContentError: function(/*Error*/ /*===== error =====*/){
		// summary:
		//		Called on DOM faults, require faults etc. in content.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		By default (if this method is not overriden), it returns
		//		nothing, so the error message is just printed to the console.
		// tags:
		//		extension
	},

	onDownloadError: function(/*Error*/ /*===== error =====*/){
		// summary:
		//		Called when download error occurs.
		//
		//		In order to display an error message in the pane, return
		//		the error message from this method, as an HTML string.
		//
		//		Default behavior (if this method is not overriden) is to display
		//		the error message inside the pane.
		// tags:
		//		extension
		return this.errorMessage;
	},

	onDownloadEnd: function(){
		// summary:
		//		Called when download is finished.
		// tags:
		//		callback
	}
});

});

},
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'dijit/layout/utils':function(){
define("dijit/layout/utils", [
	"dojo/_base/array", // array.filter array.forEach
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.getComputedStyle
	"dojo/_base/lang", // lang.mixin
	".."	// for exporting symbols to dijit, remove in 2.0
], function(array, domClass, domGeometry, domStyle, lang, dijit){

	// module:
	//		dijit/layout/utils
	// summary:
	//		marginBox2contentBox() and layoutChildren()

	var layout = lang.getObject("layout", true, dijit);
	/*===== layout = dijit.layout =====*/

	layout.marginBox2contentBox = function(/*DomNode*/ node, /*Object*/ mb){
		// summary:
		//		Given the margin-box size of a node, return its content box size.
		//		Functions like domGeometry.contentBox() but is more reliable since it doesn't have
		//		to wait for the browser to compute sizes.
		var cs = domStyle.getComputedStyle(node);
		var me = domGeometry.getMarginExtents(node, cs);
		var pb = domGeometry.getPadBorderExtents(node, cs);
		return {
			l: domStyle.toPixelValue(node, cs.paddingLeft),
			t: domStyle.toPixelValue(node, cs.paddingTop),
			w: mb.w - (me.w + pb.w),
			h: mb.h - (me.h + pb.h)
		};
	};

	function capitalize(word){
		return word.substring(0,1).toUpperCase() + word.substring(1);
	}

	function size(widget, dim){
		// size the child
		var newSize = widget.resize ? widget.resize(dim) : domGeometry.setMarginBox(widget.domNode, dim);

		// record child's size
		if(newSize){
			// if the child returned it's new size then use that
			lang.mixin(widget, newSize);
		}else{
			// otherwise, call getMarginBox(), but favor our own numbers when we have them.
			// the browser lies sometimes
			lang.mixin(widget, domGeometry.getMarginBox(widget.domNode));
			lang.mixin(widget, dim);
		}
	}

	layout.layoutChildren = function(/*DomNode*/ container, /*Object*/ dim, /*Widget[]*/ children,
			/*String?*/ changedRegionId, /*Number?*/ changedRegionSize){
		// summary:
		//		Layout a bunch of child dom nodes within a parent dom node
		// container:
		//		parent node
		// dim:
		//		{l, t, w, h} object specifying dimensions of container into which to place children
		// children:
		//		an array of Widgets or at least objects containing:
		//			* domNode: pointer to DOM node to position
		//			* region or layoutAlign: position to place DOM node
		//			* resize(): (optional) method to set size of node
		//			* id: (optional) Id of widgets, referenced from resize object, below.
		// changedRegionId:
		//		If specified, the slider for the region with the specified id has been dragged, and thus
		//		the region's height or width should be adjusted according to changedRegionSize
		// changedRegionSize:
		//		See changedRegionId.

		// copy dim because we are going to modify it
		dim = lang.mixin({}, dim);

		domClass.add(container, "dijitLayoutContainer");

		// Move "client" elements to the end of the array for layout.  a11y dictates that the author
		// needs to be able to put them in the document in tab-order, but this algorithm requires that
		// client be last.    TODO: move these lines to LayoutContainer?   Unneeded other places I think.
		children = array.filter(children, function(item){ return item.region != "center" && item.layoutAlign != "client"; })
			.concat(array.filter(children, function(item){ return item.region == "center" || item.layoutAlign == "client"; }));

		// set positions/sizes
		array.forEach(children, function(child){
			var elm = child.domNode,
				pos = (child.region || child.layoutAlign);
			if(!pos){
				throw new Error("No region setting for " + child.id)
			}

			// set elem to upper left corner of unused space; may move it later
			var elmStyle = elm.style;
			elmStyle.left = dim.l+"px";
			elmStyle.top = dim.t+"px";
			elmStyle.position = "absolute";

			domClass.add(elm, "dijitAlign" + capitalize(pos));

			// Size adjustments to make to this child widget
			var sizeSetting = {};

			// Check for optional size adjustment due to splitter drag (height adjustment for top/bottom align
			// panes and width adjustment for left/right align panes.
			if(changedRegionId && changedRegionId == child.id){
				sizeSetting[child.region == "top" || child.region == "bottom" ? "h" : "w"] = changedRegionSize;
			}

			// set size && adjust record of remaining space.
			// note that setting the width of a <div> may affect its height.
			if(pos == "top" || pos == "bottom"){
				sizeSetting.w = dim.w;
				size(child, sizeSetting);
				dim.h -= child.h;
				if(pos == "top"){
					dim.t += child.h;
				}else{
					elmStyle.top = dim.t + dim.h + "px";
				}
			}else if(pos == "left" || pos == "right"){
				sizeSetting.h = dim.h;
				size(child, sizeSetting);
				dim.w -= child.w;
				if(pos == "left"){
					dim.l += child.w;
				}else{
					elmStyle.left = dim.l + dim.w + "px";
				}
			}else if(pos == "client" || pos == "center"){
				size(child, dim);
			}
		});
	};


	return {
		marginBox2contentBox: layout.marginBox2contentBox,
		layoutChildren: layout.layoutChildren
	};
});

},
'dijit/_Contained':function(){
define("dijit/_Contained", [
	"dojo/_base/declare", // declare
	"./registry"	// registry.getEnclosingWidget(), registry.byNode()
], function(declare, registry){

	// module:
	//		dijit/_Contained
	// summary:
	//		Mixin for widgets that are children of a container widget

	return declare("dijit._Contained", null, {
		// summary:
		//		Mixin for widgets that are children of a container widget
		//
		// example:
		// | 	// make a basic custom widget that knows about it's parents
		// |	declare("my.customClass",[dijit._Widget,dijit._Contained],{});

		_getSibling: function(/*String*/ which){
			// summary:
			//      Returns next or previous sibling
			// which:
			//      Either "next" or "previous"
			// tags:
			//      private
			var node = this.domNode;
			do{
				node = node[which+"Sibling"];
			}while(node && node.nodeType != 1);
			return node && registry.byNode(node);	// dijit._Widget
		},

		getPreviousSibling: function(){
			// summary:
			//		Returns null if this is the first child of the parent,
			//		otherwise returns the next element sibling to the "left".

			return this._getSibling("previous"); // dijit._Widget
		},

		getNextSibling: function(){
			// summary:
			//		Returns null if this is the last child of the parent,
			//		otherwise returns the next element sibling to the "right".

			return this._getSibling("next"); // dijit._Widget
		},

		getIndexInParent: function(){
			// summary:
			//		Returns the index of this widget within its container parent.
			//		It returns -1 if the parent does not exist, or if the parent
			//		is not a dijit._Container

			var p = this.getParent();
			if(!p || !p.getIndexOfChild){
				return -1; // int
			}
			return p.getIndexOfChild(this); // int
		}
	});
});

},
'url:dijit/form/templates/TextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\" id=\"widget_${id}\" role=\"presentation\"\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n",
'dijit/_KeyNavContainer':function(){
define("dijit/_KeyNavContainer", [
	"dojo/_base/kernel", // kernel.deprecated
	"./_Container",
	"./_FocusMixin",
	"dojo/_base/array", // array.forEach
	"dojo/keys", // keys.END keys.HOME
	"dojo/_base/declare", // declare
	"dojo/_base/event", // event.stop
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/lang" // lang.hitch
], function(kernel, _Container, _FocusMixin, array, keys, declare, event, domAttr, lang){

/*=====
	var _FocusMixin = dijit._FocusMixin;
	var _Container = dijit._Container;
=====*/

	// module:
	//		dijit/_KeyNavContainer
	// summary:
	//		A _Container with keyboard navigation of its children.

	return declare("dijit._KeyNavContainer", [_FocusMixin, _Container], {

		// summary:
		//		A _Container with keyboard navigation of its children.
		// description:
		//		To use this mixin, call connectKeyNavHandlers() in
		//		postCreate().
		//		It provides normalized keyboard and focusing code for Container
		//		widgets.

/*=====
		// focusedChild: [protected] Widget
		//		The currently focused child widget, or null if there isn't one
		focusedChild: null,
=====*/

		// tabIndex: Integer
		//		Tab index of the container; same as HTML tabIndex attribute.
		//		Note then when user tabs into the container, focus is immediately
		//		moved to the first item in the container.
		tabIndex: "0",

		connectKeyNavHandlers: function(/*keys[]*/ prevKeyCodes, /*keys[]*/ nextKeyCodes){
			// summary:
			//		Call in postCreate() to attach the keyboard handlers
			//		to the container.
			// preKeyCodes: keys[]
			//		Key codes for navigating to the previous child.
			// nextKeyCodes: keys[]
			//		Key codes for navigating to the next child.
			// tags:
			//		protected

			// TODO: call this automatically from my own postCreate()

			var keyCodes = (this._keyNavCodes = {});
			var prev = lang.hitch(this, "focusPrev");
			var next = lang.hitch(this, "focusNext");
			array.forEach(prevKeyCodes, function(code){ keyCodes[code] = prev; });
			array.forEach(nextKeyCodes, function(code){ keyCodes[code] = next; });
			keyCodes[keys.HOME] = lang.hitch(this, "focusFirstChild");
			keyCodes[keys.END] = lang.hitch(this, "focusLastChild");
			this.connect(this.domNode, "onkeypress", "_onContainerKeypress");
			this.connect(this.domNode, "onfocus", "_onContainerFocus");
		},

		startupKeyNavChildren: function(){
			kernel.deprecated("startupKeyNavChildren() call no longer needed", "", "2.0");
		},

		startup: function(){
			this.inherited(arguments);
			array.forEach(this.getChildren(), lang.hitch(this, "_startupChild"));
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			this.inherited(arguments);
			this._startupChild(widget);
		},

		focus: function(){
			// summary:
			//		Default focus() implementation: focus the first child.
			this.focusFirstChild();
		},

		focusFirstChild: function(){
			// summary:
			//		Focus the first focusable child in the container.
			// tags:
			//		protected
			this.focusChild(this._getFirstFocusableChild());
		},

		focusLastChild: function(){
			// summary:
			//		Focus the last focusable child in the container.
			// tags:
			//		protected
			this.focusChild(this._getLastFocusableChild());
		},

		focusNext: function(){
			// summary:
			//		Focus the next widget
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, 1));
		},

		focusPrev: function(){
			// summary:
			//		Focus the last focusable node in the previous widget
			//		(ex: go to the ComboButton icon section rather than button section)
			// tags:
			//		protected
			this.focusChild(this._getNextFocusableChild(this.focusedChild, -1), true);
		},

		focusChild: function(/*dijit._Widget*/ widget, /*Boolean*/ last){
			// summary:
			//		Focus specified child widget.
			// widget:
			//		Reference to container's child widget
			// last:
			//		If true and if widget has multiple focusable nodes, focus the
			//		last one instead of the first one
			// tags:
			//		protected

			if(!widget){ return; }

			if(this.focusedChild && widget !== this.focusedChild){
				this._onChildBlur(this.focusedChild);	// used by _MenuBase
			}
			widget.set("tabIndex", this.tabIndex);	// for IE focus outline to appear, must set tabIndex before focs
			widget.focus(last ? "end" : "start");
			this._set("focusedChild", widget);
		},

		_startupChild: function(/*dijit._Widget*/ widget){
			// summary:
			//		Setup for each child widget
			// description:
			//		Sets tabIndex=-1 on each child, so that the tab key will
			//		leave the container rather than visiting each child.
			// tags:
			//		private

			widget.set("tabIndex", "-1");

			this.connect(widget, "_onFocus", function(){
				// Set valid tabIndex so tabbing away from widget goes to right place, see #10272
				widget.set("tabIndex", this.tabIndex);
			});
			this.connect(widget, "_onBlur", function(){
				widget.set("tabIndex", "-1");
			});
		},

		_onContainerFocus: function(evt){
			// summary:
			//		Handler for when the container gets focus
			// description:
			//		Initially the container itself has a tabIndex, but when it gets
			//		focus, switch focus to first child...
			// tags:
			//		private

			// Note that we can't use _onFocus() because switching focus from the
			// _onFocus() handler confuses the focus.js code
			// (because it causes _onFocusNode() to be called recursively)
			// Also, _onFocus() would fire when focus went directly to a child widget due to mouse click.

			// Ignore spurious focus events:
			//	1. focus on a child widget bubbles on FF
			//	2. on IE, clicking the scrollbar of a select dropdown moves focus from the focused child item to me
			if(evt.target !== this.domNode || this.focusedChild){ return; }

			this.focusFirstChild();

			// and then set the container's tabIndex to -1,
			// (don't remove as that breaks Safari 4)
			// so that tab or shift-tab will go to the fields after/before
			// the container, rather than the container itself
			domAttr.set(this.domNode, "tabIndex", "-1");
		},

		_onBlur: function(evt){
			// When focus is moved away the container, and its descendant (popup) widgets,
			// then restore the container's tabIndex so that user can tab to it again.
			// Note that using _onBlur() so that this doesn't happen when focus is shifted
			// to one of my child widgets (typically a popup)
			if(this.tabIndex){
				domAttr.set(this.domNode, "tabIndex", this.tabIndex);
			}
			this.focusedChild = null;
			this.inherited(arguments);
		},

		_onContainerKeypress: function(evt){
			// summary:
			//		When a key is pressed, if it's an arrow key etc. then
			//		it's handled here.
			// tags:
			//		private
			if(evt.ctrlKey || evt.altKey){ return; }
			var func = this._keyNavCodes[evt.charOrCode];
			if(func){
				func();
				event.stop(evt);
			}
		},

		_onChildBlur: function(/*dijit._Widget*/ /*===== widget =====*/){
			// summary:
			//		Called when focus leaves a child widget to go
			//		to a sibling widget.
			//		Used by MenuBase.js (TODO: move code there)
			// tags:
			//		protected
		},

		_getFirstFocusableChild: function(){
			// summary:
			//		Returns first child that can be focused
			return this._getNextFocusableChild(null, 1);	// dijit._Widget
		},

		_getLastFocusableChild: function(){
			// summary:
			//		Returns last child that can be focused
			return this._getNextFocusableChild(null, -1);	// dijit._Widget
		},

		_getNextFocusableChild: function(child, dir){
			// summary:
			//		Returns the next or previous focusable child, compared
			//		to "child"
			// child: Widget
			//		The current widget
			// dir: Integer
			//		* 1 = after
			//		* -1 = before
			if(child){
				child = this._getSiblingOfChild(child, dir);
			}
			var children = this.getChildren();
			for(var i=0; i < children.length; i++){
				if(!child){
					child = children[(dir>0) ? 0 : (children.length-1)];
				}
				if(child.isFocusable()){
					return child;	// dijit._Widget
				}
				child = this._getSiblingOfChild(child, dir);
			}
			// no focusable child found
			return null;	// dijit._Widget
		}
	});
});

},
'dijit/form/DataList':function(){
define("dijit/form/DataList", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.byId
	"dojo/_base/lang", // lang.trim
	"dojo/query", // query
	"dojo/store/Memory", // dojo.store.Memory
	"../registry"	// registry.add registry.remove
], function(declare, dom, lang, query, MemoryStore, registry){

	// module:
	//		dijit/form/DataList
	// summary:
	//		Inefficient but small data store specialized for inlined data via OPTION tags

	function toItem(/*DOMNode*/ option){
		// summary:
		//		Convert <option> node to hash
		return {
			id: option.value,
			value: option.value,
			name: lang.trim(option.innerText || option.textContent || '')
		};
	}

	return declare("dijit.form.DataList", MemoryStore, {
		// summary:
		//		Inefficient but small data store specialized for inlined data via OPTION tags
		//
		// description:
		//		Provides a store for inlined data like:
		//
		//	|	<datalist>
		//	|		<option value="AL">Alabama</option>
		//	|		...

		constructor: function(/*Object?*/ params, /*DomNode|String*/ srcNodeRef){
			// store pointer to original DOM tree
			this.domNode = dom.byId(srcNodeRef);

			lang.mixin(this, params);
			if(this.id){
				registry.add(this); // add to registry so it can be easily found by id
			}
			this.domNode.style.display = "none";

			this.inherited(arguments, [{
				data: query("option", this.domNode).map(toItem)
			}]);
		},

		destroy: function(){
			registry.remove(this.id);
		},

		fetchSelectedItem: function(){
			// summary:
			//		Get the option marked as selected, like `<option selected>`.
			//		Not part of dojo.data API.
			var option = query("> option[selected]", this.domNode)[0] || query("> option", this.domNode)[0];
			return option && toItem(option);
		}
	});
});

},
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n",
'dijit/form/CheckBox':function(){
require({cache:{
'url:dijit/form/templates/CheckBox.html':"<div class=\"dijit dijitReset dijitInline\" role=\"presentation\"\n\t><input\n\t \t${!nameAttrSetting} type=\"${type}\" ${checkedAttrSetting}\n\t\tclass=\"dijitReset dijitCheckBoxInput\"\n\t\tdata-dojo-attach-point=\"focusNode\"\n\t \tdata-dojo-attach-event=\"onclick:_onClick\"\n/></div>\n"}});
define("dijit/form/CheckBox", [
	"require",
	"dojo/_base/declare", // declare
	"dojo/dom-attr", // domAttr.set
	"dojo/_base/kernel",
	"dojo/query", // query
	"dojo/ready",
	"./ToggleButton",
	"./_CheckBoxMixin",
	"dojo/text!./templates/CheckBox.html",
	"dojo/NodeList-dom" // NodeList.addClass/removeClass
], function(require, declare, domAttr, kernel, query, ready, ToggleButton, _CheckBoxMixin, template){

/*=====
	var ToggleButton = dijit.form.ToggleButton;
	var _CheckBoxMixin = dijit.form._CheckBoxMixin;
=====*/

	// module:
	//		dijit/form/CheckBox
	// summary:
	//		Checkbox widget

	// Back compat w/1.6, remove for 2.0
	if(!kernel.isAsync){
		ready(0, function(){
			var requires = ["dijit/form/RadioButton"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return declare("dijit.form.CheckBox", [ToggleButton, _CheckBoxMixin], {
		// summary:
		// 		Same as an HTML checkbox, but with fancy styling.
		//
		// description:
		//		User interacts with real html inputs.
		//		On onclick (which occurs by mouse click, space-bar, or
		//		using the arrow keys to switch the selected radio button),
		//		we update the state of the checkbox/radio.
		//
		//		There are two modes:
		//			1. High contrast mode
		//			2. Normal mode
		//
		//		In case 1, the regular html inputs are shown and used by the user.
		//		In case 2, the regular html inputs are invisible but still used by
		//		the user. They are turned quasi-invisible and overlay the background-image.

		templateString: template,

		baseClass: "dijitCheckBox",

		_setValueAttr: function(/*String|Boolean*/ newValue, /*Boolean*/ priorityChange){
			// summary:
			//		Handler for value= attribute to constructor, and also calls to
			//		set('value', val).
			// description:
			//		During initialization, just saves as attribute to the <input type=checkbox>.
			//
			//		After initialization,
			//		when passed a boolean, controls whether or not the CheckBox is checked.
			//		If passed a string, changes the value attribute of the CheckBox (the one
			//		specified as "value" when the CheckBox was constructed (ex: <input
			//		data-dojo-type="dijit.CheckBox" value="chicken">)
			//		widget.set('value', string) will check the checkbox and change the value to the
			//		specified string
			//		widget.set('value', boolean) will change the checked state.
			if(typeof newValue == "string"){
				this._set("value", newValue);
				domAttr.set(this.focusNode, 'value', newValue);
				newValue = true;
			}
			if(this._created){
				this.set('checked', newValue, priorityChange);
			}
		},
		_getValueAttr: function(){
			// summary:
			//		Hook so get('value') works.
			// description:
			//		If the CheckBox is checked, returns the value attribute.
			//		Otherwise returns false.
			return (this.checked ? this.value : false);
		},

		// Override behavior from Button, since we don't have an iconNode
		_setIconClassAttr: null,

		postMixInProperties: function(){
			this.inherited(arguments);

			// Need to set initial checked state as part of template, so that form submit works.
			// domAttr.set(node, "checked", bool) doesn't work on IE until node has been attached
			// to <body>, see #8666
			this.checkedAttrSetting = this.checked ? "checked" : "";
		},

		 _fillContent: function(){
			// Override Button::_fillContent() since it doesn't make sense for CheckBox,
			// since CheckBox doesn't even have a container
		},

		_onFocus: function(){
			if(this.id){
				query("label[for='"+this.id+"']").addClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		},

		_onBlur: function(){
			if(this.id){
				query("label[for='"+this.id+"']").removeClass("dijitFocusedLabel");
			}
			this.inherited(arguments);
		}
	});
});

},
'dojox/gfx/matrix':function(){
define("dojox/gfx/matrix", ["./_base","dojo/_base/lang"], 
  function(g, lang){
	var m = g.matrix = {};
	/*===== g = dojox.gfx; m = dojox.gfx.matrix =====*/

	// candidates for dojox.math:
	var _degToRadCache = {};
	m._degToRad = function(degree){
		return _degToRadCache[degree] || (_degToRadCache[degree] = (Math.PI * degree / 180));
	};
	m._radToDeg = function(radian){ return radian / Math.PI * 180; };

	m.Matrix2D = function(arg){
		// summary: 
		//		a 2D matrix object
		// description: Normalizes a 2D matrix-like object. If arrays is passed,
		//		all objects of the array are normalized and multiplied sequentially.
		// arg: Object
		//		a 2D matrix-like object, a number, or an array of such objects
		if(arg){
			if(typeof arg == "number"){
				this.xx = this.yy = arg;
			}else if(arg instanceof Array){
				if(arg.length > 0){
					var matrix = m.normalize(arg[0]);
					// combine matrices
					for(var i = 1; i < arg.length; ++i){
						var l = matrix, r = m.normalize(arg[i]);
						matrix = new m.Matrix2D();
						matrix.xx = l.xx * r.xx + l.xy * r.yx;
						matrix.xy = l.xx * r.xy + l.xy * r.yy;
						matrix.yx = l.yx * r.xx + l.yy * r.yx;
						matrix.yy = l.yx * r.xy + l.yy * r.yy;
						matrix.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
						matrix.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
					}
					lang.mixin(this, matrix);
				}
			}else{
				lang.mixin(this, arg);
			}
		}
	};

	// the default (identity) matrix, which is used to fill in missing values
	lang.extend(m.Matrix2D, {xx: 1, xy: 0, yx: 0, yy: 1, dx: 0, dy: 0});

	lang.mixin(m, {
		// summary: class constants, and methods of dojox.gfx.matrix

		// matrix constants

		// identity: dojox.gfx.matrix.Matrix2D
		//		an identity matrix constant: identity * (x, y) == (x, y)
		identity: new m.Matrix2D(),

		// flipX: dojox.gfx.matrix.Matrix2D
		//		a matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)
		flipX:    new m.Matrix2D({xx: -1}),

		// flipY: dojox.gfx.matrix.Matrix2D
		//		a matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)
		flipY:    new m.Matrix2D({yy: -1}),

		// flipXY: dojox.gfx.matrix.Matrix2D
		//		a matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)
		flipXY:   new m.Matrix2D({xx: -1, yy: -1}),

		// matrix creators

		translate: function(a, b){
			// summary: forms a translation matrix
			// description: The resulting matrix is used to translate (move) points by specified offsets.
			// a: Number: an x coordinate value
			// b: Number: a y coordinate value
			if(arguments.length > 1){
				return new m.Matrix2D({dx: a, dy: b}); // dojox.gfx.matrix.Matrix2D
			}
			// branch
			// a: dojox.gfx.Point: a point-like object, which specifies offsets for both dimensions
			// b: null
			return new m.Matrix2D({dx: a.x, dy: a.y}); // dojox.gfx.matrix.Matrix2D
		},
		scale: function(a, b){
			// summary: forms a scaling matrix
			// description: The resulting matrix is used to scale (magnify) points by specified offsets.
			// a: Number: a scaling factor used for the x coordinate
			// b: Number: a scaling factor used for the y coordinate
			if(arguments.length > 1){
				return new m.Matrix2D({xx: a, yy: b}); // dojox.gfx.matrix.Matrix2D
			}
			if(typeof a == "number"){
				// branch
				// a: Number: a uniform scaling factor used for the both coordinates
				// b: null
				return new m.Matrix2D({xx: a, yy: a}); // dojox.gfx.matrix.Matrix2D
			}
			// branch
			// a: dojox.gfx.Point: a point-like object, which specifies scale factors for both dimensions
			// b: null
			return new m.Matrix2D({xx: a.x, yy: a.y}); // dojox.gfx.matrix.Matrix2D
		},
		rotate: function(angle){
			// summary: forms a rotating matrix
			// description: The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number: an angle of rotation in radians (>0 for CW)
			var c = Math.cos(angle);
			var s = Math.sin(angle);
			return new m.Matrix2D({xx: c, xy: -s, yx: s, yy: c}); // dojox.gfx.matrix.Matrix2D
		},
		rotateg: function(degree){
			// summary: forms a rotating matrix
			// description: The resulting matrix is used to rotate points
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox.gfx.matrix.rotate() for comparison.
			// degree: Number: an angle of rotation in degrees (>0 for CW)
			return m.rotate(m._degToRad(degree)); // dojox.gfx.matrix.Matrix2D
		},
		skewX: function(angle) {
			// summary: forms an x skewing matrix
			// description: The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number: an skewing angle in radians
			return new m.Matrix2D({xy: Math.tan(angle)}); // dojox.gfx.matrix.Matrix2D
		},
		skewXg: function(degree){
			// summary: forms an x skewing matrix
			// description: The resulting matrix is used to skew points in the x dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox.gfx.matrix.skewX() for comparison.
			// degree: Number: an skewing angle in degrees
			return m.skewX(m._degToRad(degree)); // dojox.gfx.matrix.Matrix2D
		},
		skewY: function(angle){
			// summary: forms a y skewing matrix
			// description: The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified angle.
			// angle: Number: an skewing angle in radians
			return new m.Matrix2D({yx: Math.tan(angle)}); // dojox.gfx.matrix.Matrix2D
		},
		skewYg: function(degree){
			// summary: forms a y skewing matrix
			// description: The resulting matrix is used to skew points in the y dimension
			//		around the origin of coordinates (0, 0) by specified degree.
			//		See dojox.gfx.matrix.skewY() for comparison.
			// degree: Number: an skewing angle in degrees
			return m.skewY(m._degToRad(degree)); // dojox.gfx.matrix.Matrix2D
		},
		reflect: function(a, b){
			// summary: forms a reflection matrix
			// description: The resulting matrix is used to reflect points around a vector,
			//		which goes through the origin.
			// a: dojox.gfx.Point: a point-like object, which specifies a vector of reflection
			// b: null
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// branch
			// a: Number: an x coordinate value
			// b: Number: a y coordinate value

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = 2 * a * b / n2;
			return new m.Matrix2D({xx: 2 * a2 / n2 - 1, xy: xy, yx: xy, yy: 2 * b2 / n2 - 1}); // dojox.gfx.matrix.Matrix2D
		},
		project: function(a, b){
			// summary: forms an orthogonal projection matrix
			// description: The resulting matrix is used to project points orthogonally on a vector,
			//		which goes through the origin.
			// a: dojox.gfx.Point: a point-like object, which specifies a vector of projection
			// b: null
			if(arguments.length == 1){
				b = a.y;
				a = a.x;
			}
			// branch
			// a: Number: an x coordinate value
			// b: Number: a y coordinate value

			// make a unit vector
			var a2 = a * a, b2 = b * b, n2 = a2 + b2, xy = a * b / n2;
			return new m.Matrix2D({xx: a2 / n2, xy: xy, yx: xy, yy: b2 / n2}); // dojox.gfx.matrix.Matrix2D
		},

		// ensure matrix 2D conformance
		normalize: function(matrix){
			// summary: converts an object to a matrix, if necessary
			// description: Converts any 2D matrix-like object or an array of
			//		such objects to a valid dojox.gfx.matrix.Matrix2D object.
			// matrix: Object: an object, which is converted to a matrix, if necessary
			return (matrix instanceof m.Matrix2D) ? matrix : new m.Matrix2D(matrix); // dojox.gfx.matrix.Matrix2D
		},

		// common operations

		clone: function(matrix){
			// summary: creates a copy of a 2D matrix
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object to be cloned
			var obj = new m.Matrix2D();
			for(var i in matrix){
				if(typeof(matrix[i]) == "number" && typeof(obj[i]) == "number" && obj[i] != matrix[i]) obj[i] = matrix[i];
			}
			return obj; // dojox.gfx.matrix.Matrix2D
		},
		invert: function(matrix){
			// summary: inverts a 2D matrix
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object to be inverted
			var M = m.normalize(matrix),
				D = M.xx * M.yy - M.xy * M.yx;
				M = new m.Matrix2D({
					xx: M.yy/D, xy: -M.xy/D,
					yx: -M.yx/D, yy: M.xx/D,
					dx: (M.xy * M.dy - M.yy * M.dx) / D,
					dy: (M.yx * M.dx - M.xx * M.dy) / D
				});
			return M; // dojox.gfx.matrix.Matrix2D
		},
		_multiplyPoint: function(matrix, x, y){
			// summary: applies a matrix to a point
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix object to be applied
			// x: Number: an x coordinate of a point
			// y: Number: a y coordinate of a point
			return {x: matrix.xx * x + matrix.xy * y + matrix.dx, y: matrix.yx * x + matrix.yy * y + matrix.dy}; // dojox.gfx.Point
		},
		multiplyPoint: function(matrix, /* Number||Point */ a, /* Number? */ b){
			// summary: applies a matrix to a point
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix object to be applied
			// a: Number: an x coordinate of a point
			// b: Number?: a y coordinate of a point
			var M = m.normalize(matrix);
			if(typeof a == "number" && typeof b == "number"){
				return m._multiplyPoint(M, a, b); // dojox.gfx.Point
			}
			// branch
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix object to be applied
			// a: dojox.gfx.Point: a point
			// b: null
			return m._multiplyPoint(M, a.x, a.y); // dojox.gfx.Point
		},
		multiply: function(matrix){
			// summary: combines matrices by multiplying them sequentially in the given order
			// matrix: dojox.gfx.matrix.Matrix2D...: a 2D matrix-like object,
			//		all subsequent arguments are matrix-like objects too
			var M = m.normalize(matrix);
			// combine matrices
			for(var i = 1; i < arguments.length; ++i){
				var l = M, r = m.normalize(arguments[i]);
				M = new m.Matrix2D();
				M.xx = l.xx * r.xx + l.xy * r.yx;
				M.xy = l.xx * r.xy + l.xy * r.yy;
				M.yx = l.yx * r.xx + l.yy * r.yx;
				M.yy = l.yx * r.xy + l.yy * r.yy;
				M.dx = l.xx * r.dx + l.xy * r.dy + l.dx;
				M.dy = l.yx * r.dx + l.yy * r.dy + l.dy;
			}
			return M; // dojox.gfx.matrix.Matrix2D
		},

		// high level operations

		_sandwich: function(matrix, x, y){
			// summary: applies a matrix at a centrtal point
			// matrix: dojox.gfx.matrix.Matrix2D: a 2D matrix-like object, which is applied at a central point
			// x: Number: an x component of the central point
			// y: Number: a y component of the central point
			return m.multiply(m.translate(x, y), matrix, m.translate(-x, -y)); // dojox.gfx.matrix.Matrix2D
		},
		scaleAt: function(a, b, c, d){
			// summary: scales a picture using a specified point as a center of scaling
			// description: Compare with dojox.gfx.matrix.scale().
			// a: Number: a scaling factor used for the x coordinate
			// b: Number: a scaling factor used for the y coordinate
			// c: Number: an x component of a central point
			// d: Number: a y component of a central point

			// accepts several signatures:
			//	1) uniform scale factor, Point
			//	2) uniform scale factor, x, y
			//	3) x scale, y scale, Point
			//	4) x scale, y scale, x, y

			switch(arguments.length){
				case 4:
					// a and b are scale factor components, c and d are components of a point
					return m._sandwich(m.scale(a, b), c, d); // dojox.gfx.matrix.Matrix2D
				case 3:
					if(typeof c == "number"){
						// branch
						// a: Number: a uniform scaling factor used for both coordinates
						// b: Number: an x component of a central point
						// c: Number: a y component of a central point
						// d: null
						return m._sandwich(m.scale(a), b, c); // dojox.gfx.matrix.Matrix2D
					}
					// branch
					// a: Number: a scaling factor used for the x coordinate
					// b: Number: a scaling factor used for the y coordinate
					// c: dojox.gfx.Point: a central point
					// d: null
					return m._sandwich(m.scale(a, b), c.x, c.y); // dojox.gfx.matrix.Matrix2D
			}
			// branch
			// a: Number: a uniform scaling factor used for both coordinates
			// b: dojox.gfx.Point: a central point
			// c: null
			// d: null
			return m._sandwich(m.scale(a), b.x, b.y); // dojox.gfx.matrix.Matrix2D
		},
		rotateAt: function(angle, a, b){
			// summary: rotates a picture using a specified point as a center of rotation
			// description: Compare with dojox.gfx.matrix.rotate().
			// angle: Number: an angle of rotation in radians (>0 for CW)
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) rotation angle in radians, Point
			//	2) rotation angle in radians, x, y

			if(arguments.length > 2){
				return m._sandwich(m.rotate(angle), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// angle: Number: an angle of rotation in radians (>0 for CCW)
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.rotate(angle), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		rotategAt: function(degree, a, b){
			// summary: rotates a picture using a specified point as a center of rotation
			// description: Compare with dojox.gfx.matrix.rotateg().
			// degree: Number: an angle of rotation in degrees (>0 for CW)
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) rotation angle in degrees, Point
			//	2) rotation angle in degrees, x, y

			if(arguments.length > 2){
				return m._sandwich(m.rotateg(degree), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// degree: Number: an angle of rotation in degrees (>0 for CCW)
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.rotateg(degree), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewXAt: function(angle, a, b){
			// summary: skews a picture along the x axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewX().
			// angle: Number: an skewing angle in radians
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in radians, Point
			//	2) skew angle in radians, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewX(angle), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// angle: Number: an skewing angle in radians
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewX(angle), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewXgAt: function(degree, a, b){
			// summary: skews a picture along the x axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewXg().
			// degree: Number: an skewing angle in degrees
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in degrees, Point
			//	2) skew angle in degrees, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewXg(degree), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// degree: Number: an skewing angle in degrees
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewXg(degree), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewYAt: function(angle, a, b){
			// summary: skews a picture along the y axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewY().
			// angle: Number: an skewing angle in radians
			// a: Number: an x component of a central point
			// b: Number: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in radians, Point
			//	2) skew angle in radians, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewY(angle), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// angle: Number: an skewing angle in radians
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewY(angle), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		},
		skewYgAt: function(/* Number */ degree, /* Number||Point */ a, /* Number? */ b){
			// summary: skews a picture along the y axis using a specified point as a center of skewing
			// description: Compare with dojox.gfx.matrix.skewYg().
			// degree: Number: an skewing angle in degrees
			// a: Number: an x component of a central point
			// b: Number?: a y component of a central point

			// accepts several signatures:
			//	1) skew angle in degrees, Point
			//	2) skew angle in degrees, x, y

			if(arguments.length > 2){
				return m._sandwich(m.skewYg(degree), a, b); // dojox.gfx.matrix.Matrix2D
			}

			// branch
			// degree: Number: an skewing angle in degrees
			// a: dojox.gfx.Point: a central point
			// b: null
			return m._sandwich(m.skewYg(degree), a.x, a.y); // dojox.gfx.matrix.Matrix2D
		}

		//TODO: rect-to-rect mapping, scale-to-fit (isotropic and anisotropic versions)

	});
	// propagate Matrix2D up
	g.Matrix2D = m.Matrix2D;

	return m;
});



},
'dijit/tree/_dndSelector':function(){
define("dijit/tree/_dndSelector", [
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/_base/connect", // connect.isCopyKey
	"dojo/_base/declare", // declare
	"dojo/_base/lang", // lang.hitch
	"dojo/mouse", // mouse.isLeft
	"dojo/on",
	"dojo/touch",
	"dojo/_base/window", // win.global
	"./_dndContainer"
], function(array, connect, declare, lang, mouse, on, touch, win, _dndContainer){

	// module:
	//		dijit/tree/_dndSelector
	// summary:
	//		This is a base class for `dijit.tree.dndSource` , and isn't meant to be used directly.
	//		It's based on `dojo.dnd.Selector`.


	return declare("dijit.tree._dndSelector", _dndContainer, {
		// summary:
		//		This is a base class for `dijit.tree.dndSource` , and isn't meant to be used directly.
		//		It's based on `dojo.dnd.Selector`.
		// tags:
		//		protected

		/*=====
		// selection: Hash<String, DomNode>
		//		(id, DomNode) map for every TreeNode that's currently selected.
		//		The DOMNode is the TreeNode.rowNode.
		selection: {},
		=====*/

		constructor: function(){
			// summary:
			//		Initialization
			// tags:
			//		private

			this.selection={};
			this.anchor = null;

			this.tree.domNode.setAttribute("aria-multiselect", !this.singular);

			this.events.push(
				on(this.tree.domNode, touch.press, lang.hitch(this,"onMouseDown")),
				on(this.tree.domNode, touch.release, lang.hitch(this,"onMouseUp")),
				on(this.tree.domNode, touch.move, lang.hitch(this,"onMouseMove"))
			);
		},

		//	singular: Boolean
		//		Allows selection of only one element, if true.
		//		Tree hasn't been tested in singular=true mode, unclear if it works.
		singular: false,

		// methods
		getSelectedTreeNodes: function(){
			// summary:
			//		Returns a list of selected node(s).
			//		Used by dndSource on the start of a drag.
			// tags:
			//		protected
			var nodes=[], sel = this.selection;
			for(var i in sel){
				nodes.push(sel[i]);
			}
			return nodes;
		},

		selectNone: function(){
			// summary:
			//		Unselects all items
			// tags:
			//		private

			this.setSelection([]);
			return this;	// self
		},

		destroy: function(){
			// summary:
			//		Prepares the object to be garbage-collected
			this.inherited(arguments);
			this.selection = this.anchor = null;
		},
		addTreeNode: function(/*dijit._TreeNode*/node, /*Boolean?*/isAnchor){
			// summary:
			//		add node to current selection
			// node: Node
			//		node to add
			// isAnchor: Boolean
			//		Whether the node should become anchor.

			this.setSelection(this.getSelectedTreeNodes().concat( [node] ));
			if(isAnchor){ this.anchor = node; }
			return node;
		},
		removeTreeNode: function(/*dijit._TreeNode*/node){
			// summary:
			//		remove node from current selection
			// node: Node
			//		node to remove
			this.setSelection(this._setDifference(this.getSelectedTreeNodes(), [node]));
			return node;
		},
		isTreeNodeSelected: function(/*dijit._TreeNode*/node){
			// summary:
			//		return true if node is currently selected
			// node: Node
			//		the node to check whether it's in the current selection

			return node.id && !!this.selection[node.id];
		},
		setSelection: function(/*dijit._treeNode[]*/ newSelection){
			// summary:
			//		set the list of selected nodes to be exactly newSelection. All changes to the
			//		selection should be passed through this function, which ensures that derived
			//		attributes are kept up to date. Anchor will be deleted if it has been removed
			//		from the selection, but no new anchor will be added by this function.
			// newSelection: Node[]
			//		list of tree nodes to make selected
			var oldSelection = this.getSelectedTreeNodes();
			array.forEach(this._setDifference(oldSelection, newSelection), lang.hitch(this, function(node){
				node.setSelected(false);
				if(this.anchor == node){
					delete this.anchor;
				}
				delete this.selection[node.id];
			}));
			array.forEach(this._setDifference(newSelection, oldSelection), lang.hitch(this, function(node){
				node.setSelected(true);
				this.selection[node.id] = node;
			}));
			this._updateSelectionProperties();
		},
		_setDifference: function(xs,ys){
			// summary:
			//		Returns a copy of xs which lacks any objects
			//		occurring in ys. Checks for membership by
			//		modifying and then reading the object, so it will
			//		not properly handle sets of numbers or strings.

			array.forEach(ys, function(y){ y.__exclude__ = true; });
			var ret = array.filter(xs, function(x){ return !x.__exclude__; });

			// clean up after ourselves.
			array.forEach(ys, function(y){ delete y['__exclude__'] });
			return ret;
		},
		_updateSelectionProperties: function(){
			// summary:
			//		Update the following tree properties from the current selection:
			//		path[s], selectedItem[s], selectedNode[s]

			var selected = this.getSelectedTreeNodes();
			var paths = [], nodes = [];
			array.forEach(selected, function(node){
				nodes.push(node);
				paths.push(node.getTreePath());
			});
			var items = array.map(nodes,function(node){ return node.item; });
			this.tree._set("paths", paths);
			this.tree._set("path", paths[0] || []);
			this.tree._set("selectedNodes", nodes);
			this.tree._set("selectedNode", nodes[0] || null);
			this.tree._set("selectedItems", items);
			this.tree._set("selectedItem", items[0] || null);
		},
		// mouse events
		onMouseDown: function(e){
			// summary:
			//		Event processor for onmousedown/ontouchstart
			// e: Event
			//		onmousedown/ontouchstart event
			// tags:
			//		protected

			// ignore click on expando node
			if(!this.current || this.tree.isExpandoNode(e.target, this.current)){ return; }

			if(!mouse.isLeft(e)){ return; } // ignore right-click

			e.preventDefault();

			var treeNode = this.current,
			  copy = connect.isCopyKey(e), id = treeNode.id;

			// if shift key is not pressed, and the node is already in the selection,
			// delay deselection until onmouseup so in the case of DND, deselection
			// will be canceled by onmousemove.
			if(!this.singular && !e.shiftKey && this.selection[id]){
				this._doDeselect = true;
				return;
			}else{
				this._doDeselect = false;
			}
			this.userSelect(treeNode, copy, e.shiftKey);
		},

		onMouseUp: function(e){
			// summary:
			//		Event processor for onmouseup/ontouchend
			// e: Event
			//		onmouseup/ontouchend event
			// tags:
			//		protected

			// _doDeselect is the flag to indicate that the user wants to either ctrl+click on
			// a already selected item (to deselect the item), or click on a not-yet selected item
			// (which should remove all current selection, and add the clicked item). This can not
			// be done in onMouseDown, because the user may start a drag after mousedown. By moving
			// the deselection logic here, the user can drags an already selected item.
			if(!this._doDeselect){ return; }
			this._doDeselect = false;
			this.userSelect(this.current, connect.isCopyKey(e), e.shiftKey);
		},
		onMouseMove: function(/*===== e =====*/){
			// summary:
			//		event processor for onmousemove/ontouchmove
			// e: Event
			//		onmousemove/ontouchmove event
			this._doDeselect = false;
		},

		_compareNodes: function(n1, n2){
			if(n1 === n2){
				return 0;
			}

			if('sourceIndex' in document.documentElement){ //IE
				//TODO: does not yet work if n1 and/or n2 is a text node
				return n1.sourceIndex - n2.sourceIndex;
			}else if('compareDocumentPosition' in document.documentElement){ //FF, Opera
				return n1.compareDocumentPosition(n2) & 2 ? 1: -1;
			}else if(document.createRange){ //Webkit
				var r1 = doc.createRange();
				r1.setStartBefore(n1);

				var r2 = doc.createRange();
				r2.setStartBefore(n2);

				return r1.compareBoundaryPoints(r1.END_TO_END, r2);
			}else{
				throw Error("dijit.tree._compareNodes don't know how to compare two different nodes in this browser");
			}
		},

		userSelect: function(node, multi, range){
			// summary:
			//		Add or remove the given node from selection, responding
			//		to a user action such as a click or keypress.
			// multi: Boolean
			//		Indicates whether this is meant to be a multi-select action (e.g. ctrl-click)
			// range: Boolean
			//		Indicates whether this is meant to be a ranged action (e.g. shift-click)
			// tags:
			//		protected

			if(this.singular){
				if(this.anchor == node && multi){
					this.selectNone();
				}else{
					this.setSelection([node]);
					this.anchor = node;
				}
			}else{
				if(range && this.anchor){
					var cr = this._compareNodes(this.anchor.rowNode, node.rowNode),
					begin, end, anchor = this.anchor;

					if(cr < 0){ //current is after anchor
						begin = anchor;
						end = node;
					}else{ //current is before anchor
						begin = node;
						end = anchor;
					}
					var nodes = [];
					//add everything betweeen begin and end inclusively
					while(begin != end){
						nodes.push(begin);
						begin = this.tree._getNextNode(begin);
					}
					nodes.push(end);

					this.setSelection(nodes);
				}else{
					if( this.selection[ node.id ] && multi ){
						this.removeTreeNode( node );
					}else if(multi){
						this.addTreeNode(node, true);
					}else{
						this.setSelection([node]);
						this.anchor = node;
					}
				}
			}
		},

		getItem: function(/*String*/ key){
			// summary:
			//		Returns the dojo.dnd.Item (representing a dragged node) by it's key (id).
			//		Called by dojo.dnd.Source.checkAcceptance().
			// tags:
			//		protected

			var widget = this.selection[key];
			return {
				data: widget,
				type: ["treeNode"]
			}; // dojo.dnd.Item
		},

		forInSelectedItems: function(/*Function*/ f, /*Object?*/ o){
			// summary:
			//		Iterates over selected items;
			//		see `dojo.dnd.Container.forInItems()` for details
			o = o || win.global;
			for(var id in this.selection){
				// console.log("selected item id: " + id);
				f.call(o, this.getItem(id), id, this);
			}
		}
	});
});

},
'dijit/_Container':function(){
define("dijit/_Container", [
	"dojo/_base/array", // array.forEach array.indexOf
	"dojo/_base/declare", // declare
	"dojo/dom-construct", // domConstruct.place
	"./registry"	// registry.byNode()
], function(array, declare, domConstruct, registry){

	// module:
	//		dijit/_Container
	// summary:
	//		Mixin for widgets that contain a set of widget children.

	return declare("dijit._Container", null, {
		// summary:
		//		Mixin for widgets that contain a set of widget children.
		// description:
		//		Use this mixin for widgets that needs to know about and
		//		keep track of their widget children. Suitable for widgets like BorderContainer
		//		and TabContainer which contain (only) a set of child widgets.
		//
		//		It's not suitable for widgets like ContentPane
		//		which contains mixed HTML (plain DOM nodes in addition to widgets),
		//		and where contained widgets are not necessarily directly below
		//		this.containerNode.   In that case calls like addChild(node, position)
		//		wouldn't make sense.

		buildRendering: function(){
			this.inherited(arguments);
			if(!this.containerNode){
				// all widgets with descendants must set containerNode
	 			this.containerNode = this.domNode;
			}
		},

		addChild: function(/*dijit._Widget*/ widget, /*int?*/ insertIndex){
			// summary:
			//		Makes the given widget a child of this widget.
			// description:
			//		Inserts specified child widget's dom node as a child of this widget's
			//		container node, and possibly does other processing (such as layout).

			var refNode = this.containerNode;
			if(insertIndex && typeof insertIndex == "number"){
				var children = this.getChildren();
				if(children && children.length >= insertIndex){
					refNode = children[insertIndex-1].domNode;
					insertIndex = "after";
				}
			}
			domConstruct.place(widget.domNode, refNode, insertIndex);

			// If I've been started but the child widget hasn't been started,
			// start it now.  Make sure to do this after widget has been
			// inserted into the DOM tree, so it can see that it's being controlled by me,
			// so it doesn't try to size itself.
			if(this._started && !widget._started){
				widget.startup();
			}
		},

		removeChild: function(/*Widget|int*/ widget){
			// summary:
			//		Removes the passed widget instance from this widget but does
			//		not destroy it.  You can also pass in an integer indicating
			//		the index within the container to remove

			if(typeof widget == "number"){
				widget = this.getChildren()[widget];
			}

			if(widget){
				var node = widget.domNode;
				if(node && node.parentNode){
					node.parentNode.removeChild(node); // detach but don't destroy
				}
			}
		},

		hasChildren: function(){
			// summary:
			//		Returns true if widget has children, i.e. if this.containerNode contains something.
			return this.getChildren().length > 0;	// Boolean
		},

		_getSiblingOfChild: function(/*dijit._Widget*/ child, /*int*/ dir){
			// summary:
			//		Get the next or previous widget sibling of child
			// dir:
			//		if 1, get the next sibling
			//		if -1, get the previous sibling
			// tags:
			//      private
			var node = child.domNode,
				which = (dir>0 ? "nextSibling" : "previousSibling");
			do{
				node = node[which];
			}while(node && (node.nodeType != 1 || !registry.byNode(node)));
			return node && registry.byNode(node);	// dijit._Widget
		},

		getIndexOfChild: function(/*dijit._Widget*/ child){
			// summary:
			//		Gets the index of the child in this container or -1 if not found
			return array.indexOf(this.getChildren(), child);	// int
		}
	});
});

},
'dojo/data/ItemFileReadStore':function(){
define("dojo/data/ItemFileReadStore", ["../_base/kernel", "../_base/lang", "../_base/declare", "../_base/array", "../_base/xhr", 
	"../Evented", "../_base/window", "./util/filter", "./util/simpleFetch", "../date/stamp"
], function(kernel, lang, declare, array, xhr, Evented, window, filterUtil, simpleFetch, dateStamp) {
	// module:
	//		dojo/data/ItemFileReadStore
	// summary:
	//		TODOC


var ItemFileReadStore = declare("dojo.data.ItemFileReadStore", [Evented],{
	//	summary:
	//		The ItemFileReadStore implements the dojo.data.api.Read API and reads
	//		data from JSON files that have contents in this format --
	//		{ items: [
	//			{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	//			{ name:'Fozzie Bear', wears:['hat', 'tie']},
	//			{ name:'Miss Piggy', pets:'Foo-Foo'}
	//		]}
	//		Note that it can also contain an 'identifer' property that specified which attribute on the items
	//		in the array of items that acts as the unique identifier for that item.
	//
	constructor: function(/* Object */ keywordParameters){
		//	summary: constructor
		//	keywordParameters: {url: String}
		//	keywordParameters: {data: jsonObject}
		//	keywordParameters: {typeMap: object)
		//		The structure of the typeMap object is as follows:
		//		{
		//			type0: function || object,
		//			type1: function || object,
		//			...
		//			typeN: function || object
		//		}
		//		Where if it is a function, it is assumed to be an object constructor that takes the
		//		value of _value as the initialization parameters.  If it is an object, then it is assumed
		//		to be an object of general form:
		//		{
		//			type: function, //constructor.
		//			deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
		//		}

		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = [];
		this._loadFinished = false;
		this._jsonFileUrl = keywordParameters.url;
		this._ccUrl = keywordParameters.url;
		this.url = keywordParameters.url;
		this._jsonData = keywordParameters.data;
		this.data = null;
		this._datatypeMap = keywordParameters.typeMap || {};
		if(!this._datatypeMap['Date']){
			//If no default mapping for dates, then set this as default.
			//We use the dojo.date.stamp here because the ISO format is the 'dojo way'
			//of generically representing dates.
			this._datatypeMap['Date'] = {
											type: Date,
											deserialize: function(value){
												return dateStamp.fromISOString(value);
											}
										};
		}
		this._features = {'dojo.data.api.Read':true, 'dojo.data.api.Identity':true};
		this._itemsByIdentity = null;
		this._storeRefPropName = "_S"; // Default name for the store reference to attach to every item.
		this._itemNumPropName = "_0"; // Default Item Id for isItem to attach to every item.
		this._rootItemPropName = "_RI"; // Default Item Id for isItem to attach to every item.
		this._reverseRefMap = "_RRM"; // Default attribute for constructing a reverse reference map for use with reference integrity
		this._loadInProgress = false; //Got to track the initial load to prevent duelling loads of the dataset.
		this._queuedFetches = [];
		if(keywordParameters.urlPreventCache !== undefined){
			this.urlPreventCache = keywordParameters.urlPreventCache?true:false;
		}
		if(keywordParameters.hierarchical !== undefined){
			this.hierarchical = keywordParameters.hierarchical?true:false;
		}
		if(keywordParameters.clearOnClose){
			this.clearOnClose = true;
		}
		if("failOk" in keywordParameters){
			this.failOk = keywordParameters.failOk?true:false;
		}
	},

	url: "",	// use "" rather than undefined for the benefit of the parser (#3539)

	//Internal var, crossCheckUrl.  Used so that setting either url or _jsonFileUrl, can still trigger a reload
	//when clearOnClose and close is used.
	_ccUrl: "",

	data: null,	// define this so that the parser can populate it

	typeMap: null, //Define so parser can populate.

	//Parameter to allow users to specify if a close call should force a reload or not.
	//By default, it retains the old behavior of not clearing if close is called.  But
	//if set true, the store will be reset to default state.  Note that by doing this,
	//all item handles will become invalid and a new fetch must be issued.
	clearOnClose: false,

	//Parameter to allow specifying if preventCache should be passed to the xhrGet call or not when loading data from a url.
	//Note this does not mean the store calls the server on each fetch, only that the data load has preventCache set as an option.
	//Added for tracker: #6072
	urlPreventCache: false,

	//Parameter for specifying that it is OK for the xhrGet call to fail silently.
	failOk: false,

	//Parameter to indicate to process data from the url as hierarchical
	//(data items can contain other data items in js form).  Default is true
	//for backwards compatibility.  False means only root items are processed
	//as items, all child objects outside of type-mapped objects and those in
	//specific reference format, are left straight JS data objects.
	hierarchical: true,

	_assertIsItem: function(/* item */ item){
		//	summary:
		//		This function tests whether the item passed in is indeed an item in the store.
		//	item:
		//		The item to test for being contained by the store.
		if(!this.isItem(item)){
			throw new Error("dojo.data.ItemFileReadStore: Invalid item argument.");
		}
	},

	_assertIsAttribute: function(/* attribute-name-string */ attribute){
		//	summary:
		//		This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.
		//	attribute:
		//		The attribute to test for being contained by the store.
		if(typeof attribute !== "string"){
			throw new Error("dojo.data.ItemFileReadStore: Invalid attribute argument.");
		}
	},

	getValue: function(	/* item */ item,
						/* attribute-name-string */ attribute,
						/* value? */ defaultValue){
		//	summary:
		//		See dojo.data.api.Read.getValue()
		var values = this.getValues(item, attribute);
		return (values.length > 0)?values[0]:defaultValue; // mixed
	},

	getValues: function(/* item */ item,
						/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.getValues()

		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		// Clone it before returning.  refs: #10474
		return (item[attribute] || []).slice(0); // Array
	},

	getAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getAttributes()
		this._assertIsItem(item);
		var attributes = [];
		for(var key in item){
			// Save off only the real item attributes, not the special id marks for O(1) isItem.
			if((key !== this._storeRefPropName) && (key !== this._itemNumPropName) && (key !== this._rootItemPropName) && (key !== this._reverseRefMap)){
				attributes.push(key);
			}
		}
		return attributes; // Array
	},

	hasAttribute: function(	/* item */ item,
							/* attribute-name-string */ attribute){
		//	summary:
		//		See dojo.data.api.Read.hasAttribute()
		this._assertIsItem(item);
		this._assertIsAttribute(attribute);
		return (attribute in item);
	},

	containsValue: function(/* item */ item,
							/* attribute-name-string */ attribute,
							/* anything */ value){
		//	summary:
		//		See dojo.data.api.Read.containsValue()
		var regexp = undefined;
		if(typeof value === "string"){
			regexp = filterUtil.patternToRegExp(value, false);
		}
		return this._containsValue(item, attribute, value, regexp); //boolean.
	},

	_containsValue: function(	/* item */ item,
								/* attribute-name-string */ attribute,
								/* anything */ value,
								/* RegExp?*/ regexp){
		//	summary:
		//		Internal function for looking at the values contained by the item.
		//	description:
		//		Internal function for looking at the values contained by the item.  This
		//		function allows for denoting if the comparison should be case sensitive for
		//		strings or not (for handling filtering cases where string case should not matter)
		//
		//	item:
		//		The data item to examine for attribute values.
		//	attribute:
		//		The attribute to inspect.
		//	value:
		//		The value to match.
		//	regexp:
		//		Optional regular expression generated off value if value was of string type to handle wildcarding.
		//		If present and attribute values are string, then it can be used for comparison instead of 'value'
		return array.some(this.getValues(item, attribute), function(possibleValue){
			if(possibleValue !== null && !lang.isObject(possibleValue) && regexp){
				if(possibleValue.toString().match(regexp)){
					return true; // Boolean
				}
			}else if(value === possibleValue){
				return true; // Boolean
			}
		});
	},

	isItem: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItem()
		if(something && something[this._storeRefPropName] === this){
			if(this._arrayOfAllItems[something[this._itemNumPropName]] === something){
				return true;
			}
		}
		return false; // Boolean
	},

	isItemLoaded: function(/* anything */ something){
		//	summary:
		//		See dojo.data.api.Read.isItemLoaded()
		return this.isItem(something); //boolean
	},

	loadItem: function(/* object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Read.loadItem()
		this._assertIsItem(keywordArgs.item);
	},

	getFeatures: function(){
		//	summary:
		//		See dojo.data.api.Read.getFeatures()
		return this._features; //Object
	},

	getLabel: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabel()
		if(this._labelAttr && this.isItem(item)){
			return this.getValue(item,this._labelAttr); //String
		}
		return undefined; //undefined
	},

	getLabelAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Read.getLabelAttributes()
		if(this._labelAttr){
			return [this._labelAttr]; //array
		}
		return null; //null
	},

	_fetchItems: function(	/* Object */ keywordArgs,
							/* Function */ findCallback,
							/* Function */ errorCallback){
		//	summary:
		//		See dojo.data.util.simpleFetch.fetch()
		var self = this,
		    filter = function(requestArgs, arrayOfItems){
			var items = [],
			    i, key;
			if(requestArgs.query){
				var value,
				    ignoreCase = requestArgs.queryOptions ? requestArgs.queryOptions.ignoreCase : false;

				//See if there are any string values that can be regexp parsed first to avoid multiple regexp gens on the
				//same value for each item examined.  Much more efficient.
				var regexpList = {};
				for(key in requestArgs.query){
					value = requestArgs.query[key];
					if(typeof value === "string"){
						regexpList[key] = filterUtil.patternToRegExp(value, ignoreCase);
					}else if(value instanceof RegExp){
						regexpList[key] = value;
					}
				}
				for(i = 0; i < arrayOfItems.length; ++i){
					var match = true;
					var candidateItem = arrayOfItems[i];
					if(candidateItem === null){
						match = false;
					}else{
						for(key in requestArgs.query){
							value = requestArgs.query[key];
							if(!self._containsValue(candidateItem, key, value, regexpList[key])){
								match = false;
							}
						}
					}
					if(match){
						items.push(candidateItem);
					}
				}
				findCallback(items, requestArgs);
			}else{
				// We want a copy to pass back in case the parent wishes to sort the array.
				// We shouldn't allow resort of the internal list, so that multiple callers
				// can get lists and sort without affecting each other.  We also need to
				// filter out any null values that have been left as a result of deleteItem()
				// calls in ItemFileWriteStore.
				for(i = 0; i < arrayOfItems.length; ++i){
					var item = arrayOfItems[i];
					if(item !== null){
						items.push(item);
					}
				}
				findCallback(items, requestArgs);
			}
		};

		if(this._loadFinished){
			filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
		}else{
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				kernel.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){
				//If fetches come in before the loading has finished, but while
				//a load is in progress, we have to defer the fetching to be
				//invoked in the callback.
				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs, filter: filter});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
						};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;

							filter(keywordArgs, self._getItemsArray(keywordArgs.queryOptions));
							self._handleQueuedFetches();
						}catch(e){
							self._loadFinished = true;
							self._loadInProgress = false;
							errorCallback(e, keywordArgs);
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						errorCallback(error, keywordArgs);
					});

					//Wire up the cancel to abort of the request
					//This call cancel on the deferred if it hasn't been called
					//yet and then will chain to the simple abort of the
					//simpleFetch keywordArgs
					var oldAbort = null;
					if(keywordArgs.abort){
						oldAbort = keywordArgs.abort;
					}
					keywordArgs.abort = function(){
						var df = getHandler;
						if(df && df.fired === -1){
							df.cancel();
							df = null;
						}
						if(oldAbort){
							oldAbort.call(keywordArgs);
						}
					};
				}
			}else if(this._jsonData){
				try{
					this._loadFinished = true;
					this._getItemsFromLoadedData(this._jsonData);
					this._jsonData = null;
					filter(keywordArgs, this._getItemsArray(keywordArgs.queryOptions));
				}catch(e){
					errorCallback(e, keywordArgs);
				}
			}else{
				errorCallback(new Error("dojo.data.ItemFileReadStore: No JSON source data was provided as either URL or a nested Javascript object."), keywordArgs);
			}
		}
	},

	_handleQueuedFetches: function(){
		//	summary:
		//		Internal function to execute delayed request in the store.
		//Execute any deferred fetches now.
		if(this._queuedFetches.length > 0){
			for(var i = 0; i < this._queuedFetches.length; i++){
				var fData = this._queuedFetches[i],
				    delayedQuery = fData.args,
				    delayedFilter = fData.filter;
				if(delayedFilter){
					delayedFilter(delayedQuery, this._getItemsArray(delayedQuery.queryOptions));
				}else{
					this.fetchItemByIdentity(delayedQuery);
				}
			}
			this._queuedFetches = [];
		}
	},

	_getItemsArray: function(/*object?*/queryOptions){
		//	summary:
		//		Internal function to determine which list of items to search over.
		//	queryOptions: The query options parameter, if any.
		if(queryOptions && queryOptions.deep){
			return this._arrayOfAllItems;
		}
		return this._arrayOfTopLevelItems;
	},

	close: function(/*dojo.data.api.Request || keywordArgs || null */ request){
		 //	summary:
		 //		See dojo.data.api.Read.close()
		 if(this.clearOnClose &&
			this._loadFinished &&
			!this._loadInProgress){
			 //Reset all internalsback to default state.  This will force a reload
			 //on next fetch.  This also checks that the data or url param was set
			 //so that the store knows it can get data.  Without one of those being set,
			 //the next fetch will trigger an error.

			 if(((this._jsonFileUrl == "" || this._jsonFileUrl == null) &&
				 (this.url == "" || this.url == null)
				) && this.data == null){
				 console.debug("dojo.data.ItemFileReadStore: WARNING!  Data reload " +
					" information has not been provided." +
					"  Please set 'url' or 'data' to the appropriate value before" +
					" the next fetch");
			 }
			 this._arrayOfAllItems = [];
			 this._arrayOfTopLevelItems = [];
			 this._loadFinished = false;
			 this._itemsByIdentity = null;
			 this._loadInProgress = false;
			 this._queuedFetches = [];
		 }
	},

	_getItemsFromLoadedData: function(/* Object */ dataObject){
		//	summary:
		//		Function to parse the loaded data into item format and build the internal items array.
		//	description:
		//		Function to parse the loaded data into item format and build the internal items array.
		//
		//	dataObject:
		//		The JS data object containing the raw data to convery into item format.
		//
		// 	returns: array
		//		Array of items in store item format.

		// First, we define a couple little utility functions...
		var addingArrays = false,
		    self = this;

		function valueIsAnItem(/* anything */ aValue){
			// summary:
			//		Given any sort of value that could be in the raw json data,
			//		return true if we should interpret the value as being an
			//		item itself, rather than a literal value or a reference.
			// example:
			// 	|	false == valueIsAnItem("Kermit");
			// 	|	false == valueIsAnItem(42);
			// 	|	false == valueIsAnItem(new Date());
			// 	|	false == valueIsAnItem({_type:'Date', _value:'1802-05-14'});
			// 	|	false == valueIsAnItem({_reference:'Kermit'});
			// 	|	true == valueIsAnItem({name:'Kermit', color:'green'});
			// 	|	true == valueIsAnItem({iggy:'pop'});
			// 	|	true == valueIsAnItem({foo:42});
			return (aValue !== null) &&
				(typeof aValue === "object") &&
				(!lang.isArray(aValue) || addingArrays) &&
				(!lang.isFunction(aValue)) &&
				(aValue.constructor == Object || lang.isArray(aValue)) &&
				(typeof aValue._reference === "undefined") &&
				(typeof aValue._type === "undefined") &&
				(typeof aValue._value === "undefined") &&
				self.hierarchical;
		}

		function addItemAndSubItemsToArrayOfAllItems(/* Item */ anItem){
			self._arrayOfAllItems.push(anItem);
			for(var attribute in anItem){
				var valueForAttribute = anItem[attribute];
				if(valueForAttribute){
					if(lang.isArray(valueForAttribute)){
						var valueArray = valueForAttribute;
						for(var k = 0; k < valueArray.length; ++k){
							var singleValue = valueArray[k];
							if(valueIsAnItem(singleValue)){
								addItemAndSubItemsToArrayOfAllItems(singleValue);
							}
						}
					}else{
						if(valueIsAnItem(valueForAttribute)){
							addItemAndSubItemsToArrayOfAllItems(valueForAttribute);
						}
					}
				}
			}
		}

		this._labelAttr = dataObject.label;

		// We need to do some transformations to convert the data structure
		// that we read from the file into a format that will be convenient
		// to work with in memory.

		// Step 1: Walk through the object hierarchy and build a list of all items
		var i,
		    item;
		this._arrayOfAllItems = [];
		this._arrayOfTopLevelItems = dataObject.items;

		for(i = 0; i < this._arrayOfTopLevelItems.length; ++i){
			item = this._arrayOfTopLevelItems[i];
			if(lang.isArray(item)){
				addingArrays = true;
			}
			addItemAndSubItemsToArrayOfAllItems(item);
			item[this._rootItemPropName]=true;
		}

		// Step 2: Walk through all the attribute values of all the items,
		// and replace single values with arrays.  For example, we change this:
		//		{ name:'Miss Piggy', pets:'Foo-Foo'}
		// into this:
		//		{ name:['Miss Piggy'], pets:['Foo-Foo']}
		//
		// We also store the attribute names so we can validate our store
		// reference and item id special properties for the O(1) isItem
		var allAttributeNames = {},
		    key;

		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			for(key in item){
				if(key !== this._rootItemPropName){
					var value = item[key];
					if(value !== null){
						if(!lang.isArray(value)){
							item[key] = [value];
						}
					}else{
						item[key] = [null];
					}
				}
				allAttributeNames[key]=key;
			}
		}

		// Step 3: Build unique property names to use for the _storeRefPropName and _itemNumPropName
		// This should go really fast, it will generally never even run the loop.
		while(allAttributeNames[this._storeRefPropName]){
			this._storeRefPropName += "_";
		}
		while(allAttributeNames[this._itemNumPropName]){
			this._itemNumPropName += "_";
		}
		while(allAttributeNames[this._reverseRefMap]){
			this._reverseRefMap += "_";
		}

		// Step 4: Some data files specify an optional 'identifier', which is
		// the name of an attribute that holds the identity of each item.
		// If this data file specified an identifier attribute, then build a
		// hash table of items keyed by the identity of the items.
		var arrayOfValues;

		var identifier = dataObject.identifier;
		if(identifier){
			this._itemsByIdentity = {};
			this._features['dojo.data.api.Identity'] = identifier;
			for(i = 0; i < this._arrayOfAllItems.length; ++i){
				item = this._arrayOfAllItems[i];
				arrayOfValues = item[identifier];
				var identity = arrayOfValues[0];
				if(!Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
					this._itemsByIdentity[identity] = item;
				}else{
					if(this._jsonFileUrl){
						throw new Error("dojo.data.ItemFileReadStore:  The json data as specified by: [" + this._jsonFileUrl + "] is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}else if(this._jsonData){
						throw new Error("dojo.data.ItemFileReadStore:  The json data provided by the creation arguments is malformed.  Items within the list have identifier: [" + identifier + "].  Value collided: [" + identity + "]");
					}
				}
			}
		}else{
			this._features['dojo.data.api.Identity'] = Number;
		}

		// Step 5: Walk through all the items, and set each item's properties
		// for _storeRefPropName and _itemNumPropName, so that store.isItem() will return true.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i];
			item[this._storeRefPropName] = this;
			item[this._itemNumPropName] = i;
		}

		// Step 6: We walk through all the attribute values of all the items,
		// looking for type/value literals and item-references.
		//
		// We replace item-references with pointers to items.  For example, we change:
		//		{ name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
		// into this:
		//		{ name:['Kermit'], friends:[miss_piggy] }
		// (where miss_piggy is the object representing the 'Miss Piggy' item).
		//
		// We replace type/value pairs with typed-literals.  For example, we change:
		//		{ name:['Nelson Mandela'], born:[{_type:'Date', _value:'1918-07-18'}] }
		// into this:
		//		{ name:['Kermit'], born:(new Date(1918, 6, 18)) }
		//
		// We also generate the associate map for all items for the O(1) isItem function.
		for(i = 0; i < this._arrayOfAllItems.length; ++i){
			item = this._arrayOfAllItems[i]; // example: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
			for(key in item){
				arrayOfValues = item[key]; // example: [{_reference:{name:'Miss Piggy'}}]
				for(var j = 0; j < arrayOfValues.length; ++j){
					value = arrayOfValues[j]; // example: {_reference:{name:'Miss Piggy'}}
					if(value !== null && typeof value == "object"){
						if(("_type" in value) && ("_value" in value)){
							var type = value._type; // examples: 'Date', 'Color', or 'ComplexNumber'
							var mappingObj = this._datatypeMap[type]; // examples: Date, dojo.Color, foo.math.ComplexNumber, {type: dojo.Color, deserialize(value){ return new dojo.Color(value)}}
							if(!mappingObj){
								throw new Error("dojo.data.ItemFileReadStore: in the typeMap constructor arg, no object class was specified for the datatype '" + type + "'");
							}else if(lang.isFunction(mappingObj)){
								arrayOfValues[j] = new mappingObj(value._value);
							}else if(lang.isFunction(mappingObj.deserialize)){
								arrayOfValues[j] = mappingObj.deserialize(value._value);
							}else{
								throw new Error("dojo.data.ItemFileReadStore: Value provided in typeMap was neither a constructor, nor a an object with a deserialize function");
							}
						}
						if(value._reference){
							var referenceDescription = value._reference; // example: {name:'Miss Piggy'}
							if(!lang.isObject(referenceDescription)){
								// example: 'Miss Piggy'
								// from an item like: { name:['Kermit'], friends:[{_reference:'Miss Piggy'}]}
								arrayOfValues[j] = this._getItemByIdentity(referenceDescription);
							}else{
								// example: {name:'Miss Piggy'}
								// from an item like: { name:['Kermit'], friends:[{_reference:{name:'Miss Piggy'}}] }
								for(var k = 0; k < this._arrayOfAllItems.length; ++k){
									var candidateItem = this._arrayOfAllItems[k],
									    found = true;
									for(var refKey in referenceDescription){
										if(candidateItem[refKey] != referenceDescription[refKey]){
											found = false;
										}
									}
									if(found){
										arrayOfValues[j] = candidateItem;
									}
								}
							}
							if(this.referenceIntegrity){
								var refItem = arrayOfValues[j];
								if(this.isItem(refItem)){
									this._addReferenceToMap(refItem, item, key);
								}
							}
						}else if(this.isItem(value)){
							//It's a child item (not one referenced through _reference).
							//We need to treat this as a referenced item, so it can be cleaned up
							//in a write store easily.
							if(this.referenceIntegrity){
								this._addReferenceToMap(value, item, key);
							}
						}
					}
				}
			}
		}
	},

	_addReferenceToMap: function(/*item*/ refItem, /*item*/ parentItem, /*string*/ attribute){
		 //	summary:
		 //		Method to add an reference map entry for an item and attribute.
		 //	description:
		 //		Method to add an reference map entry for an item and attribute. 		 //
		 //	refItem:
		 //		The item that is referenced.
		 //	parentItem:
		 //		The item that holds the new reference to refItem.
		 //	attribute:
		 //		The attribute on parentItem that contains the new reference.

		 //Stub function, does nothing.  Real processing is in ItemFileWriteStore.
	},

	getIdentity: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentity()
		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			return item[this._itemNumPropName]; // Number
		}else{
			var arrayOfValues = item[identifier];
			if(arrayOfValues){
				return arrayOfValues[0]; // Object || String
			}
		}
		return null; // null
	},

	fetchItemByIdentity: function(/* Object */ keywordArgs){
		//	summary:
		//		See dojo.data.api.Identity.fetchItemByIdentity()

		// Hasn't loaded yet, we have to trigger the load.
		var item,
		    scope;
		if(!this._loadFinished){
			var self = this;
			//Do a check on the JsonFileUrl and crosscheck it.
			//If it doesn't match the cross-check, it needs to be updated
			//This allows for either url or _jsonFileUrl to he changed to
			//reset the store load location.  Done this way for backwards
			//compatibility.  People use _jsonFileUrl (even though officially
			//private.
			if(this._jsonFileUrl !== this._ccUrl){
				kernel.deprecated("dojo.data.ItemFileReadStore: ",
					"To change the url, set the url property of the store," +
					" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
				this._ccUrl = this._jsonFileUrl;
				this.url = this._jsonFileUrl;
			}else if(this.url !== this._ccUrl){
				this._jsonFileUrl = this.url;
				this._ccUrl = this.url;
			}

			//See if there was any forced reset of data.
			if(this.data != null && this._jsonData == null){
				this._jsonData = this.data;
				this.data = null;
			}

			if(this._jsonFileUrl){

				if(this._loadInProgress){
					this._queuedFetches.push({args: keywordArgs});
				}else{
					this._loadInProgress = true;
					var getArgs = {
							url: self._jsonFileUrl,
							handleAs: "json-comment-optional",
							preventCache: this.urlPreventCache,
							failOk: this.failOk
					};
					var getHandler = xhr.get(getArgs);
					getHandler.addCallback(function(data){
						var scope = keywordArgs.scope?keywordArgs.scope:window.global;
						try{
							self._getItemsFromLoadedData(data);
							self._loadFinished = true;
							self._loadInProgress = false;
							item = self._getItemByIdentity(keywordArgs.identity);
							if(keywordArgs.onItem){
								keywordArgs.onItem.call(scope, item);
							}
							self._handleQueuedFetches();
						}catch(error){
							self._loadInProgress = false;
							if(keywordArgs.onError){
								keywordArgs.onError.call(scope, error);
							}
						}
					});
					getHandler.addErrback(function(error){
						self._loadInProgress = false;
						if(keywordArgs.onError){
							var scope = keywordArgs.scope?keywordArgs.scope:window.global;
							keywordArgs.onError.call(scope, error);
						}
					});
				}

			}else if(this._jsonData){
				// Passed in data, no need to xhr.
				self._getItemsFromLoadedData(self._jsonData);
				self._jsonData = null;
				self._loadFinished = true;
				item = self._getItemByIdentity(keywordArgs.identity);
				if(keywordArgs.onItem){
					scope = keywordArgs.scope?keywordArgs.scope:window.global;
					keywordArgs.onItem.call(scope, item);
				}
			}
		}else{
			// Already loaded.  We can just look it up and call back.
			item = this._getItemByIdentity(keywordArgs.identity);
			if(keywordArgs.onItem){
				scope = keywordArgs.scope?keywordArgs.scope:window.global;
				keywordArgs.onItem.call(scope, item);
			}
		}
	},

	_getItemByIdentity: function(/* Object */ identity){
		//	summary:
		//		Internal function to look an item up by its identity map.
		var item = null;
		if(this._itemsByIdentity){
			// If this map is defined, we need to just try to get it.  If it fails
			// the item does not exist.
			if(Object.hasOwnProperty.call(this._itemsByIdentity, identity)){
				item = this._itemsByIdentity[identity];
			}
		}else if (Object.hasOwnProperty.call(this._arrayOfAllItems, identity)){
			item = this._arrayOfAllItems[identity];
		}
		if(item === undefined){
			item = null;
		}
		return item; // Object
	},

	getIdentityAttributes: function(/* item */ item){
		//	summary:
		//		See dojo.data.api.Identity.getIdentityAttributes()

		var identifier = this._features['dojo.data.api.Identity'];
		if(identifier === Number){
			// If (identifier === Number) it means getIdentity() just returns
			// an integer item-number for each item.  The dojo.data.api.Identity
			// spec says we need to return null if the identity is not composed
			// of attributes
			return null; // null
		}else{
			return [identifier]; // Array
		}
	},

	_forceLoad: function(){
		//	summary:
		//		Internal function to force a load of the store if it hasn't occurred yet.  This is required
		//		for specific functions to work properly.
		var self = this;
		//Do a check on the JsonFileUrl and crosscheck it.
		//If it doesn't match the cross-check, it needs to be updated
		//This allows for either url or _jsonFileUrl to he changed to
		//reset the store load location.  Done this way for backwards
		//compatibility.  People use _jsonFileUrl (even though officially
		//private.
		if(this._jsonFileUrl !== this._ccUrl){
			kernel.deprecated("dojo.data.ItemFileReadStore: ",
				"To change the url, set the url property of the store," +
				" not _jsonFileUrl.  _jsonFileUrl support will be removed in 2.0");
			this._ccUrl = this._jsonFileUrl;
			this.url = this._jsonFileUrl;
		}else if(this.url !== this._ccUrl){
			this._jsonFileUrl = this.url;
			this._ccUrl = this.url;
		}

		//See if there was any forced reset of data.
		if(this.data != null){
			this._jsonData = this.data;
			this.data = null;
		}

		if(this._jsonFileUrl){
				var getArgs = {
					url: this._jsonFileUrl,
					handleAs: "json-comment-optional",
					preventCache: this.urlPreventCache,
					failOk: this.failOk,
					sync: true
				};
			var getHandler = xhr.get(getArgs);
			getHandler.addCallback(function(data){
				try{
					//Check to be sure there wasn't another load going on concurrently
					//So we don't clobber data that comes in on it.  If there is a load going on
					//then do not save this data.  It will potentially clobber current data.
					//We mainly wanted to sync/wait here.
					//TODO:  Revisit the loading scheme of this store to improve multi-initial
					//request handling.
					if(self._loadInProgress !== true && !self._loadFinished){
						self._getItemsFromLoadedData(data);
						self._loadFinished = true;
					}else if(self._loadInProgress){
						//Okay, we hit an error state we can't recover from.  A forced load occurred
						//while an async load was occurring.  Since we cannot block at this point, the best
						//that can be managed is to throw an error.
						throw new Error("dojo.data.ItemFileReadStore:  Unable to perform a synchronous load, an async load is in progress.");
					}
				}catch(e){
					console.log(e);
					throw e;
				}
			});
			getHandler.addErrback(function(error){
				throw error;
			});
		}else if(this._jsonData){
			self._getItemsFromLoadedData(self._jsonData);
			self._jsonData = null;
			self._loadFinished = true;
		}
	}
});
//Mix in the simple fetch implementation to this class.
lang.extend(ItemFileReadStore,simpleFetch);

return ItemFileReadStore;
});

},
'dojo/dnd/Source':function(){
define("dojo/dnd/Source", ["../main", "./Selector", "./Manager"], function(dojo, Selector, Manager) {
	// module:
	//		dojo/dnd/Source
	// summary:
	//		TODOC

/*=====
Selector = dojo.dnd.Selector;
=====*/

/*
	Container property:
		"Horizontal"- if this is the horizontal container
	Source states:
		""			- normal state
		"Moved"		- this source is being moved
		"Copied"	- this source is being copied
	Target states:
		""			- normal state
		"Disabled"	- the target cannot accept an avatar
	Target anchor state:
		""			- item is not selected
		"Before"	- insert point is before the anchor
		"After"		- insert point is after the anchor
*/

/*=====
dojo.dnd.__SourceArgs = function(){
	//	summary:
	//		a dict of parameters for DnD Source configuration. Note that any
	//		property on Source elements may be configured, but this is the
	//		short-list
	//	isSource: Boolean?
	//		can be used as a DnD source. Defaults to true.
	//	accept: Array?
	//		list of accepted types (text strings) for a target; defaults to
	//		["text"]
	//	autoSync: Boolean
	//		if true refreshes the node list on every operation; false by default
	//	copyOnly: Boolean?
	//		copy items, if true, use a state of Ctrl key otherwise,
	//		see selfCopy and selfAccept for more details
	//	delay: Number
	//		the move delay in pixels before detecting a drag; 0 by default
	//	horizontal: Boolean?
	//		a horizontal container, if true, vertical otherwise or when omitted
	//	selfCopy: Boolean?
	//		copy items by default when dropping on itself,
	//		false by default, works only if copyOnly is true
	//	selfAccept: Boolean?
	//		accept its own items when copyOnly is true,
	//		true by default, works only if copyOnly is true
	//	withHandles: Boolean?
	//		allows dragging only by handles, false by default
	//  generateText: Boolean?
	//		generate text node for drag and drop, true by default
	this.isSource = isSource;
	this.accept = accept;
	this.autoSync = autoSync;
	this.copyOnly = copyOnly;
	this.delay = delay;
	this.horizontal = horizontal;
	this.selfCopy = selfCopy;
	this.selfAccept = selfAccept;
	this.withHandles = withHandles;
	this.generateText = true;
}
=====*/

// For back-compat, remove in 2.0.
if(!dojo.isAsync){
	dojo.ready(0, function(){
		var requires = ["dojo/dnd/AutoSource", "dojo/dnd/Target"];
		require(requires);	// use indirection so modules not rolled into a build
	})
}

return dojo.declare("dojo.dnd.Source", Selector, {
	// summary:
	//		a Source object, which can be used as a DnD source, or a DnD target

	// object attributes (for markup)
	isSource: true,
	horizontal: false,
	copyOnly: false,
	selfCopy: false,
	selfAccept: true,
	skipForm: false,
	withHandles: false,
	autoSync: false,
	delay: 0, // pixels
	accept: ["text"],
	generateText: true,

	constructor: function(/*DOMNode|String*/node, /*dojo.dnd.__SourceArgs?*/params){
		// summary:
		//		a constructor of the Source
		// node:
		//		node or node's id to build the source on
		// params:
		//		any property of this class may be configured via the params
		//		object which is mixed-in to the `dojo.dnd.Source` instance
		dojo.mixin(this, dojo.mixin({}, params));
		var type = this.accept;
		if(type.length){
			this.accept = {};
			for(var i = 0; i < type.length; ++i){
				this.accept[type[i]] = 1;
			}
		}
		// class-specific variables
		this.isDragging = false;
		this.mouseDown = false;
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
		this._lastX = 0;
		this._lastY = 0;
		// states
		this.sourceState  = "";
		if(this.isSource){
			dojo.addClass(this.node, "dojoDndSource");
		}
		this.targetState  = "";
		if(this.accept){
			dojo.addClass(this.node, "dojoDndTarget");
		}
		if(this.horizontal){
			dojo.addClass(this.node, "dojoDndHorizontal");
		}
		// set up events
		this.topics = [
			dojo.subscribe("/dnd/source/over", this, "onDndSourceOver"),
			dojo.subscribe("/dnd/start",  this, "onDndStart"),
			dojo.subscribe("/dnd/drop",   this, "onDndDrop"),
			dojo.subscribe("/dnd/cancel", this, "onDndCancel")
		];
	},

	// methods
	checkAcceptance: function(source, nodes){
		// summary:
		//		checks if the target can accept nodes from this source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		if(this == source){
			return !this.copyOnly || this.selfAccept;
		}
		for(var i = 0; i < nodes.length; ++i){
			var type = source.getItem(nodes[i].id).type;
			// type instanceof Array
			var flag = false;
			for(var j = 0; j < type.length; ++j){
				if(type[j] in this.accept){
					flag = true;
					break;
				}
			}
			if(!flag){
				return false;	// Boolean
			}
		}
		return true;	// Boolean
	},
	copyState: function(keyPressed, self){
		// summary:
		//		Returns true if we need to copy items, false to move.
		//		It is separated to be overwritten dynamically, if needed.
		// keyPressed: Boolean
		//		the "copy" key was pressed
		// self: Boolean?
		//		optional flag that means that we are about to drop on itself

		if(keyPressed){ return true; }
		if(arguments.length < 2){
			self = this == Manager.manager().target;
		}
		if(self){
			if(this.copyOnly){
				return this.selfCopy;
			}
		}else{
			return this.copyOnly;
		}
		return false;	// Boolean
	},
	destroy: function(){
		// summary:
		//		prepares the object to be garbage-collected
		dojo.dnd.Source.superclass.destroy.call(this);
		dojo.forEach(this.topics, dojo.unsubscribe);
		this.targetAnchor = null;
	},

	// mouse event processors
	onMouseMove: function(e){
		// summary:
		//		event processor for onmousemove
		// e: Event
		//		mouse event
		if(this.isDragging && this.targetState == "Disabled"){ return; }
		dojo.dnd.Source.superclass.onMouseMove.call(this, e);
		var m = Manager.manager();
		if(!this.isDragging){
			if(this.mouseDown && this.isSource &&
					(Math.abs(e.pageX - this._lastX) > this.delay || Math.abs(e.pageY - this._lastY) > this.delay)){
				var nodes = this.getSelectedNodes();
				if(nodes.length){
					m.startDrag(this, nodes, this.copyState(dojo.isCopyKey(e), true));
				}
			}
		}
		if(this.isDragging){
			// calculate before/after
			var before = false;
			if(this.current){
				if(!this.targetBox || this.targetAnchor != this.current){
					this.targetBox = dojo.position(this.current, true);
				}
				if(this.horizontal){
					before = (e.pageX - this.targetBox.x) < (this.targetBox.w / 2);
				}else{
					before = (e.pageY - this.targetBox.y) < (this.targetBox.h / 2);
				}
			}
			if(this.current != this.targetAnchor || before != this.before){
				this._markTargetAnchor(before);
				m.canDrop(!this.current || m.source != this || !(this.current.id in this.selection));
			}
		}
	},
	onMouseDown: function(e){
		// summary:
		//		event processor for onmousedown
		// e: Event
		//		mouse event
		if(!this.mouseDown && this._legalMouseDown(e) && (!this.skipForm || !dojo.dnd.isFormElement(e))){
			this.mouseDown = true;
			this._lastX = e.pageX;
			this._lastY = e.pageY;
			dojo.dnd.Source.superclass.onMouseDown.call(this, e);
		}
	},
	onMouseUp: function(e){
		// summary:
		//		event processor for onmouseup
		// e: Event
		//		mouse event
		if(this.mouseDown){
			this.mouseDown = false;
			dojo.dnd.Source.superclass.onMouseUp.call(this, e);
		}
	},

	// topic event processors
	onDndSourceOver: function(source){
		// summary:
		//		topic event processor for /dnd/source/over, called when detected a current source
		// source: Object
		//		the source which has the mouse over it
		if(this != source){
			this.mouseDown = false;
			if(this.targetAnchor){
				this._unmarkTargetAnchor();
			}
		}else if(this.isDragging){
			var m = Manager.manager();
			m.canDrop(this.targetState != "Disabled" && (!this.current || m.source != this || !(this.current.id in this.selection)));
		}
	},
	onDndStart: function(source, nodes, copy){
		// summary:
		//		topic event processor for /dnd/start, called to initiate the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		if(this.autoSync){ this.sync(); }
		if(this.isSource){
			this._changeState("Source", this == source ? (copy ? "Copied" : "Moved") : "");
		}
		var accepted = this.accept && this.checkAcceptance(source, nodes);
		this._changeState("Target", accepted ? "" : "Disabled");
		if(this == source){
			Manager.manager().overSource(this);
		}
		this.isDragging = true;
	},
	onDndDrop: function(source, nodes, copy, target){
		// summary:
		//		topic event processor for /dnd/drop, called to finish the DnD operation
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise
		// target: Object
		//		the target which accepts items
		if(this == target){
			// this one is for us => move nodes!
			this.onDrop(source, nodes, copy);
		}
		this.onDndCancel();
	},
	onDndCancel: function(){
		// summary:
		//		topic event processor for /dnd/cancel, called to cancel the DnD operation
		if(this.targetAnchor){
			this._unmarkTargetAnchor();
			this.targetAnchor = null;
		}
		this.before = true;
		this.isDragging = false;
		this.mouseDown = false;
		this._changeState("Source", "");
		this._changeState("Target", "");
	},

	// local events
	onDrop: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		if(this != source){
			this.onDropExternal(source, nodes, copy);
		}else{
			this.onDropInternal(nodes, copy);
		}
	},
	onDropExternal: function(source, nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from an external source
		// source: Object
		//		the source which provides items
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		var oldCreator = this._normalizedCreator;
		// transferring nodes from the source to the target
		if(this.creator){
			// use defined creator
			this._normalizedCreator = function(node, hint){
				return oldCreator.call(this, source.getItem(node.id).data, hint);
			};
		}else{
			// we have no creator defined => move/clone nodes
			if(copy){
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}else{
				// move nodes
				this._normalizedCreator = function(node, hint){
					var t = source.getItem(node.id);
					source.delItem(node.id);
					return {node: node, data: t.data, type: t.type};
				};
			}
		}
		this.selectNone();
		if(!copy && !this.creator){
			source.selectNone();
		}
		this.insertNodes(true, nodes, this.before, this.current);
		if(!copy && this.creator){
			source.deleteSelectedNodes();
		}
		this._normalizedCreator = oldCreator;
	},
	onDropInternal: function(nodes, copy){
		// summary:
		//		called only on the current target, when drop is performed
		//		from the same target/source
		// nodes: Array
		//		the list of transferred items
		// copy: Boolean
		//		copy items, if true, move items otherwise

		var oldCreator = this._normalizedCreator;
		// transferring nodes within the single source
		if(this.current && this.current.id in this.selection){
			// do nothing
			return;
		}
		if(copy){
			if(this.creator){
				// create new copies of data items
				this._normalizedCreator = function(node, hint){
					return oldCreator.call(this, this.getItem(node.id).data, hint);
				};
			}else{
				// clone nodes
				this._normalizedCreator = function(node, hint){
					var t = this.getItem(node.id);
					var n = node.cloneNode(true);
					n.id = dojo.dnd.getUniqueId();
					return {node: n, data: t.data, type: t.type};
				};
			}
		}else{
			// move nodes
			if(!this.current){
				// do nothing
				return;
			}
			this._normalizedCreator = function(node, hint){
				var t = this.getItem(node.id);
				return {node: node, data: t.data, type: t.type};
			};
		}
		this._removeSelection();
		this.insertNodes(true, nodes, this.before, this.current);
		this._normalizedCreator = oldCreator;
	},
	onDraggingOver: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged over this target, and it is not disabled
	},
	onDraggingOut: function(){
		// summary:
		//		called during the active DnD operation, when items
		//		are dragged away from this target, and it is not disabled
	},

	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
		dojo.dnd.Source.superclass.onOverEvent.call(this);
		Manager.manager().overSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOver();
		}
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
		dojo.dnd.Source.superclass.onOutEvent.call(this);
		Manager.manager().outSource(this);
		if(this.isDragging && this.targetState != "Disabled"){
			this.onDraggingOut();
		}
	},
	_markTargetAnchor: function(before){
		// summary:
		//		assigns a class to the current target anchor based on "before" status
		// before: Boolean
		//		insert before, if true, after otherwise
		if(this.current == this.targetAnchor && this.before == before){ return; }
		if(this.targetAnchor){
			this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
		this.targetAnchor = this.current;
		this.targetBox = null;
		this.before = before;
		if(this.targetAnchor){
			this._addItemClass(this.targetAnchor, this.before ? "Before" : "After");
		}
	},
	_unmarkTargetAnchor: function(){
		// summary:
		//		removes a class of the current target anchor based on "before" status
		if(!this.targetAnchor){ return; }
		this._removeItemClass(this.targetAnchor, this.before ? "Before" : "After");
		this.targetAnchor = null;
		this.targetBox = null;
		this.before = true;
	},
	_markDndStatus: function(copy){
		// summary:
		//		changes source's state based on "copy" status
		this._changeState("Source", copy ? "Copied" : "Moved");
	},
	_legalMouseDown: function(e){
		// summary:
		//		checks if user clicked on "approved" items
		// e: Event
		//		mouse event

		// accept only the left mouse button
		if(!dojo.mouseButtons.isLeft(e)){ return false; }

		if(!this.withHandles){ return true; }

		// check for handles
		for(var node = e.target; node && node !== this.node; node = node.parentNode){
			if(dojo.hasClass(node, "dojoDndHandle")){ return true; }
			if(dojo.hasClass(node, "dojoDndItem") || dojo.hasClass(node, "dojoDndIgnore")){ break; }
		}
		return false;	// Boolean
	}
});

});

},
'dojo/html':function(){
define("dojo/html", ["./_base/kernel", "./_base/lang", "./_base/array", "./_base/declare", "./dom", "./dom-construct", "./parser"], function(dojo, lang, darray, declare, dom, domConstruct, parser) {
	// module:
	//		dojo/html
	// summary:
	//		TODOC

	lang.getObject("html", true, dojo);

	// the parser might be needed..

	// idCounter is incremented with each instantiation to allow asignment of a unique id for tracking, logging purposes
	var idCounter = 0;

	dojo.html._secureForInnerHtml = function(/*String*/ cont){
		// summary:
		//		removes !DOCTYPE and title elements from the html string.
		//
		//		khtml is picky about dom faults, you can't attach a style or <title> node as child of body
		//		must go into head, so we need to cut out those tags
		//	cont:
		//		An html string for insertion into the dom
		//
		return cont.replace(/(?:\s*<!DOCTYPE\s[^>]+>|<title[^>]*>[\s\S]*?<\/title>)/ig, ""); // String
	};

/*====
	dojo.html._emptyNode = function(node){
		// summary:
		//		removes all child nodes from the given node
		//	node: DOMNode
		//		the parent element
	};
=====*/
	dojo.html._emptyNode = domConstruct.empty;

	dojo.html._setNodeContent = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont){
		// summary:
		//		inserts the given content into the given node
		//	node:
		//		the parent element
		//	content:
		//		the content to be set on the parent element.
		//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes

		// always empty
		domConstruct.empty(node);

		if(cont) {
			if(typeof cont == "string") {
				cont = domConstruct.toDom(cont, node.ownerDocument);
			}
			if(!cont.nodeType && lang.isArrayLike(cont)) {
				// handle as enumerable, but it may shrink as we enumerate it
				for(var startlen=cont.length, i=0; i<cont.length; i=startlen==cont.length ? i+1 : 0) {
					domConstruct.place( cont[i], node, "last");
				}
			} else {
				// pass nodes, documentFragments and unknowns through to dojo.place
				domConstruct.place(cont, node, "last");
			}
		}

		// return DomNode
		return node;
	};

	// we wrap up the content-setting operation in a object
	declare("dojo.html._ContentSetter", null,
		{
			// node: DomNode|String
			//		An node which will be the parent element that we set content into
			node: "",

			// content: String|DomNode|DomNode[]
			//		The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes
			content: "",

			// id: String?
			//		Usually only used internally, and auto-generated with each instance
			id: "",

			// cleanContent: Boolean
			//		Should the content be treated as a full html document,
			//		and the real content stripped of <html>, <body> wrapper before injection
			cleanContent: false,

			// extractContent: Boolean
			//		Should the content be treated as a full html document, and the real content stripped of <html>, <body> wrapper before injection
			extractContent: false,

			// parseContent: Boolean
			//		Should the node by passed to the parser after the new content is set
			parseContent: false,

			// parserScope: String
			//		Flag passed to parser.	Root for attribute names to search for.	  If scopeName is dojo,
			//		will search for data-dojo-type (or dojoType).  For backwards compatibility
			//		reasons defaults to dojo._scopeName (which is "dojo" except when
			//		multi-version support is used, when it will be something like dojo16, dojo20, etc.)
			parserScope: dojo._scopeName,

			// startup: Boolean
			//		Start the child widgets after parsing them.	  Only obeyed if parseContent is true.
			startup: true,

			// lifecyle methods
			constructor: function(/* Object */params, /* String|DomNode */node){
				//	summary:
				//		Provides a configurable, extensible object to wrap the setting on content on a node
				//		call the set() method to actually set the content..

				// the original params are mixed directly into the instance "this"
				lang.mixin(this, params || {});

				// give precedence to params.node vs. the node argument
				// and ensure its a node, not an id string
				node = this.node = dom.byId( this.node || node );

				if(!this.id){
					this.id = [
						"Setter",
						(node) ? node.id || node.tagName : "",
						idCounter++
					].join("_");
				}
			},
			set: function(/* String|DomNode|NodeList? */ cont, /* Object? */ params){
				// summary:
				//		front-end to the set-content sequence
				//	cont:
				//		An html string, node or enumerable list of nodes for insertion into the dom
				//		If not provided, the object's content property will be used
				if(undefined !== cont){
					this.content = cont;
				}
				// in the re-use scenario, set needs to be able to mixin new configuration
				if(params){
					this._mixin(params);
				}

				this.onBegin();
				this.setContent();
				this.onEnd();

				return this.node;
			},
			setContent: function(){
				// summary:
				//		sets the content on the node

				var node = this.node;
				if(!node) {
					// can't proceed
					throw new Error(this.declaredClass + ": setContent given no node");
				}
				try{
					node = dojo.html._setNodeContent(node, this.content);
				}catch(e){
					// check if a domfault occurs when we are appending this.errorMessage
					// like for instance if domNode is a UL and we try append a DIV

					// FIXME: need to allow the user to provide a content error message string
					var errMess = this.onContentError(e);
					try{
						node.innerHTML = errMess;
					}catch(e){
						console.error('Fatal ' + this.declaredClass + '.setContent could not change content due to '+e.message, e);
					}
				}
				// always put back the node for the next method
				this.node = node; // DomNode
			},

			empty: function() {
				// summary
				//	cleanly empty out existing content

				// destroy any widgets from a previous run
				// NOTE: if you dont want this you'll need to empty
				// the parseResults array property yourself to avoid bad things happenning
				if(this.parseResults && this.parseResults.length) {
					darray.forEach(this.parseResults, function(w) {
						if(w.destroy){
							w.destroy();
						}
					});
					delete this.parseResults;
				}
				// this is fast, but if you know its already empty or safe, you could
				// override empty to skip this step
				dojo.html._emptyNode(this.node);
			},

			onBegin: function(){
				// summary
				//		Called after instantiation, but before set();
				//		It allows modification of any of the object properties
				//		- including the node and content provided - before the set operation actually takes place
				//		This default implementation checks for cleanContent and extractContent flags to
				//		optionally pre-process html string content
				var cont = this.content;

				if(lang.isString(cont)){
					if(this.cleanContent){
						cont = dojo.html._secureForInnerHtml(cont);
					}

					if(this.extractContent){
						var match = cont.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
						if(match){ cont = match[1]; }
					}
				}

				// clean out the node and any cruft associated with it - like widgets
				this.empty();

				this.content = cont;
				return this.node; /* DomNode */
			},

			onEnd: function(){
				// summary
				//		Called after set(), when the new content has been pushed into the node
				//		It provides an opportunity for post-processing before handing back the node to the caller
				//		This default implementation checks a parseContent flag to optionally run the dojo parser over the new content
				if(this.parseContent){
					// populates this.parseResults if you need those..
					this._parse();
				}
				return this.node; /* DomNode */
			},

			tearDown: function(){
				// summary
				//		manually reset the Setter instance if its being re-used for example for another set()
				// description
				//		tearDown() is not called automatically.
				//		In normal use, the Setter instance properties are simply allowed to fall out of scope
				//		but the tearDown method can be called to explicitly reset this instance.
				delete this.parseResults;
				delete this.node;
				delete this.content;
			},

			onContentError: function(err){
				return "Error occured setting content: " + err;
			},

			_mixin: function(params){
				// mix properties/methods into the instance
				// TODO: the intention with tearDown is to put the Setter's state
				// back to that of the original constructor (vs. deleting/resetting everything regardless of ctor params)
				// so we could do something here to move the original properties aside for later restoration
				var empty = {}, key;
				for(key in params){
					if(key in empty){ continue; }
					// TODO: here's our opportunity to mask the properties we dont consider configurable/overridable
					// .. but history shows we'll almost always guess wrong
					this[key] = params[key];
				}
			},
			_parse: function(){
				// summary:
				//		runs the dojo parser over the node contents, storing any results in this.parseResults
				//		Any errors resulting from parsing are passed to _onError for handling

				var rootNode = this.node;
				try{
					// store the results (widgets, whatever) for potential retrieval
					var inherited = {};
					darray.forEach(["dir", "lang", "textDir"], function(name){
						if(this[name]){
							inherited[name] = this[name];
						}
					}, this);
					this.parseResults = parser.parse({
						rootNode: rootNode,
						noStart: !this.startup,
						inherited: inherited,
						scope: this.parserScope
					});
				}catch(e){
					this._onError('Content', e, "Error parsing in _ContentSetter#"+this.id);
				}
			},

			_onError: function(type, err, consoleText){
				// summary:
				//		shows user the string that is returned by on[type]Error
				//		overide/implement on[type]Error and return your own string to customize
				var errText = this['on' + type + 'Error'].call(this, err);
				if(consoleText){
					console.error(consoleText, err);
				}else if(errText){ // a empty string won't change current content
					dojo.html._setNodeContent(this.node, errText, true);
				}
			}
	}); // end dojo.declare()

	dojo.html.set = function(/* DomNode */ node, /* String|DomNode|NodeList */ cont, /* Object? */ params){
			// summary:
			//		inserts (replaces) the given content into the given node. dojo.place(cont, node, "only")
			//		may be a better choice for simple HTML insertion.
			// description:
			//		Unless you need to use the params capabilities of this method, you should use
			//		dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
			//		an HTML string into the DOM, but it only handles inserting an HTML string as DOM
			//		elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
			//		or the other capabilities as defined by the params object for this method.
			//	node:
			//		the parent element that will receive the content
			//	cont:
			//		the content to be set on the parent element.
			//		This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes
			//	params:
			//		Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter
			//	example:
			//		A safe string/node/nodelist content replacement/injection with hooks for extension
			//		Example Usage:
			//		dojo.html.set(node, "some string");
			//		dojo.html.set(node, contentNode, {options});
			//		dojo.html.set(node, myNode.childNodes, {options});
		if(undefined == cont){
			console.warn("dojo.html.set: no cont argument provided, using empty string");
			cont = "";
		}
		if(!params){
			// simple and fast
			return dojo.html._setNodeContent(node, cont, true);
		}else{
			// more options but slower
			// note the arguments are reversed in order, to match the convention for instantiation via the parser
			var op = new dojo.html._ContentSetter(lang.mixin(
					params,
					{ content: cont, node: node }
			));
			return op.set();
		}
	};

	return dojo.html;
});

},
'ibm/tivoli/simplesrm/srm/dijit/ProgressSpinner':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dijit/_Templated,dojo/parser"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner");

dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dojo.parser");

// A class for displaying a progress spinner
//
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner", 
	[dijit._Widget, dijit._Templated],
{	
	templateString: "<div class='srmspinner' style='visibility: hidden;display:inline;'><img src='${spinnerImagePath}' alt='' style='width: 16px; height: 16px; vertical-align: middle;'><span dojoAttachPoint='label' class='srmspinnerlabel'>${text}</span></div>",
	spinnerImagePath: '',
	text: '',
	
	constructor: function(/*object*/params, /*domNode*/domNode)
	{
		console.log("ProgressSpinner.ctor");
		//this.spinnerImagePath = dojo.moduleUrl("ibm.tivoli.simplesrm.srm.dijit", "images/progress-anim.gif");
		this.spinnerImagePath = dojo.moduleUrl("ibm.tivoli.tip.dijit", "themes/images/processing-toolbar.gif");
	},
	show: function() 
	{
		console.log("showing spinner: ", this.id);
		dojo.style(this.domNode, "visibility", "visible");
	},
	hide: function() {
		dojo.style(this.domNode, "visibility", "hidden");
	}
	
});
});

},
'ibm/tivoli/simplesrm/srm/dijit/BaguetteChart':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!dijit/_Widget,dojox/gfx,dojox/color,ibm/tivoli/simplesrm/srm/dojo/SimpleSRMError"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.BaguetteChart");

dojo.require("dijit._Widget");
dojo.require("dojox.gfx");
dojo.require("dojox.color");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError");

dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.BaguetteChart", 
	[dijit._Widget],
{	
	backgroundColor: [162, 178, 202],	// the background color
	graysOnly: false,				// if true, render the data in grayscale
	barWidth: 0,					// width of the bar, not including padding
	barHeight: 20,					// height of the bar, not including padding
	captionHeight: 16,				// height of a row of the captions
	captionFontSize: 12,			// in pixels.  Should be > k
	outlineWidth: 4,				// inpixels, thickness of the graph's outline
	num_cells: 20,					// the number of cells drawn over the bar
	paddingx: 5,					// padding
	paddingy: 5,
	showLegend: true,				// do I draw the legend?
	showTotal: false,				// do I include a Total in the legend?
	totalLegend: "Total",			// replace to localize
	surface: null,					// the drawing surface
	bg_rect: null,					// the background color
	top_grp: null,					// container of everything else, transform creates the padding
	data_grp: null,					// data colored rectangles are drawn here, child of top_grp
	outline_grp: null,				// the white outline, child of top_grp
	legend_grp: null,				// group holding the data legend
	_legend_lines: 1,				// the number of lines of legend
	_clickhandlers: null,
	_data: null,					// my rendered data
	_nominalHeight: 0,				// basic height of the widget, taking into account the bar, outline and padding
	_canRender: true,				// might be false for ie + silverlight
	_domNode: null,
	
	isReady: false,
	ieCount: 1,
	
	constructor: function(/*object*/params, /*domNode*/domNode)
	{
		if(params && params.id) {
			this.id = params.id;
		}
		this.data_group = null;
		this._clickhandlers = [];
		this._domNode = domNode;
	},
	postMixInProperties: function()
	{
		// make sure the outline is wide enough to mask the corners of the data bar
		this.outlineWidth = Math.round(Math.sqrt(2*Math.pow(this.barHeight/2, 2)) - this.barHeight/2);
	},
	buildRendering: function()
	{
		this.inherited(arguments);
		if(dojo.isIE) {
			this._canRender = ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.testIEForSilverlight();
			if(this._canRender){
				dojo.style(this.domNode, "position", "relative");
			}
			else{
				dojo.style(this.domNode, "display", "none");
			}
		}
	},
	startup: function()
	{
		if(this._canRender){
			this._createSurface();
		}
		this.inherited(arguments);
	},
	_createSurface: function()
	{
		// if we haven't been given a width, size the chart to fit in its parent
		if(this.barWidth <= 0) {
			this._findBarWidth();
		}
		if(this.barWidth <= 0) {
			// at this point, this.domNode doesn't always have a size yet
			window.setTimeout(dojo.hitch(this, this._createSurface), 500);
			return;
		}

		this._nominalHeight = this.barHeight + 2*this.outlineWidth + 2*this.paddingy;
		this.surface = dojox.gfx.createSurface(this.domNode, 
									this.barWidth + 2*this.outlineWidth + 2*this.paddingx, 
									this._nominalHeight + (this.showLegend ? (this.captionHeight + this.paddingy) : 0));
		
		this.surface.whenLoaded(this, this._createGraphics);
	},
	_findBarWidth: function()
	{
		if(this.domNode) {
			var sz = dojo.contentBox(this.domNode);
			this.barWidth = sz.w - 2 * this.outlineWidth - 2 * this.paddingx;
			//Fixed : IE not able to display Baguette Chart in My Requests pod. 
			//It is not able to get Width (sz.w) from style sheet (OverviewPod) and goes infinity loop. Bellow code, sets width for IE same as FireFox does
			//if(dojo.isIE && this.domNode.id == "ibm_tivoli_simplesrm_srm_dijit_BaguetteChart_0")
			if(dojo.isIE)
			{

				if(this.ieCount > 2)
					this.barWidth = 364;
				else
					this.barWidth = -16;

				this.ieCount = this.ieCount + 1;
			}

		}
	},
	_createGraphics: function()
	{
		try {
			if(!this.surface) {
				// shouldn't be here
				throw new Error("Don't call _createGraphics yourself");
			}
	
			bg_grp = this.surface.createGroup();
			h = (this.barHeight + 2*this.outlineWidth + 2*this.paddingy) +
				 (this.showLegend ? (this.captionHeight + this.paddingy) : 0);
			this.bg_rect = bg_grp.createRect({x: 0, y: 0, 
									width: this.barWidth + 2*this.outlineWidth + 2*this.paddingx, 
									height: h});
			// FYI: if the bg_rect doesn't fill the entire space around the graph, it looks pretty bad
			//		.setFill({type: "linear", x1:0, y1: 0, x2:0, y2:h,
			//					colors: [{offset:0, color:"#F0F0F0"}, {offset:1, color:"#B3B3B3"}]})
			//		;
	
			this.top_grp = bg_grp.createGroup();
			this.top_grp.setTransform({dx: this.outlineWidth + this.paddingx, dy: this.outlineWidth + this.paddingy});	// shift the origin over to create a margin
					
			// data will go here
			this.data_grp = this.top_grp.createGroup();
			this._drawNoData();
					
			// dojox.gfx doesn't support clipping.  
			// create a mask the background color around the rounded ends
			var endcap_radius = this.barHeight/2;
			var buf = this.paddingy;
	
			// super deluxe new outline
			// TODO: should the outline gradient be a function of the background color?
			ocolora = "#f0f0f0";
			ocolorz = "#b3b3b3";
			this.outline_grp = this.top_grp.createGroup();
			this.outline_grp.createShape({type: "path"})
				.setAbsoluteMode("relative")
				.setStroke(null)
				.moveTo(this.barWidth-endcap_radius, 2*endcap_radius)
				.lineTo(-(this.barWidth-2*endcap_radius), 0)
				.arcTo(endcap_radius, endcap_radius, 0, 0, 1, 0, -2*endcap_radius)
				.lineTo(this.barWidth-2*endcap_radius, 0)
				.arcTo(endcap_radius, endcap_radius, 0, 0, 1, 0, 2*endcap_radius)
				.closePath()
				.moveTo(0, this.outlineWidth)
				.lineTo(-(this.barWidth-2*endcap_radius), 0)
				.arcTo(endcap_radius+this.outlineWidth, endcap_radius+this.outlineWidth, 0, 0, 1, 0, -2*(endcap_radius+this.outlineWidth))
				.lineTo(this.barWidth-2*endcap_radius, 0)
				.arcTo(endcap_radius+this.outlineWidth, endcap_radius+this.outlineWidth, 0, 0, 1, 0, 2*(endcap_radius+this.outlineWidth))
				.closePath()
				.setFill({type: "linear", x1:0, y1:2*(endcap_radius+this.outlineWidth), x2:0, y2:-this.outlineWidth,
							colors:[{offset:0, color:ocolora}, {offset:1, color:ocolorz}]});
				
	
	
			// the inner grid
			var cell_w = this.barWidth/this.num_cells;
			var grid = this.outline_grp.createShape({type: "path"})
				.setStroke({color: "white", style: "Solid", width: 1})
				.setAbsoluteMode("relative")
				.moveTo(cell_w, 0);
			for(var i = 0; i < this.num_cells-1; ++i) {
				grid.lineTo(0, this.barHeight).moveTo(cell_w, -this.barHeight);
			}
			
			// the legend area
			this.legend_grp = bg_grp.createGroup();
			this.isReady = true;
		}
		catch(ex) {
//			delete this.surface;
//			this.surface = null;
			console.error("BaguetteChart._createGraphics failed: ", ex);
		}
		return;
	},	
	_drawNoData: function()
	{
		try {
			this.data_grp.createShape({type: "rect", x: 0, y: 0, width: this.barWidth, height: this.barHeight})
						.setFill({type: "linear", x1: 0, y1: 0, x2: 0, y2: this.barHeight,
									colors: [{offset: 0, color: "white"}, {offset: 0.4, color: [140,140,140]}, {offset: 1, color: [200,200,200]}] });
		}
		catch(ex){
			// ie troubles
			console.log("BaguetteChart._drawNoData choked: ", ex);
		}
	},
	destroy: function()
	{
		this._disconnect();
		this.inherited(arguments);
	},
	_disconnect: function()
	{
		var h;
		while(h = this._clickhandlers.pop()) {
			if (h.name!='MouseLeftButtonUp' && h.name!='MouseEnter' && h.name!='MouseLeave')  //IE hack
			    dojo.disconnect(h);
		}
	},
	/*
	** the incoming data is an array of objects with the following properties
	**	name: name of this datum. gets passed to the onDatumClick event handler
	** 	value: integer value representing this datum
	**	color: an array representing the RGB color value for this datum (Note: must be RGB)
	**	caption: [optional] if not provided, the graph will create a caption as "name (value)"
	** TODO: use the dojox.color facilities to convert if I have to, or take a dojox.color.Color as input
	** for example:
	**	[
	** 		{name: 'one', value: 25, color: [166, 110, 219], caption: "caption 1"}, 
	**		{name: 'two', value: 25, color: [85, 186, 65], caption: "caption 2"}, 
	**		{name: 'three', value: 45, color: [81, 122, 204], caption: "Caption 3"}
	**	]
	*/
	// TODO: if the legend gets wider than the available space, I start a second row
	// but each row is left justified.  If I need 2 rows, I should put half in each row,
	// 3 rows 1/3 etc.
	_data_set: null,
	setData: function(/*array*/data_set)
	{
		if(!this._canRender){
			return;
		}
		if(!dojo.isArray(data_set)){
			data_set = null;	// when called on the timer, get an int sometimes
		}
		if(undefined != data_set){
			this._data_set = data_set;	// cache for later
		}

		if(!this.isReady) {
			//this.connect(this, this._createGraphics, this.setData);	didn't work
			window.setTimeout(dojo.hitch(this, this.setData), 1000);
			return;
		}
		
		if(undefined == data_set) { 
			data_set = this._data_set;
		}
		// copy the data
		if(undefined != data_set) {
			this._data = data_set.slice(0);
		}
		
		// disconnect the onclick handlers
		this._disconnect();
		this.data_grp.clear();
		this._drawNoData();
		this.legend_grp.clear();
		this._legend_lines = 0;
		this._sizeToFitLegend();		
		
		if(!this._data){
			return;
		}
		var data = this._data;
		var i;
		
		// the colored rectangles for each datum
		var total = 0;
		for(i in data) {
			if(data.hasOwnProperty(i)){
				total += data[i].value;
			}
		}
		
		if(this.showTotal) {
			if(data.length >0 && data[data.length-1].name == this.totalLegend){
				data[data.length-1].value = total;
			}
			else { 
				data.push({name: this.totalLegend, value: total, color: [200, 200, 200]});
			}
		}		
		
		if(total > 0) {
			var current_legend_lines = 1;
			var data_left = 0;
			var cap_left = this.paddingx;
			var max_cap_left = 0;
			var cap_top = (this.barHeight + 2*this.outlineWidth + 2*this.paddingy);
			for( i = 0; i < data.length; ++i) {
				// draw the data bar
				var bar = data[i].value / total;
				var datum_rect_width = Math.round(this.barWidth * bar);
				var mono = this._makeGradient(new dojox.color.Color(data[i].color));
				var gradient = [mono[2], mono[3], mono[1], mono[0]];
				if(this.graysOnly) {
					gradient = this._makeGrayscale(gradient);
				}
				var fill = {type: "linear", x1: 0, y1: this.barHeight, x2: 0, y2: 0,
							colors: [{offset: 0, color: gradient[0]}, {offset: 0.6, color: gradient[1]}, 
							         {offset: 0.7, color: gradient[2]}, {offset: 1, color: gradient[3]}] };
				if(datum_rect_width > 0 && !(this.showTotal && data[i].name == this.totalLegend) ) {
					// Total doesn't go in the graph
					var datum  = this.data_grp.createShape({type: "rect", x: data_left, y: 0, width: datum_rect_width, height: this.barHeight})
											.setFill(fill);
					if(!dojo.isIE) { 
						datum.getNode().setAttribute("name", data[i].name);						
					} else  {							 
						datum.name =  data[i].name;						
					}
					this._clickhandlers.push(datum.connect("onmouseover", this, "_overDatum"));
					this._clickhandlers.push(datum.connect("onmouseout", this, "_outDatum"));
					this._clickhandlers.push(datum.connect("onclick", this, "_clickDatum"));						
				    //}
					data_left += datum_rect_width;
				}
				if(this.showLegend) {
					// draw the caption	
					var one_cap = this.legend_grp.createGroup();
					if(!dojo.isIE) { 
						one_cap.getNode().setAttribute("name", data[i].name);						
					} else  {						 
						one_cap.name =  data[i].name;						
					}
					this._clickhandlers.push(one_cap.connect("onmouseover", this, "_overDatum"));
					this._clickhandlers.push(one_cap.connect("onmouseout", this, "_outDatum"));
					this._clickhandlers.push(one_cap.connect("onclick", this, "_clickDatum"));						
					//}
					
					// the colored box
					fill.y1 = this.captionHeight;
					if(data[i].name !== this.totalLegend) {	// no box for the total
						var capbox = one_cap.createShape({type: "rect", x: 0, y: 0, width: this.captionHeight, height: this.captionHeight})
										.setFill(fill)
										.setStroke({color: "#333333", width: 1});
										
					}
					// the text, which is a little tricky, since it's origin is at it's bottom, where everything else has y=0 at the top
					var cap_text_string = data[i].caption === undefined ? data[i].name + " (" + data[i].value + ")" : data[i].caption;
					var cap_text = one_cap.createText({
									x: this.captionHeight + this.paddingx, 
									y: this.captionFontSize+(this.captionHeight-this.captionFontSize)/2, 
									align: "start", text: cap_text_string})
							.setFont({family: "Arial", style: "normal", weight: (data[i].name === this.totalLegend?"bold":"normal"), size: this.captionFontSize + "px"})
							.setFill("#333333")
							.setStroke(null);
							
	
					var text_width = Math.round((cap_text_string.length * this.captionFontSize) * 0.7);	// rough estimate
					try {
						text_width = cap_text.getTextWidth();
					}
					catch(ex) {/* if display:none, can't getTextWidth */}
					var cap_width = this.captionHeight + this.paddingx + text_width;
					if(cap_left + cap_width + this.paddingx > this.barWidth) {
						cap_left = this.paddingx;
						cap_top += this.captionHeight + this.paddingy;
						var ssz = this.surface.getDimensions();
						if(++current_legend_lines > this._legend_lines) {
							this._legend_lines = current_legend_lines;
							this._sizeToFitLegend();
						}
					}
					one_cap.setTransform({dx: cap_left, dy: cap_top});
					this.legend_grp.add(one_cap);
					
					cap_left += cap_width + this.paddingx*2;
					if(cap_left > max_cap_left) {max_cap_left = cap_left;}
				}
			}
			if(this.showLegend) {
				max_cap_left -= this.paddingx;	// remove the unused right-side padding
				this.legend_grp.setTransform({dx: (this.barWidth - max_cap_left)/2});
			}
			if(current_legend_lines < this._legend_lines) {
				this._legend_lines = current_legend_lines;
				this._sizeToFitLegend();
			}
		}
		this.outline_grp.moveToFront();
	},
	_makeGrayscale: function(colors)
	{
		var grays = [];
		for(var i in colors)
		{
			if(colors.hasOwnProperty(i)){
				var c = colors[i];
			    var luma = Math.round(c.r*0.3 + c.g*0.59+ c.b*0.11);
			    grays.push(new dojox.color.Color([luma, luma, luma]));
			}
		}
		return grays;
	},
	_makeGradient: function(basecolor)
	{
		// I don't like the gradient generated by dojox.color.Palette.generators.monochromatic or shades.
		// cook up my own based on some experiements with the data the old dojox.color.Generator
		var g = new Array(4);
		g[2] = basecolor;

		var cmyk = basecolor.toCmyk();
		cmyk.c = Math.round(cmyk.c / 1.5);
		cmyk.m = Math.round(cmyk.m / 1.5);
		cmyk.y = Math.round(cmyk.y / 1.5);
		cmyk.b = Math.round(cmyk.b / 1.5);
		g[1] = dojox.color.fromCmyk(cmyk);
		cmyk.c = Math.round(cmyk.c / 1.4);
		cmyk.m = Math.round(cmyk.m / 1.4);
		cmyk.y = Math.round(cmyk.y / 1.4);
		cmyk.b = Math.round(cmyk.b / 1.4);
		g[0] = dojox.color.fromCmyk(cmyk);
		cmyk = basecolor.toCmyk();
		cmyk.c *= 2;
		cmyk.m *= 2;
		cmyk.y *= 2;
		cmyk.b *= 2;
		// bringing the data w/in bounds is handled by from Cmyk, but I feel dirty not taking care of business myself
		if(cmyk.c > 100) {cmyk.c = 100;}
		if(cmyk.m > 100) {cmyk.m = 100;}
		if(cmyk.y > 100) {cmyk.y = 100;}
		if(cmyk.b > 100) {cmyk.b = 100;}
		g[3] = dojox.color.fromCmyk(cmyk);
		return g;
	},
	resize: function() {
		if(this.surface) {
			this.surface.clear();
			this._createGraphics();
			this.setData();
		}
	},
	_sizeToFitLegend: function()
	{
		var ssz = this.surface.getDimensions();
		var legend_lines = (this._legend_lines === 0 && this.showLegend) ? 1 : this._legend_lines;
		this._resize(parseInt(ssz.width,10), this._nominalHeight + legend_lines * (this.captionHeight + this.paddingy));
	},
	_resize: function(w, h) {
		if(this.surface) {
			this.surface.setDimensions(w, h);
			var s = this.bg_rect.getShape();
			s.width = w;
			s.height = h;
			this.bg_rect.setShape(s);
		}
	},
	_clickDatum: function(evt) 
	{
		if(!dojo.isIE) { 
		   console.log("Clicked ", evt.currentTarget.getAttribute("name"));
		} else {
	  	   console.log("Clicked ", evt.gfxTarget.name);  
		}
		var target="";
		if(!dojo.isIE) { 
		  target = evt.currentTarget.getAttribute("name");
		} else {
			target = evt.gfxTarget.name;
		}  
		 
		if("function" == typeof this.onDatumClick ) {
			this.onDatumClick(evt, target);
		}
		evt.stopPropagation();
	},
	_overDatum: function(evt)
	{
		if("function" == typeof this.onDatumClick ) { 
			if(!dojo.isIE) { 
			   dojo.style(evt.currentTarget, "cursor", "pointer");
			} else {
			   dojo.style(this._domNode, "cursor", "pointer");
			}
		}
	},
	_outDatum: function(evt)
	{
		if("function" == typeof this.onDatumClick ) {
			if(!dojo.isIE) { 
			   dojo.style(evt.currentTarget, "cursor", "default");
			} else {
				dojo.style(this._domNode, "cursor", "default");
			}
		}		
	}
});
/**
 * these colors will work even if the UI is in greyscale, or the user is colorblind
 */
ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.defaultColors = 
[
	[127, 102, 153],
	[226, 141, 0],
	[139, 173, 231],
	[76, 204, 51],
	[0, 0, 93],
	[204, 160, 72],
	[7, 88, 196],
	[195, 195, 0],
	[102, 102, 127],
	[39, 14, 150],
	[188, 210, 232],
	[152, 96, 48],
	[255, 170, 28],
	[32, 88, 112],
	[127, 173, 220],
	[153, 153, 29],
	[153, 127, 178],
	[248, 208, 128],
	[21, 60, 5],
	[0,255,255],
	[51,204,51],
	[255,153,102],
	[255,0,255],
	[67,100,45],
	[255,51,0]
];

ibm.tivoli.simplesrm.srm.dijit.BaguetteChart._colorTable = {};
ibm.tivoli.simplesrm.srm.dijit.BaguetteChart._nextFreeColor = 0;

ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.getDefaultColor = function(i)
{
	if(typeof i == "number") {
		return ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.defaultColors[i % ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.defaultColors.length];
	}
	else {
		if( !ibm.tivoli.simplesrm.srm.dijit.BaguetteChart._colorTable[i]) 
		{
			ibm.tivoli.simplesrm.srm.dijit.BaguetteChart._colorTable[i] = 
				ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.defaultColors[ibm.tivoli.simplesrm.srm.dijit.BaguetteChart._nextFreeColor++];
		}
		return ibm.tivoli.simplesrm.srm.dijit.BaguetteChart._colorTable[i];
	}
};

ibm.tivoli.simplesrm.srm.dijit.BaguetteChart.testIEForSilverlight = function()
{
	slInstalled = false;
	if(dojo.isIE) {
		 try 
		 {
			 var slControl = new ActiveXObject('AgControl.AgControl');
			 slInstalled = true;
		 }
		 catch (ex) {
			 console.error("",ex);
		 }
	}
	return slInstalled;
};

});

},
'dijit/form/ValidationTextBox':function(){
require({cache:{
'url:dijit/form/templates/ValidationTextBox.html':"<div class=\"dijit dijitReset dijitInline dijitLeft\"\n\tid=\"widget_${id}\" role=\"presentation\"\n\t><div class='dijitReset dijitValidationContainer'\n\t\t><input class=\"dijitReset dijitInputField dijitValidationIcon dijitValidationInner\" value=\"&#935; \" type=\"text\" tabIndex=\"-1\" readonly=\"readonly\" role=\"presentation\"\n\t/></div\n\t><div class=\"dijitReset dijitInputField dijitInputContainer\"\n\t\t><input class=\"dijitReset dijitInputInner\" data-dojo-attach-point='textbox,focusNode' autocomplete=\"off\"\n\t\t\t${!nameAttrSetting} type='${type}'\n\t/></div\n></div>\n"}});
define("dijit/form/ValidationTextBox", [
	"dojo/_base/declare", // declare
	"dojo/i18n", // i18n.getLocalization
	"./TextBox",
	"../Tooltip",
	"dojo/text!./templates/ValidationTextBox.html",
	"dojo/i18n!./nls/validate"
], function(declare, i18n, TextBox, Tooltip, template){

/*=====
	var Tooltip = dijit.Tooltip;
	var TextBox = dijit.form.TextBox;
=====*/

	// module:
	//		dijit/form/ValidationTextBox
	// summary:
	//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.


	/*=====
		dijit.form.ValidationTextBox.__Constraints = function(){
			// locale: String
			//		locale used for validation, picks up value from this widget's lang attribute
			// _flags_: anything
			//		various flags passed to regExpGen function
			this.locale = "";
			this._flags_ = "";
		}
	=====*/

	return declare("dijit.form.ValidationTextBox", TextBox, {
		// summary:
		//		Base class for textbox widgets with the ability to validate content of various types and provide user feedback.
		// tags:
		//		protected

		templateString: template,
		baseClass: "dijitTextBox dijitValidationTextBox",

		// required: Boolean
		//		User is required to enter data into this field.
		required: false,

		// promptMessage: String
		//		If defined, display this hint string immediately on focus to the textbox, if empty.
		//		Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
		//		Think of this like a tooltip that tells the user what to do, not an error message
		//		that tells the user what they've done wrong.
		//
		//		Message disappears when user starts typing.
		promptMessage: "",

		// invalidMessage: String
		// 		The message to display if value is invalid.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the promptMessage instead.
		invalidMessage: "$_unset_$",

		// missingMessage: String
		// 		The message to display if value is empty and the field is required.
		//		The translated string value is read from the message file by default.
		// 		Set to "" to use the invalidMessage instead.
		missingMessage: "$_unset_$",

		// message: String
		//		Currently error/prompt message.
		//		When using the default tooltip implementation, this will only be
		//		displayed when the field is focused.
		message: "",

		// constraints: dijit.form.ValidationTextBox.__Constraints
		//		user-defined object needed to pass parameters to the validator functions
		constraints: {},

		// regExp: [extension protected] String
		//		regular expression string used to validate the input
		//		Do not specify both regExp and regExpGen
		regExp: ".*",

		regExpGen: function(/*dijit.form.ValidationTextBox.__Constraints*/ /*===== constraints =====*/){
			// summary:
			//		Overridable function used to generate regExp when dependent on constraints.
			//		Do not specify both regExp and regExpGen.
			// tags:
			//		extension protected
			return this.regExp; // String
		},

		// state: [readonly] String
		//		Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
		state: "",

		// tooltipPosition: String[]
		//		See description of `dijit.Tooltip.defaultPosition` for details on this parameter.
		tooltipPosition: [],

		_setValueAttr: function(){
			// summary:
			//		Hook so set('value', ...) works.
			this.inherited(arguments);
			this.validate(this.focused);
		},

		validator: function(/*anything*/ value, /*dijit.form.ValidationTextBox.__Constraints*/ constraints){
			// summary:
			//		Overridable function used to validate the text input against the regular expression.
			// tags:
			//		protected
			return (new RegExp("^(?:" + this.regExpGen(constraints) + ")"+(this.required?"":"?")+"$")).test(value) &&
				(!this.required || !this._isEmpty(value)) &&
				(this._isEmpty(value) || this.parse(value, constraints) !== undefined); // Boolean
		},

		_isValidSubset: function(){
			// summary:
			//		Returns true if the value is either already valid or could be made valid by appending characters.
			//		This is used for validation while the user [may be] still typing.
			return this.textbox.value.search(this._partialre) == 0;
		},

		isValid: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Tests if value is valid.
			//		Can override with your own routine in a subclass.
			// tags:
			//		protected
			return this.validator(this.textbox.value, this.constraints);
		},

		_isEmpty: function(value){
			// summary:
			//		Checks for whitespace
			return (this.trim ? /^\s*$/ : /^$/).test(value); // Boolean
		},

		getErrorMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return an error message to show if appropriate
			// tags:
			//		protected
			return (this.required && this._isEmpty(this.textbox.value)) ? this.missingMessage : this.invalidMessage; // String
		},

		getPromptMessage: function(/*Boolean*/ /*===== isFocused =====*/){
			// summary:
			//		Return a hint message to show when widget is first focused
			// tags:
			//		protected
			return this.promptMessage; // String
		},

		_maskValidSubsetError: true,
		validate: function(/*Boolean*/ isFocused){
			// summary:
			//		Called by oninit, onblur, and onkeypress.
			// description:
			//		Show missing or invalid messages if appropriate, and highlight textbox field.
			// tags:
			//		protected
			var message = "";
			var isValid = this.disabled || this.isValid(isFocused);
			if(isValid){ this._maskValidSubsetError = true; }
			var isEmpty = this._isEmpty(this.textbox.value);
			var isValidSubset = !isValid && isFocused && this._isValidSubset();
			this._set("state", isValid ? "" : (((((!this._hasBeenBlurred || isFocused) && isEmpty) || isValidSubset) && this._maskValidSubsetError) ? "Incomplete" : "Error"));
			this.focusNode.setAttribute("aria-invalid", isValid ? "false" : "true");

			if(this.state == "Error"){
				this._maskValidSubsetError = isFocused && isValidSubset; // we want the error to show up after a blur and refocus
				message = this.getErrorMessage(isFocused);
			}else if(this.state == "Incomplete"){
				message = this.getPromptMessage(isFocused); // show the prompt whenever the value is not yet complete
				this._maskValidSubsetError = !this._hasBeenBlurred || isFocused; // no Incomplete warnings while focused
			}else if(isEmpty){
				message = this.getPromptMessage(isFocused); // show the prompt whenever there's no error and no text
			}
			this.set("message", message);

			return isValid;
		},

		displayMessage: function(/*String*/ message){
			// summary:
			//		Overridable method to display validation errors/hints.
			//		By default uses a tooltip.
			// tags:
			//		extension
			if(message && this.focused){
				Tooltip.show(message, this.domNode, this.tooltipPosition, !this.isLeftToRight());
			}else{
				Tooltip.hide(this.domNode);
			}
		},

		_refreshState: function(){
			// Overrides TextBox._refreshState()
			this.validate(this.focused);
			this.inherited(arguments);
		},

		//////////// INITIALIZATION METHODS ///////////////////////////////////////

		constructor: function(){
			this.constraints = {};
		},

		_setConstraintsAttr: function(/*Object*/ constraints){
			if(!constraints.locale && this.lang){
				constraints.locale = this.lang;
			}
			this._set("constraints", constraints);
			this._computePartialRE();
		},

		_computePartialRE: function(){
			var p = this.regExpGen(this.constraints);
			this.regExp = p;
			var partialre = "";
			// parse the regexp and produce a new regexp that matches valid subsets
			// if the regexp is .* then there's no use in matching subsets since everything is valid
			if(p != ".*"){ this.regExp.replace(/\\.|\[\]|\[.*?[^\\]{1}\]|\{.*?\}|\(\?[=:!]|./g,
				function(re){
					switch(re.charAt(0)){
						case '{':
						case '+':
						case '?':
						case '*':
						case '^':
						case '$':
						case '|':
						case '(':
							partialre += re;
							break;
						case ")":
							partialre += "|$)";
							break;
						 default:
							partialre += "(?:"+re+"|$)";
							break;
					}
				}
			);}
			try{ // this is needed for now since the above regexp parsing needs more test verification
				"".search(partialre);
			}catch(e){ // should never be here unless the original RE is bad or the parsing is bad
				partialre = this.regExp;
				console.warn('RegExp error in ' + this.declaredClass + ': ' + this.regExp);
			} // should never be here unless the original RE is bad or the parsing is bad
			this._partialre = "^(?:" + partialre + ")$";
		},

		postMixInProperties: function(){
			this.inherited(arguments);
			this.messages = i18n.getLocalization("dijit.form", "validate", this.lang);
			if(this.invalidMessage == "$_unset_$"){ this.invalidMessage = this.messages.invalidMessage; }
			if(!this.invalidMessage){ this.invalidMessage = this.promptMessage; }
			if(this.missingMessage == "$_unset_$"){ this.missingMessage = this.messages.missingMessage; }
			if(!this.missingMessage){ this.missingMessage = this.invalidMessage; }
			this._setConstraintsAttr(this.constraints); // this needs to happen now (and later) due to codependency on _set*Attr calls attachPoints
		},

		_setDisabledAttr: function(/*Boolean*/ value){
			this.inherited(arguments);	// call FormValueWidget._setDisabledAttr()
			this._refreshState();
		},

		_setRequiredAttr: function(/*Boolean*/ value){
			this._set("required", value);
			this.focusNode.setAttribute("aria-required", value);
			this._refreshState();
		},

		_setMessageAttr: function(/*String*/ message){
			this._set("message", message);
			this.displayMessage(message);
		},

		reset:function(){
			// Overrides dijit.form.TextBox.reset() by also
			// hiding errors about partial matches
			this._maskValidSubsetError = true;
			this.inherited(arguments);
		},

		_onBlur: function(){
			// the message still exists but for back-compat, and to erase the tooltip
			// (if the message is being displayed as a tooltip), call displayMessage('')
			this.displayMessage('');

			this.inherited(arguments);
		}
	});
});

},
'dijit/layout/BorderContainer':function(){
define("dijit/layout/BorderContainer", [
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.toggle
	"dojo/dom-construct", // domConstruct.destroy domConstruct.place
	"dojo/dom-geometry", // domGeometry.marginBox
	"dojo/dom-style", // domStyle.style
	"dojo/_base/event", // event.stop
	"dojo/keys",
	"dojo/_base/lang", // lang.getObject lang.hitch
	"dojo/on",
	"dojo/touch",
	"dojo/_base/window", // win.body win.doc win.doc.createElement
	"../_WidgetBase",
	"../_Widget",
	"../_TemplatedMixin",
	"./_LayoutWidget",
	"./utils"		// layoutUtils.layoutChildren
], function(array, cookie, declare, domClass, domConstruct, domGeometry, domStyle, event, keys, lang, on, touch, win,
			_WidgetBase, _Widget, _TemplatedMixin, _LayoutWidget, layoutUtils){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _LayoutWidget = dijit.layout._LayoutWidget;
=====*/

// module:
//		dijit/layout/BorderContainer
// summary:
//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.

var _Splitter = declare("dijit.layout._Splitter", [_Widget, _TemplatedMixin ],
{
	// summary:
	//		A draggable spacer between two items in a `dijit.layout.BorderContainer`.
	// description:
	//		This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create it directly.
	// tags:
	//		private

/*=====
 	// container: [const] dijit.layout.BorderContainer
 	//		Pointer to the parent BorderContainer
	container: null,

	// child: [const] dijit.layout._LayoutWidget
	//		Pointer to the pane associated with this splitter
	child: null,

	// region: [const] String
	//		Region of pane associated with this splitter.
	//		"top", "bottom", "left", "right".
	region: null,
=====*/

	// live: [const] Boolean
	//		If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	//		otherwise, the size doesn't change until you drop the splitter (by mouse-up)
	live: true,

	templateString: '<div class="dijitSplitter" data-dojo-attach-event="onkeypress:_onKeyPress,press:_startDrag,onmouseenter:_onMouse,onmouseleave:_onMouse" tabIndex="0" role="separator"><div class="dijitSplitterThumb"></div></div>',

	constructor: function(){
		this._handlers = [];
	},

	postMixInProperties: function(){
		this.inherited(arguments);

		this.horizontal = /top|bottom/.test(this.region);
		this._factor = /top|left/.test(this.region) ? 1 : -1;
		this._cookieName = this.container.id + "_" + this.region;
	},

	buildRendering: function(){
		this.inherited(arguments);

		domClass.add(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V"));

		if(this.container.persist){
			// restore old size
			var persistSize = cookie(this._cookieName);
			if(persistSize){
				this.child.domNode.style[this.horizontal ? "height" : "width"] = persistSize;
			}
		}
	},

	_computeMaxSize: function(){
		// summary:
		//		Return the maximum size that my corresponding pane can be set to

		var dim = this.horizontal ? 'h' : 'w',
			childSize = domGeometry.getMarginBox(this.child.domNode)[dim],
			center = array.filter(this.container.getChildren(), function(child){ return child.region == "center";})[0],
			spaceAvailable = domGeometry.getMarginBox(center.domNode)[dim];	// can expand until center is crushed to 0

		return Math.min(this.child.maxSize, childSize + spaceAvailable);
	},

	_startDrag: function(e){
		if(!this.cover){
			this.cover = win.doc.createElement('div');
			domClass.add(this.cover, "dijitSplitterCover");
			domConstruct.place(this.cover, this.child.domNode, "after");
		}
		domClass.add(this.cover, "dijitSplitterCoverActive");

		// Safeguard in case the stop event was missed.  Shouldn't be necessary if we always get the mouse up.
		if(this.fake){ domConstruct.destroy(this.fake); }
		if(!(this._resize = this.live)){ //TODO: disable live for IE6?
			// create fake splitter to display at old position while we drag
			(this.fake = this.domNode.cloneNode(true)).removeAttribute("id");
			domClass.add(this.domNode, "dijitSplitterShadow");
			domConstruct.place(this.fake, this.domNode, "after");
		}
		domClass.add(this.domNode, "dijitSplitterActive dijitSplitter" + (this.horizontal ? "H" : "V") + "Active");
		if(this.fake){
			domClass.remove(this.fake, "dijitSplitterHover dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover");
		}

		//Performance: load data info local vars for onmousevent function closure
		var factor = this._factor,
			isHorizontal = this.horizontal,
			axis = isHorizontal ? "pageY" : "pageX",
			pageStart = e[axis],
			splitterStyle = this.domNode.style,
			dim = isHorizontal ? 'h' : 'w',
			childStart = domGeometry.getMarginBox(this.child.domNode)[dim],
			max = this._computeMaxSize(),
			min = this.child.minSize || 20,
			region = this.region,
			splitterAttr = region == "top" || region == "bottom" ? "top" : "left",	// style attribute of splitter to adjust
			splitterStart = parseInt(splitterStyle[splitterAttr], 10),
			resize = this._resize,
			layoutFunc = lang.hitch(this.container, "_layoutChildren", this.child.id),
			de = win.doc;

		this._handlers = this._handlers.concat([
			on(de, touch.move, this._drag = function(e, forceResize){
				var delta = e[axis] - pageStart,
					childSize = factor * delta + childStart,
					boundChildSize = Math.max(Math.min(childSize, max), min);

				if(resize || forceResize){
					layoutFunc(boundChildSize);
				}
				// TODO: setting style directly (usually) sets content box size, need to set margin box size
				splitterStyle[splitterAttr] = delta + splitterStart + factor*(boundChildSize - childSize) + "px";
			}),
			on(de, "dragstart", event.stop),
			on(win.body(), "selectstart", event.stop),
			on(de, touch.release, lang.hitch(this, "_stopDrag"))
		]);
		event.stop(e);
	},

	_onMouse: function(e){
		// summary:
		//		Handler for onmouseenter / onmouseleave events
		var o = (e.type == "mouseover" || e.type == "mouseenter");
		domClass.toggle(this.domNode, "dijitSplitterHover", o);
		domClass.toggle(this.domNode, "dijitSplitter" + (this.horizontal ? "H" : "V") + "Hover", o);
	},

	_stopDrag: function(e){
		try{
			if(this.cover){
				domClass.remove(this.cover, "dijitSplitterCoverActive");
			}
			if(this.fake){ domConstruct.destroy(this.fake); }
			domClass.remove(this.domNode, "dijitSplitterActive dijitSplitter"
				+ (this.horizontal ? "H" : "V") + "Active dijitSplitterShadow");
			this._drag(e); //TODO: redundant with onmousemove?
			this._drag(e, true);
		}finally{
			this._cleanupHandlers();
			delete this._drag;
		}

		if(this.container.persist){
			cookie(this._cookieName, this.child.domNode.style[this.horizontal ? "height" : "width"], {expires:365});
		}
	},

	_cleanupHandlers: function(){
		var h;
		while(h = this._handlers.pop()){ h.remove(); }
	},

	_onKeyPress: function(/*Event*/ e){
		// should we apply typematic to this?
		this._resize = true;
		var horizontal = this.horizontal;
		var tick = 1;
		switch(e.charOrCode){
			case horizontal ? keys.UP_ARROW : keys.LEFT_ARROW:
				tick *= -1;
//				break;
			case horizontal ? keys.DOWN_ARROW : keys.RIGHT_ARROW:
				break;
			default:
//				this.inherited(arguments);
				return;
		}
		var childSize = domGeometry.getMarginSize(this.child.domNode)[ horizontal ? 'h' : 'w' ] + this._factor * tick;
		this.container._layoutChildren(this.child.id, Math.max(Math.min(childSize, this._computeMaxSize()), this.child.minSize));
		event.stop(e);
	},

	destroy: function(){
		this._cleanupHandlers();
		delete this.child;
		delete this.container;
		delete this.cover;
		delete this.fake;
		this.inherited(arguments);
	}
});

var _Gutter = declare("dijit.layout._Gutter", [_Widget, _TemplatedMixin],
{
	// summary:
	// 		Just a spacer div to separate side pane from center pane.
	//		Basically a trick to lookup the gutter/splitter width from the theme.
	// description:
	//		Instantiated by `dijit.layout.BorderContainer`.  Users should not
	//		create directly.
	// tags:
	//		private

	templateString: '<div class="dijitGutter" role="presentation"></div>',

	postMixInProperties: function(){
		this.inherited(arguments);
		this.horizontal = /top|bottom/.test(this.region);
	},

	buildRendering: function(){
		this.inherited(arguments);
		domClass.add(this.domNode, "dijitGutter" + (this.horizontal ? "H" : "V"));
	}
});

var BorderContainer = declare("dijit.layout.BorderContainer", _LayoutWidget, {
	// summary:
	//		Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.
	//
	// description:
	//		A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	//		that contains a child widget marked region="center" and optionally children widgets marked
	//		region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	//		Children along the edges will be laid out according to width or height dimensions and may
	//		include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	//		space is designated for the center region.
	//
	//		The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	//		and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	//		it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	//		"left" and "right" except that they will be reversed in right-to-left environments.
	//
	//		For complex layouts, multiple children can be specified for a single region.   In this case, the
	//		layoutPriority flag on the children determines which child is closer to the edge (low layoutPriority)
	//		and which child is closer to the center (high layoutPriority).   layoutPriority can also be used
	//		instead of the design attribute to control layout precedence of horizontal vs. vertical panes.
	// example:
	// |	<div data-dojo-type="dijit.layout.BorderContainer" data-dojo-props="design: 'sidebar', gutters: false"
	// |            style="width: 400px; height: 300px;">
	// |		<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'top'">header text</div>
	// |		<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'right', splitter: true" style="width: 200px;">table of contents</div>
	// |		<div data-dojo-type="dijit.layout.ContentPane" data-dojo-props="region: 'center'">client area</div>
	// |	</div>

	// design: String
	//		Which design is used for the layout:
	//			- "headline" (default) where the top and bottom extend
	//				the full width of the container
	//			- "sidebar" where the left and right sides extend from top to bottom.
	design: "headline",

	// gutters: [const] Boolean
	//		Give each pane a border and margin.
	//		Margin determined by domNode.paddingLeft.
	//		When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.
	gutters: true,

	// liveSplitters: [const] Boolean
	//		Specifies whether splitters resize as you drag (true) or only upon mouseup (false)
	liveSplitters: true,

	// persist: Boolean
	//		Save splitter positions in a cookie.
	persist: false,

	baseClass: "dijitBorderContainer",

	// _splitterClass: Function||String
	// 		Optional hook to override the default Splitter widget used by BorderContainer
	_splitterClass: _Splitter,

	postMixInProperties: function(){
		// change class name to indicate that BorderContainer is being used purely for
		// layout (like LayoutContainer) rather than for pretty formatting.
		if(!this.gutters){
			this.baseClass += "NoGutter";
		}
		this.inherited(arguments);
	},

	startup: function(){
		if(this._started){ return; }
		array.forEach(this.getChildren(), this._setupChild, this);
		this.inherited(arguments);
	},

	_setupChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget._setupChild().

		var region = child.region;
		if(region){
			this.inherited(arguments);

			domClass.add(child.domNode, this.baseClass+"Pane");

			var ltr = this.isLeftToRight();
			if(region == "leading"){ region = ltr ? "left" : "right"; }
			if(region == "trailing"){ region = ltr ? "right" : "left"; }

			// Create draggable splitter for resizing pane,
			// or alternately if splitter=false but BorderContainer.gutters=true then
			// insert dummy div just for spacing
			if(region != "center" && (child.splitter || this.gutters) && !child._splitterWidget){
				var _Splitter = child.splitter ? this._splitterClass : _Gutter;
				if(lang.isString(_Splitter)){
					_Splitter = lang.getObject(_Splitter);	// for back-compat, remove in 2.0
				}
				var splitter = new _Splitter({
					id: child.id + "_splitter",
					container: this,
					child: child,
					region: region,
					live: this.liveSplitters
				});
				splitter.isSplitter = true;
				child._splitterWidget = splitter;

				domConstruct.place(splitter.domNode, child.domNode, "after");

				// Splitters aren't added as Contained children, so we need to call startup explicitly
				splitter.startup();
			}
			child.region = region;	// TODO: technically wrong since it overwrites "trailing" with "left" etc.
		}
	},

	layout: function(){
		// Implement _LayoutWidget.layout() virtual method.
		this._layoutChildren();
	},

	addChild: function(/*dijit._Widget*/ child, /*Integer?*/ insertIndex){
		// Override _LayoutWidget.addChild().
		this.inherited(arguments);
		if(this._started){
			this.layout(); //OPT
		}
	},

	removeChild: function(/*dijit._Widget*/ child){
		// Override _LayoutWidget.removeChild().

		var region = child.region;
		var splitter = child._splitterWidget;
		if(splitter){
			splitter.destroy();
			delete child._splitterWidget;
		}
		this.inherited(arguments);

		if(this._started){
			this._layoutChildren();
		}
		// Clean up whatever style changes we made to the child pane.
		// Unclear how height and width should be handled.
		domClass.remove(child.domNode, this.baseClass+"Pane");
		domStyle.set(child.domNode, {
			top: "auto",
			bottom: "auto",
			left: "auto",
			right: "auto",
			position: "static"
		});
		domStyle.set(child.domNode, region == "top" || region == "bottom" ? "width" : "height", "auto");
	},

	getChildren: function(){
		// Override _LayoutWidget.getChildren() to only return real children, not the splitters.
		return array.filter(this.inherited(arguments), function(widget){
			return !widget.isSplitter;
		});
	},

	// TODO: remove in 2.0
	getSplitter: function(/*String*/region){
		// summary:
		//		Returns the widget responsible for rendering the splitter associated with region
		// tags:
		//		deprecated
		return array.filter(this.getChildren(), function(child){
			return child.region == region;
		})[0]._splitterWidget;
	},

	resize: function(newSize, currentSize){
		// Overrides _LayoutWidget.resize().

		// resetting potential padding to 0px to provide support for 100% width/height + padding
		// TODO: this hack doesn't respect the box model and is a temporary fix
		if(!this.cs || !this.pe){
			var node = this.domNode;
			this.cs = domStyle.getComputedStyle(node);
			this.pe = domGeometry.getPadExtents(node, this.cs);
			this.pe.r = domStyle.toPixelValue(node, this.cs.paddingRight);
			this.pe.b = domStyle.toPixelValue(node, this.cs.paddingBottom);

			domStyle.set(node, "padding", "0px");
		}

		this.inherited(arguments);
	},

	_layoutChildren: function(/*String?*/ changedChildId, /*Number?*/ changedChildSize){
		// summary:
		//		This is the main routine for setting size/position of each child.
		// description:
		//		With no arguments, measures the height of top/bottom panes, the width
		//		of left/right panes, and then sizes all panes accordingly.
		//
		//		With changedRegion specified (as "left", "top", "bottom", or "right"),
		//		it changes that region's width/height to changedRegionSize and
		//		then resizes other regions that were affected.
		// changedChildId:
		//		Id of the child which should be resized because splitter was dragged.
		// changedChildSize:
		//		The new width/height (in pixels) to make specified child

		if(!this._borderBox || !this._borderBox.h){
			// We are currently hidden, or we haven't been sized by our parent yet.
			// Abort.   Someone will resize us later.
			return;
		}

		// Generate list of wrappers of my children in the order that I want layoutChildren()
		// to process them (i.e. from the outside to the inside)
		var wrappers = array.map(this.getChildren(), function(child, idx){
			return {
				pane: child,
				weight: [
					child.region == "center" ? Infinity : 0,
					child.layoutPriority,
					(this.design == "sidebar" ? 1 : -1) * (/top|bottom/.test(child.region) ? 1 : -1),
					idx
				]
			};
		}, this);
		wrappers.sort(function(a, b){
			var aw = a.weight, bw = b.weight;
			for(var i=0; i<aw.length; i++){
				if(aw[i] != bw[i]){
					return aw[i] - bw[i];
				}
			}
			return 0;
		});

		// Make new list, combining the externally specified children with splitters and gutters
		var childrenAndSplitters = [];
		array.forEach(wrappers, function(wrapper){
			var pane = wrapper.pane;
			childrenAndSplitters.push(pane);
			if(pane._splitterWidget){
				childrenAndSplitters.push(pane._splitterWidget);
			}
		});

		// Compute the box in which to lay out my children
		var dim = {
			l: this.pe.l,
			t: this.pe.t,
			w: this._borderBox.w - this.pe.w,
			h: this._borderBox.h - this.pe.h
		};

		// Layout the children, possibly changing size due to a splitter drag
		layoutUtils.layoutChildren(this.domNode, dim, childrenAndSplitters,
			changedChildId, changedChildSize);
	},

	destroyRecursive: function(){
		// Destroy splitters first, while getChildren() still works
		array.forEach(this.getChildren(), function(child){
			var splitter = child._splitterWidget;
			if(splitter){
				splitter.destroy();
			}
			delete child._splitterWidget;
		});

		// Then destroy the real children, and myself
		this.inherited(arguments);
	}
});

// This argument can be specified for the children of a BorderContainer.
// Since any widget can be specified as a LayoutContainer child, mix it
// into the base widget class.  (This is a hack, but it's effective.)
lang.extend(_WidgetBase, {
	// region: [const] String
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Values: "top", "bottom", "leading", "trailing", "left", "right", "center".
	//		See the `dijit.layout.BorderContainer` description for details.
	region: '',

	// layoutPriority: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Children with a higher layoutPriority will be placed closer to the BorderContainer center,
	//		between children with a lower layoutPriority.
	layoutPriority: 0,

	// splitter: [const] Boolean
	//		Parameter for child of `dijit.layout.BorderContainer` where region != "center".
	//		If true, enables user to resize the widget by putting a draggable splitter between
	//		this widget and the region=center widget.
	splitter: false,

	// minSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a minimum size (in pixels) for this widget when resized by a splitter.
	minSize: 0,

	// maxSize: [const] Number
	//		Parameter for children of `dijit.layout.BorderContainer`.
	//		Specifies a maximum size (in pixels) for this widget when resized by a splitter.
	maxSize: Infinity
});

// For monkey patching
BorderContainer._Splitter = _Splitter;
BorderContainer._Gutter = _Gutter;

return BorderContainer;
});

},
'ibm/tivoli/simplesrm/srm/dijit/Overview/Pod':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dojo/i18n,dijit/_Widget,dijit/_Templated,dijit/form/Button,dijit/layout/BorderContainer,dijit/DialogUnderlay,dijit/Dialog,dijit/_DialogMixin,ibm/tivoli/simplesrm/srm/dijit/MultipleModal,ibm/tivoli/simplesrm/srm/dijit/OpenHelp"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.Pod");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.View");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.DataTable");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.Details");

dojo.require("dojo.i18n");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
dojo.require("dijit._Widget");
dojo.require("dijit._Templated");
dojo.require("dijit.form.Button");
dojo.require("dijit.layout.BorderContainer");
dojo.require("dijit.DialogUnderlay");
dojo.require("dijit.Dialog");
dojo.require("dijit._DialogMixin");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MultipleModal");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");

// Summary:
//	Overview.Pod is the rectangular box holding the overview data.
//	Overview.View is the contents contained within the Pod
//	Overview.DataTable is a 2-column table, with the styling specified for the Pods
//
//	It's up to classes derived from Overview.Pod to create their own view, and know how
//	to get their data, making each Pod type self-contained.
//
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.Pod", [dijit._Widget, dijit._Templated],
{
	widgetsInTemplate: true,
	templateString: '<div><table class="pod" border="0" cellpadding="0" cellspacing="0">\n'+
				 '	<tr><td class="top-lt"></td><td class="top-ctr"></td><td class="top-rt"></td></tr>\n'+
				 '	<tr><td class="lt"></td><td class="ctr">\n'+
				 '		<div class="OverviewPod">\n'+
				 '				<h2 class="title">${heading}</h2>\n'+
				 '				<div dojoAttachPoint="_view" dojoType="${viewType}" view_dialog="${view_dialog}"></div>\n'+
				 '				<div dojoAttachPoint="footer" class="footer"><a href="${detailsUrl}" dojoAttachPoint="detailsLink">${detailsLinkLabel}</a></div>\n'+
				 '			</div>\n'+
				 '		</td><td class="rt"></td></tr>\n'+
				 '	<tr><td class="bot-lt"></td><td class="bot-ctr"></td><td class="bot-rt"></td></tr>\n'+
				 '</table></div>',

	viewType: "ibm.tivoli.simplesrm.srm.dijit.Overview.View",
	detailsType: "",
	autoRefreshProperty: "",
	heading: "",
	detailsLinkLabel: "",
	detailsUrl: "#",
	autoRefreshInterval: Number.NaN,
	_mostRecent: 0,		// time of the most recent record.  Used to compare records when auto-updating
	_autoRefreshTimerId: -1,

	_view: null,		// my Overview.View object
	_details: null,		// my details pop-up window
	_detailsData: null,	// my details data
	 view_dialog: "",   //tpae Dialog to launch when clicking on SR
	
	constructor: function()
	{
		console.log("OverviewPod.Pod.ctor");
	},
	postMixInProperties: function()
	{
		this.inherited(arguments);
		if(isNaN(this.autoRefreshInterval) && this.autoRefreshProperty.length > 0) {
			this.autoRefreshInterval = parseInt(ibm.tivoli.tpae.dojo.data.getConfigProperty(this.autoRefreshProperty),10);
			if(isNaN(this.autoRefreshInterval) || this.autoRefreshInterval < 0) {
				this.autoRefreshInterval = Number.NaN;
			}
		}
	},
	postCreate: function()
	{
		this.inherited(arguments);
		this.connect(this.detailsLink, "onclick", this.onShowDetails);
	},
	// requery data
	refresh: function()
	{
		// override in derived pods to requery data
	},
	// _onDataReady should be called when the derived class' data is updated
	//	If you provide an implementation in your derived class, you should probably
	//	call this.inherited(arguments)
	_onDataReady: function()
	{
		dojo.removeClass(this.footer, "invisible");
		try {
			this.onRefresh(this._detailsData);
		}
		catch(ex) {
			console.log("Error in onRefresh handler");
		}
	},
	_refreshErrorCount: 0,
	__refreshError: function(response)
	{
		++this._refreshErrorCount;
		ibm.tivoli.logger.warn("RequestPod refresh failure: " + response);
		this._resetPoll();
	},
	_cancelPoll: function()
	{
		if(this._autoRefreshTimerId > 0) {
			window.clearTimeout(this._autoRefreshTimerId);
			this._autoRefreshTimerId = 0;
		}
	},
	_resetPoll: function()
	{
		if(!isNaN(this.autoRefreshInterval)) {
			this._cancelPoll();
			this._autoRefreshTimerId = window.setTimeout(dojo.hitch(this, this._poll), (this._refreshErrorCount +1) * this.autoRefreshInterval);
		}
	},
	_poll: function()
	{
		// override for your autoupdate polling query
	},
	// Summary:
	// 	event fired when the pod is refreshed with new data
	// 	latest_data: the new data set
	onRefresh: function(latest_data)
	{
	},
	// Summary:
	//	Called when the user clicks the details link
	onShowDetails: function()
	{
		// lazy create
		if(!this._details) {
			dojo["require"](this.detailsType);
			//dojo.require(this.detailsType);		
			//dojo._loadModule(this.detailsType);
			
			var cls = dojo.getObject(this.detailsType);
			this._details = new cls();
		} else {
			if (this._details.detailsWidget.toolBar) //clear search field 
				this._details.detailsWidget.toolBar.searchField.searchField.value = "";
		}
		this._details.refresh(this._detailsData);
		this._details.show();
	}
});
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.View", [dijit._Widget, dijit._Templated],
{
	_detailsData: null
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.DataTable", [dijit._Widget, dijit._Templated],
{
	templateString: '<div class="OverviewPodDataTable">\n' +
					'	<table class="OverviewPodDataTable" dojoAttachPoint="overviewPodDataTable">\n' +
					'		<caption dojoAttachPoint="tableCaption">${heading}</caption>\n' +
					'		<tbody></tbody>\n' +
					'	</table>\n' +
					'</div>\n',
	heading: "",
	maxRows: 5,
	
	addRow: function(leftcol, rightcol)
	{
		if(undefined == this.overviewPodDataTable) return null;
		var i = 0;
		try {
			i = this.overviewPodDataTable.rows.length;
		}
		catch(ex) {
			console.error("",ex);
		}
		if(i > this.maxRows) {return null;}

		var r = this.overviewPodDataTable.insertRow(i);
		var cell = r.insertCell(0);
		cell.className = "left";
		cell.innerHTML = undefined == leftcol ? "..." : leftcol;
				
		cell = r.insertCell(1);
		cell.className = "right";
		cell.innerHTML = undefined == rightcol ? "..." : "<span class='nowrap'>" + rightcol + "</span>";
		
		//Check if Pod width needs to be increased because of extra long row
		var row_width = dojo.coords(r).w;
		var container = r.parentNode.parentNode.parentNode.parentNode.parentNode;
		if (dojo.hasClass(container,"OverviewPod")) {
		   var container_width = dojo.coords(container).w;
		   if ( row_width > container_width)
		      dojo.style(container,{width: row_width});
		}
		
		return r;
	},
	deleteRow: function(rowIndex)
	{
		this.overviewPodDataTable.deleteRow(rowIndex);
	},
	clear: function()
	{
		var nrows = this.overviewPodDataTable.rows.length;
		for(var i = 0; i < nrows; ++i) {
			this.deleteRow(0);
		}
	},
	_setHeadingAttr: function(newcap)
	{
		this.heading = this.tableCaption.innerHTML = newcap;
	}
});

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.Details", 
		[dijit._Widget,
		 dijit._Templated,ibm.tivoli.simplesrm.srm.dijit.MultipleModal,
		 ibm.tivoli.simplesrm.srm.dijit.OpenHelp],
{
	//used to control tabbing/focus 
	_getFocusItems : dijit._DialogMixin.prototype._getFocusItems,
	widgetsInTemplate: true,
	templateString:"<div dojoAttachPoint='containerNode' class='tundra simplesrm'>\n<!--\n @HTML_LONG_COPYRIGHT_BEGIN@\n @HTML_LONG_COPYRIGHT_END@\n-->\n\t<table dojoAttachPoint='glassTable' class='glass' style='width:100%;margin:auto;'>\n\t\t<tr>\n\t\t\t<td class='glass ul'></td>\n\t\t\t<td class='glass um'></td>\n\t\t\t<td class='glass ur'></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td class='glass lt'></td>\n\t\t\t<td class='glass content'>\n\t\t\t\t<div class='overview_content'>\n\t\t\t\t\t<div class='my_records_grid_header'>\n\t\t\t\t\t\t<button class='overviewPodButton'\n\t\t\t\t\t\t\tdojoType='dijit.form.Button'\n\t\t\t\t\t\t\ticonClass='closeDetailsIcon'\n\t\t\t\t\t\t\tshowLabel='false'\n\t\t\t\t\t\t\tdojoAttachEvent='onClick:hide'>\n\t\t\t\t\t\t\t${closeBtnLabel}\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<button class='overviewPodButton'\n\t\t\t\t\t\t\tdojoType='dijit.form.Button'\n\t\t\t\t\t\t\ticonClass='helpDetailsIcon'\n\t\t\t\t\t\t\tshowLabel='false'\n\t\t\t\t\t\t\tdojoAttachEvent='onClick:showHelp'>\n\t\t\t\t\t\t\t${helpBtnLabel}\n\t\t\t\t\t\t</button>\n\t\t\t\t\t\t<h2 class='grid_heading'>${headingText}</h2>\n\t\t\t\t\t\t<div class='clear'></div>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div dojoAttachPoint='detailsWidget' dojoType='${detailsType}'></div>\n\t\t\t\t</div>\n\t\t\t</td>\n\t\t\t<td class='glass rt'></td>\t\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td class='glass ll'></td>\n\t\t\t<td class='glass lm'></td>\n\t\t\t<td class='glass lr'></td>\n\t\t</tr>\n\t</table>\n</div>\n",
	//templateString: "",
	detailsType: "",
	headingText: "",
	closeBtnLabel: "Close",
	helpBtnLabel: "Help",
	
	_detailsData: {},
	_fadeTime: 1000,	// millisecs
	_animIn: null,
	_animOut: null,
	_cshKey: "",
	_firstFocusItem: null,	//read-only,set by _getFocusItems
	_lastFocusItem: null, //read-only,set by _getFocusItems
		
	constructor: function(params){
		this.closeBtnLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Close;
		this.helpBtnLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").Help;

		//console.log("Overview.Details: constructor");
		/*if (params.cshKey) {
			this._cshKey = params.cshKey;
		} else {
			console.log("Details: no help file given");
		}*/
	},
	
	postCreate: function()
	{
		try {
			// create the faders
			var node = this.domNode;
			this._animIn = dojo.fadeIn({
				node: node, 
				duration: this._fadeTime,
				//set focus on the first (focusable) element on panel 
				onEnd: dojo.hitch(this ,function(){
					this._getFocusItems(this.domNode);
					//console.log("first focus:"+ this._firstFocusItem);
					
					//Change to last focus item. When it was set to first one, it was on the Close button
					dijit.focus(this._lastFocusItem);  
				})
			});
			
			this._animOut = dojo.fadeOut({
				node: node,
				duration: this._fadeTime,
				onEnd: function(){
					node.style.visibility="hidden";
					node.style.top = "-9999px";
				}
			 });
			
			// start hidden
			dojo.style(this.domNode, {
				visibility:"hidden",
				position:"absolute",
				display:"",
				top:"-9999px"
			});
			dojo.body().appendChild(this.domNode);

			this.connect(window, "onscroll","layout");
			this.connect(window, "onresize","resize");			
//			// load my data
//			this.refresh();
//			this.resize();
		}
		catch(ex) {
			console.error("Failed creating ibm.tivoli.simplesrm.srm.dijit.Overview.Details",ex);
			ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError("Failed creating ibm.tivoli.simplesrm.srm.dijit.Overview.Details");
			ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError(ex);
		}
		this.inherited(arguments);
	},
	destroy: function()
	{
		if(this._animIn.status() == "playing"){
			this._animIn.stop();
		}
		if(this._animOut.status() == "playing"){
			this._animOut.stop();
		}
		if(this._keyhandle) {
			dojo.disconnect(this._keyhandle);
		}
	},
	
	_onkey: function(evt)
	{	/*
		 * uses _onKey method from dijit.Dialog
		 * features:
		 * 1) closing with Esc
		 * 2) tabbing only inside panel
		 * 3)if event belongs to other modal panel(widget) it doesn't proccess it
		 */
		if(!this.preOnKeyTest(evt)){
			return; // it's not your event
		}			
		var onKey = dojo.hitch(this,dijit.Dialog.prototype._onKey);
		onKey(evt);		
	},

	refresh: function()
	{
		if(this.detailsWidget && "function" == typeof this.detailsWidget.refresh){
			this.detailsWidget.refresh();
		}
	},
	resize: function()
	{
		this.layout();
	},
	_position: function(){
		// partially copied from dijit.Dialog._position
		
		var node = this.containerNode;
		var viewport = dijit.getViewport();
		
		var theapp = dojo.coords(dojo.query("body")[0]);	 
		//dojo.query(".clientarea");
		 

		var left = viewport.l > theapp.x ? viewport.l : theapp.x;
		var top = viewport.t > theapp.y ? viewport.t : theapp.y;
		var width = viewport.w < theapp.w ? viewport.w : theapp.w;

		var height = viewport.h - 200;
		if (height < 200)
			height = 200;
		
		dojo.style(node,{
			left: left + "px",
			top: top + "px",
			width: width + "px",
			height: height + "px",
			position: "absolute"
		});


		// We need to set the height in the embedded Dojo grid as well. Not IE though - causes extra space in grid
		if (!dojo.isIE) {
		   var theGrid = dojo.query('.my_records_grid_container', node)
		   if (theGrid !== undefined && theGrid.length == 1) {
			   dojo.style(theGrid[0],{height: height + "px"});
		   }
		}
	},

	layout: function(){
		// copied from dijit.Dialog._position
		// summary:
		//		Position the Dialog and the underlay		
		if(this.domNode.style.visibility != "hidden"){
			dijit._underlay.layout();
			this._position();
		}
	},	
	
	onCancel: function(){
		//	required by _onkey (dijit.Dialog._onKey)
		this.hide();
	},
		
	_keyhandle:null,
	show: function()
	{			
		if(dojo.isIE && this._hideMyRequestHandle==null)
			this._hideMyRequestHandle = dojo.subscribe("hideMyRequest", this, "hideDialog");
		
		// modify dijit.DialogUnderlay
		this.patchCode(); 		
		
		//set dijit._underlay (if not set already by other modal widget)
		// code from dijit.Dialog._setup
		var underlayAttrs = {
			dialogId: this.id,
			"class": ""			
		};				
		var underlay = dijit._underlay;
		if(!underlay){ 
			underlay = dijit._underlay = new dijit.DialogUnderlay(underlayAttrs); 
		}
		underlay.show();
				
		//set z-index above all current modal panels
		this.domNode.style.zIndex = dijit._underlay.getDialogZIndex();
				
		if(this._animOut.status() == "playing"){
			this._animOut.stop();
		}
		dojo.style(this.domNode, {
			opacity:0,
			visibility:""
		});
		this.resize();
		//onkeydown doesn't set evt.charOrCode which is used by _onkey (dijit.Dialog._onKey)
		this._keyhandle = dojo.connect(dojo.doc.documentElement, "onkeypress", this, this._onkey);
		this._animIn.play();
	},
	hide: function()
	{		
		dijit._underlay.hide();
		
		if(this._animIn.status() == "playing"){
			this._animIn.stop();
		}
		dojo.disconnect(this._keyhandle);
		this._animOut.play();
	},
	_hideMyRequestHandle : null,
	_showMyRequestHandle : null,
	showDialog: function(){
		dojo.unsubscribe(this._showMyRequestHandle);
		this._hideMyRequestHandle = dojo.subscribe("hideMyRequest", this, "hideDialog");
		if(this._animOut.status() == "playing"){
			this._animOut.stop();
		}
		dojo.style(this.domNode, {
			opacity:0,
			visibility:""
		});
		this.resize();
		//onkeydown doesn't set evt.charOrCode which is used by _onkey (dijit.Dialog._onKey)
		this._keyhandle = dojo.connect(dojo.doc.documentElement, "onkeypress", this, this._onkey);
		this._animIn.play();
	},
	hideDialog: function(){
		dijit._underlay.hide();
		dojo.unsubscribe(this._hideMyRequestHandle);
		this._showMyRequestHandle = dojo.subscribe("showMyRequest", this, "showDialog");
		this.domNode.style.visibility = "hidden";
		if(this._animIn.status() == "playing"){
			this._animIn.stop();
		}
		dojo.disconnect(this._keyhandle);
		this._animOut.play();
	},
	/**
	 * Displays the help related to this panel. The cshKey variable
	 * indicates the file name of the help document to open.
	 */
	showHelp: function() {
		//this.openHelpWindow(this._cshKey);
		window.open(this._cshKey);
	}
});

});

},
'dojo/window':function(){
define("dojo/window", ["./_base/lang", "./_base/sniff", "./_base/window", "./dom", "./dom-geometry", "./dom-style"],
	function(lang, has, baseWindow, dom, geom, style) {

// module:
//		dojo/window
// summary:
//		TODOC

var window = lang.getObject("dojo.window", true);

/*=====
dojo.window = {
	// summary:
	//		TODO
};
window = dojo.window;
=====*/

window.getBox = function(){
	// summary:
	//		Returns the dimensions and scroll position of the viewable area of a browser window

	var
		scrollRoot = (baseWindow.doc.compatMode == 'BackCompat') ? baseWindow.body() : baseWindow.doc.documentElement,
		// get scroll position
		scroll = geom.docScroll(), // scrollRoot.scrollTop/Left should work
		w, h;

	if(has("touch")){ // if(scrollbars not supported)
		var uiWindow = baseWindow.doc.parentWindow || baseWindow.doc.defaultView;   // use UI window, not dojo.global window. baseWindow.doc.parentWindow probably not needed since it's not defined for webkit
		// on mobile, scrollRoot.clientHeight <= uiWindow.innerHeight <= scrollRoot.offsetHeight, return uiWindow.innerHeight
		w = uiWindow.innerWidth || scrollRoot.clientWidth; // || scrollRoot.clientXXX probably never evaluated
		h = uiWindow.innerHeight || scrollRoot.clientHeight;
	}else{
		// on desktops, scrollRoot.clientHeight <= scrollRoot.offsetHeight <= uiWindow.innerHeight, return scrollRoot.clientHeight
		// uiWindow.innerWidth/Height includes the scrollbar and cannot be used
		w = scrollRoot.clientWidth;
		h = scrollRoot.clientHeight;
	}
	return {
		l: scroll.x,
		t: scroll.y,
		w: w,
		h: h
	};
};

window.get = function(doc){
	// summary:
	// 		Get window object associated with document doc

	// In some IE versions (at least 6.0), document.parentWindow does not return a
	// reference to the real window object (maybe a copy), so we must fix it as well
	// We use IE specific execScript to attach the real window reference to
	// document._parentWindow for later use
	if(has("ie") && window !== document.parentWindow){
		/*
		In IE 6, only the variable "window" can be used to connect events (others
		may be only copies).
		*/
		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
		//to prevent memory leak, unset it after use
		//another possibility is to add an onUnload handler which seems overkill to me (liucougar)
		var win = doc._parentWindow;
		doc._parentWindow = null;
		return win;	//	Window
	}

	return doc.parentWindow || doc.defaultView;	//	Window
};

window.scrollIntoView = function(/*DomNode*/ node, /*Object?*/ pos){
	// summary:
	//		Scroll the passed node into view, if it is not already.

	// don't rely on node.scrollIntoView working just because the function is there

	try{ // catch unexpected/unrecreatable errors (#7808) since we can recover using a semi-acceptable native method
		node = dom.byId(node);
		var doc = node.ownerDocument || baseWindow.doc,
			body = doc.body || baseWindow.body(),
			html = doc.documentElement || body.parentNode,
			isIE = has("ie"), isWK = has("webkit");
		// if an untested browser, then use the native method
		if((!(has("mozilla") || isIE || isWK || has("opera")) || node == body || node == html) && (typeof node.scrollIntoView != "undefined")){
			node.scrollIntoView(false); // short-circuit to native if possible
			return;
		}
		var backCompat = doc.compatMode == 'BackCompat',
			clientAreaRoot = (isIE >= 9 && node.ownerDocument.parentWindow.frameElement)
				? ((html.clientHeight > 0 && html.clientWidth > 0 && (body.clientHeight == 0 || body.clientWidth == 0 || body.clientHeight > html.clientHeight || body.clientWidth > html.clientWidth)) ? html : body)
				: (backCompat ? body : html),
			scrollRoot = isWK ? body : clientAreaRoot,
			rootWidth = clientAreaRoot.clientWidth,
			rootHeight = clientAreaRoot.clientHeight,
			rtl = !geom.isBodyLtr(),
			nodePos = pos || geom.position(node),
			el = node.parentNode,
			isFixed = function(el){
				return ((isIE <= 6 || (isIE && backCompat))? false : (style.get(el, 'position').toLowerCase() == "fixed"));
			};
		if(isFixed(node)){ return; } // nothing to do

		while(el){
			if(el == body){ el = scrollRoot; }
			var elPos = geom.position(el),
				fixedPos = isFixed(el);

			if(el == scrollRoot){
				elPos.w = rootWidth; elPos.h = rootHeight;
				if(scrollRoot == html && isIE && rtl){ elPos.x += scrollRoot.offsetWidth-elPos.w; } // IE workaround where scrollbar causes negative x
				if(elPos.x < 0 || !isIE){ elPos.x = 0; } // IE can have values > 0
				if(elPos.y < 0 || !isIE){ elPos.y = 0; }
			}else{
				var pb = geom.getPadBorderExtents(el);
				elPos.w -= pb.w; elPos.h -= pb.h; elPos.x += pb.l; elPos.y += pb.t;
				var clientSize = el.clientWidth,
					scrollBarSize = elPos.w - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.w = clientSize;
					elPos.x += (rtl && (isIE || el.clientLeft > pb.l/*Chrome*/)) ? scrollBarSize : 0;
				}
				clientSize = el.clientHeight;
				scrollBarSize = elPos.h - clientSize;
				if(clientSize > 0 && scrollBarSize > 0){
					elPos.h = clientSize;
				}
			}
			if(fixedPos){ // bounded by viewport, not parents
				if(elPos.y < 0){
					elPos.h += elPos.y; elPos.y = 0;
				}
				if(elPos.x < 0){
					elPos.w += elPos.x; elPos.x = 0;
				}
				if(elPos.y + elPos.h > rootHeight){
					elPos.h = rootHeight - elPos.y;
				}
				if(elPos.x + elPos.w > rootWidth){
					elPos.w = rootWidth - elPos.x;
				}
			}
			// calculate overflow in all 4 directions
			var l = nodePos.x - elPos.x, // beyond left: < 0
				t = nodePos.y - Math.max(elPos.y, 0), // beyond top: < 0
				r = l + nodePos.w - elPos.w, // beyond right: > 0
				bot = t + nodePos.h - elPos.h; // beyond bottom: > 0
			if(r * l > 0){
				var s = Math[l < 0? "max" : "min"](l, r);
				if(rtl && ((isIE == 8 && !backCompat) || isIE >= 9)){ s = -s; }
				nodePos.x += el.scrollLeft;
				el.scrollLeft += s;
				nodePos.x -= el.scrollLeft;
			}
			if(bot * t > 0){
				nodePos.y += el.scrollTop;
				el.scrollTop += Math[t < 0? "max" : "min"](t, bot);
				nodePos.y -= el.scrollTop;
			}
			el = (el != scrollRoot) && !fixedPos && el.parentNode;
		}
	}catch(error){
		console.error('scrollIntoView: ' + error);
		node.scrollIntoView(false);
	}
};

return window;
});

},
'dojo/number':function(){
define("dojo/number", ["./_base/kernel", "./_base/lang", "./i18n", "./i18n!./cldr/nls/number", "./string", "./regexp"],
	function(dojo, lang, i18n, nlsNumber, dstring, dregexp) {

	// module:
	//		dojo/number
	// summary:
	//		TODOC

lang.getObject("number", true, dojo);

/*=====
dojo.number = {
	// summary: localized formatting and parsing routines for Number
}

dojo.number.__FormatOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	places: Number?
	//		fixed number of decimal places to show.  This overrides any
	//		information in the provided pattern.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means do not round.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	fractional: Boolean?
	//		If false, show no decimal places, overriding places and pattern settings.
	this.pattern = pattern;
	this.type = type;
	this.places = places;
	this.round = round;
	this.locale = locale;
	this.fractional = fractional;
}
=====*/

dojo.number.format = function(/*Number*/value, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Format a Number as a String, using locale-specific settings
	// description:
	//		Create a string from a Number using a known localized pattern.
	//		Formatting patterns appropriate to the locale are chosen from the
	//		[Common Locale Data Repository](http://unicode.org/cldr) as well as the appropriate symbols and
	//		delimiters.
	//		If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.
	// value:
	//		the number to be formatted

	options = lang.mixin({}, options || {});
	var locale = i18n.normalizeLocale(options.locale),
		bundle = i18n.getLocalization("dojo.cldr", "number", locale);
	options.customs = bundle;
	var pattern = options.pattern || bundle[(options.type || "decimal") + "Format"];
	if(isNaN(value) || Math.abs(value) == Infinity){ return null; } // null
	return dojo.number._applyPattern(value, pattern, options); // String
};

//dojo.number._numberPatternRE = /(?:[#0]*,?)*[#0](?:\.0*#*)?/; // not precise, but good enough
dojo.number._numberPatternRE = /[#0,]*[#0](?:\.0*#*)?/; // not precise, but good enough

dojo.number._applyPattern = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatOptions?*/options){
	// summary:
	//		Apply pattern to format value as a string using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted.
	// pattern:
	//		a pattern string as described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	// options: dojo.number.__FormatOptions?
	//		_applyPattern is usually called via `dojo.number.format()` which
	//		populates an extra property in the options parameter, "customs".
	//		The customs object specifies group and decimal parameters if set.

	//TODO: support escapes
	options = options || {};
	var group = options.customs.group,
		decimal = options.customs.decimal,
		patternList = pattern.split(';'),
		positivePattern = patternList[0];
	pattern = patternList[(value < 0) ? 1 : 0] || ("-" + positivePattern);

	//TODO: only test against unescaped
	if(pattern.indexOf('%') != -1){
		value *= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		value *= 1000; // per mille
	}else if(pattern.indexOf('\u00a4') != -1){
		group = options.customs.currencyGroup || group;//mixins instead?
		decimal = options.customs.currencyDecimal || decimal;// Should these be mixins instead?
		pattern = pattern.replace(/\u00a4{1,3}/, function(match){
			var prop = ["symbol", "currency", "displayName"][match.length-1];
			return options[prop] || options.currency || "";
		});
	}else if(pattern.indexOf('E') != -1){
		throw new Error("exponential notation not supported");
	}

	//TODO: support @ sig figs?
	var numberPatternRE = dojo.number._numberPatternRE;
	var numberPattern = positivePattern.match(numberPatternRE);
	if(!numberPattern){
		throw new Error("unable to find a number expression in pattern: "+pattern);
	}
	if(options.fractional === false){ options.places = 0; }
	return pattern.replace(numberPatternRE,
		dojo.number._formatAbsolute(value, numberPattern[0], {decimal: decimal, group: group, places: options.places, round: options.round}));
};

dojo.number.round = function(/*Number*/value, /*Number?*/places, /*Number?*/increment){
	//	summary:
	//		Rounds to the nearest value with the given number of decimal places, away from zero
	//	description:
	//		Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	//		Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	//		fractional increments also, such as the nearest quarter.
	//		NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.
	//	value:
	//		The number to round
	//	places:
	//		The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	//		Must be non-negative.
	//	increment:
	//		Rounds next place to nearest value of increment/10.  10 by default.
	//	example:
	//		>>> dojo.number.round(-0.5)
	//		-1
	//		>>> dojo.number.round(162.295, 2)
	//		162.29  // note floating point error.  Should be 162.3
	//		>>> dojo.number.round(10.71, 0, 2.5)
	//		10.75
	var factor = 10 / (increment || 10);
	return (factor * +value).toFixed(places) / factor; // Number
};

if((0.9).toFixed() == 0){
	// (isIE) toFixed() bug workaround: Rounding fails on IE when most significant digit
	// is just after the rounding place and is >=5
	var round = dojo.number.round;
	dojo.number.round = function(v, p, m){
		var d = Math.pow(10, -p || 0), a = Math.abs(v);
		if(!v || a >= d || a * Math.pow(10, p + 1) < 5){
			d = 0;
		}
		return round(v, p, m) + (v > 0 ? d : -d);
	};
}

/*=====
dojo.number.__FormatAbsoluteOptions = function(){
	//	decimal: String?
	//		the decimal separator
	//	group: String?
	//		the group separator
	//	places: Number?|String?
	//		number of decimal places.  the range "n,m" will format to m places.
	//	round: Number?
	//		5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	//		means don't round.
	this.decimal = decimal;
	this.group = group;
	this.places = places;
	this.round = round;
}
=====*/

dojo.number._formatAbsolute = function(/*Number*/value, /*String*/pattern, /*dojo.number.__FormatAbsoluteOptions?*/options){
	// summary:
	//		Apply numeric pattern to absolute value using options. Gives no
	//		consideration to local customs.
	// value:
	//		the number to be formatted, ignores sign
	// pattern:
	//		the number portion of a pattern (e.g. `#,##0.00`)
	options = options || {};
	if(options.places === true){options.places=0;}
	if(options.places === Infinity){options.places=6;} // avoid a loop; pick a limit

	var patternParts = pattern.split("."),
		comma = typeof options.places == "string" && options.places.indexOf(","),
		maxPlaces = options.places;
	if(comma){
		maxPlaces = options.places.substring(comma + 1);
	}else if(!(maxPlaces >= 0)){
		maxPlaces = (patternParts[1] || []).length;
	}
	if(!(options.round < 0)){
		value = dojo.number.round(value, maxPlaces, options.round);
	}

	var valueParts = String(Math.abs(value)).split("."),
		fractional = valueParts[1] || "";
	if(patternParts[1] || options.places){
		if(comma){
			options.places = options.places.substring(0, comma);
		}
		// Pad fractional with trailing zeros
		var pad = options.places !== undefined ? options.places : (patternParts[1] && patternParts[1].lastIndexOf("0") + 1);
		if(pad > fractional.length){
			valueParts[1] = dstring.pad(fractional, pad, '0', true);
		}

		// Truncate fractional
		if(maxPlaces < fractional.length){
			valueParts[1] = fractional.substr(0, maxPlaces);
		}
	}else{
		if(valueParts[1]){ valueParts.pop(); }
	}

	// Pad whole with leading zeros
	var patternDigits = patternParts[0].replace(',', '');
	pad = patternDigits.indexOf("0");
	if(pad != -1){
		pad = patternDigits.length - pad;
		if(pad > valueParts[0].length){
			valueParts[0] = dstring.pad(valueParts[0], pad);
		}

		// Truncate whole
		if(patternDigits.indexOf("#") == -1){
			valueParts[0] = valueParts[0].substr(valueParts[0].length - pad);
		}
	}

	// Add group separators
	var index = patternParts[0].lastIndexOf(','),
		groupSize, groupSize2;
	if(index != -1){
		groupSize = patternParts[0].length - index - 1;
		var remainder = patternParts[0].substr(0, index);
		index = remainder.lastIndexOf(',');
		if(index != -1){
			groupSize2 = remainder.length - index - 1;
		}
	}
	var pieces = [];
	for(var whole = valueParts[0]; whole;){
		var off = whole.length - groupSize;
		pieces.push((off > 0) ? whole.substr(off) : whole);
		whole = (off > 0) ? whole.slice(0, off) : "";
		if(groupSize2){
			groupSize = groupSize2;
			delete groupSize2;
		}
	}
	valueParts[0] = pieces.reverse().join(options.group || ",");

	return valueParts.join(options.decimal || ".");
};

/*=====
dojo.number.__RegexpOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	places: Number|String?
	//		number of decimal places to accept: Infinity, a positive number, or
	//		a range "n,m".  Defined by pattern or Infinity if pattern not provided.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.places = places;
}
=====*/
dojo.number.regexp = function(/*dojo.number.__RegexpOptions?*/options){
	//	summary:
	//		Builds the regular needed to parse a number
	//	description:
	//		Returns regular expression with positive and negative match, group
	//		and decimal separators
	return dojo.number._parseInfo(options).regexp; // String
};

dojo.number._parseInfo = function(/*Object?*/options){
	options = options || {};
	var locale = i18n.normalizeLocale(options.locale),
		bundle = i18n.getLocalization("dojo.cldr", "number", locale),
		pattern = options.pattern || bundle[(options.type || "decimal") + "Format"],
//TODO: memoize?
		group = bundle.group,
		decimal = bundle.decimal,
		factor = 1;

	if(pattern.indexOf('%') != -1){
		factor /= 100;
	}else if(pattern.indexOf('\u2030') != -1){
		factor /= 1000; // per mille
	}else{
		var isCurrency = pattern.indexOf('\u00a4') != -1;
		if(isCurrency){
			group = bundle.currencyGroup || group;
			decimal = bundle.currencyDecimal || decimal;
		}
	}

	//TODO: handle quoted escapes
	var patternList = pattern.split(';');
	if(patternList.length == 1){
		patternList.push("-" + patternList[0]);
	}

	var re = dregexp.buildGroupRE(patternList, function(pattern){
		pattern = "(?:"+dregexp.escapeString(pattern, '.')+")";
		return pattern.replace(dojo.number._numberPatternRE, function(format){
			var flags = {
				signed: false,
				separator: options.strict ? group : [group,""],
				fractional: options.fractional,
				decimal: decimal,
				exponent: false
				},

				parts = format.split('.'),
				places = options.places;

			// special condition for percent (factor != 1)
			// allow decimal places even if not specified in pattern
			if(parts.length == 1 && factor != 1){
			    parts[1] = "###";
			}
			if(parts.length == 1 || places === 0){
				flags.fractional = false;
			}else{
				if(places === undefined){ places = options.pattern ? parts[1].lastIndexOf('0') + 1 : Infinity; }
				if(places && options.fractional == undefined){flags.fractional = true;} // required fractional, unless otherwise specified
				if(!options.places && (places < parts[1].length)){ places += "," + parts[1].length; }
				flags.places = places;
			}
			var groups = parts[0].split(',');
			if(groups.length > 1){
				flags.groupSize = groups.pop().length;
				if(groups.length > 1){
					flags.groupSize2 = groups.pop().length;
				}
			}
			return "("+dojo.number._realNumberRegexp(flags)+")";
		});
	}, true);

	if(isCurrency){
		// substitute the currency symbol for the placeholder in the pattern
		re = re.replace(/([\s\xa0]*)(\u00a4{1,3})([\s\xa0]*)/g, function(match, before, target, after){
			var prop = ["symbol", "currency", "displayName"][target.length-1],
				symbol = dregexp.escapeString(options[prop] || options.currency || "");
			before = before ? "[\\s\\xa0]" : "";
			after = after ? "[\\s\\xa0]" : "";
			if(!options.strict){
				if(before){before += "*";}
				if(after){after += "*";}
				return "(?:"+before+symbol+after+")?";
			}
			return before+symbol+after;
		});
	}

//TODO: substitute localized sign/percent/permille/etc.?

	// normalize whitespace and return
	return {regexp: re.replace(/[\xa0 ]/g, "[\\s\\xa0]"), group: group, decimal: decimal, factor: factor}; // Object
};

/*=====
dojo.number.__ParseOptions = function(){
	//	pattern: String?
	//		override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	//		with this string.  Default value is based on locale.  Overriding this property will defeat
	//		localization.  Literal characters in patterns are not supported.
	//	type: String?
	//		choose a format type based on the locale from the following:
	//		decimal, scientific (not yet supported), percent, currency. decimal by default.
	//	locale: String?
	//		override the locale used to determine formatting rules
	//	strict: Boolean?
	//		strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	//		Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators
	//	fractional: Boolean?|Array?
	//		Whether to include the fractional portion, where the number of decimal places are implied by pattern
	//		or explicit 'places' parameter.  The value [true,false] makes the fractional portion optional.
	this.pattern = pattern;
	this.type = type;
	this.locale = locale;
	this.strict = strict;
	this.fractional = fractional;
}
=====*/
dojo.number.parse = function(/*String*/expression, /*dojo.number.__ParseOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Number, using
	//		locale-specific settings.
	// description:
	//		Create a Number from a string using a known localized pattern.
	//		Formatting patterns are chosen appropriate to the locale
	//		and follow the syntax described by
	//		[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
    	//		Note that literal characters in patterns are not supported.
	// expression:
	//		A string representation of a Number
	var info = dojo.number._parseInfo(options),
		results = (new RegExp("^"+info.regexp+"$")).exec(expression);
	if(!results){
		return NaN; //NaN
	}
	var absoluteMatch = results[1]; // match for the positive expression
	if(!results[1]){
		if(!results[2]){
			return NaN; //NaN
		}
		// matched the negative pattern
		absoluteMatch =results[2];
		info.factor *= -1;
	}

	// Transform it to something Javascript can parse as a number.  Normalize
	// decimal point and strip out group separators or alternate forms of whitespace
	absoluteMatch = absoluteMatch.
		replace(new RegExp("["+info.group + "\\s\\xa0"+"]", "g"), "").
		replace(info.decimal, ".");
	// Adjust for negative sign, percent, etc. as necessary
	return absoluteMatch * info.factor; //Number
};

/*=====
dojo.number.__RealNumberRegexpFlags = function(){
	//	places: Number?
	//		The integer number of decimal places or a range given as "n,m".  If
	//		not given, the decimal part is optional and the number of places is
	//		unlimited.
	//	decimal: String?
	//		A string for the character used as the decimal point.  Default
	//		is ".".
	//	fractional: Boolean?|Array?
	//		Whether decimal places are used.  Can be true, false, or [true,
	//		false].  Default is [true, false] which means optional.
	//	exponent: Boolean?|Array?
	//		Express in exponential notation.  Can be true, false, or [true,
	//		false]. Default is [true, false], (i.e. will match if the
	//		exponential part is present are not).
	//	eSigned: Boolean?|Array?
	//		The leading plus-or-minus sign on the exponent.  Can be true,
	//		false, or [true, false].  Default is [true, false], (i.e. will
	//		match if it is signed or unsigned).  flags in regexp.integer can be
	//		applied.
	this.places = places;
	this.decimal = decimal;
	this.fractional = fractional;
	this.exponent = exponent;
	this.eSigned = eSigned;
}
=====*/

dojo.number._realNumberRegexp = function(/*dojo.number.__RealNumberRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression to match a real number in exponential
	//		notation

	// assign default values to missing parameters
	flags = flags || {};
	//TODO: use mixin instead?
	if(!("places" in flags)){ flags.places = Infinity; }
	if(typeof flags.decimal != "string"){ flags.decimal = "."; }
	if(!("fractional" in flags) || /^0/.test(flags.places)){ flags.fractional = [true, false]; }
	if(!("exponent" in flags)){ flags.exponent = [true, false]; }
	if(!("eSigned" in flags)){ flags.eSigned = [true, false]; }

	var integerRE = dojo.number._integerRegexp(flags),
		decimalRE = dregexp.buildGroupRE(flags.fractional,
		function(q){
			var re = "";
			if(q && (flags.places!==0)){
				re = "\\" + flags.decimal;
				if(flags.places == Infinity){
					re = "(?:" + re + "\\d+)?";
				}else{
					re += "\\d{" + flags.places + "}";
				}
			}
			return re;
		},
		true
	);

	var exponentRE = dregexp.buildGroupRE(flags.exponent,
		function(q){
			if(q){ return "([eE]" + dojo.number._integerRegexp({ signed: flags.eSigned}) + ")"; }
			return "";
		}
	);

	var realRE = integerRE + decimalRE;
	// allow for decimals without integers, e.g. .25
	if(decimalRE){realRE = "(?:(?:"+ realRE + ")|(?:" + decimalRE + "))";}
	return realRE + exponentRE; // String
};

/*=====
dojo.number.__IntegerRegexpFlags = function(){
	//	signed: Boolean?
	//		The leading plus-or-minus sign. Can be true, false, or `[true,false]`.
	//		Default is `[true, false]`, (i.e. will match if it is signed
	//		or unsigned).
	//	separator: String?
	//		The character used as the thousands separator. Default is no
	//		separator. For more than one symbol use an array, e.g. `[",", ""]`,
	//		makes ',' optional.
	//	groupSize: Number?
	//		group size between separators
	//	groupSize2: Number?
	//		second grouping, where separators 2..n have a different interval than the first separator (for India)
	this.signed = signed;
	this.separator = separator;
	this.groupSize = groupSize;
	this.groupSize2 = groupSize2;
}
=====*/

dojo.number._integerRegexp = function(/*dojo.number.__IntegerRegexpFlags?*/flags){
	// summary:
	//		Builds a regular expression that matches an integer

	// assign default values to missing parameters
	flags = flags || {};
	if(!("signed" in flags)){ flags.signed = [true, false]; }
	if(!("separator" in flags)){
		flags.separator = "";
	}else if(!("groupSize" in flags)){
		flags.groupSize = 3;
	}

	var signRE = dregexp.buildGroupRE(flags.signed,
		function(q){ return q ? "[-+]" : ""; },
		true
	);

	var numberRE = dregexp.buildGroupRE(flags.separator,
		function(sep){
			if(!sep){
				return "(?:\\d+)";
			}

			sep = dregexp.escapeString(sep);
			if(sep == " "){ sep = "\\s"; }
			else if(sep == "\xa0"){ sep = "\\s\\xa0"; }

			var grp = flags.groupSize, grp2 = flags.groupSize2;
			//TODO: should we continue to enforce that numbers with separators begin with 1-9?  See #6933
			if(grp2){
				var grp2RE = "(?:0|[1-9]\\d{0," + (grp2-1) + "}(?:[" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
				return ((grp-grp2) > 0) ? "(?:" + grp2RE + "|(?:0|[1-9]\\d{0," + (grp-1) + "}))" : grp2RE;
			}
			return "(?:0|[1-9]\\d{0," + (grp-1) + "}(?:[" + sep + "]\\d{" + grp + "})*)";
		},
		true
	);

	return signRE + numberRE; // String
};

return dojo.number;
});

},
'dijit/_FocusMixin':function(){
define("dijit/_FocusMixin", [
	"./focus",
	"./_WidgetBase",
	"dojo/_base/declare", // declare
	"dojo/_base/lang" // lang.extend
], function(focus, _WidgetBase, declare, lang){

/*=====
	var _WidgetBase = dijit._WidgetBase;
=====*/

	// module:
	//		dijit/_FocusMixin
	// summary:
	//		Mixin to widget to provide _onFocus() and _onBlur() methods that
	//		fire when a widget or it's descendants get/lose focus

	// We don't know where _FocusMixin will occur in the inheritance chain, but we need the _onFocus()/_onBlur() below
	// to be last in the inheritance chain, so mixin to _WidgetBase.
	lang.extend(_WidgetBase, {
		// focused: [readonly] Boolean
		//		This widget or a widget it contains has focus, or is "active" because
		//		it was recently clicked.
		focused: false,

		onFocus: function(){
			// summary:
			//		Called when the widget becomes "active" because
			//		it or a widget inside of it either has focus, or has recently
			//		been clicked.
			// tags:
			//		callback
		},

		onBlur: function(){
			// summary:
			//		Called when the widget stops being "active" because
			//		focus moved to something outside of it, or the user
			//		clicked somewhere outside of it, or the widget was
			//		hidden.
			// tags:
			//		callback
		},

		_onFocus: function(){
			// summary:
			//		This is where widgets do processing for when they are active,
			//		such as changing CSS classes.  See onFocus() for more details.
			// tags:
			//		protected
			this.onFocus();
		},

		_onBlur: function(){
			// summary:
			//		This is where widgets do processing for when they stop being active,
			//		such as changing CSS classes.  See onBlur() for more details.
			// tags:
			//		protected
			this.onBlur();
		}
	});

	return declare("dijit._FocusMixin", null, {
		// summary:
		//		Mixin to widget to provide _onFocus() and _onBlur() methods that
		//		fire when a widget or it's descendants get/lose focus

		// flag that I want _onFocus()/_onBlur() notifications from focus manager
		_focusManager: focus
	});

});

},
'dijit/_WidgetsInTemplateMixin':function(){
define("dijit/_WidgetsInTemplateMixin", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/declare", // declare
	"dojo/parser", // parser.parse
	"dijit/registry"	// registry.findWidgets
], function(array, declare, parser, registry){

	// module:
	//		dijit/_WidgetsInTemplateMixin
	// summary:
	//		Mixin to supplement _TemplatedMixin when template contains widgets

	return declare("dijit._WidgetsInTemplateMixin", null, {
		// summary:
		//		Mixin to supplement _TemplatedMixin when template contains widgets

		// _earlyTemplatedStartup: Boolean
		//		A fallback to preserve the 1.0 - 1.3 behavior of children in
		//		templates having their startup called before the parent widget
		//		fires postCreate. Defaults to 'false', causing child widgets to
		//		have their .startup() called immediately before a parent widget
		//		.startup(), but always after the parent .postCreate(). Set to
		//		'true' to re-enable to previous, arguably broken, behavior.
		_earlyTemplatedStartup: false,

		// widgetsInTemplate: [protected] Boolean
		//		Should we parse the template to find widgets that might be
		//		declared in markup inside it?  (Remove for 2.0 and assume true)
		widgetsInTemplate: true,

		_beforeFillContent: function(){
			if(this.widgetsInTemplate){
				// Before copying over content, instantiate widgets in template
				var node = this.domNode;

				var cw = (this._startupWidgets = parser.parse(node, {
					noStart: !this._earlyTemplatedStartup,
					template: true,
					inherited: {dir: this.dir, lang: this.lang, textDir: this.textDir},
					propsThis: this,	// so data-dojo-props of widgets in the template can reference "this" to refer to me
					scope: "dojo"	// even in multi-version mode templates use dojoType/data-dojo-type
				}));

				this._supportingWidgets = registry.findWidgets(node);

				this._attachTemplateNodes(cw, function(n,p){
					return n[p];
				});
			}
		},

		startup: function(){
			array.forEach(this._startupWidgets, function(w){
				if(w && !w._started && w.startup){
					w.startup();
				}
			});
			this.inherited(arguments);
		}
	});
});

},
'dojo/data/util/filter':function(){
define("dojo/data/util/filter", ["dojo/_base/lang"], function(lang) {
	// module:
	//		dojo/data/util/filter
	// summary:
	//		TODOC

var filter = lang.getObject("dojo.data.util.filter", true);

filter.patternToRegExp = function(/*String*/pattern, /*boolean?*/ ignoreCase){
	//	summary:
	//		Helper function to convert a simple pattern to a regular expression for matching.
	//	description:
	//		Returns a regular expression object that conforms to the defined conversion rules.
	//		For example:
	//			ca*   -> /^ca.*$/
	//			*ca*  -> /^.*ca.*$/
	//			*c\*a*  -> /^.*c\*a.*$/
	//			*c\*a?*  -> /^.*c\*a..*$/
	//			and so on.
	//
	//	pattern: string
	//		A simple matching pattern to convert that follows basic rules:
	//			* Means match anything, so ca* means match anything starting with ca
	//			? Means match single character.  So, b?b will match to bob and bab, and so on.
	//      	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	//				To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	//				represented by \\ to be treated as an ordinary \ character instead of an escape.
	//
	//	ignoreCase:
	//		An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	//		By default, it is assumed case sensitive.

	var rxp = "^";
	var c = null;
	for(var i = 0; i < pattern.length; i++){
		c = pattern.charAt(i);
		switch(c){
			case '\\':
				rxp += c;
				i++;
				rxp += pattern.charAt(i);
				break;
			case '*':
				rxp += ".*"; break;
			case '?':
				rxp += "."; break;
			case '$':
			case '^':
			case '/':
			case '+':
			case '.':
			case '|':
			case '(':
			case ')':
			case '{':
			case '}':
			case '[':
			case ']':
				rxp += "\\"; //fallthrough
			default:
				rxp += c;
		}
	}
	rxp += "$";
	if(ignoreCase){
		return new RegExp(rxp,"mi"); //RegExp
	}else{
		return new RegExp(rxp,"m"); //RegExp
	}

};

return filter;
});

},
'dojox/gfx/path':function(){
define("dojox/gfx/path", ["./_base", "dojo/_base/lang","dojo/_base/declare", "./matrix", "./shape"], 
  function(g, lang, declare, matrix, shapeLib){
/*===== 
	dojox.gfx.path = {
		// summary:
		//		This module contains the core graphics Path API.
		//		Path command format follows the W3C SVG 1.0 Path api.
	};
	g = dojox.gfx;
	shape.Shape = dojox.gfx.shape.Shape;
  =====*/

	var path = g.path = {};
	var Path = declare("dojox.gfx.path.Path", shapeLib.Shape, {
		// summary: a generalized path shape

		constructor: function(rawNode){
			// summary: a path constructor
			// rawNode: Node
			//		a DOM node to be used by this path object
			this.shape = lang.clone(g.defaultPath);
			this.segments = [];
			this.tbbox = null;
			this.absolute = true;
			this.last = {};
			this.rawNode = rawNode;
			this.segmented = false;
		},

		// mode manipulations
		setAbsoluteMode: function(mode){
			// summary: sets an absolute or relative mode for path points
			// mode: Boolean
			//		true/false or "absolute"/"relative" to specify the mode
			this._confirmSegmented();
			this.absolute = typeof mode == "string" ? (mode == "absolute") : mode;
			return this; // self
		},
		getAbsoluteMode: function(){
			// summary: returns a current value of the absolute mode
			this._confirmSegmented();
			return this.absolute; // Boolean
		},

		getBoundingBox: function(){
			// summary: returns the bounding box {x, y, width, height} or null
			this._confirmSegmented();
			return (this.bbox && ("l" in this.bbox)) ? {x: this.bbox.l, y: this.bbox.t, width: this.bbox.r - this.bbox.l, height: this.bbox.b - this.bbox.t} : null; // dojox.gfx.Rectangle
		},

		_getRealBBox: function(){
			// summary: returns an array of four points or null
			//	four points represent four corners of the untransformed bounding box
			this._confirmSegmented();
			if(this.tbbox){
				return this.tbbox;	// Array
			}
			var bbox = this.bbox, matrix = this._getRealMatrix();
			this.bbox = null;
			for(var i = 0, len = this.segments.length; i < len; ++i){
				this._updateWithSegment(this.segments[i], matrix);
			}
			var t = this.bbox;
			this.bbox = bbox;
			this.tbbox = t ? [
				{x: t.l, y: t.t},
				{x: t.r, y: t.t},
				{x: t.r, y: t.b},
				{x: t.l, y: t.b}
			] : null;
			return this.tbbox;	// Array
		},

		getLastPosition: function(){
			// summary: returns the last point in the path, or null
			this._confirmSegmented();
			return "x" in this.last ? this.last : null; // Object
		},

		_applyTransform: function(){
			this.tbbox = null;
			return this.inherited(arguments);
		},

		// segment interpretation
		_updateBBox: function(x, y, m){
			// summary: updates the bounding box of path with new point
			// x: Number
			//		an x coordinate
			// y: Number
			//		a y coordinate

			if(m){
				var t = matrix.multiplyPoint(m, x, y);
				x = t.x;
				y = t.y;
			}

			// we use {l, b, r, t} representation of a bbox
			if(this.bbox && ("l" in this.bbox)){
				if(this.bbox.l > x) this.bbox.l = x;
				if(this.bbox.r < x) this.bbox.r = x;
				if(this.bbox.t > y) this.bbox.t = y;
				if(this.bbox.b < y) this.bbox.b = y;
			}else{
				this.bbox = {l: x, b: y, r: x, t: y};
			}
		},
		_updateWithSegment: function(segment, matrix){
			// summary: updates the bounding box of path with new segment
			// segment: Object
			//		a segment
			var n = segment.args, l = n.length, i;
			// update internal variables: bbox, absolute, last
			switch(segment.action){
				case "M":
				case "L":
				case "C":
				case "S":
				case "Q":
				case "T":
					for(i = 0; i < l; i += 2){
						this._updateBBox(n[i], n[i + 1], matrix);
					}
					this.last.x = n[l - 2];
					this.last.y = n[l - 1];
					this.absolute = true;
					break;
				case "H":
					for(i = 0; i < l; ++i){
						this._updateBBox(n[i], this.last.y, matrix);
					}
					this.last.x = n[l - 1];
					this.absolute = true;
					break;
				case "V":
					for(i = 0; i < l; ++i){
						this._updateBBox(this.last.x, n[i], matrix);
					}
					this.last.y = n[l - 1];
					this.absolute = true;
					break;
				case "m":
					var start = 0;
					if(!("x" in this.last)){
						this._updateBBox(this.last.x = n[0], this.last.y = n[1], matrix);
						start = 2;
					}
					for(i = start; i < l; i += 2){
						this._updateBBox(this.last.x += n[i], this.last.y += n[i + 1], matrix);
					}
					this.absolute = false;
					break;
				case "l":
				case "t":
					for(i = 0; i < l; i += 2){
						this._updateBBox(this.last.x += n[i], this.last.y += n[i + 1], matrix);
					}
					this.absolute = false;
					break;
				case "h":
					for(i = 0; i < l; ++i){
						this._updateBBox(this.last.x += n[i], this.last.y, matrix);
					}
					this.absolute = false;
					break;
				case "v":
					for(i = 0; i < l; ++i){
						this._updateBBox(this.last.x, this.last.y += n[i], matrix);
					}
					this.absolute = false;
					break;
				case "c":
					for(i = 0; i < l; i += 6){
						this._updateBBox(this.last.x + n[i], this.last.y + n[i + 1], matrix);
						this._updateBBox(this.last.x + n[i + 2], this.last.y + n[i + 3], matrix);
						this._updateBBox(this.last.x += n[i + 4], this.last.y += n[i + 5], matrix);
					}
					this.absolute = false;
					break;
				case "s":
				case "q":
					for(i = 0; i < l; i += 4){
						this._updateBBox(this.last.x + n[i], this.last.y + n[i + 1], matrix);
						this._updateBBox(this.last.x += n[i + 2], this.last.y += n[i + 3], matrix);
					}
					this.absolute = false;
					break;
				case "A":
					for(i = 0; i < l; i += 7){
						this._updateBBox(n[i + 5], n[i + 6], matrix);
					}
					this.last.x = n[l - 2];
					this.last.y = n[l - 1];
					this.absolute = true;
					break;
				case "a":
					for(i = 0; i < l; i += 7){
						this._updateBBox(this.last.x += n[i + 5], this.last.y += n[i + 6], matrix);
					}
					this.absolute = false;
					break;
			}
			// add an SVG path segment
			var path = [segment.action];
			for(i = 0; i < l; ++i){
				path.push(g.formatNumber(n[i], true));
			}
			if(typeof this.shape.path == "string"){
				this.shape.path += path.join("");
			}else{
				Array.prototype.push.apply(this.shape.path, path); //FIXME: why not simple push()?
			}
		},

		// a dictionary, which maps segment type codes to a number of their arguments
		_validSegments: {m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7, z: 0},

		_pushSegment: function(action, args){
			// summary: adds a segment
			// action: String
			//		valid SVG code for a segment's type
			// args: Array
			//		a list of parameters for this segment
			this.tbbox = null;
			var group = this._validSegments[action.toLowerCase()], segment;
			if(typeof group == "number"){
				if(group){
					if(args.length >= group){
						segment = {action: action, args: args.slice(0, args.length - args.length % group)};
						this.segments.push(segment);
						this._updateWithSegment(segment);
					}
				}else{
					segment = {action: action, args: []};
					this.segments.push(segment);
					this._updateWithSegment(segment);
				}
			}
		},

		_collectArgs: function(array, args){
			// summary: converts an array of arguments to plain numeric values
			// array: Array
			//		an output argument (array of numbers)
			// args: Array
			//		an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)
			for(var i = 0; i < args.length; ++i){
				var t = args[i];
				if(typeof t == "boolean"){
					array.push(t ? 1 : 0);
				}else if(typeof t == "number"){
					array.push(t);
				}else if(t instanceof Array){
					this._collectArgs(array, t);
				}else if("x" in t && "y" in t){
					array.push(t.x, t.y);
				}
			}
		},

		// segments
		moveTo: function(){
			// summary: forms a move segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "M" : "m", args);
			return this; // self
		},
		lineTo: function(){
			// summary: forms a line segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "L" : "l", args);
			return this; // self
		},
		hLineTo: function(){
			// summary: forms a horizontal line segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "H" : "h", args);
			return this; // self
		},
		vLineTo: function(){
			// summary: forms a vertical line segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "V" : "v", args);
			return this; // self
		},
		curveTo: function(){
			// summary: forms a curve segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "C" : "c", args);
			return this; // self
		},
		smoothCurveTo: function(){
			// summary: forms a smooth curve segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "S" : "s", args);
			return this; // self
		},
		qCurveTo: function(){
			// summary: forms a quadratic curve segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "Q" : "q", args);
			return this; // self
		},
		qSmoothCurveTo: function(){
			// summary: forms a quadratic smooth curve segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "T" : "t", args);
			return this; // self
		},
		arcTo: function(){
			// summary: forms an elliptic arc segment
			this._confirmSegmented();
			var args = [];
			this._collectArgs(args, arguments);
			this._pushSegment(this.absolute ? "A" : "a", args);
			return this; // self
		},
		closePath: function(){
			// summary: closes a path
			this._confirmSegmented();
			this._pushSegment("Z", []);
			return this; // self
		},

		_confirmSegmented: function() {
			if (!this.segmented) {
				var path = this.shape.path;
				// switch to non-updating version of path building
				this.shape.path = [];
				this._setPath(path);
				// switch back to the string path
				this.shape.path = this.shape.path.join("");
				// become segmented
				this.segmented = true;
			}
		},

		// setShape
		_setPath: function(path){
			// summary: forms a path using an SVG path string
			// path: String
			//		an SVG path string
			var p = lang.isArray(path) ? path : path.match(g.pathSvgRegExp);
			this.segments = [];
			this.absolute = true;
			this.bbox = {};
			this.last = {};
			if(!p) return;
			// create segments
			var action = "",	// current action
				args = [],		// current arguments
				l = p.length;
			for(var i = 0; i < l; ++i){
				var t = p[i], x = parseFloat(t);
				if(isNaN(x)){
					if(action){
						this._pushSegment(action, args);
					}
					args = [];
					action = t;
				}else{
					args.push(x);
				}
			}
			this._pushSegment(action, args);
		},
		setShape: function(newShape){
			// summary: forms a path using a shape
			// newShape: Object
			//		an SVG path string or a path object (see dojox.gfx.defaultPath)
			this.inherited(arguments, [typeof newShape == "string" ? {path: newShape} : newShape]);

			this.segmented = false;
			this.segments = [];
			if(!g.lazyPathSegmentation){
				this._confirmSegmented();
			}
			return this; // self
		},

		// useful constant for descendants
		_2PI: Math.PI * 2
	});

	var TextPath = declare("dojox.gfx.path.TextPath", Path, {
		// summary: a generalized TextPath shape

		constructor: function(rawNode){
			// summary: a TextPath shape constructor
			// rawNode: Node
			//		a DOM node to be used by this TextPath object
			if(!("text" in this)){
				this.text = lang.clone(g.defaultTextPath);
			}
			if(!("fontStyle" in this)){
				this.fontStyle = lang.clone(g.defaultFont);
			}
		},
		getText: function(){
			// summary: returns the current text object or null
			return this.text;	// Object
		},
		setText: function(newText){
			// summary: sets a text to be drawn along the path
			this.text = g.makeParameters(this.text,
				typeof newText == "string" ? {text: newText} : newText);
			this._setText();
			return this;	// self
		},
		getFont: function(){
			// summary: returns the current font object or null
			return this.fontStyle;	// Object
		},
		setFont: function(newFont){
			// summary: sets a font for text
			this.fontStyle = typeof newFont == "string" ?
				g.splitFontString(newFont) :
				g.makeParameters(g.defaultFont, newFont);
			this._setFont();
			return this;	// self
		}
	});

	return { // our hash of newly defined objects
		Path: Path,
		TextPath: TextPath
	};
});

},
'ibm/tivoli/simplesrm/srm/dijit/MyBBoardMessagesGrid':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dijit/MyRecordsGrid,ibm/tivoli/simplesrm/srm/dijit/MessageDetails,dijit/Dialog"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MyBBoardMessagesGrid");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ShowMessageDetails");

// include modules
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MessageDetails");
dojo.require("dijit.Dialog");


// Summary:
//	A mixin for showing message details.
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ShowMessageDetails",
			 ibm.tivoli.simplesrm.srm.dijit.CreatorFactory,
{
	_approveRights: false,

	popup: null,
	
	showRecordDetails: function(selected_record)
	{
		if(this.popup) {
			this.popup.destroy();
			this.popup = null;
		}
		if(selected_record) {
			console.log("ShowMessageDetails", selected_record);
			var rd = new ibm.tivoli.simplesrm.srm.dijit.MessageDetails({approval: this._approveRights});
			rd.setData(selected_record);

			/*var d = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMessageDetails(selected_record);
			d.addCallback(dojo.hitch(this, function(response)
			{
				var rd = new ibm.tivoli.simplesrm.srm.dijit.MessageDetails({approval: this._approveRights});
				rd.setData(response);
			})); */
		}
	},
	
	/**
	 * Specify whether the parent grid allows the approval panel to be displayed
	 * or not.
	 */
	setApprContext: function(approvalContext) {
		this._approveRights = approvalContext;
	}
});

// Format Grid
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.MyBBoardMessagesGrid", 
	[dijit._Widget, ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid, ibm.tivoli.simplesrm.srm.dijit.ShowMessageDetails],
{
 
	// constructor defines "static" properties for this class, and
	// declares "instance" properties for this class
	constructor: function()
	{
		console.log("MyBBoardMessagesGrid.ctor");
		
//		this._hoverer = new  ibm.tivoli.simplesrm.srm.dojo.Hoverer();
//		this._conn_onHover = dojo.connect(this._hoverer, "OnHover", this, "_showGridTooltip");
		
 		// the column definitions
 		// the order they are listed here is the order they will be displayed in the tooltip
		this._column_defs = [
			 {field: 'key',			name: "",							 	width: '10%',	compare: dojo.hitch(this, "_sortDefault"), showInTooltip: false}
			,{field: 'id', 			name: 'id',								width: '10%',	compare: dojo.hitch(this, "_sortNumber")}
			,{field: 'type', 		name: "Object Type",					width: '10%',	compare: dojo.hitch(this, "_sortString"), showInTooltip: false}
			,{field: 'SUBJECT',		name: this._uiStringTable.Subject, 	    width: '20%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
			,{field: 'MESSAGE',     name: this._uiStringTable.Message,  	width: '40%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringHtml")}
			,{field: 'POSTDATE',    name: this._uiStringTable.PostDate,     width: '15%',   compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")}
			,{field: 'EXPIREDATE',  name: this._uiStringTable.ExpireDate,   width: '15%',   compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")}
			,{field: 'StatusString',name: this._uiStringTable.Status,		width: '5%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe")}
		];
		
		//,{field: 'ISVIEWED',    name: this._uiStringTable.MsgViewed,    width: '5%',    compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe")}
		
		var tracking = ibm.tivoli.simplesrm.srm.dijit.Overview._BBoardPodTracking();
		if(tracking == "1")
		
		{
			this._column_defs.push({field: "ISVIEWED",  name: this._uiStringTable.MsgViewed,   width: '5%',  compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")});
			this._initial_view_cols = [3, 4, 5, 6, 8];
		}
		else
		{
			this._initial_view_cols = [3, 4, 5, 6];
		}
		
		this._data_key_field = 0;
		this._initial_sort_index = 2;	 	// change date (column index, not field index)
		this._initial_sort_asc = false;		// descending
		
		// query parameters
		this._queryErrorMessage = "CTJZH2361E";

	},
	ajaxQueryData: function()
	{
		return ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getBBoardMessages();

	},
	
	// load handler for the data query
	_processQueryResult: function(response)
	{
		if(!dojo.isArray(response.Requests)) {
			response.requests = [];
		}
		
		var messages = ibm.tivoli.simplesrm.srm.dijit.Overview._BBoardPod()._processMessages(response.Requests);
		
		this._loadGrid(messages);
		return this.inherited(arguments);
	},

	_dummy:null
});

});

},
'ibm/tivoli/simplesrm/srm/dijit/Overview/LiveChatPod':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!ibm/tivoli/simplesrm/srm/dijit/Overview/Pod,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatPod");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatView");
//dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatDetails");

dojo.require("ibm.tivoli.simplesrm.srm.dijit.Overview.Pod");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery"); 
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable"); 


/*
 * LiveChatPod
 * Live Chat information and link to start a live chat
*/
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatPod", ibm.tivoli.simplesrm.srm.dijit.Overview.Pod, {
	//widget to fill in Pod information section
	viewType: "ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatView",
	dialog: 'pmtcochatqueue',  //widget input parms
	title: "",
	buttontitle: "",
	
	//detailsType: "ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatDetails",
	//autoRefreshProperty: "MessageAutoRefresh",
	
	constructor: function() 	{
		console.log("Overview.LiveChatPod.ctor");
		ibm.tivoli.simplesrm.srm.dijit.Overview.livechatpod = this;	     		
	},
	
	postMixInProperties: function() 	{
		console.log("Overview.LiveChatPod.postMixInProperties");
		if (this.title!="")
			this.heading = this.title;
		else
		     this.heading = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").LiveChatHeading;
		if (this.buttontitle!="")
			this.detailsLinkLabel = this.buttontitle;
		else
		    this.detailsLinkLabel = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").LiveChatLink;
		this.detailsUrl = "#requests";
		 
		
		this.inherited(arguments);
	},
	postCreate: function() 	{
		this.refresh();
		this.inherited(arguments);		
		
		
		//Check sigoption to hide footer
		var sigoptions = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._sigoptions;
		if (sigoptions!=null && dojo.indexOf(sigoptions, "PMTCOCHATNOW")<0) {  //sigoption
			//hide footer
			dojo.style(this.footer, "display", "none"); 
		} else {
		   //replace anchor with button in footer
		   this.footer.innerHTML="<button id='livechatbutton' class='livechatbutton'>" + this.detailsLinkLabel + "</button>";
		   dojo.byId("livechatbutton").title = this.detailsLinkLabel;
		   dojo.connect(dojo.byId("livechatbutton"), "onclick",  this, this.onShowDetails);
		   //dojo.style(this.footer, "fontSize", .9+"em");  //enlarge link
		}
		
		//Add chat icon to heading
		var pod = this.footer.parentNode;
		var head = dojo.query(".title", pod);
		if (head && this.iconimage && this.iconimage.length>0) {
			var image_path = dojo.moduleUrl("ibm.tivoli.simplesrm.srm.dijit") + "images/" + this.iconimage;
			head[0].innerHTML = "<img src='" + image_path + "' alt='|' style='width:20px;height:20px;margin-bottom: -5px;'/>  " + this.heading;			
		}
		 
	},
	
	//Get Live Chat message from PMTCOCHATMSG table
	refresh: function() 	{
		console.log("Overview.LiveChatPod.refresh");
		//this._cancelPoll();
				 				
		//default message
		//var message = "<h3 style='margin-top:.5em;'>" + dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").LiveChatMessage + "</h3>";  //default message
		var message = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable").LiveChatMessage;
		
		
		//Get message from PMTCOCHATMSG mbo, with clob field PMTCOCHATMSG.MESSAGE.
		var params = {};
		params._exactmatch=1;
		//params.contentuid='1,461';  //TODO - get key from maxvar The maxvar is PMTCOCHATMESSAGEUID and the value is longdescription.contentuid
		params._compact=1;
		params.sync = true;	
		params._includecols="message";
		 
							
		//Get mbo
		var deferred  =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMbo("PMTCOCHATMSG",params);
		if (deferred) {
		   deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
		      if (response.PMTCOCHATMSGMboSet.rsCount>0) {
		          var ld = response.PMTCOCHATMSGMboSet.PMTCOCHATMSG[0].MESSAGE;
		          ld = ld.replace(/&nbsp;/g, " ");
		          this._view.setData(ld);
		      } else {
		    	  console.log("LiveChatPod:refresh - no Long Description");
		    	  this._view.setData(message);  //set default message in Pod view
		      }
		   }));
		} else {
			 console.log("LiveChatPod:refresh - no deferred Long Description");
			this._view.setData(message);  //set default message in Pod view
		}
				 
	},			
					
	 
	_onDataReady: function() {
		this.inherited(arguments);
	},
	
	//Called when Live Chat link/button clicked to start live chat
	onShowDetails: function() 	{
		//TODO show LiveChat dialog
		console.log("LiveChatView.onShowDetails - display live chat dialog");
						
		arguments.caller=null; //running into a IE bug in stacktrace()		
		var navid = "mx107";
	    var nav = dojo.query("div.srmnavigator");  //use id of navigator
	    if (nav.length>0)
		    navid = nav[0].id;	    
		sendEvent(this.dialog,  navid,  "pmtcochatqueue");		//launch livechat dialog 
	}
});

/**
 * Widget to display live chat information
 * 
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatView", 
		[ibm.tivoli.simplesrm.srm.dijit.Overview.View],
{
	widgetsInTemplate: true,
	//'	<div dojoType="ibm.tivoli.simplesrm.srm.dijit.Overview.DataTable" dojoAttachPoint="dataTable" heading="${tableCaption}"></div>\n' +
	templateString: '<div>' +	                
	                '<div id="livechatview" class="livechatview"></div>' +					
					'</div>',
	tableCaption: "",
	totalStr: "Total",
	showDetails: "Show details",
	
	constructor: function() 	{
		console.log("Overview.LiveChatView.ctor");
	},
	
	postMixInProperties: function() 	{
		console.log("Overview.LiveChatView.postMixInProperties");		 
		this.inherited(arguments);
	},
	
	
	//set live chat data in dom
	setData: function(messages) {
		console.log("Overview.LiveChatView.setData");
				
		dojo.byId("livechatview").innerHTML = messages;		 
	} 
	 
	 
});
 

/*ibm.tivoli.simplesrm.srm.dijit.Overview.livechatpod = null;
ibm.tivoli.simplesrm.srm.dijit.Overview._LiveChatPod = function(){
	// summary: returns the singleton bulletin board object
	if(!ibm.tivoli.simplesrm.srm.dijit.Overview.livechatpod){
		ibm.tivoli.simplesrm.srm.dijit.Overview.livechatpod = new ibm.tivoli.simplesrm.srm.dijit.Overview.LiveChatPod(); 
	}
	return ibm.tivoli.simplesrm.srm.dijit.Overview.livechatpod;	// Object
};*/ 
});

},
'dojox/grid/_Builder':function(){
define("dojox/grid/_Builder", [
	"../main",
	"dojo/_base/array",
	"dojo/_base/lang",
	"dojo/_base/window",
	"dojo/_base/event",
	"dojo/_base/sniff",
	"dojo/_base/connect",
	"dojo/dnd/Moveable",
	"dojox/html/metrics",
	"./util",
	"dojo/_base/html"
], function(dojox, array, lang, win, event, has, connect, Moveable, metrics, util, html){

	var dg = dojox.grid;

	var getTdIndex = function(td){
		return td.cellIndex >=0 ? td.cellIndex : array.indexOf(td.parentNode.cells, td);
	};
	
	var getTrIndex = function(tr){
		return tr.rowIndex >=0 ? tr.rowIndex : array.indexOf(tr.parentNode.childNodes, tr);
	};
	
	var getTr = function(rowOwner, index){
		return rowOwner && ((rowOwner.rows||0)[index] || rowOwner.childNodes[index]);
	};

	var findTable = function(node){
		for(var n=node; n && n.tagName!='TABLE'; n=n.parentNode){}
		return n;
	};
	
	var ascendDom = function(inNode, inWhile){
		for(var n=inNode; n && inWhile(n); n=n.parentNode){}
		return n;
	};
	
	var makeNotTagName = function(inTagName){
		var name = inTagName.toUpperCase();
		return function(node){ return node.tagName != name; };
	};

	var rowIndexTag = util.rowIndexTag;
	var gridViewTag = util.gridViewTag;

	// base class for generating markup for the views
	var _Builder = dg._Builder = lang.extend(function(view){
		if(view){
			this.view = view;
			this.grid = view.grid;
		}
	},{
		view: null,
		// boilerplate HTML
		_table: '<table class="dojoxGridRowTable" border="0" cellspacing="0" cellpadding="0" role="presentation"',

		// Returns the table variable as an array - and with the view width, if specified
		getTableArray: function(){
			var html = [this._table];
			if(this.view.viewWidth){
				html.push([' style="width:', this.view.viewWidth, ';"'].join(''));
			}
			html.push('>');
			return html;
		},
		
		// generate starting tags for a cell
		generateCellMarkup: function(inCell, inMoreStyles, inMoreClasses, isHeader){
			var result = [], html;
			if(isHeader){
				var sortInfo = inCell.index != inCell.grid.getSortIndex() ? "" : inCell.grid.sortInfo > 0 ? 'aria-sort="ascending"' : 'aria-sort="descending"';
				if (!inCell.id){
					inCell.id = this.grid.id + "Hdr" + inCell.index;
				}
				// column headers are not editable, mark as aria-readonly=true
				html = ['<th tabIndex="-1" aria-readonly="true" role="columnheader"', sortInfo, 'id="', inCell.id, '"'];
			}else{
				// cells inherit grid aria-readonly property; default value for aria-readonly is false(grid is editable)
				// if grid is editable (had any editable cells), mark non editable cells as aria-readonly=true
				// if no editable cells, grid's aria-readonly value will have been set to true and cells will inherit
				var editInfo = this.grid.editable && !inCell.editable ? 'aria-readonly="true"' : "";
				html = ['<td tabIndex="-1" role="gridcell"', editInfo];
			}
			if(inCell.colSpan){
				html.push(' colspan="', inCell.colSpan, '"');
			}
			if(inCell.rowSpan){
				html.push(' rowspan="', inCell.rowSpan, '"');
			}
			html.push(' class="dojoxGridCell ');
			if(inCell.classes){
				html.push(inCell.classes, ' ');
			}
			if(inMoreClasses){
				html.push(inMoreClasses, ' ');
			}
			// result[0] => td opener, style
			result.push(html.join(''));
			// SLOT: result[1] => td classes
			result.push('');
			html = ['" idx="', inCell.index, '" style="'];
			if(inMoreStyles && inMoreStyles[inMoreStyles.length-1] != ';'){
				inMoreStyles += ';';
			}
			html.push(inCell.styles, inMoreStyles||'', inCell.hidden?'display:none;':'');
			if(inCell.unitWidth){
				html.push('width:', inCell.unitWidth, ';');
			}
			// result[2] => markup
			result.push(html.join(''));
			// SLOT: result[3] => td style
			result.push('');
			html = [ '"' ];
			if(inCell.attrs){
				html.push(" ", inCell.attrs);
			}
			html.push('>');
			// result[4] => td postfix
			result.push(html.join(''));
			// SLOT: result[5] => content
			result.push('');
			// result[6] => td closes
			result.push(isHeader?'</th>':'</td>');
			return result; // Array
		},

		// cell finding
		isCellNode: function(inNode){
			return Boolean(inNode && inNode!=win.doc && html.attr(inNode, "idx"));
		},
		
		getCellNodeIndex: function(inCellNode){
			return inCellNode ? Number(html.attr(inCellNode, "idx")) : -1;
		},
		
		getCellNode: function(inRowNode, inCellIndex){
			for(var i=0, row; ((row = getTr(inRowNode.firstChild, i)) && row.cells); i++){
				for(var j=0, cell; (cell = row.cells[j]); j++){
					if(this.getCellNodeIndex(cell) == inCellIndex){
						return cell;
					}
				}
			}
			return null;
		},
		
		findCellTarget: function(inSourceNode, inTopNode){
			var n = inSourceNode;
			while(n && (!this.isCellNode(n) || (n.offsetParent && gridViewTag in n.offsetParent.parentNode && n.offsetParent.parentNode[gridViewTag] != this.view.id)) && (n!=inTopNode)){
				n = n.parentNode;
			}
			return n!=inTopNode ? n : null;
		},
		
		// event decoration
		baseDecorateEvent: function(e){
			e.dispatch = 'do' + e.type;
			e.grid = this.grid;
			e.sourceView = this.view;
			e.cellNode = this.findCellTarget(e.target, e.rowNode);
			e.cellIndex = this.getCellNodeIndex(e.cellNode);
			e.cell = (e.cellIndex >= 0 ? this.grid.getCell(e.cellIndex) : null);
		},
		
		// event dispatch
		findTarget: function(inSource, inTag){
			var n = inSource;
			while(n && (n!=this.domNode) && (!(inTag in n) || (gridViewTag in n && n[gridViewTag] != this.view.id))){
				n = n.parentNode;
			}
			return (n != this.domNode) ? n : null;
		},

		findRowTarget: function(inSource){
			return this.findTarget(inSource, rowIndexTag);
		},

		isIntraNodeEvent: function(e){
			try{
				return (e.cellNode && e.relatedTarget && html.isDescendant(e.relatedTarget, e.cellNode));
			}catch(x){
				// e.relatedTarget has permission problem in FF if it's an input: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		isIntraRowEvent: function(e){
			try{
				var row = e.relatedTarget && this.findRowTarget(e.relatedTarget);
				return !row && (e.rowIndex==-1) || row && (e.rowIndex==row.gridRowIndex);
			}catch(x){
				// e.relatedTarget on INPUT has permission problem in FF: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
				return false;
			}
		},

		dispatchEvent: function(e){
			if(e.dispatch in this){
				return this[e.dispatch](e);
			}
			return false;
		},

		// dispatched event handlers
		domouseover: function(e){
			if(e.cellNode && (e.cellNode!=this.lastOverCellNode)){
				this.lastOverCellNode = e.cellNode;
				this.grid.onMouseOver(e);
			}
			this.grid.onMouseOverRow(e);
		},

		domouseout: function(e){
			if(e.cellNode && (e.cellNode==this.lastOverCellNode) && !this.isIntraNodeEvent(e, this.lastOverCellNode)){
				this.lastOverCellNode = null;
				this.grid.onMouseOut(e);
				if(!this.isIntraRowEvent(e)){
					this.grid.onMouseOutRow(e);
				}
			}
		},
		
		domousedown: function(e){
			if (e.cellNode)
				this.grid.onMouseDown(e);
			this.grid.onMouseDownRow(e);
		}
	});

	// Produces html for grid data content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	var _ContentBuilder = dg._ContentBuilder = lang.extend(function(view){
		_Builder.call(this, view);
	},_Builder.prototype,{
		update: function(){
			this.prepareHtml();
		},

		// cache html for rendering data rows
		prepareHtml: function(){
			var defaultGet=this.grid.get, cells=this.view.structure.cells;
			for(var j=0, row; (row=cells[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					cell.get = cell.get || (cell.value == undefined) && defaultGet;
					cell.markup = this.generateCellMarkup(cell, cell.cellStyles, cell.cellClasses, false);
					if (!this.grid.editable && cell.editable){
						this.grid.editable = true;
					}
				}
			}
		},

		// time critical: generate html using cache and data source
		generateHtml: function(inDataIndex, inRowIndex){
			var
				html = this.getTableArray(),
				v = this.view,
				cells = v.structure.cells,
				item = this.grid.getItem(inRowIndex);

			util.fire(this.view, "onBeforeRow", [inRowIndex, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden || row.header){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, m, cc, cs; (cell=row[i]); i++){
					m = cell.markup; cc = cell.customClasses = []; cs = cell.customStyles = [];
					// content (format can fill in cc and cs as side-effects)
					m[5] = cell.format(inRowIndex, item);
					if(has("ie") < 8 && (m[5] === null || m[5] === '' || /^\s+$/.test(m[5]))){
						//fix IE 6/7 quirks - border style not effective for empty td
						m[5] = '&nbsp;'
					}
					// classes
					m[1] = cc.join(' ');
					// styles
					m[3] = cs.join(';');
					// in-place concat
					html.push.apply(html, m);
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join(''); // String
		},

		decorateEvent: function(e){
			e.rowNode = this.findRowTarget(e.target);
			if(!e.rowNode){return false;}
			e.rowIndex = e.rowNode[rowIndexTag];
			this.baseDecorateEvent(e);
			e.cell = this.grid.getCell(e.cellIndex);
			return true; // Boolean
		}
	});

	// Produces html for grid header content. Owned by grid and used internally
	// for rendering data. Override to implement custom rendering.
	var _HeaderBuilder = dg._HeaderBuilder = lang.extend(function(view){
		this.moveable = null;
		_Builder.call(this, view);
	},_Builder.prototype,{
		_skipBogusClicks: false,
		overResizeWidth: 4,
		minColWidth: 1,
		
		update: function(){
			if(this.tableMap){
				this.tableMap.mapRows(this.view.structure.cells);
			}else{
				this.tableMap = new dg._TableMap(this.view.structure.cells);
			}
		},

		generateHtml: function(inGetValue, inValue){
			var html = this.getTableArray(), cells = this.view.structure.cells;
			
			util.fire(this.view, "onBeforeRow", [-1, cells]);
			for(var j=0, row; (row=cells[j]); j++){
				if(row.hidden){
					continue;
				}
				html.push(!row.invisible ? '<tr>' : '<tr class="dojoxGridInvisible">');
				for(var i=0, cell, markup; (cell=row[i]); i++){
					cell.customClasses = [];
					cell.customStyles = [];
					if(this.view.simpleStructure){
						if(cell.draggable){
							if(cell.headerClasses){
								if(cell.headerClasses.indexOf('dojoDndItem') == -1){
									cell.headerClasses += ' dojoDndItem';
								}
							}else{
								cell.headerClasses = 'dojoDndItem';
							}
						}
						if(cell.attrs){
							if(cell.attrs.indexOf("dndType='gridColumn_") == -1){
								cell.attrs += " dndType='gridColumn_" + this.grid.id + "'";
							}
						}else{
							cell.attrs = "dndType='gridColumn_" + this.grid.id + "'";
						}
					}
					markup = this.generateCellMarkup(cell, cell.headerStyles, cell.headerClasses, true);
					// content
					markup[5] = (inValue != undefined ? inValue : inGetValue(cell));
					// styles
					markup[3] = cell.customStyles.join(';');
					// classes
					markup[1] = cell.customClasses.join(' '); //(cell.customClasses ? ' ' + cell.customClasses : '');
					html.push(markup.join(''));
				}
				html.push('</tr>');
			}
			html.push('</table>');
			return html.join('');
		},

		// event helpers
		getCellX: function(e){
			var n, x = e.layerX;
			if(has("mozilla") || has("ie") >= 9){
				n = ascendDom(e.target, makeNotTagName("th"));
				x -= (n && n.offsetLeft) || 0;
				var t = e.sourceView.getScrollbarWidth();
				if(!this.grid.isLeftToRight()/*&& e.sourceView.headerNode.scrollLeft < t*/){
					//fix #11253
					table = ascendDom(n,makeNotTagName("table"));
					x -= (table && table.offsetLeft) || 0;
				}
				//x -= getProp(ascendDom(e.target, mkNotTagName("td")), "offsetLeft") || 0;
			}
			n = ascendDom(e.target, function(){
				if(!n || n == e.cellNode){
					return false;
				}
				// Mozilla 1.8 (FF 1.5) has a bug that makes offsetLeft = -parent border width
				// when parent has border, overflow: hidden, and is positioned
				// handle this problem here ... not a general solution!
				x += (n.offsetLeft < 0 ? 0 : n.offsetLeft);
				return true;
			});
			return x;
		},

		// event decoration
		decorateEvent: function(e){
			this.baseDecorateEvent(e);
			e.rowIndex = -1;
			e.cellX = this.getCellX(e);
			return true;
		},

		// event handlers
		// resizing
		prepareResize: function(e, mod){
			do{
				var i = e.cellIndex;
				e.cellNode = (i ? e.cellNode.parentNode.cells[i+mod] : null);
				e.cellIndex = (e.cellNode ? this.getCellNodeIndex(e.cellNode) : -1);
			}while(e.cellNode && e.cellNode.style.display == "none");
			return Boolean(e.cellNode);
		},

		canResize: function(e){
			if(!e.cellNode || e.cellNode.colSpan > 1){
				return false;
			}
			var cell = this.grid.getCell(e.cellIndex);
			return !cell.noresize && cell.canResize();
		},

		overLeftResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(html.hasClass(win.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(has("ie")){
				var tN = e.target;
				if(html.hasClass(tN, "dojoxGridArrowButtonNode") ||
					html.hasClass(tN, "dojoxGridArrowButtonChar") ||
					html.hasClass(tN, "dojoxGridColCaption")){
					return false;
				}
			}

			if(this.grid.isLeftToRight()){
				return (e.cellIndex>0) && (e.cellX > 0 && e.cellX < this.overResizeWidth) && this.prepareResize(e, -1);
			}
			var t = e.cellNode && (e.cellX > 0 && e.cellX < this.overResizeWidth);
			return t;
		},

		overRightResizeArea: function(e){
			// We are never over a resize area if we are in the process of moving
			if(html.hasClass(win.body(), "dojoDndMove")){
				return false;
			}
			//Bugfix for crazy IE problem (#8807).  IE returns position information for the icon and text arrow divs
			//as if they were still on the left instead of returning the position they were 'float: right' to.
			//So, the resize check ends up checking the wrong adjacent cell.  This checks to see if the hover was over
			//the image or text nodes, then just ignored them/treat them not in scale range.
			if(has("ie")){
				var tN = e.target;
				if(html.hasClass(tN, "dojoxGridArrowButtonNode") ||
					html.hasClass(tN, "dojoxGridArrowButtonChar") ||
					html.hasClass(tN, "dojoxGridColCaption")){
					return false;
				}
			}

			if(this.grid.isLeftToRight()){
				return e.cellNode && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth);
			}
			return (e.cellIndex>0) && (e.cellX >= e.cellNode.offsetWidth - this.overResizeWidth) && this.prepareResize(e, -1);
		},

		domousemove: function(e){
			//console.log(e.cellIndex, e.cellX, e.cellNode.offsetWidth);
			if(!this.moveable){
				var c = (this.overRightResizeArea(e) ? 'dojoxGridColResize' : (this.overLeftResizeArea(e) ? 'dojoxGridColResize' : ''));
				if(c && !this.canResize(e)){
					c = 'dojoxGridColNoResize';
				}
				html.toggleClass(e.sourceView.headerNode, "dojoxGridColNoResize", (c == "dojoxGridColNoResize"));
				html.toggleClass(e.sourceView.headerNode, "dojoxGridColResize", (c == "dojoxGridColResize"));
				if(c){
					event.stop(e);
				}
			}
		},

		domousedown: function(e){
			if(!this.moveable){
				if((this.overRightResizeArea(e) || this.overLeftResizeArea(e)) && this.canResize(e)){
					this.beginColumnResize(e);
				}else{
					this.grid.onMouseDown(e);
					this.grid.onMouseOverRow(e);
				}
				//else{
				//	this.beginMoveColumn(e);
				//}
			}
		},

		doclick: function(e) {
			if(this._skipBogusClicks){
				event.stop(e);
				return true;
			}
			return false;
		},

		// column resizing
		colResizeSetup: function(/*Event Object*/e, /*boolean*/ isMouse ){
			//Set up the drag object for column resizing
			// Called with mouse event in case of drag and drop,
			// Also called from keyboard shift-arrow event when focus is on a header
			var headContentBox = html.contentBox(e.sourceView.headerNode);
			
			if(isMouse){  //IE draws line even with no mouse down so separate from keyboard
				this.lineDiv = document.createElement('div');

				var vw = html.position(e.sourceView.headerNode, true);
				var bodyContentBox = html.contentBox(e.sourceView.domNode);
				//fix #11340
				var l = e.pageX;
				if(!this.grid.isLeftToRight() && has("ie") < 8){
					l -= metrics.getScrollbar().w;
				}
				html.style(this.lineDiv, {
					top: vw.y + "px",
					left: l + "px",
					height: (bodyContentBox.h + headContentBox.h) + "px"
				});
				html.addClass(this.lineDiv, "dojoxGridResizeColLine");
				this.lineDiv._origLeft = l;
				win.body().appendChild(this.lineDiv);
			}
			var spanners = [], nodes = this.tableMap.findOverlappingNodes(e.cellNode);
			for(var i=0, cell; (cell=nodes[i]); i++){
				spanners.push({ node: cell, index: this.getCellNodeIndex(cell), width: cell.offsetWidth });
				//console.log("spanner: " + this.getCellNodeIndex(cell));
			}

			var view = e.sourceView;
			var adj = this.grid.isLeftToRight() ? 1 : -1;
			var views = e.grid.views.views;
			var followers = [];
			for(var j=view.idx+adj, cView; (cView=views[j]); j=j+adj){
				followers.push({ node: cView.headerNode, left: window.parseInt(cView.headerNode.style.left) });
			}
			var table = view.headerContentNode.firstChild;
			var drag = {
				scrollLeft: e.sourceView.headerNode.scrollLeft,
				view: view,
				node: e.cellNode,
				index: e.cellIndex,
				w: html.contentBox(e.cellNode).w,
				vw: headContentBox.w,
				table: table,
				tw: html.contentBox(table).w,
				spanners: spanners,
				followers: followers
			};
			return drag;
		},
		beginColumnResize: function(e){
			this.moverDiv = document.createElement("div");
			html.style(this.moverDiv,{position: "absolute", left:0}); // to make DnD work with dir=rtl
			win.body().appendChild(this.moverDiv);
			html.addClass(this.grid.domNode, "dojoxGridColumnResizing");
			var m = (this.moveable = new Moveable(this.moverDiv));

			var drag = this.colResizeSetup(e,true);

			m.onMove = lang.hitch(this, "doResizeColumn", drag);

			connect.connect(m, "onMoveStop", lang.hitch(this, function(){
				this.endResizeColumn(drag);
				if(drag.node.releaseCapture){
					drag.node.releaseCapture();
				}
				this.moveable.destroy();
				delete this.moveable;
				this.moveable = null;
				html.removeClass(this.grid.domNode, "dojoxGridColumnResizing");
			}));

			if(e.cellNode.setCapture){
				e.cellNode.setCapture();
			}
			m.onMouseDown(e);
		},

		doResizeColumn: function(inDrag, mover, leftTop){
			var changeX = leftTop.l;
			var data = {
				deltaX: changeX,
				w: inDrag.w + (this.grid.isLeftToRight() ? changeX : -changeX),//fix #11341
				vw: inDrag.vw + changeX,
				tw: inDrag.tw + changeX
			};
			
			this.dragRecord = {inDrag: inDrag, mover: mover, leftTop:leftTop};
			
			if(data.w >= this.minColWidth){
				if (!mover) { // we are using keyboard do immediate resize
					this.doResizeNow(inDrag, data);
				}
				else{
					html.style(this.lineDiv, "left", (this.lineDiv._origLeft + data.deltaX) + "px");
				}
			}
		},

		endResizeColumn: function(inDrag){
			if(this.dragRecord){
				var leftTop = this.dragRecord.leftTop;
				var changeX = this.grid.isLeftToRight() ? leftTop.l : -leftTop.l;
				// Make sure we are not under our minimum
				// http://bugs.dojotoolkit.org/ticket/9390
				changeX += Math.max(inDrag.w + changeX, this.minColWidth) - (inDrag.w + changeX);
				if(has("webkit") && inDrag.spanners.length){
					// Webkit needs the pad border extents back in
					changeX += html._getPadBorderExtents(inDrag.spanners[0].node).w;
				}
				var data = {
					deltaX: changeX,
					w: inDrag.w + changeX,
					vw: inDrag.vw + changeX,
					tw: inDrag.tw + changeX
				};
				// Only resize the columns when the drag has finished
				this.doResizeNow(inDrag, data);
				delete this.dragRecord;
			}
			
			html.destroy(this.lineDiv);
 			html.destroy(this.moverDiv);
			html.destroy(this.moverDiv);
			delete this.moverDiv;
			this._skipBogusClicks = true;
			inDrag.view.update();
			this._skipBogusClicks = false;
			this.grid.onResizeColumn(inDrag.index);
		},
		doResizeNow: function(inDrag, data){
			inDrag.view.convertColPctToFixed();
			if(inDrag.view.flexCells && !inDrag.view.testFlexCells()){
				var t = findTable(inDrag.node);
				if(t){
					(t.style.width = '');
				}
			}
			var i, s, sw, f, fl;
			for(i=0; (s=inDrag.spanners[i]); i++){
				sw = s.width + data.deltaX;
				if(sw > 0){
					s.node.style.width = sw + 'px';
					inDrag.view.setColWidth(s.index, sw);
				}
			}
			if(this.grid.isLeftToRight() || !has("ie")){//fix #11339
				for(i=0; (f=inDrag.followers[i]); i++){
					fl = f.left + data.deltaX;
					f.node.style.left = fl + 'px';
				}
			}
			inDrag.node.style.width = data.w + 'px';
			inDrag.view.setColWidth(inDrag.index, data.w);
			inDrag.view.headerNode.style.width = data.vw + 'px';
			inDrag.view.setColumnsWidth(data.tw);
			if(!this.grid.isLeftToRight()){
				inDrag.view.headerNode.scrollLeft = inDrag.scrollLeft + data.deltaX;
			}
		}
	});

	// Maps an html table into a structure parsable for information about cell row and col spanning.
	// Used by HeaderBuilder.
	dg._TableMap = lang.extend(function(rows){
		this.mapRows(rows);
	},{
		map: null,

		mapRows: function(inRows){
			// summary: Map table topography

			//console.log('mapRows');
			// # of rows
			var rowCount = inRows.length;
			if(!rowCount){
				return;
			}
			// map which columns and rows fill which cells
			this.map = [];
			var row;
			for(var k=0; (row=inRows[k]); k++){
				this.map[k] = [];
			}
			for(var j=0; (row=inRows[j]); j++){
				for(var i=0, x=0, cell, colSpan, rowSpan; (cell=row[i]); i++){
					while(this.map[j][x]){x++;}
					this.map[j][x] = { c: i, r: j };
					rowSpan = cell.rowSpan || 1;
					colSpan = cell.colSpan || 1;
					for(var y=0; y<rowSpan; y++){
						for(var s=0; s<colSpan; s++){
							this.map[j+y][x+s] = this.map[j][x];
						}
					}
					x += colSpan;
				}
			}
			//this.dumMap();
		},

		dumpMap: function(){
			for(var j=0, row, h=''; (row=this.map[j]); j++,h=''){
				for(var i=0, cell; (cell=row[i]); i++){
					h += cell.r + ',' + cell.c + '   ';
				}
			}
		},

		getMapCoords: function(inRow, inCol){
			// summary: Find node's map coords by it's structure coords
			for(var j=0, row; (row=this.map[j]); j++){
				for(var i=0, cell; (cell=row[i]); i++){
					if(cell.c==inCol && cell.r == inRow){
						return { j: j, i: i };
					}
					//else{console.log(inRow, inCol, ' : ', i, j, " : ", cell.r, cell.c); };
				}
			}
			return { j: -1, i: -1 };
		},
		
		getNode: function(inTable, inRow, inCol){
			// summary: Find a node in inNode's table with the given structure coords
			var row = inTable && inTable.rows[inRow];
			return row && row.cells[inCol];
		},
		
		_findOverlappingNodes: function(inTable, inRow, inCol){
			var nodes = [];
			var m = this.getMapCoords(inRow, inCol);
			//console.log("node j: %d, i: %d", m.j, m.i);
			for(var j=0, row; (row=this.map[j]); j++){
				if(j == m.j){ continue; }
				var rw = row[m.i];
				//console.log("overlaps: r: %d, c: %d", rw.r, rw.c);
				var n = (rw?this.getNode(inTable, rw.r, rw.c):null);
				if(n){ nodes.push(n); }
			}
			//console.log(nodes);
			return nodes;
		},
		
		findOverlappingNodes: function(inNode){
			return this._findOverlappingNodes(findTable(inNode), getTrIndex(inNode.parentNode), getTdIndex(inNode));
		}
	});

	return {
		_Builder: _Builder,
		_HeaderBuilder: _HeaderBuilder,
		_ContentBuilder: _ContentBuilder
	};
});
},
'dojox/gfx/renderer':function(){
define("dojox/gfx/renderer", ["./_base","dojo/_base/lang", "dojo/_base/sniff", "dojo/_base/window", "dojo/_base/config"],
  function(g, lang, has, win, config){
  //>> noBuildResolver
/*=====
	dojox.gfx.renderer = {
		// summary:
		//		This module is an AMD loader plugin that loads the appropriate graphics renderer
		//		implementation based on detected environment and current configuration settings.
	};
  =====*/
	var currentRenderer = null;
	return {
		load: function(id, require, load){
			if(currentRenderer && id != "force"){
				load(currentRenderer);
				return;
			}
			var renderer = config.forceGfxRenderer,
				renderers = !renderer && (lang.isString(config.gfxRenderer) ?
					config.gfxRenderer : "svg,vml,canvas,silverlight").split(","),
				silverlightObject, silverlightFlag;

			while(!renderer && renderers.length){
				switch(renderers.shift()){
					case "svg":
						// the next test is from https://github.com/phiggins42/has.js
						if("SVGAngle" in win.global){
							renderer = "svg";
						}
						break;
					case "vml":
						if(has("ie")){
							renderer = "vml";
						}
						break;
					case "silverlight":
						try{
							if(has("ie")){
								silverlightObject = new ActiveXObject("AgControl.AgControl");
								if(silverlightObject && silverlightObject.IsVersionSupported("1.0")){
									silverlightFlag = true;
								}
							}else{
								if(navigator.plugins["Silverlight Plug-In"]){
									silverlightFlag = true;
								}
							}
						}catch(e){
							silverlightFlag = false;
						}finally{
							silverlightObject = null;
						}
						if(silverlightFlag){
							renderer = "silverlight";
						}
						break;
					case "canvas":
						if(win.global.CanvasRenderingContext2D){
							renderer = "canvas";
						}
						break;
				}
			}

			if (renderer === 'canvas' && config.canvasEvents !== false) {
				renderer = "canvasWithEvents";
			}

			if(config.isDebug){
				console.log("gfx renderer = " + renderer);
			}

			function loadRenderer(){
				require(["dojox/gfx/" + renderer], function(module){
					g.renderer = renderer;
					// memorize the renderer module
					currentRenderer = module;
					// now load it
					load(module);
				});
			}
			if(renderer == "svg" && typeof window.svgweb != "undefined"){
				window.svgweb.addOnLoad(loadRenderer);
			}else{
				loadRenderer();
			}
		}
	};
});

},
'ibm/tivoli/simplesrm/srm/dijit/PopupDialog':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dijit/Dialog,ibm/tivoli/simplesrm/srm/dijit/OpenHelp,ibm/tivoli/simplesrm/srm/dijit/MultipleModal,dijit/DialogUnderlay,dojox/html/metrics"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.PopupDialog");

dojo.require("dijit.Dialog");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MultipleModal");
dojo.require("dijit.DialogUnderlay");
dojo.require("dojox.html.metrics");

dojo.declare("ibm.tivoli.simplesrm.srm.dijit.PopupDialog", 
		[dijit.Dialog,ibm.tivoli.simplesrm.srm.dijit.OpenHelp,ibm.tivoli.simplesrm.srm.dijit.MultipleModal],
{
	//added to retrieve title attribute for help
	_uiStringTable: null,
	//context sensitive help - unique key that is mapped on server side to help topics
	cshKey: null ,
	
	constructor: function(params, domNode)
	{
		console.log("PopupDialog.ctor");
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
	},
	postCreate: function(){	
		console.log("PopupDialog.postCreate");
		this.inherited(arguments);
	},
	show: function()
	{
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		//modify dijit.DialogUnderlay
		if (product==null || product.indexOf("srm")<0)
			this.patchCode();
		this.inherited(arguments);
		//set z-index above other modal widget
		if (product==null || product.indexOf("srm")<0)
			this.domNode.style.zIndex = dijit._underlay.getDialogZIndex();
		// dijit.Dialog connects window.onresize to dijit.Dialog.layout(), which only
		// repositions the popup, and doesn't resize.  
		// unshift (rather than push) gets _size called before layout
		this._modalconnects.unshift(dojo.connect(window, "onresize", this, "_size"));
	},
	_onKey: function(event){
		//changes original method to support multiple modal dialogs
		if(!this.preOnKeyTest(event)){
			return;// it's not your event
		}				
		this.inherited(arguments);			
	},
	_size: function()
	{	
		// this code is a modification of dijit.Dialog._size
		var mb = dojo.marginBox(this.domNode);
		var viewport = dijit.getViewport();
		var bShrink = false;
		if(mb.w >= viewport.w) {
			dojo.style(this.containerNode, "width", Math.floor(viewport.w * 0.9)+"px");
		}
		var container_w = dojo.style(this.containerNode, "width");
				
		var divlist = dojo.query(".banner", this.domNode);
		var banner = divlist.length > 0 ? divlist[0] : null; 
		if(banner) {
			var bsz = dojo.marginBox(this.containerNode);
			var pbx = dojo._getPadBorderExtents(banner); 
			dojo.style(banner, "width", (bsz.w-pbx.w) + "px");
		}
		if(mb.h >= viewport.h){
			bht = banner ? dojo.marginBox(banner).h : 0;
			tht = dojo.marginBox(this.titleBar).h;
			divlist = dojo.query(".footer", this.domNode);
			fht = divlist.length > 0 ? dojo.marginBox(divlist[0]).h : 0;
			var ht = Math.floor(viewport.h - bht - tht - fht - 10);
			if(ht < 0){
				ht = viewport.h * 0.75;	// what else can I do?
			}
			dojo.style(this.containerNode, {
				height: ht+"px",
				width: container_w + "px"	// in IE, width changes when I set height
			});
		}
		if(mb.w >= viewport.w || mb.h >= viewport.h)  {
			dojo.style(this.containerNode, {
				overflow: "auto",
				position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
			});
		}
	
		this.resize();
	},
	resize: function()
	{
		this.inherited(arguments);
		this._position();	// re-center
		return;
	},
	_position: function() {
		this.inherited(arguments);		
		//wow this is a hack! I need to set the top to a fixed 40px for the solution search dialog
		if (this.domNode.id=="search-dialog") {
	       dojo.style(this.domNode, "top", "40px");  
	    }
	    
	},

	// prevent the user from interacting
	_screen: null,
	disableAll: function(bState)
	{
		if(bState) {
			// disable
			var box = dojo.marginBox(this.domNode);
			if(this._screen == null) {
				this._screen = document.createElement("div");
			}
			dojo.style(this._screen, {
				position: "absolute",
				left: box.l + "px",
				top: box.t + "px",
				width: box.w + "px",
				height: box.h + "px",
				cursor: "wait",
				zIndex: 1000,
				backgroundColor: "transparent"
			});
			dojo.place(this._screen, document.body, "first");
		}
		else {
			// enable
			try {
				document.body.removeChild(this._screen);
			}
			catch(ignore){
				console.info("ignore",ignore);
			}
		}
	},
	
	//handler:used when user clicks '?'
	openHelp: function(event){
		this.openHelpWindow(this.cshKey);		
	},
	
	//error handler: used when help url can't be retrieved from server
	_errorRetrievingUrl:function(){				
		(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({messageId: "CTJZH2302E"})).show();
	},
	
	//sets cshKey, adds '?' to title bar, connects help events 
	addHelp: function(cshKey){

		this.cshKey = cshKey;
		
		var helpNode = document.createElement("span");
		
		dojo.addClass(helpNode , "dijitDialogHelpIcon");			
		dojo.attr(helpNode , "id" , this.id + "_visual_" + cshKey);
		dojo.attr(helpNode , "title" , this._uiStringTable["Help"]);
		dojo.attr(helpNode , "tabindex" , 0);
		
		var res = dojo.place(helpNode, this.closeButtonNode ,"before");
		this.connect(helpNode , "onclick" , "openHelp");
		this.connect(helpNode , "onmouseenter","_onHelpEnter");		
		this.connect(helpNode , "onmouseleave","_onHelpLeave");
		this.connect(helpNode , "onkeypress" , "_onEnterPressed");
		
		var textHelpNode = document.createElement("span");
					
		dojo.addClass(textHelpNode , "closeText");
		dojo.attr(textHelpNode , "id" , this.id + "_text_" + cshKey);
		dojo.attr(textHelpNode , "title" , this._uiStringTable["Help"]);			
		
		var textNode = document.createTextNode("?");
		dojo.place(textNode , textHelpNode );
		
		dojo.place(textHelpNode, helpNode);
		
		this.connect(this.domNode,"keypress","_onHelpKey");
	} ,		
	_onHelpEnter: function(){						 
		var helpNode = dojo.query(".dijitDialogHelpIcon",this.titleBar);
		dojo.addClass(helpNode[0], "dijitDialogHelpIcon-hover");
	},
	_onHelpLeave: function(){
		var helpNode = dojo.query(".dijitDialogHelpIcon-hover",this.titleBar);
		dojo.removeClass(helpNode[0] , "dijitDialogHelpIcon-hover");
	},
	_onHelpKey: function(event){
		/*
		if ((dojo.isIE) && (event.keyChar == 'p'))
			return true;
		*/
		
		// help key accessible from whole panel
		if(event.keyCode == dojo.keys.F1){
			
			// on IE dojo.stopEvent() is not enough to cancel this event
			// "onhelp" attribute is valid for IE only
			if (dojo.isIE){
				//For IE, keyCode of 'p' char is misteriously equal to F1... 
				if (event.keyChar == 'p'){
					return true;
				}
				document.onhelp = function(){return false;};
				window.onhelp = function(){return false;};
			}
			
			if(this.cshKey && this.openHelp){				
				dojo.stopEvent(event);			
				this.openHelp(event);
				return false;
			}
		}
		return true;
	},
	_onEnterPressed: function(event){
		//open only if Enter was pressed on help icon
		if ((event.keyCode == dojo.keys.ENTER) && 
			(dojo.hasClass(event.target ,"dijitDialogHelpIcon"))){
			dojo.stopEvent(event);
			this.openHelp(event);
			return false;
		}
		return true;
	},
	
	_dummy:null

});	
});

},
'dojox/grid/_EditManager':function(){
define("dojox/grid/_EditManager", [
	"dojo/_base/lang",
	"dojo/_base/array",
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/sniff",
	"./util"
], function(lang, array, declare, connect, has, util){

return declare("dojox.grid._EditManager", null, {
	// summary:
	//		Controls grid cell editing process. Owned by grid and used internally for editing.
	constructor: function(inGrid){
		// inGrid: dojox.Grid
		//		The dojox.Grid this editor should be attached to
		this.grid = inGrid;
		if(has("ie")){
			this.connections = [connect.connect(document.body, "onfocus", lang.hitch(this, "_boomerangFocus"))];
		}else{
			this.connections = [connect.connect(this.grid, 'onBlur', this, 'apply')];
		}
	},
	
	info: {},

	destroy: function(){
		array.forEach(this.connections, connect.disconnect);
	},

	cellFocus: function(inCell, inRowIndex){
		// summary:
		//		Invoke editing when cell is focused
		// inCell: cell object
		//		Grid cell object
		// inRowIndex: Integer
		//		Grid row index
		if(this.grid.singleClickEdit || this.isEditRow(inRowIndex)){
			// if same row or quick editing, edit
			this.setEditCell(inCell, inRowIndex);
		}else{
			// otherwise, apply any pending row edits
			this.apply();
		}
		// if dynamic or static editing...
		if(this.isEditing() || (inCell && inCell.editable && inCell.alwaysEditing)){
			// let the editor focus itself as needed
			this._focusEditor(inCell, inRowIndex);
		}
	},

	rowClick: function(e){
		if(this.isEditing() && !this.isEditRow(e.rowIndex)){
			this.apply();
		}
	},

	styleRow: function(inRow){
		if(inRow.index == this.info.rowIndex){
			inRow.customClasses += ' dojoxGridRowEditing';
		}
	},

	dispatchEvent: function(e){
		var c = e.cell, ed = (c && c["editable"]) ? c : 0;
		return ed && ed.dispatchEvent(e.dispatch, e);
	},

	// Editing
	isEditing: function(){
		// summary:
		//		Indicates editing state of the grid.
		// returns: Boolean
		//	 	True if grid is actively editing
		return this.info.rowIndex !== undefined;
	},

	isEditCell: function(inRowIndex, inCellIndex){
		// summary:
		//		Indicates if the given cell is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// inCellIndex: Integer
		//		Grid cell index
		// returns: Boolean
		//	 	True if given cell is being edited
		return (this.info.rowIndex === inRowIndex) && (this.info.cell.index == inCellIndex);
	},

	isEditRow: function(inRowIndex){
		// summary:
		//		Indicates if the given row is being edited.
		// inRowIndex: Integer
		//		Grid row index
		// returns: Boolean
		//	 	True if given row is being edited
		return this.info.rowIndex === inRowIndex;
	},

	setEditCell: function(inCell, inRowIndex){
		// summary:
		//		Set the given cell to be edited
		// inRowIndex: Integer
		//		Grid row index
		// inCell: Object
		//		Grid cell object
		if(!this.isEditCell(inRowIndex, inCell.index) && this.grid.canEdit && this.grid.canEdit(inCell, inRowIndex)){
			this.start(inCell, inRowIndex, this.isEditRow(inRowIndex) || inCell.editable);
		}
	},

	_focusEditor: function(inCell, inRowIndex){
		util.fire(inCell, "focus", [inRowIndex]);
	},

	focusEditor: function(){
		if(this.isEditing()){
			this._focusEditor(this.info.cell, this.info.rowIndex);
		}
	},

	// implement fix for focus boomerang effect on IE
	_boomerangWindow: 500,
	_shouldCatchBoomerang: function(){
		return this._catchBoomerang > new Date().getTime();
	},
	_boomerangFocus: function(){
		//console.log("_boomerangFocus");
		if(this._shouldCatchBoomerang()){
			// make sure we don't utterly lose focus
			this.grid.focus.focusGrid();
			// let the editor focus itself as needed
			this.focusEditor();
			// only catch once
			this._catchBoomerang = 0;
		}
	},
	_doCatchBoomerang: function(){
		// give ourselves a few ms to boomerang IE focus effects
		if(has("ie")){this._catchBoomerang = new Date().getTime() + this._boomerangWindow;}
	},
	// end boomerang fix API

	start: function(inCell, inRowIndex, inEditing){
		if(!this._isValidInput()){
			return;
		}
		this.grid.beginUpdate();
		this.editorApply();
		if(this.isEditing() && !this.isEditRow(inRowIndex)){
			this.applyRowEdit();
			this.grid.updateRow(inRowIndex);
		}
		if(inEditing){
			this.info = { cell: inCell, rowIndex: inRowIndex };
			this.grid.doStartEdit(inCell, inRowIndex);
			this.grid.updateRow(inRowIndex);
		}else{
			this.info = {};
		}
		this.grid.endUpdate();
		// make sure we don't utterly lose focus
		this.grid.focus.focusGrid();
		// let the editor focus itself as needed
		this._focusEditor(inCell, inRowIndex);
		// give ourselves a few ms to boomerang IE focus effects
		this._doCatchBoomerang();
	},

	_editorDo: function(inMethod){
		var c = this.info.cell;
		//c && c.editor && c.editor[inMethod](c, this.info.rowIndex);
		if(c && c.editable){
			c[inMethod](this.info.rowIndex);
		}
	},

	editorApply: function(){
		this._editorDo("apply");
	},

	editorCancel: function(){
		this._editorDo("cancel");
	},

	applyCellEdit: function(inValue, inCell, inRowIndex){
		if(this.grid.canEdit(inCell, inRowIndex)){
			this.grid.doApplyCellEdit(inValue, inRowIndex, inCell.field);
		}
	},

	applyRowEdit: function(){
		this.grid.doApplyEdit(this.info.rowIndex, this.info.cell.field);
	},

	apply: function(){
		// summary:
		//		Apply a grid edit
		if(this.isEditing() && this._isValidInput()){
			this.grid.beginUpdate();
			this.editorApply();
			this.applyRowEdit();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	cancel: function(){
		// summary:
		//		Cancel a grid edit
		if(this.isEditing()){
			this.grid.beginUpdate();
			this.editorCancel();
			this.info = {};
			this.grid.endUpdate();
			this.grid.focus.focusGrid();
			this._doCatchBoomerang();
		}
	},

	save: function(inRowIndex, inView){
		// summary:
		//		Save the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && (!inView || c.view==inView) && c.editable){
			c.save(c, this.info.rowIndex);
		}
	},

	restore: function(inView, inRowIndex){
		// summary:
		//		Restores the grid editing state
		// inRowIndex: Integer
		//		Grid row index
		// inView: Object
		//		Grid view
		var c = this.info.cell;
		if(this.isEditRow(inRowIndex) && c.view == inView && c.editable){
			c.restore(this.info.rowIndex);
		}
	},
	
	_isValidInput: function(){
		var w = (this.info.cell || {}).widget;		
		if(!w || !w.isValid){
			//no validation needed
			return true;
		}		
		w.focused = true;
		return w.isValid(true);
	}
});
});
},
'dojo/data/util/sorter':function(){
define("dojo/data/util/sorter", ["dojo/_base/lang"], function(lang) {
	// module:
	//		dojo/data/util/sorter
	// summary:
	//		TODOC

var sorter = lang.getObject("dojo.data.util.sorter", true);

sorter.basicComparator = function(	/*anything*/ a,
													/*anything*/ b){
	//	summary:
	//		Basic comparision function that compares if an item is greater or less than another item
	//	description:
	//		returns 1 if a > b, -1 if a < b, 0 if equal.
	//		'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	//		And compared to each other, null is equivalent to undefined.

	//null is a problematic compare, so if null, we set to undefined.
	//Makes the check logic simple, compact, and consistent
	//And (null == undefined) === true, so the check later against null
	//works for undefined and is less bytes.
	var r = -1;
	if(a === null){
		a = undefined;
	}
	if(b === null){
		b = undefined;
	}
	if(a == b){
		r = 0;
	}else if(a > b || a == null){
		r = 1;
	}
	return r; //int {-1,0,1}
};

sorter.createSortFunction = function(	/* attributes array */sortSpec, /*dojo.data.core.Read*/ store){
	//	summary:
	//		Helper function to generate the sorting function based off the list of sort attributes.
	//	description:
	//		The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	//		it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	//		use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	//		Returns the sorting function for this particular list of attributes and sorting directions.
	//
	//	sortSpec: array
	//		A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	//		The objects should be formatted as follows:
	//		{
	//			attribute: "attributeName-string" || attribute,
	//			descending: true|false;   // Default is false.
	//		}
	//	store: object
	//		The datastore object to look up item values from.
	//
	var sortFunctions=[];

	function createSortFunction(attr, dir, comp, s){
		//Passing in comp and s (comparator and store), makes this
		//function much faster.
		return function(itemA, itemB){
			var a = s.getValue(itemA, attr);
			var b = s.getValue(itemB, attr);
			return dir * comp(a,b); //int
		};
	}
	var sortAttribute;
	var map = store.comparatorMap;
	var bc = sorter.basicComparator;
	for(var i = 0; i < sortSpec.length; i++){
		sortAttribute = sortSpec[i];
		var attr = sortAttribute.attribute;
		if(attr){
			var dir = (sortAttribute.descending) ? -1 : 1;
			var comp = bc;
			if(map){
				if(typeof attr !== "string" && ("toString" in attr)){
					 attr = attr.toString();
				}
				comp = map[attr] || bc;
			}
			sortFunctions.push(createSortFunction(attr,
				dir, comp, store));
		}
	}
	return function(rowA, rowB){
		var i=0;
		while(i < sortFunctions.length){
			var ret = sortFunctions[i++](rowA, rowB);
			if(ret !== 0){
				return ret;//int
			}
		}
		return 0; //int
	}; // Function
};

return sorter;
});

},
'dijit/form/_ButtonMixin':function(){
define("dijit/form/_ButtonMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom", // dom.setSelectable
	"dojo/_base/event", // event.stop
	"../registry"		// registry.byNode
], function(declare, dom, event, registry){

// module:
//		dijit/form/_ButtonMixin
// summary:
//		A mixin to add a thin standard API wrapper to a normal HTML button

return declare("dijit.form._ButtonMixin", null, {
	// summary:
	//		A mixin to add a thin standard API wrapper to a normal HTML button
	// description:
	//		A label should always be specified (through innerHTML) or the label attribute.
	//		Attach points:
	//			focusNode (required): this node receives focus
	//			valueNode (optional): this node's value gets submitted with FORM elements
	//			containerNode (optional): this node gets the innerHTML assignment for label
	// example:
	// |	<button data-dojo-type="dijit.form.Button" onClick="...">Hello world</button>
	//
	// example:
	// |	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
	// |	dojo.body().appendChild(button1.domNode);

	// label: HTML String
	//		Content to display in button.
	label: "",

	// type: [const] String
	//		Type of button (submit, reset, button, checkbox, radio)
	type: "button",

	_onClick: function(/*Event*/ e){
		// summary:
		//		Internal function to handle click actions
		if(this.disabled){
			event.stop(e);
			return false;
		}
		var preventDefault = this.onClick(e) === false; // user click actions
		if(!preventDefault && this.type == "submit" && !(this.valueNode||this.focusNode).form){ // see if a non-form widget needs to be signalled
			for(var node=this.domNode; node.parentNode; node=node.parentNode){
				var widget=registry.byNode(node);
				if(widget && typeof widget._onSubmit == "function"){
					widget._onSubmit(e);
					preventDefault = true;
					break;
				}
			}
		}
		if(preventDefault){
			e.preventDefault();
		}
		return !preventDefault;
	},

	postCreate: function(){
		this.inherited(arguments);
		dom.setSelectable(this.focusNode, false);
	},

	onClick: function(/*Event*/ /*===== e =====*/){
		// summary:
		//		Callback for when button is clicked.
		//		If type="submit", return true to perform submit, or false to cancel it.
		// type:
		//		callback
		return true;		// Boolean
	},

	_setLabelAttr: function(/*String*/ content){
		// summary:
		//		Hook for set('label', ...) to work.
		// description:
		//		Set the label (text) of the button; takes an HTML string.
		this._set("label", content);
		(this.containerNode||this.focusNode).innerHTML = content;
	}
});

});

},
'dojo/colors':function(){
define("dojo/colors", ["./_base/kernel", "./_base/lang", "./_base/Color", "./_base/array"], function(dojo, lang, Color, ArrayUtil) {
	// module:
	//		dojo/colors
	// summary:
	//		TODOC

	var ColorExt = lang.getObject("dojo.colors", true);

//TODO: this module appears to break naming conventions

/*=====
	lang.mixin(dojo, {
		colors: {
			// summary: Color utilities, extending Base dojo.Color
		}
	});
=====*/

	// this is a standard conversion prescribed by the CSS3 Color Module
	var hue2rgb = function(m1, m2, h){
		if(h < 0){ ++h; }
		if(h > 1){ --h; }
		var h6 = 6 * h;
		if(h6 < 1){ return m1 + (m2 - m1) * h6; }
		if(2 * h < 1){ return m2; }
		if(3 * h < 2){ return m1 + (m2 - m1) * (2 / 3 - h) * 6; }
		return m1;
	};
	// Override base Color.fromRgb with the impl in this module
	dojo.colorFromRgb = Color.fromRgb = function(/*String*/ color, /*dojo.Color?*/ obj){
		// summary:
		//		get rgb(a) array from css-style color declarations
		// description:
		//		this function can handle all 4 CSS3 Color Module formats: rgb,
		//		rgba, hsl, hsla, including rgb(a) with percentage values.
		var m = color.toLowerCase().match(/^(rgba?|hsla?)\(([\s\.\-,%0-9]+)\)/);
		if(m){
			var c = m[2].split(/\s*,\s*/), l = c.length, t = m[1], a;
			if((t == "rgb" && l == 3) || (t == "rgba" && l == 4)){
				var r = c[0];
				if(r.charAt(r.length - 1) == "%"){
					// 3 rgb percentage values
					a = ArrayUtil.map(c, function(x){
						return parseFloat(x) * 2.56;
					});
					if(l == 4){ a[3] = c[3]; }
					return Color.fromArray(a, obj); // dojo.Color
				}
				return Color.fromArray(c, obj); // dojo.Color
			}
			if((t == "hsl" && l == 3) || (t == "hsla" && l == 4)){
				// normalize hsl values
				var H = ((parseFloat(c[0]) % 360) + 360) % 360 / 360,
					S = parseFloat(c[1]) / 100,
					L = parseFloat(c[2]) / 100,
					// calculate rgb according to the algorithm
					// recommended by the CSS3 Color Module
					m2 = L <= 0.5 ? L * (S + 1) : L + S - L * S,
					m1 = 2 * L - m2;
				a = [
					hue2rgb(m1, m2, H + 1 / 3) * 256,
					hue2rgb(m1, m2, H) * 256,
					hue2rgb(m1, m2, H - 1 / 3) * 256,
					1
				];
				if(l == 4){ a[3] = c[3]; }
				return Color.fromArray(a, obj); // dojo.Color
			}
		}
		return null;	// dojo.Color
	};

	var confine = function(c, low, high){
		// summary:
		//		sanitize a color component by making sure it is a number,
		//		and clamping it to valid values
		c = Number(c);
		return isNaN(c) ? high : c < low ? low : c > high ? high : c;	// Number
	};

	Color.prototype.sanitize = function(){
		// summary: makes sure that the object has correct attributes
		var t = this;
		t.r = Math.round(confine(t.r, 0, 255));
		t.g = Math.round(confine(t.g, 0, 255));
		t.b = Math.round(confine(t.b, 0, 255));
		t.a = confine(t.a, 0, 1);
		return this;	// dojo.Color
	};

	ColorExt.makeGrey = Color.makeGrey = function(/*Number*/ g, /*Number?*/ a){
		// summary: creates a greyscale color with an optional alpha
		return Color.fromArray([g, g, g, a]);	// dojo.Color
	};

	// mixin all CSS3 named colors not already in _base, along with SVG 1.0 variant spellings
	lang.mixin(Color.named, {
		"aliceblue":	[240,248,255],
		"antiquewhite": [250,235,215],
		"aquamarine":	[127,255,212],
		"azure":	[240,255,255],
		"beige":	[245,245,220],
		"bisque":	[255,228,196],
		"blanchedalmond":	[255,235,205],
		"blueviolet":	[138,43,226],
		"brown":	[165,42,42],
		"burlywood":	[222,184,135],
		"cadetblue":	[95,158,160],
		"chartreuse":	[127,255,0],
		"chocolate":	[210,105,30],
		"coral":	[255,127,80],
		"cornflowerblue":	[100,149,237],
		"cornsilk": [255,248,220],
		"crimson":	[220,20,60],
		"cyan": [0,255,255],
		"darkblue": [0,0,139],
		"darkcyan": [0,139,139],
		"darkgoldenrod":	[184,134,11],
		"darkgray": [169,169,169],
		"darkgreen":	[0,100,0],
		"darkgrey": [169,169,169],
		"darkkhaki":	[189,183,107],
		"darkmagenta":	[139,0,139],
		"darkolivegreen":	[85,107,47],
		"darkorange":	[255,140,0],
		"darkorchid":	[153,50,204],
		"darkred":	[139,0,0],
		"darksalmon":	[233,150,122],
		"darkseagreen": [143,188,143],
		"darkslateblue":	[72,61,139],
		"darkslategray":	[47,79,79],
		"darkslategrey":	[47,79,79],
		"darkturquoise":	[0,206,209],
		"darkviolet":	[148,0,211],
		"deeppink": [255,20,147],
		"deepskyblue":	[0,191,255],
		"dimgray":	[105,105,105],
		"dimgrey":	[105,105,105],
		"dodgerblue":	[30,144,255],
		"firebrick":	[178,34,34],
		"floralwhite":	[255,250,240],
		"forestgreen":	[34,139,34],
		"gainsboro":	[220,220,220],
		"ghostwhite":	[248,248,255],
		"gold": [255,215,0],
		"goldenrod":	[218,165,32],
		"greenyellow":	[173,255,47],
		"grey": [128,128,128],
		"honeydew": [240,255,240],
		"hotpink":	[255,105,180],
		"indianred":	[205,92,92],
		"indigo":	[75,0,130],
		"ivory":	[255,255,240],
		"khaki":	[240,230,140],
		"lavender": [230,230,250],
		"lavenderblush":	[255,240,245],
		"lawngreen":	[124,252,0],
		"lemonchiffon": [255,250,205],
		"lightblue":	[173,216,230],
		"lightcoral":	[240,128,128],
		"lightcyan":	[224,255,255],
		"lightgoldenrodyellow": [250,250,210],
		"lightgray":	[211,211,211],
		"lightgreen":	[144,238,144],
		"lightgrey":	[211,211,211],
		"lightpink":	[255,182,193],
		"lightsalmon":	[255,160,122],
		"lightseagreen":	[32,178,170],
		"lightskyblue": [135,206,250],
		"lightslategray":	[119,136,153],
		"lightslategrey":	[119,136,153],
		"lightsteelblue":	[176,196,222],
		"lightyellow":	[255,255,224],
		"limegreen":	[50,205,50],
		"linen":	[250,240,230],
		"magenta":	[255,0,255],
		"mediumaquamarine": [102,205,170],
		"mediumblue":	[0,0,205],
		"mediumorchid": [186,85,211],
		"mediumpurple": [147,112,219],
		"mediumseagreen":	[60,179,113],
		"mediumslateblue":	[123,104,238],
		"mediumspringgreen":	[0,250,154],
		"mediumturquoise":	[72,209,204],
		"mediumvioletred":	[199,21,133],
		"midnightblue": [25,25,112],
		"mintcream":	[245,255,250],
		"mistyrose":	[255,228,225],
		"moccasin": [255,228,181],
		"navajowhite":	[255,222,173],
		"oldlace":	[253,245,230],
		"olivedrab":	[107,142,35],
		"orange":	[255,165,0],
		"orangered":	[255,69,0],
		"orchid":	[218,112,214],
		"palegoldenrod":	[238,232,170],
		"palegreen":	[152,251,152],
		"paleturquoise":	[175,238,238],
		"palevioletred":	[219,112,147],
		"papayawhip":	[255,239,213],
		"peachpuff":	[255,218,185],
		"peru": [205,133,63],
		"pink": [255,192,203],
		"plum": [221,160,221],
		"powderblue":	[176,224,230],
		"rosybrown":	[188,143,143],
		"royalblue":	[65,105,225],
		"saddlebrown":	[139,69,19],
		"salmon":	[250,128,114],
		"sandybrown":	[244,164,96],
		"seagreen": [46,139,87],
		"seashell": [255,245,238],
		"sienna":	[160,82,45],
		"skyblue":	[135,206,235],
		"slateblue":	[106,90,205],
		"slategray":	[112,128,144],
		"slategrey":	[112,128,144],
		"snow": [255,250,250],
		"springgreen":	[0,255,127],
		"steelblue":	[70,130,180],
		"tan":	[210,180,140],
		"thistle":	[216,191,216],
		"tomato":	[255,99,71],
		"turquoise":	[64,224,208],
		"violet":	[238,130,238],
		"wheat":	[245,222,179],
		"whitesmoke":	[245,245,245],
		"yellowgreen":	[154,205,50]
	});

	return Color;
});

},
'dijit/registry':function(){
define("dijit/registry", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/sniff", // has("ie")
	"dojo/_base/unload", // unload.addOnWindowUnload
	"dojo/_base/window", // win.body
	"."	// dijit._scopeName
], function(array, has, unload, win, dijit){

	// module:
	//		dijit/registry
	// summary:
	//		Registry of existing widget on page, plus some utility methods.
	//		Must be accessed through AMD api, ex:
	//		require(["dijit/registry"], function(registry){ registry.byId("foo"); })

	var _widgetTypeCtr = {}, hash = {};

	var registry =  {
		// summary:
		//		A set of widgets indexed by id

		length: 0,

		add: function(/*dijit._Widget*/ widget){
			// summary:
			//		Add a widget to the registry. If a duplicate ID is detected, a error is thrown.
			//
			// widget: dijit._Widget
			//		Any dijit._Widget subclass.
			if(hash[widget.id]){
				throw new Error("Tried to register widget with id==" + widget.id + " but that id is already registered");
			}
			hash[widget.id] = widget;
			this.length++;
		},

		remove: function(/*String*/ id){
			// summary:
			//		Remove a widget from the registry. Does not destroy the widget; simply
			//		removes the reference.
			if(hash[id]){
				delete hash[id];
				this.length--;
			}
		},

		byId: function(/*String|Widget*/ id){
			// summary:
			//		Find a widget by it's id.
			//		If passed a widget then just returns the widget.
			return typeof id == "string" ? hash[id] : id;	// dijit._Widget
		},

		byNode: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget corresponding to the given DOMNode
			return hash[node.getAttribute("widgetId")]; // dijit._Widget
		},

		toArray: function(){
			// summary:
			//		Convert registry into a true Array
			//
			// example:
			//		Work with the widget .domNodes in a real Array
			//		|	array.map(dijit.registry.toArray(), function(w){ return w.domNode; });

			var ar = [];
			for(var id in hash){
				ar.push(hash[id]);
			}
			return ar;	// dijit._Widget[]
		},

		getUniqueId: function(/*String*/widgetType){
			// summary:
			//		Generates a unique id for a given widgetType

			var id;
			do{
				id = widgetType + "_" +
					(widgetType in _widgetTypeCtr ?
						++_widgetTypeCtr[widgetType] : _widgetTypeCtr[widgetType] = 0);
			}while(hash[id]);
			return dijit._scopeName == "dijit" ? id : dijit._scopeName + "_" + id; // String
		},

		findWidgets: function(/*DomNode*/ root){
			// summary:
			//		Search subtree under root returning widgets found.
			//		Doesn't search for nested widgets (ie, widgets inside other widgets).

			var outAry = [];

			function getChildrenHelper(root){
				for(var node = root.firstChild; node; node = node.nextSibling){
					if(node.nodeType == 1){
						var widgetId = node.getAttribute("widgetId");
						if(widgetId){
							var widget = hash[widgetId];
							if(widget){	// may be null on page w/multiple dojo's loaded
								outAry.push(widget);
							}
						}else{
							getChildrenHelper(node);
						}
					}
				}
			}

			getChildrenHelper(root);
			return outAry;
		},

		_destroyAll: function(){
			// summary:
			//		Code to destroy all widgets and do other cleanup on page unload

			// Clean up focus manager lingering references to widgets and nodes
			dijit._curFocus = null;
			dijit._prevFocus = null;
			dijit._activeStack = [];

			// Destroy all the widgets, top down
			array.forEach(registry.findWidgets(win.body()), function(widget){
				// Avoid double destroy of widgets like Menu that are attached to <body>
				// even though they are logically children of other widgets.
				if(!widget._destroyed){
					if(widget.destroyRecursive){
						widget.destroyRecursive();
					}else if(widget.destroy){
						widget.destroy();
					}
				}
			});
		},

		getEnclosingWidget: function(/*DOMNode*/ node){
			// summary:
			//		Returns the widget whose DOM tree contains the specified DOMNode, or null if
			//		the node is not contained within the DOM tree of any widget
			while(node){
				var id = node.getAttribute && node.getAttribute("widgetId");
				if(id){
					return hash[id];
				}
				node = node.parentNode;
			}
			return null;
		},

		// In case someone needs to access hash.
		// Actually, this is accessed from WidgetSet back-compatibility code
		_hash: hash
	};

	if(has("ie")){
		// Only run _destroyAll() for IE because we think it's only necessary in that case,
		// and because it causes problems on FF.  See bug #3531 for details.
		unload.addOnWindowUnload(function(){
			registry._destroyAll();
		});
	}

	/*=====
	dijit.registry = {
		// summary:
		//		A list of widgets on a page.
	};
	=====*/
	dijit.registry = registry;

	return registry;
});

},
'dojo/date/locale':function(){
define("dojo/date/locale", [
	"../_base/kernel",
	"../_base/lang",
	"../_base/array",
	"../date",
	"../cldr/supplemental",
	"../regexp",
	"../string",
	"../i18n!../cldr/nls/gregorian"
], function(dojo, lang, array, date, cldr, regexp, string, gregorian) {
	// module:
	//		dojo/date/locale
	// summary:
	//		This modules defines dojo.date.locale, localization methods for Date.

lang.getObject("date.locale", true, dojo);

// Localization methods for Date.   Honor local customs using locale-dependent dojo.cldr data.

// Load the bundles containing localization information for
// names and formats

//NOTE: Everything in this module assumes Gregorian calendars.
// Other calendars will be implemented in separate modules.

	// Format a pattern without literals
	function formatPattern(dateObject, bundle, options, pattern){
		return pattern.replace(/([a-z])\1*/ig, function(match){
			var s, pad,
				c = match.charAt(0),
				l = match.length,
				widthList = ["abbr", "wide", "narrow"];
			switch(c){
				case 'G':
					s = bundle[(l < 4) ? "eraAbbr" : "eraNames"][dateObject.getFullYear() < 0 ? 0 : 1];
					break;
				case 'y':
					s = dateObject.getFullYear();
					switch(l){
						case 1:
							break;
						case 2:
							if(!options.fullYear){
								s = String(s); s = s.substr(s.length - 2);
								break;
							}
							// fallthrough
						default:
							pad = true;
					}
					break;
				case 'Q':
				case 'q':
					s = Math.ceil((dateObject.getMonth()+1)/3);
//					switch(l){
//						case 1: case 2:
							pad = true;
//							break;
//						case 3: case 4: // unimplemented
//					}
					break;
				case 'M':
					var m = dateObject.getMonth();
					if(l<3){
						s = m+1; pad = true;
					}else{
						var propM = ["months", "format", widthList[l-3]].join("-");
						s = bundle[propM][m];
					}
					break;
				case 'w':
					var firstDay = 0;
					s = dojo.date.locale._getWeekOfYear(dateObject, firstDay); pad = true;
					break;
				case 'd':
					s = dateObject.getDate(); pad = true;
					break;
				case 'D':
					s = dojo.date.locale._getDayOfYear(dateObject); pad = true;
					break;
				case 'E':
					var d = dateObject.getDay();
					if(l<3){
						s = d+1; pad = true;
					}else{
						var propD = ["days", "format", widthList[l-3]].join("-");
						s = bundle[propD][d];
					}
					break;
				case 'a':
					var timePeriod = (dateObject.getHours() < 12) ? 'am' : 'pm';
					s = options[timePeriod] || bundle['dayPeriods-format-wide-' + timePeriod];
					break;
				case 'h':
				case 'H':
				case 'K':
				case 'k':
					var h = dateObject.getHours();
					// strange choices in the date format make it impossible to write this succinctly
					switch (c){
						case 'h': // 1-12
							s = (h % 12) || 12;
							break;
						case 'H': // 0-23
							s = h;
							break;
						case 'K': // 0-11
							s = (h % 12);
							break;
						case 'k': // 1-24
							s = h || 24;
							break;
					}
					pad = true;
					break;
				case 'm':
					s = dateObject.getMinutes(); pad = true;
					break;
				case 's':
					s = dateObject.getSeconds(); pad = true;
					break;
				case 'S':
					s = Math.round(dateObject.getMilliseconds() * Math.pow(10, l-3)); pad = true;
					break;
				case 'v': // FIXME: don't know what this is. seems to be same as z?
				case 'z':
					// We only have one timezone to offer; the one from the browser
					s = dojo.date.locale._getZone(dateObject, true, options);
					if(s){break;}
					l=4;
					// fallthrough... use GMT if tz not available
				case 'Z':
					var offset = dojo.date.locale._getZone(dateObject, false, options);
					var tz = [
						(offset<=0 ? "+" : "-"),
						string.pad(Math.floor(Math.abs(offset)/60), 2),
						string.pad(Math.abs(offset)% 60, 2)
					];
					if(l==4){
						tz.splice(0, 0, "GMT");
						tz.splice(3, 0, ":");
					}
					s = tz.join("");
					break;
//				case 'Y': case 'u': case 'W': case 'F': case 'g': case 'A': case 'e':
//					console.log(match+" modifier unimplemented");
				default:
					throw new Error("dojo.date.locale.format: invalid pattern char: "+pattern);
			}
			if(pad){ s = string.pad(s, l); }
			return s;
		});
	}

/*=====
	dojo.date.locale.__FormatOptions = function(){
	//	selector: String
	//		choice of 'time','date' (default: date and time)
	//	formatLength: String
	//		choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'
	//	datePattern:String
	//		override pattern with this string
	//	timePattern:String
	//		override pattern with this string
	//	am: String
	//		override strings for am in times
	//	pm: String
	//		override strings for pm in times
	//	locale: String
	//		override the locale used to determine formatting rules
	//	fullYear: Boolean
	//		(format only) use 4 digit years whenever 2 digit years are called for
	//	strict: Boolean
	//		(parse only) strict parsing, off by default
		this.selector = selector;
		this.formatLength = formatLength;
		this.datePattern = datePattern;
		this.timePattern = timePattern;
		this.am = am;
		this.pm = pm;
		this.locale = locale;
		this.fullYear = fullYear;
		this.strict = strict;
	}
=====*/

dojo.date.locale._getZone = function(/*Date*/dateObject, /*boolean*/getName, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Returns the zone (or offset) for the given date and options.  This
	//		is broken out into a separate function so that it can be overridden
	//		by timezone-aware code.
	//
	// dateObject:
	//		the date and/or time being formatted.
	//
	// getName:
	//		Whether to return the timezone string (if true), or the offset (if false)
	//
	// options:
	//		The options being used for formatting
	if(getName){
		return date.getTimezoneName(dateObject);
	}else{
		return dateObject.getTimezoneOffset();
	}
};


dojo.date.locale.format = function(/*Date*/dateObject, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Format a Date object as a String, using locale-specific settings.
	//
	// description:
	//		Create a string from a Date object using a known localized pattern.
	//		By default, this method formats both date and time from dateObject.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//
	// dateObject:
	//		the date and/or time to be formatted.  If a time only is formatted,
	//		the values in the year, month, and day fields are irrelevant.  The
	//		opposite is true when formatting only dates.

	options = options || {};

	var locale = dojo.i18n.normalizeLocale(options.locale),
		formatLength = options.formatLength || 'short',
		bundle = dojo.date.locale._getGregorianBundle(locale),
		str = [],
		sauce = lang.hitch(this, formatPattern, dateObject, bundle, options);
	if(options.selector == "year"){
		return _processPattern(bundle["dateFormatItem-yyyy"] || "yyyy", sauce);
	}
	var pattern;
	if(options.selector != "date"){
		pattern = options.timePattern || bundle["timeFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}
	if(options.selector != "time"){
		pattern = options.datePattern || bundle["dateFormat-"+formatLength];
		if(pattern){str.push(_processPattern(pattern, sauce));}
	}

	return str.length == 1 ? str[0] : bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
		function(match, key){ return str[key]; }); // String
};

dojo.date.locale.regexp = function(/*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Builds the regular needed to parse a localized date

	return dojo.date.locale._parseInfo(options).regexp; // String
};

dojo.date.locale._parseInfo = function(/*dojo.date.locale.__FormatOptions?*/options){
	options = options || {};
	var locale = dojo.i18n.normalizeLocale(options.locale),
		bundle = dojo.date.locale._getGregorianBundle(locale),
		formatLength = options.formatLength || 'short',
		datePattern = options.datePattern || bundle["dateFormat-" + formatLength],
		timePattern = options.timePattern || bundle["timeFormat-" + formatLength],
		pattern;
	if(options.selector == 'date'){
		pattern = datePattern;
	}else if(options.selector == 'time'){
		pattern = timePattern;
	}else{
		pattern = bundle["dateTimeFormat-"+formatLength].replace(/\{(\d+)\}/g,
			function(match, key){ return [timePattern, datePattern][key]; });
	}

	var tokens = [],
		re = _processPattern(pattern, lang.hitch(this, _buildDateTimeRE, tokens, bundle, options));
	return {regexp: re, tokens: tokens, bundle: bundle};
};

dojo.date.locale.parse = function(/*String*/value, /*dojo.date.locale.__FormatOptions?*/options){
	// summary:
	//		Convert a properly formatted string to a primitive Date object,
	//		using locale-specific settings.
	//
	// description:
	//		Create a Date object from a string using a known localized pattern.
	//		By default, this method parses looking for both date and time in the string.
	//		Formatting patterns are chosen appropriate to the locale.  Different
	//		formatting lengths may be chosen, with "full" used by default.
	//		Custom patterns may be used or registered with translations using
	//		the dojo.date.locale.addCustomFormats method.
	//
	//		Formatting patterns are implemented using [the syntax described at
	//		unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	//		When two digit years are used, a century is chosen according to a sliding
	//		window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	//		year < 100CE requires strict mode.
	//
	// value:
	//		A string representation of a date

	// remove non-printing bidi control chars from input and pattern
	var controlChars = /[\u200E\u200F\u202A\u202E]/g,
		info = dojo.date.locale._parseInfo(options),
		tokens = info.tokens, bundle = info.bundle,
		re = new RegExp("^" + info.regexp.replace(controlChars, "") + "$",
			info.strict ? "" : "i"),
		match = re.exec(value && value.replace(controlChars, ""));

	if(!match){ return null; } // null

	var widthList = ['abbr', 'wide', 'narrow'],
		result = [1970,0,1,0,0,0,0], // will get converted to a Date at the end
		amPm = "",
		valid = dojo.every(match, function(v, i){
		if(!i){return true;}
		var token=tokens[i-1];
		var l=token.length;
		switch(token.charAt(0)){
			case 'y':
				if(l != 2 && options.strict){
					//interpret year literally, so '5' would be 5 A.D.
					result[0] = v;
				}else{
					if(v<100){
						v = Number(v);
						//choose century to apply, according to a sliding window
						//of 80 years before and 20 years after present year
						var year = '' + new Date().getFullYear(),
							century = year.substring(0, 2) * 100,
							cutoff = Math.min(Number(year.substring(2, 4)) + 20, 99);
						result[0] = (v < cutoff) ? century + v : century - 100 + v;
					}else{
						//we expected 2 digits and got more...
						if(options.strict){
							return false;
						}
						//interpret literally, so '150' would be 150 A.D.
						//also tolerate '1950', if 'yyyy' input passed to 'yy' format
						result[0] = v;
					}
				}
				break;
			case 'M':
				if(l>2){
					var months = bundle['months-format-' + widthList[l-3]].concat();
					if(!options.strict){
						//Tolerate abbreviating period in month part
						//Case-insensitive comparison
						v = v.replace(".","").toLowerCase();
						months = dojo.map(months, function(s){ return s.replace(".","").toLowerCase(); } );
					}
					v = dojo.indexOf(months, v);
					if(v == -1){
//						console.log("dojo.date.locale.parse: Could not parse month name: '" + v + "'.");
						return false;
					}
				}else{
					v--;
				}
				result[1] = v;
				break;
			case 'E':
			case 'e':
				var days = bundle['days-format-' + widthList[l-3]].concat();
				if(!options.strict){
					//Case-insensitive comparison
					v = v.toLowerCase();
					days = dojo.map(days, function(d){return d.toLowerCase();});
				}
				v = dojo.indexOf(days, v);
				if(v == -1){
//					console.log("dojo.date.locale.parse: Could not parse weekday name: '" + v + "'.");
					return false;
				}

				//TODO: not sure what to actually do with this input,
				//in terms of setting something on the Date obj...?
				//without more context, can't affect the actual date
				//TODO: just validate?
				break;
			case 'D':
				result[1] = 0;
				// fallthrough...
			case 'd':
				result[2] = v;
				break;
			case 'a': //am/pm
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
				if(!options.strict){
					var period = /\./g;
					v = v.replace(period,'').toLowerCase();
					am = am.replace(period,'').toLowerCase();
					pm = pm.replace(period,'').toLowerCase();
				}
				if(options.strict && v != am && v != pm){
//					console.log("dojo.date.locale.parse: Could not parse am/pm part.");
					return false;
				}

				// we might not have seen the hours field yet, so store the state and apply hour change later
				amPm = (v == pm) ? 'p' : (v == am) ? 'a' : '';
				break;
			case 'K': //hour (1-24)
				if(v == 24){ v = 0; }
				// fallthrough...
			case 'h': //hour (1-12)
			case 'H': //hour (0-23)
			case 'k': //hour (0-11)
				//TODO: strict bounds checking, padding
				if(v > 23){
//					console.log("dojo.date.locale.parse: Illegal hours value");
					return false;
				}

				//in the 12-hour case, adjusting for am/pm requires the 'a' part
				//which could come before or after the hour, so we will adjust later
				result[3] = v;
				break;
			case 'm': //minutes
				result[4] = v;
				break;
			case 's': //seconds
				result[5] = v;
				break;
			case 'S': //milliseconds
				result[6] = v;
//				break;
//			case 'w':
//TODO				var firstDay = 0;
//			default:
//TODO: throw?
//				console.log("dojo.date.locale.parse: unsupported pattern char=" + token.charAt(0));
		}
		return true;
	});

	var hours = +result[3];
	if(amPm === 'p' && hours < 12){
		result[3] = hours + 12; //e.g., 3pm -> 15
	}else if(amPm === 'a' && hours == 12){
		result[3] = 0; //12am -> 0
	}

	//TODO: implement a getWeekday() method in order to test
	//validity of input strings containing 'EEE' or 'EEEE'...

	var dateObject = new Date(result[0], result[1], result[2], result[3], result[4], result[5], result[6]); // Date
	if(options.strict){
		dateObject.setFullYear(result[0]);
	}

	// Check for overflow.  The Date() constructor normalizes things like April 32nd...
	//TODO: why isn't this done for times as well?
	var allTokens = tokens.join(""),
		dateToken = allTokens.indexOf('d') != -1,
		monthToken = allTokens.indexOf('M') != -1;

	if(!valid ||
		(monthToken && dateObject.getMonth() > result[1]) ||
		(dateToken && dateObject.getDate() > result[2])){
		return null;
	}

	// Check for underflow, due to DST shifts.  See #9366
	// This assumes a 1 hour dst shift correction at midnight
	// We could compare the timezone offset after the shift and add the difference instead.
	if((monthToken && dateObject.getMonth() < result[1]) ||
		(dateToken && dateObject.getDate() < result[2])){
		dateObject = date.add(dateObject, "hour", 1);
	}

	return dateObject; // Date
};

function _processPattern(pattern, applyPattern, applyLiteral, applyAll){
	//summary: Process a pattern with literals in it

	// Break up on single quotes, treat every other one as a literal, except '' which becomes '
	var identity = function(x){return x;};
	applyPattern = applyPattern || identity;
	applyLiteral = applyLiteral || identity;
	applyAll = applyAll || identity;

	//split on single quotes (which escape literals in date format strings)
	//but preserve escaped single quotes (e.g., o''clock)
	var chunks = pattern.match(/(''|[^'])+/g),
		literal = pattern.charAt(0) == "'";

	dojo.forEach(chunks, function(chunk, i){
		if(!chunk){
			chunks[i]='';
		}else{
			chunks[i]=(literal ? applyLiteral : applyPattern)(chunk.replace(/''/g, "'"));
			literal = !literal;
		}
	});
	return applyAll(chunks.join(''));
}

function _buildDateTimeRE(tokens, bundle, options, pattern){
	pattern = regexp.escapeString(pattern);
	if(!options.strict){ pattern = pattern.replace(" a", " ?a"); } // kludge to tolerate no space before am/pm
	return pattern.replace(/([a-z])\1*/ig, function(match){
		// Build a simple regexp.  Avoid captures, which would ruin the tokens list
		var s,
			c = match.charAt(0),
			l = match.length,
			p2 = '', p3 = '';
		if(options.strict){
			if(l > 1){ p2 = '0' + '{'+(l-1)+'}'; }
			if(l > 2){ p3 = '0' + '{'+(l-2)+'}'; }
		}else{
			p2 = '0?'; p3 = '0{0,2}';
		}
		switch(c){
			case 'y':
				s = '\\d{2,4}';
				break;
			case 'M':
				s = (l>2) ? '\\S+?' : '1[0-2]|'+p2+'[1-9]';
				break;
			case 'D':
				s = '[12][0-9][0-9]|3[0-5][0-9]|36[0-6]|'+p2+'[1-9][0-9]|'+p3+'[1-9]';
				break;
			case 'd':
				s = '3[01]|[12]\\d|'+p2+'[1-9]';
				break;
			case 'w':
				s = '[1-4][0-9]|5[0-3]|'+p2+'[1-9]';
				break;
			case 'E':
				s = '\\S+';
				break;
			case 'h': //hour (1-12)
				s = '1[0-2]|'+p2+'[1-9]';
				break;
			case 'k': //hour (0-11)
				s = '1[01]|'+p2+'\\d';
				break;
			case 'H': //hour (0-23)
				s = '1\\d|2[0-3]|'+p2+'\\d';
				break;
			case 'K': //hour (1-24)
				s = '1\\d|2[0-4]|'+p2+'[1-9]';
				break;
			case 'm':
			case 's':
				s = '[0-5]\\d';
				break;
			case 'S':
				s = '\\d{'+l+'}';
				break;
			case 'a':
				var am = options.am || bundle['dayPeriods-format-wide-am'],
					pm = options.pm || bundle['dayPeriods-format-wide-pm'];
					s = am + '|' + pm;
				if(!options.strict){
					if(am != am.toLowerCase()){ s += '|' + am.toLowerCase(); }
					if(pm != pm.toLowerCase()){ s += '|' + pm.toLowerCase(); }
					if(s.indexOf('.') != -1){ s += '|' + s.replace(/\./g, ""); }
				}
				s = s.replace(/\./g, "\\.");
				break;
			default:
			// case 'v':
			// case 'z':
			// case 'Z':
				s = ".*";
//				console.log("parse of date format, pattern=" + pattern);
		}

		if(tokens){ tokens.push(match); }

		return "(" + s + ")"; // add capture
	}).replace(/[\xa0 ]/g, "[\\s\\xa0]"); // normalize whitespace.  Need explicit handling of \xa0 for IE.
}

var _customFormats = [];
dojo.date.locale.addCustomFormats = function(/*String*/packageName, /*String*/bundleName){
	// summary:
	//		Add a reference to a bundle containing localized custom formats to be
	//		used by date/time formatting and parsing routines.
	//
	// description:
	//		The user may add custom localized formats where the bundle has properties following the
	//		same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	//		The pattern string should match the format used by the CLDR.
	//		See dojo.date.locale.format() for details.
	//		The resources must be loaded by dojo.requireLocalization() prior to use

	_customFormats.push({pkg:packageName,name:bundleName});
};

dojo.date.locale._getGregorianBundle = function(/*String*/locale){
	var gregorian = {};
	dojo.forEach(_customFormats, function(desc){
		var bundle = dojo.i18n.getLocalization(desc.pkg, desc.name, locale);
		gregorian = lang.mixin(gregorian, bundle);
	}, this);
	return gregorian; /*Object*/
};

dojo.date.locale.addCustomFormats("dojo.cldr","gregorian");

dojo.date.locale.getNames = function(/*String*/item, /*String*/type, /*String?*/context, /*String?*/locale){
	// summary:
	//		Used to get localized strings from dojo.cldr for day or month names.
	//
	// item:
	//	'months' || 'days'
	// type:
	//	'wide' || 'abbr' || 'narrow' (e.g. "Monday", "Mon", or "M" respectively, in English)
	// context:
	//	'standAlone' || 'format' (default)
	// locale:
	//	override locale used to find the names

	var label,
		lookup = dojo.date.locale._getGregorianBundle(locale),
		props = [item, context, type];
	if(context == 'standAlone'){
		var key = props.join('-');
		label = lookup[key];
		// Fall back to 'format' flavor of name
		if(label[0] == 1){ label = undefined; } // kludge, in the absence of real aliasing support in dojo.cldr
	}
	props[1] = 'format';

	// return by copy so changes won't be made accidentally to the in-memory model
	return (label || lookup[props.join('-')]).concat(); /*Array*/
};

dojo.date.locale.isWeekend = function(/*Date?*/dateObject, /*String?*/locale){
	// summary:
	//	Determines if the date falls on a weekend, according to local custom.

	var weekend = cldr.getWeekend(locale),
		day = (dateObject || new Date()).getDay();
	if(weekend.end < weekend.start){
		weekend.end += 7;
		if(day < weekend.start){ day += 7; }
	}
	return day >= weekend.start && day <= weekend.end; // Boolean
};

// These are used only by format and strftime.  Do they need to be public?  Which module should they go in?

dojo.date.locale._getDayOfYear = function(/*Date*/dateObject){
	// summary: gets the day of the year as represented by dateObject
	return date.difference(new Date(dateObject.getFullYear(), 0, 1, dateObject.getHours()), dateObject) + 1; // Number
};

dojo.date.locale._getWeekOfYear = function(/*Date*/dateObject, /*Number*/firstDayOfWeek){
	if(arguments.length == 1){ firstDayOfWeek = 0; } // Sunday

	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1).getDay(),
		adj = (firstDayOfYear - firstDayOfWeek + 7) % 7,
		week = Math.floor((dojo.date.locale._getDayOfYear(dateObject) + adj - 1) / 7);

	// if year starts on the specified day, start counting weeks at 1
	if(firstDayOfYear == firstDayOfWeek){ week++; }

	return week; // Number
};

return dojo.date.locale;
});

},
'dijit/tree/_dndContainer':function(){
define("dijit/tree/_dndContainer", [
	"dojo/aspect",	// aspect.after
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace
	"dojo/_base/event",	// event.stop
	"dojo/_base/lang", // lang.getObject lang.mixin lang.hitch
	"dojo/mouse",	// mouse.enter, mouse.leave
	"dojo/on"
], function(aspect, declare, domClass, event, lang, mouse, on){

	// module:
	//		dijit/tree/_dndContainer
	// summary:
	//		This is a base class for `dijit.tree._dndSelector`, and isn't meant to be used directly.
	//		It's modeled after `dojo.dnd.Container`.

	return declare("dijit.tree._dndContainer", null, {

		// summary:
		//		This is a base class for `dijit.tree._dndSelector`, and isn't meant to be used directly.
		//		It's modeled after `dojo.dnd.Container`.
		// tags:
		//		protected

		/*=====
		// current: DomNode
		//		The currently hovered TreeNode.rowNode (which is the DOM node
		//		associated w/a given node in the tree, excluding it's descendants)
		current: null,
		=====*/

		constructor: function(tree, params){
			// summary:
			//		A constructor of the Container
			// tree: Node
			//		Node or node's id to build the container on
			// params: dijit.tree.__SourceArgs
			//		A dict of parameters, which gets mixed into the object
			// tags:
			//		private
			this.tree = tree;
			this.node = tree.domNode;	// TODO: rename; it's not a TreeNode but the whole Tree
			lang.mixin(this, params);

			// class-specific variables
			this.current = null;	// current TreeNode's DOM node

			// states
			this.containerState = "";
			domClass.add(this.node, "dojoDndContainer");

			// set up events
			this.events = [
				// container level events
				on(this.node, mouse.enter, lang.hitch(this, "onOverEvent")),
				on(this.node, mouse.leave,	lang.hitch(this, "onOutEvent")),

				// switching between TreeNodes
				aspect.after(this.tree, "_onNodeMouseEnter", lang.hitch(this, "onMouseOver"), true),
				aspect.after(this.tree, "_onNodeMouseLeave", lang.hitch(this, "onMouseOut"), true),

				// cancel text selection and text dragging
				on(this.node, "dragstart", lang.hitch(event, "stop")),
				on(this.node, "selectstart", lang.hitch(event, "stop"))
			];
		},

		destroy: function(){
			// summary:
			//		Prepares this object to be garbage-collected

			var h;
			while(h = this.events.pop()){ h.remove(); }

			// this.clearItems();
			this.node = this.parent = null;
		},

		// mouse events
		onMouseOver: function(widget /*===== , evt =====*/){
			// summary:
			//		Called when mouse is moved over a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = widget;
		},

		onMouseOut: function(/*===== widget, evt =====*/){
			// summary:
			//		Called when mouse is moved away from a TreeNode
			// widget: TreeNode
			// evt: Event
			// tags:
			//		protected
			this.current = null;
		},

		_changeState: function(type, newState){
			// summary:
			//		Changes a named state to new state value
			// type: String
			//		A name of the state to change
			// newState: String
			//		new state
			var prefix = "dojoDnd" + type;
			var state = type.toLowerCase() + "State";
			//domClass.replace(this.node, prefix + newState, prefix + this[state]);
			domClass.replace(this.node, prefix + newState, prefix + this[state]);
			this[state] = newState;
		},

		_addItemClass: function(node, type){
			// summary:
			//		Adds a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.add(node, "dojoDndItem" + type);
		},

		_removeItemClass: function(node, type){
			// summary:
			//		Removes a class with prefix "dojoDndItem"
			// node: Node
			//		A node
			// type: String
			//		A variable suffix for a class name
			domClass.remove(node, "dojoDndItem" + type);
		},

		onOverEvent: function(){
			// summary:
			//		This function is called once, when mouse is over our container
			// tags:
			//		protected
			this._changeState("Container", "Over");
		},

		onOutEvent: function(){
			// summary:
			//		This function is called once, when mouse is out of our container
			// tags:
			//		protected
			this._changeState("Container", "");
		}
	});
});

},
'url:dojox/grid/resources/View.html':"<div class=\"dojoxGridView\" role=\"presentation\">\n\t<div class=\"dojoxGridHeader\" dojoAttachPoint=\"headerNode\" role=\"presentation\">\n\t\t<div dojoAttachPoint=\"headerNodeContainer\" style=\"width:9000em\" role=\"presentation\">\n\t\t\t<div dojoAttachPoint=\"headerContentNode\" role=\"row\"></div>\n\t\t</div>\n\t</div>\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" dojoAttachPoint=\"hiddenFocusNode\" role=\"presentation\" />\n\t<input type=\"checkbox\" class=\"dojoxGridHiddenFocus\" role=\"presentation\" />\n\t<div class=\"dojoxGridScrollbox\" dojoAttachPoint=\"scrollboxNode\" role=\"presentation\">\n\t\t<div class=\"dojoxGridContent\" dojoAttachPoint=\"contentNode\" hidefocus=\"hidefocus\" role=\"presentation\"></div>\n\t</div>\n</div>\n",
'dojo/store/util/QueryResults':function(){
define("dojo/store/util/QueryResults", ["../../_base/array", "../../_base/lang", "../../_base/Deferred"
], function(array, lang, Deferred) {
  //  module:
  //    dojo/store/util/QueryResults
  //  summary:
  //    The module defines a query results wrapper

var util = lang.getObject("dojo.store.util", true);

util.QueryResults = function(results){
	// summary:
	//		A function that wraps the results of a store query with additional
	//		methods.
	//
	// description:
	//		QueryResults is a basic wrapper that allows for array-like iteration
	//		over any kind of returned data from a query.  While the simplest store
	//		will return a plain array of data, other stores may return deferreds or
	//		promises; this wrapper makes sure that *all* results can be treated
	//		the same.
	//
	//		Additional methods include `forEach`, `filter` and `map`.
	//
	// returns: Object
	//		An array-like object that can be used for iterating over.
	//
	// example:
	//		Query a store and iterate over the results.
	//
	//	|	store.query({ prime: true }).forEach(function(item){
	//	|		//	do something
	//	|	});

	if(!results){
		return results;
	}
	// if it is a promise it may be frozen
	if(results.then){
		results = lang.delegate(results);
	}
	function addIterativeMethod(method){
		if(!results[method]){
			results[method] = function(){
				var args = arguments;
				return Deferred.when(results, function(results){
					Array.prototype.unshift.call(args, results);
					return util.QueryResults(array[method].apply(array, args));
				});
			};
		}
	}
	addIterativeMethod("forEach");
	addIterativeMethod("filter");
	addIterativeMethod("map");
	if(!results.total){
		results.total = Deferred.when(results, function(results){
			return results.length;
		});
	}
	return results;
};

return util.QueryResults;
});

},
'dijit/form/_ListBase':function(){
define("dijit/form/_ListBase", [
	"dojo/_base/declare",	// declare
	"dojo/window" // winUtils.scrollIntoView
], function(declare, winUtils){

// module:
//		dijit/form/_ListBase
// summary:
//		Focus-less menu to handle UI events consistently

return declare( "dijit.form._ListBase", null, {
	// summary:
	//		Focus-less menu to handle UI events consistently
	//		Abstract methods that must be defined externally:
	//			onSelect: item is active (mousedown but not yet mouseup, or keyboard arrow selected but no Enter)
	//			onDeselect:  cancels onSelect
	// tags:
	//		private

	// selected: DOMnode
	//		currently selected node
	selected: null,

	_getTarget: function(/*Event*/ evt){
		var tgt = evt.target;
		var container = this.containerNode;
		if(tgt == container || tgt == this.domNode){ return null; }
		while(tgt && tgt.parentNode != container){
			// recurse to the top
			tgt = tgt.parentNode;
		}
		return tgt;
	},

	selectFirstNode: function(){
		// summary:
		// 		Select the first displayed item in the list.
		var first = this.containerNode.firstChild;
		while(first && first.style.display == "none"){
			first = first.nextSibling;
		}
		this._setSelectedAttr(first);
	},

	selectLastNode: function(){
		// summary:
		// 		Select the last displayed item in the list
		var last = this.containerNode.lastChild;
		while(last && last.style.display == "none"){
			last = last.previousSibling;
		}
		this._setSelectedAttr(last);
	},

	selectNextNode: function(){
		// summary:
		// 		Select the item just below the current selection.
		// 		If nothing selected, select first node.
		var selectedNode = this._getSelectedAttr();
		if(!selectedNode){
			this.selectFirstNode();
		}else{
			var next = selectedNode.nextSibling;
			while(next && next.style.display == "none"){
				next = next.nextSibling;
			}
			if(!next){
				this.selectFirstNode();
			}else{
				this._setSelectedAttr(next);
			}
		}
	},

	selectPreviousNode: function(){
		// summary:
		// 		Select the item just above the current selection.
		// 		If nothing selected, select last node (if
		// 		you select Previous and try to keep scrolling up the list).
		var selectedNode = this._getSelectedAttr();
		if(!selectedNode){
			this.selectLastNode();
		}else{
			var prev = selectedNode.previousSibling;
			while(prev && prev.style.display == "none"){
				prev = prev.previousSibling;
			}
			if(!prev){
				this.selectLastNode();
			}else{
				this._setSelectedAttr(prev);
			}
		}
	},

	_setSelectedAttr: function(/*DomNode*/ node){
		// summary:
		//		Does the actual select.
		if(this.selected != node){
			var selectedNode = this._getSelectedAttr();
			if(selectedNode){
				this.onDeselect(selectedNode);
				this.selected = null;
			}
			if(node && node.parentNode == this.containerNode){
				this.selected = node;
				winUtils.scrollIntoView(node);
				this.onSelect(node);
			}
		}else if(node){
			this.onSelect(node);
		}
	},

	_getSelectedAttr: function(){
		// summary:
		//		Returns the selected node.
		var v = this.selected;
		return (v && v.parentNode == this.containerNode) ? v : (this.selected = null);
	}
});

});

},
'dijit/form/_FormWidget':function(){
define("dijit/form/_FormWidget", [
	"dojo/_base/declare",	// declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/ready",
	"../_Widget",
	"../_CssStateMixin",
	"../_TemplatedMixin",
	"./_FormWidgetMixin"
], function(declare, kernel, ready, _Widget, _CssStateMixin, _TemplatedMixin, _FormWidgetMixin){

/*=====
var _Widget = dijit._Widget;
var _TemplatedMixin = dijit._TemplatedMixin;
var _CssStateMixin = dijit._CssStateMixin;
var _FormWidgetMixin = dijit.form._FormWidgetMixin;
=====*/

// module:
//		dijit/form/_FormWidget
// summary:
//		FormWidget


// Back compat w/1.6, remove for 2.0
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/form/_FormValueWidget"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

return declare("dijit.form._FormWidget", [_Widget, _TemplatedMixin, _CssStateMixin, _FormWidgetMixin], {
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <checkbox> or <button>,
	//		which can be children of a <form> node or a `dijit.form.Form` widget.
	//
	// description:
	//		Represents a single HTML element.
	//		All these widgets should have these attributes just like native HTML input elements.
	//		You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	//
	//		They also share some common methods.

	setDisabled: function(/*Boolean*/ disabled){
		// summary:
		//		Deprecated.  Use set('disabled', ...) instead.
		kernel.deprecated("setDisabled("+disabled+") is deprecated. Use set('disabled',"+disabled+") instead.", "", "2.0");
		this.set('disabled', disabled);
	},

	setValue: function(/*String*/ value){
		// summary:
		//		Deprecated.  Use set('value', ...) instead.
		kernel.deprecated("dijit.form._FormWidget:setValue("+value+") is deprecated.  Use set('value',"+value+") instead.", "", "2.0");
		this.set('value', value);
	},

	getValue: function(){
		// summary:
		//		Deprecated.  Use get('value') instead.
		kernel.deprecated(this.declaredClass+"::getValue() is deprecated. Use get('value') instead.", "", "2.0");
		return this.get('value');
	},

	postMixInProperties: function(){
		// Setup name=foo string to be referenced from the template (but only if a name has been specified)
		// Unfortunately we can't use _setNameAttr to set the name due to IE limitations, see #8484, #8660.
		// Regarding escaping, see heading "Attribute values" in
		// http://www.w3.org/TR/REC-html40/appendix/notes.html#h-B.3.2
		this.nameAttrSetting = this.name ? ('name="' + this.name.replace(/'/g, "&quot;") + '"') : '';
		this.inherited(arguments);
	},

	// Override automatic assigning type --> focusNode, it causes exception on IE.
	// Instead, type must be specified as ${type} in the template, as part of the original DOM
	_setTypeAttr: null
});

});

},
'dojo/DeferredList':function(){
define("dojo/DeferredList", ["./_base/kernel", "./_base/Deferred", "./_base/array"], function(dojo, Deferred, darray) {
	// module:
	//		dojo/DeferredList
	// summary:
	//		TODOC


dojo.DeferredList = function(/*Array*/ list, /*Boolean?*/ fireOnOneCallback, /*Boolean?*/ fireOnOneErrback, /*Boolean?*/ consumeErrors, /*Function?*/ canceller){
	// summary:
	//		Provides event handling for a group of Deferred objects.
	// description:
	//		DeferredList takes an array of existing deferreds and returns a new deferred of its own
	//		this new deferred will typically have its callback fired when all of the deferreds in
	//		the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	//		fireOnOneErrback, will fire before all the deferreds as appropriate
	//
	// list:
	//		The list of deferreds to be synchronizied with this DeferredList
	// fireOnOneCallback:
	//		Will cause the DeferredLists callback to be fired as soon as any
	//		of the deferreds in its list have been fired instead of waiting until
	//		the entire list has finished
	// fireonOneErrback:
	//		Will cause the errback to fire upon any of the deferreds errback
	// canceller:
	//		A deferred canceller function, see dojo.Deferred
	var resultList = [];
	Deferred.call(this);
	var self = this;
	if(list.length === 0 && !fireOnOneCallback){
		this.resolve([0, []]);
	}
	var finished = 0;
	darray.forEach(list, function(item, i){
		item.then(function(result){
			if(fireOnOneCallback){
				self.resolve([i, result]);
			}else{
				addResult(true, result);
			}
		},function(error){
			if(fireOnOneErrback){
				self.reject(error);
			}else{
				addResult(false, error);
			}
			if(consumeErrors){
				return null;
			}
			throw error;
		});
		function addResult(succeeded, result){
			resultList[i] = [succeeded, result];
			finished++;
			if(finished === list.length){
				self.resolve(resultList);
			}

		}
	});
};
dojo.DeferredList.prototype = new Deferred();

dojo.DeferredList.prototype.gatherResults = function(deferredList){
	// summary:
	//		Gathers the results of the deferreds for packaging
	//		as the parameters to the Deferred Lists' callback
	// deferredList: dojo.DeferredList
	//		The deferred list from which this function gathers results.
	// returns: dojo.DeferredList
	//		The newly created deferred list which packs results as
	//		parameters to its callback.

	var d = new dojo.DeferredList(deferredList, false, true, false);
	d.addCallback(function(results){
		var ret = [];
		darray.forEach(results, function(result){
			ret.push(result[1]);
		});
		return ret;
	});
	return d;
};

return dojo.DeferredList;
});

},
'dojo/dnd/common':function(){
define("dojo/dnd/common", ["../main"], function(dojo) {
	// module:
	//		dojo/dnd/common
	// summary:
	//		TODOC

dojo.getObject("dnd", true, dojo);

dojo.dnd.getCopyKeyState = dojo.isCopyKey;

dojo.dnd._uniqueId = 0;
dojo.dnd.getUniqueId = function(){
	// summary:
	//		returns a unique string for use with any DOM element
	var id;
	do{
		id = dojo._scopeName + "Unique" + (++dojo.dnd._uniqueId);
	}while(dojo.byId(id));
	return id;
};

dojo.dnd._empty = {};

dojo.dnd.isFormElement = function(/*Event*/ e){
	// summary:
	//		returns true if user clicked on a form element
	var t = e.target;
	if(t.nodeType == 3 /*TEXT_NODE*/){
		t = t.parentNode;
	}
	return " button textarea input select option ".indexOf(" " + t.tagName.toLowerCase() + " ") >= 0;	// Boolean
};

return dojo.dnd;
});

},
'ibm/tivoli/simplesrm/srm/dijit/OpenHelp':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");

/**
 * groups methods/queries responsible for providing help 
 */

dojo.declare(
		"ibm.tivoli.simplesrm.srm.dijit.OpenHelp",
		null,
{		
				
		/**retrieves url to help topic that maps to given helpKey
		after successful retrieval callback "action(url)" is launched
		@param {String} helpKey	or {Array} containing more params  
		@param {Callback} action
		@see ibm.tivoli.simplesrm.srm.dijit.MessageDialog
		@type {void}	
		*/	
		_help:function(helpKey , action){			
			console.log("_help called");
			var params={};
			if(dojo.isString(helpKey)){
				dojo.mixin(params,{helpKey: helpKey});
			}
			else if (dojo.isArray(helpKey)){
				//assume that array contains valid parameters
				dojo.forEach(helpKey, function(x){
					dojo.mixin(params,x);
				});
			}
			var helpUrl;
			var deferred = dojo.xhrGet({
				url: "/help/index.jsp?topic=/com.ibm.mbs.doc/startcntr/c_start_center_overview.html",
            //url: "/maximohelp/en/mergedProjects/startcntr/startcntr.htm",
				content: params,
				handleAs: "text",
				load: function(response){					
					if(response){
						helpUrl = response;
					}
					else{
						console.log("invalid result");
						return new Error();
					}
				},
				error: function(error){
					console.log("xhrGet failed: " + error.message);					
				}
			}
			);	
					
			deferred.addCallback(function(){								
				action(helpUrl);						
			});
			deferred.addErrback(this._errorRetrievingUrl);
								
		},
		
		/**
		 * callback: sets href attribute of given link to the
		 * infocenter home page
		 * @param {DOMNode} link  
		 * @type {void}
		 */
		addInfocenterUrl: function(link){
			var action = function(link,url){
				dojo.attr(link , "href" , url);
			};
			this._help("PMRDP_UI_Help.htm",dojo.hitch(null, action, link));
		},	
		/**
		 * callback: opens new window
		 * @param {String} helpKey or {Array}
		 * @type {void}
		 */
		openHelpWindow: function(helpKey){
			var action = function(url){
				window.open(url);
			};
			this._help(helpKey , action);
		},

		/**
		 * extension point. error callback. 
		 * default action: do nothing
		 * @type {void}
		 */ 
		_errorRetrievingUrl: function(){				
			//default == no action	
			console.log("error retrieving help url");
		}
		
		});
});

},
'dojox/grid/_Events':function(){
define("dojox/grid/_Events", [
	"dojo/keys",
	"dojo/dom-class",
	"dojo/_base/declare",
	"dojo/_base/event",
	"dojo/_base/sniff"
], function(keys, domClass, declare, event, has){

return declare("dojox.grid._Events", null, {
	// summary:
	//		_Grid mixin that provides default implementations for grid events.
	// description:
	//		Default synthetic events dispatched for _Grid. dojo.connect to events to
	//		retain default implementation or override them for custom handling.
	
	// cellOverClass: String
	// 		css class to apply to grid cells over which the cursor is placed.
	cellOverClass: "dojoxGridCellOver",
	
	onKeyEvent: function(e){
		// summary: top level handler for Key Events
		this.dispatchKeyEvent(e);
	},

	onContentEvent: function(e){
		// summary: Top level handler for Content events
		this.dispatchContentEvent(e);
	},

	onHeaderEvent: function(e){
		// summary: Top level handler for header events
		this.dispatchHeaderEvent(e);
	},

	onStyleRow: function(inRow){
		// summary:
		//		Perform row styling on a given row. Called whenever row styling is updated.
		//
		// inRow: Object
		// 		Object containing row state information: selected, true if the row is selcted; over:
		// 		true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
		// 		customStyles to control row css classes and styles; both properties are strings.
		//
		// example: onStyleRow({ selected: true, over:true, odd:false })
		var i = inRow;
		i.customClasses += (i.odd?" dojoxGridRowOdd":"") + (i.selected?" dojoxGridRowSelected":"") + (i.over?" dojoxGridRowOver":"");
		this.focus.styleRow(inRow);
		this.edit.styleRow(inRow);
	},
	
	onKeyDown: function(e){
		// summary:
		// 		Grid key event handler. By default enter begins editing and applies edits, escape cancels an edit,
		// 		tab, shift-tab, and arrow keys move grid cell focus.
		if(e.altKey || e.metaKey){
			return;
		}
		var colIdx;
		switch(e.keyCode){
			case keys.ESCAPE:
				this.edit.cancel();
				break;
			case keys.ENTER:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					event.stop(e);
				}
				if(!e.shiftKey){
					var isEditing = this.edit.isEditing();
					this.edit.apply();
					if(!isEditing){
						this.edit.setEditCell(this.focus.cell, this.focus.rowIndex);
					}
				}
				if (!this.edit.isEditing()){
					var curView = this.focus.focusView || this.views.views[0];  //if no focusView than only one view
					curView.content.decorateEvent(e);
					this.onRowClick(e);
					event.stop(e);
				}
				break;
			case keys.SPACE:
				if(!this.edit.isEditing()){
					colIdx = this.focus.getHeaderIndex();
					if(colIdx >= 0) {
						this.setSortIndex(colIdx);
						break;
					}else {
						this.selection.clickSelect(this.focus.rowIndex, dojo.isCopyKey(e), e.shiftKey);
					}
					event.stop(e);
				}
				break;
			case keys.TAB:
				this.focus[e.shiftKey ? 'previousKey' : 'nextKey'](e);
				break;
			case keys.LEFT_ARROW:
			case keys.RIGHT_ARROW:
				if(!this.edit.isEditing()){
					var keyCode = e.keyCode;  // IE seems to lose after stopEvent when modifier keys
					event.stop(e);
					colIdx = this.focus.getHeaderIndex();
					if (colIdx >= 0 && (e.shiftKey && e.ctrlKey)){
						this.focus.colSizeAdjust(e, colIdx, (keyCode == keys.LEFT_ARROW ? -1 : 1)*5);
					}
					else{
						var offset = (keyCode == keys.LEFT_ARROW) ? 1 : -1;
						if(this.isLeftToRight()){ offset *= -1; }
						this.focus.move(0, offset);
					}
				}
				break;
			case keys.UP_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					event.stop(e);
					this.focus.move(-1, 0);
				}
				break;
			case keys.DOWN_ARROW:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					event.stop(e);
					this.focus.move(1, 0);
				}
				break;
			case keys.PAGE_UP:
				if(!this.edit.isEditing() && this.focus.rowIndex !== 0){
					event.stop(e);
					if(this.focus.rowIndex != this.scroller.firstVisibleRow+1){
						this.focus.move(this.scroller.firstVisibleRow-this.focus.rowIndex, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex-1));
						this.focus.move(this.scroller.firstVisibleRow-this.scroller.lastVisibleRow+1, 0);
					}
				}
				break;
			case keys.PAGE_DOWN:
				if(!this.edit.isEditing() && this.focus.rowIndex+1 != this.rowCount){
					event.stop(e);
					if(this.focus.rowIndex != this.scroller.lastVisibleRow-1){
						this.focus.move(this.scroller.lastVisibleRow-this.focus.rowIndex-1, 0);
					}else{
						this.setScrollTop(this.scroller.findScrollTop(this.focus.rowIndex+1));
						this.focus.move(this.scroller.lastVisibleRow-this.scroller.firstVisibleRow-1, 0);
					}
				}
				break;
			default:
				break;
		}
	},
	
	onMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over the grid.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOver(e) : this.onCellMouseOver(e);
	},
	
	onMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseOut(e) : this.onCellMouseOut(e);
	},
	
	onMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down inside grid.
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		e.rowIndex == -1 ? this.onHeaderCellMouseDown(e) : this.onCellMouseDown(e);
	},
	
	onMouseOverRow: function(e){
		// summary:
		//		Event fired when mouse is over any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(!this.rows.isOver(e.rowIndex)){
			this.rows.setOverRow(e.rowIndex);
			e.rowIndex == -1 ? this.onHeaderMouseOver(e) : this.onRowMouseOver(e);
		}
	},
	onMouseOutRow: function(e){
		// summary:
		//		Event fired when mouse moves out of any row (data or header).
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(this.rows.isOver(-1)){
			this.onHeaderMouseOut(e);
		}else if(!this.rows.isOver(-2)){
			this.rows.setOverRow(-2);
			this.onRowMouseOut(e);
		}
	},
	
	onMouseDownRow: function(e){
		// summary:
		//		Event fired when mouse is down inside grid row
		// e: Event
		//		Decorated event object that contains reference to grid, cell, and rowIndex
		if(e.rowIndex != -1)
			this.onRowMouseDown(e);
	},

	// cell events
	onCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse is over a cell.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.add(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a cell.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.remove(e.cellNode, this.cellOverClass);
		}
	},
	
	onCellMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onCellClick: function(e){
		// summary:
		//		Event fired when a cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this._click[0] = this._click[1];
		this._click[1] = e;
		if(!this.edit.isEditCell(e.rowIndex, e.cellIndex)){
			this.focus.setFocusCell(e.cell, e.rowIndex);
		}
		// in some cases click[0] is null which causes false doubeClicks. Fixes #100703
		if(this._click.length > 1 && this._click[0] == null){
			this._click.shift();
		}
		this.onRowClick(e);
	},

	onCellDblClick: function(e){
		// summary:
		//		Event fired when a cell is double-clicked.
		// e: Event
		//		Decorated event object contains reference to grid, cell, and rowIndex
		var event;
		if(this._click.length > 1 && has("ie")){
			event = this._click[1];
		}else if(this._click.length > 1 && this._click[0].rowIndex != this._click[1].rowIndex){
			event = this._click[0];
		}else{
			event = e;
		}
		this.focus.setFocusCell(event.cell, event.rowIndex);
		this.onRowClick(event);
		this.edit.setEditCell(event.cell, event.rowIndex);
		this.onRowDblClick(e);
	},

	onCellContextMenu: function(e){
		// summary:
		//		Event fired when a cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onRowContextMenu(e);
	},

	onCellFocus: function(inCell, inRowIndex){
		// summary:
		//		Event fired when a cell receives focus.
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
		this.edit.cellFocus(inCell, inRowIndex);
	},

	// row events
	onRowClick: function(e){
		// summary:
		//		Event fired when a row is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.edit.rowClick(e);
		this.selection.clickSelectEvent(e);
	},

	onRowDblClick: function(e){
		// summary:
		//		Event fired when a row is double clicked.
		// e: Event
		//		decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a data row.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a data row.
		// e: Event
		// 		Decorated event object contains reference to grid, cell, and rowIndex
	},
	
	onRowMouseDown: function(e){
		// summary:
		//		Event fired when mouse is down in a row.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onRowContextMenu: function(e){
		// summary:
		//		Event fired when a row context menu is accessed via mouse right click.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		event.stop(e);
	},

	// header events
	onHeaderMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over the grid header.
		// e: Event
		// 		Decorated event object contains reference to grid, cell, and rowIndex
	},

	onHeaderMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of the grid header.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellMouseOver: function(e){
		// summary:
		//		Event fired when mouse moves over a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.add(e.cellNode, this.cellOverClass);
		}
	},

	onHeaderCellMouseOut: function(e){
		// summary:
		//		Event fired when mouse moves out of a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
		if(e.cellNode){
			domClass.remove(e.cellNode, this.cellOverClass);
		}
	},
	
	onHeaderCellMouseDown: function(e) {
		// summary:
		//		Event fired when mouse is down in a header cell.
		// e: Event
		// 		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderClick: function(e){
		// summary:
		//		Event fired when the grid header is clicked.
		// e: Event
		// Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellClick: function(e){
		// summary:
		//		Event fired when a header cell is clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.setSortIndex(e.cell.index);
		this.onHeaderClick(e);
	},

	onHeaderDblClick: function(e){
		// summary:
		//		Event fired when the grid header is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
	},

	onHeaderCellDblClick: function(e){
		// summary:
		//		Event fired when a header cell is double clicked.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderDblClick(e);
	},

	onHeaderCellContextMenu: function(e){
		// summary:
		//		Event fired when a header cell context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		this.onHeaderContextMenu(e);
	},

	onHeaderContextMenu: function(e){
		// summary:
		//		Event fired when the grid header context menu is accessed via mouse right click.
		// e: Event
		//		Decorated event object which contains reference to grid, cell, and rowIndex
		if(!this.headerMenu){
			event.stop(e);
		}
	},

	// editing
	onStartEdit: function(inCell, inRowIndex){
		// summary:
		//		Event fired when editing is started for a given grid cell
		// inCell: Object
		//		Cell object containing properties of the grid column.
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyCellEdit: function(inValue, inRowIndex, inFieldIndex){
		// summary:
		//		Event fired when editing is applied for a given grid cell
		// inValue: String
		//		Value from cell editor
		// inRowIndex: Integer
		//		Index of the grid row
		// inFieldIndex: Integer
		//		Index in the grid's data store
	},

	onCancelEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is cancelled for a given grid cell
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onApplyEdit: function(inRowIndex){
		// summary:
		//		Event fired when editing is applied for a given grid row
		// inRowIndex: Integer
		//		Index of the grid row
	},

	onCanSelect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be selected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be selected
		return true;
	},

	onCanDeselect: function(inRowIndex){
		// summary:
		//		Event to determine if a grid row may be deselected
		// inRowIndex: Integer
		//		Index of the grid row
		// returns: Boolean
		//		true if the row can be deselected
		return true;
	},

	onSelected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is selected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onDeselected: function(inRowIndex){
		// summary:
		//		Event fired when a grid row is deselected
		// inRowIndex: Integer
		//		Index of the grid row
		this.updateRowStyles(inRowIndex);
	},

	onSelectionChanged: function(){
	}
});
});
},
'dijit/CheckedMenuItem':function(){
require({cache:{
'url:dijit/templates/CheckedMenuItem.html':"<tr class=\"dijitReset dijitMenuItem\" data-dojo-attach-point=\"focusNode\" role=\"menuitemcheckbox\" tabIndex=\"-1\"\n\t\tdata-dojo-attach-event=\"onmouseenter:_onHover,onmouseleave:_onUnhover,ondijitclick:_onClick\">\n\t<td class=\"dijitReset dijitMenuItemIconCell\" role=\"presentation\">\n\t\t<img src=\"${_blankGif}\" alt=\"\" class=\"dijitMenuItemIcon dijitCheckedMenuItemIcon\" data-dojo-attach-point=\"iconNode\"/>\n\t\t<span class=\"dijitCheckedMenuItemIconChar\">&#10003;</span>\n\t</td>\n\t<td class=\"dijitReset dijitMenuItemLabel\" colspan=\"2\" data-dojo-attach-point=\"containerNode,labelNode\"></td>\n\t<td class=\"dijitReset dijitMenuItemAccelKey\" style=\"display: none\" data-dojo-attach-point=\"accelKeyNode\"></td>\n\t<td class=\"dijitReset dijitMenuArrowCell\" role=\"presentation\">&#160;</td>\n</tr>\n"}});
define("dijit/CheckedMenuItem", [
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.toggle
	"./MenuItem",
	"dojo/text!./templates/CheckedMenuItem.html",
	"./hccss"
], function(declare, domClass, MenuItem, template){

/*=====
	var MenuItem = dijit.MenuItem;
=====*/

	// module:
	//		dijit/CheckedMenuItem
	// summary:
	//		A checkbox-like menu item for toggling on and off

	return declare("dijit.CheckedMenuItem", MenuItem, {
		// summary:
		//		A checkbox-like menu item for toggling on and off

		templateString: template,

		// checked: Boolean
		//		Our checked state
		checked: false,
		_setCheckedAttr: function(/*Boolean*/ checked){
			// summary:
			//		Hook so attr('checked', bool) works.
			//		Sets the class and state for the check box.
			domClass.toggle(this.domNode, "dijitCheckedMenuItemChecked", checked);
			this.domNode.setAttribute("aria-checked", checked);
			this._set("checked", checked);
		},

		iconClass: "",	// override dijitNoIcon

		onChange: function(/*Boolean*/ /*===== checked =====*/){
			// summary:
			//		User defined function to handle check/uncheck events
			// tags:
			//		callback
		},

		_onClick: function(/*Event*/ e){
			// summary:
			//		Clicking this item just toggles its state
			// tags:
			//		private
			if(!this.disabled){
				this.set("checked", !this.checked);
				this.onChange(this.checked);
			}
			this.inherited(arguments);
		}
	});
});

},
'dijit/_base/place':function(){
define("dijit/_base/place", [
	"dojo/_base/array", // array.forEach
	"dojo/_base/lang", // lang.isArray
	"dojo/window", // windowUtils.getBox
	"../place",
	".."	// export to dijit namespace
], function(array, lang, windowUtils, place, dijit){

	// module:
	//		dijit/_base/place
	// summary:
	//		Back compatibility module, new code should use dijit/place directly instead of using this module.

	dijit.getViewport = function(){
		// summary:
		//		Deprecated method to return the dimensions and scroll position of the viewable area of a browser window.
		//		New code should use windowUtils.getBox()

		return windowUtils.getBox();
	};

	/*=====
	dijit.placeOnScreen = function(node, pos, corners, padding){
		// summary:
		//		Positions one of the node's corners at specified position
		//		such that node is fully visible in viewport.
		//		Deprecated, new code should use dijit.place.at() instead.
	};
	=====*/
	dijit.placeOnScreen = place.at;

	/*=====
	dijit.placeOnScreenAroundElement = function(node, aroundElement, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
		//		for the "around" argument and finds a proper processor to place a node.
		//		Deprecated, new code should use dijit.place.around() instead.
	};
	====*/
	dijit.placeOnScreenAroundElement = function(node, aroundNode, aroundCorners, layoutNode){
		// Convert old style {"BL": "TL", "BR": "TR"} type argument
		// to style needed by dijit.place code:
		//		[
		// 			{aroundCorner: "BL", corner: "TL" },
		//			{aroundCorner: "BR", corner: "TR" }
		//		]
		var positions;
		if(lang.isArray(aroundCorners)){
			positions = aroundCorners;
		}else{
			positions = [];
			for(var key in aroundCorners){
				positions.push({aroundCorner: key, corner: aroundCorners[key]});
			}
		}

		return place.around(node, aroundNode, positions, true, layoutNode);
	};

	/*=====
	dijit.placeOnScreenAroundNode = function(node, aroundNode, aroundCorners, layoutNode){
		// summary:
		//		Position node adjacent or kitty-corner to aroundNode
		//		such that it's fully visible in viewport.
		//		Deprecated, new code should use dijit.place.around() instead.
	};
	=====*/
	dijit.placeOnScreenAroundNode = dijit.placeOnScreenAroundElement;

	/*=====
	dijit.placeOnScreenAroundRectangle = function(node, aroundRect, aroundCorners, layoutNode){
		// summary:
		//		Like dijit.placeOnScreenAroundNode(), except that the "around"
		//		parameter is an arbitrary rectangle on the screen (x, y, width, height)
		//		instead of a dom node.
		//		Deprecated, new code should use dijit.place.around() instead.
	};
	=====*/
	dijit.placeOnScreenAroundRectangle = dijit.placeOnScreenAroundElement;

	dijit.getPopupAroundAlignment = function(/*Array*/ position, /*Boolean*/ leftToRight){
		// summary:
		//		Deprecated method, unneeded when using dijit/place directly.
		//		Transforms the passed array of preferred positions into a format suitable for
		//		passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.
		//
		// position: String[]
		//		This variable controls the position of the drop down.
		//		It's an array of strings with the following values:
		//
		//			* before: places drop down to the left of the target node/widget, or to the right in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* after: places drop down to the right of the target node/widget, or to the left in
		//			  the case of RTL scripts like Hebrew and Arabic
		//			* above: drop down goes above target node
		//			* below: drop down goes below target node
		//
		//		The list is positions is tried, in order, until a position is found where the drop down fits
		//		within the viewport.
		//
		// leftToRight: Boolean
		//		Whether the popup will be displaying in leftToRight mode.
		//
		var align = {};
		array.forEach(position, function(pos){
			var ltr = leftToRight;
			switch(pos){
				case "after":
					align[leftToRight ? "BR" : "BL"] = leftToRight ? "BL" : "BR";
					break;
				case "before":
					align[leftToRight ? "BL" : "BR"] = leftToRight ? "BR" : "BL";
					break;
				case "below-alt":
					ltr = !ltr;
					// fall through
				case "below":
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "BL" : "BR"] = ltr ? "TL" : "TR";
					align[ltr ? "BR" : "BL"] = ltr ? "TR" : "TL";
					break;
				case "above-alt":
					ltr = !ltr;
					// fall through
				case "above":
				default:
					// first try to align left borders, next try to align right borders (or reverse for RTL mode)
					align[ltr ? "TL" : "TR"] = ltr ? "BL" : "BR";
					align[ltr ? "TR" : "TL"] = ltr ? "BR" : "BL";
					break;
			}
		});
		return align;
	};

	return dijit;
});

},
'dojox/grid/util':function(){
define("dojox/grid/util", [
	"../main",
	"dojo/_base/lang",
	"dojo/dom"
], function(dojox, lang, dom){

// summary: grid utility library
	var dgu = lang.getObject("grid.util", true, dojox);

	dgu.na = '...';
	dgu.rowIndexTag = "gridRowIndex";
	dgu.gridViewTag = "gridView";


	dgu.fire = function(ob, ev, args){
		var fn = ob && ev && ob[ev];
		return fn && (args ? fn.apply(ob, args) : ob[ev]());
	};
	
	dgu.setStyleHeightPx = function(inElement, inHeight){
		if(inHeight >= 0){
			var s = inElement.style;
			var v = inHeight + 'px';
			if(inElement && s['height'] != v){
				s['height'] = v;
			}
		}
	};
	
	dgu.mouseEvents = [ 'mouseover', 'mouseout', /*'mousemove',*/ 'mousedown', 'mouseup', 'click', 'dblclick', 'contextmenu' ];

	dgu.keyEvents = [ 'keyup', 'keydown', 'keypress' ];

	dgu.funnelEvents = function(inNode, inObject, inMethod, inEvents){
		var evts = (inEvents ? inEvents : dgu.mouseEvents.concat(dgu.keyEvents));
		for (var i=0, l=evts.length; i<l; i++){
			inObject.connect(inNode, 'on' + evts[i], inMethod);
		}
	};

	dgu.removeNode = function(inNode){
		inNode = dom.byId(inNode);
		inNode && inNode.parentNode && inNode.parentNode.removeChild(inNode);
		return inNode;
	};
	
	dgu.arrayCompare = function(inA, inB){
		for(var i=0,l=inA.length; i<l; i++){
			if(inA[i] != inB[i]){return false;}
		}
		return (inA.length == inB.length);
	};
	
	dgu.arrayInsert = function(inArray, inIndex, inValue){
		if(inArray.length <= inIndex){
			inArray[inIndex] = inValue;
		}else{
			inArray.splice(inIndex, 0, inValue);
		}
	};
	
	dgu.arrayRemove = function(inArray, inIndex){
		inArray.splice(inIndex, 1);
	};
	
	dgu.arraySwap = function(inArray, inI, inJ){
		var cache = inArray[inI];
		inArray[inI] = inArray[inJ];
		inArray[inJ] = cache;
	};

	return dojox.grid.util;

});
},
'dijit/form/_ComboBoxMenu':function(){
define("dijit/form/_ComboBoxMenu", [
	"dojo/_base/declare", // declare
	"dojo/dom-class", // domClass.add domClass.remove
	"dojo/dom-construct", // domConstruct.create
	"dojo/dom-style", // domStyle.get
	"dojo/keys", // keys.DOWN_ARROW keys.PAGE_DOWN keys.PAGE_UP keys.UP_ARROW
	"../_WidgetBase",
	"../_TemplatedMixin",
	"./_ComboBoxMenuMixin",
	"./_ListMouseMixin"
], function(declare, domClass, domConstruct, domStyle, keys,
			_WidgetBase, _TemplatedMixin, _ComboBoxMenuMixin, _ListMouseMixin){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _ComboBoxMenuMixin = dijit.form._ComboBoxMenuMixin;
	var _ListMouseMixin = dijit.form._ListMouseMixin;
=====*/

	// module:
	//		dijit/form/_ComboBoxMenu
	// summary:
	//		Focus-less menu for internal use in `dijit.form.ComboBox`

	return declare("dijit.form._ComboBoxMenu",[_WidgetBase, _TemplatedMixin, _ListMouseMixin, _ComboBoxMenuMixin], {
		// summary:
		//		Focus-less menu for internal use in `dijit.form.ComboBox`
		//              Abstract methods that must be defined externally:
		//                      onChange: item was explicitly chosen (mousedown somewhere on the menu and mouseup somewhere on the menu)
		//                      onPage: next(1) or previous(-1) button pressed
		// tags:
		//		private

		templateString: "<div class='dijitReset dijitMenu' data-dojo-attach-point='containerNode' style='overflow: auto; overflow-x: hidden;'>"
				+"<div class='dijitMenuItem dijitMenuPreviousButton' data-dojo-attach-point='previousButton' role='option'></div>"
				+"<div class='dijitMenuItem dijitMenuNextButton' data-dojo-attach-point='nextButton' role='option'></div>"
				+"</div>",

		baseClass: "dijitComboBoxMenu",

		_createMenuItem: function(){
			return domConstruct.create("div", {
				"class": "dijitReset dijitMenuItem" +(this.isLeftToRight() ? "" : " dijitMenuItemRtl"),
				role: "option"
			});
		},

		onHover: function(/*DomNode*/ node){
			// summary:
			//		Add hover CSS
			domClass.add(node, "dijitMenuItemHover");
		},

		onUnhover: function(/*DomNode*/ node){
			// summary:
			//		Remove hover CSS
			domClass.remove(node, "dijitMenuItemHover");
		},

		onSelect: function(/*DomNode*/ node){
			// summary:
			//		Add selected CSS
			domClass.add(node, "dijitMenuItemSelected");
		},

		onDeselect: function(/*DomNode*/ node){
			// summary:
			//		Remove selected CSS
			domClass.remove(node, "dijitMenuItemSelected");
		},

		_page: function(/*Boolean*/ up){
			// summary:
			//		Handles page-up and page-down keypresses

			var scrollamount = 0;
			var oldscroll = this.domNode.scrollTop;
			var height = domStyle.get(this.domNode, "height");
			// if no item is highlighted, highlight the first option
			if(!this.getHighlightedOption()){
				this.selectNextNode();
			}
			while(scrollamount<height){
				if(up){
					// stop at option 1
					if(!this.getHighlightedOption().previousSibling ||
						this._highlighted_option.previousSibling.style.display == "none"){
						break;
					}
					this.selectPreviousNode();
				}else{
					// stop at last option
					if(!this.getHighlightedOption().nextSibling ||
						this._highlighted_option.nextSibling.style.display == "none"){
						break;
					}
					this.selectNextNode();
				}
				// going backwards
				var newscroll=this.domNode.scrollTop;
				scrollamount+=(newscroll-oldscroll)*(up ? -1:1);
				oldscroll=newscroll;
			}
		},

		handleKey: function(evt){
			// summary:
			//		Handle keystroke event forwarded from ComboBox, returning false if it's
			//		a keystroke I recognize and process, true otherwise.
			switch(evt.charOrCode){
				case keys.DOWN_ARROW:
					this.selectNextNode();
					return false;
				case keys.PAGE_DOWN:
					this._page(false);
					return false;
				case keys.UP_ARROW:
					this.selectPreviousNode();
					return false;
				case keys.PAGE_UP:
					this._page(true);
					return false;
				default:
					return true;
			}
		}
	});
});

},
'url:dijit/layout/templates/ScrollingTabController.html':"<div class=\"dijitTabListContainer-${tabPosition}\" style=\"visibility:hidden\">\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerMenuButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_menuBtn\"\n\t\t\tdata-dojo-props=\"containerId: '${containerId}', iconClass: 'dijitTabStripMenuIcon',\n\t\t\t\t\tdropDownPosition: ['below-alt', 'above-alt']\"\n\t\t\tdata-dojo-attach-point=\"_menuBtn\" showLabel=\"false\" title=\"\">&#9660;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_leftBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideLeftIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_leftBtn\" data-dojo-attach-event=\"onClick: doSlideLeft\">&#9664;</div>\n\t<div data-dojo-type=\"dijit.layout._ScrollingTabControllerButton\"\n\t\t\tclass=\"tabStripButton-${tabPosition}\"\n\t\t\tid=\"${id}_rightBtn\"\n\t\t\tdata-dojo-props=\"iconClass:'dijitTabStripSlideRightIcon', showLabel:false, title:''\"\n\t\t\tdata-dojo-attach-point=\"_rightBtn\" data-dojo-attach-event=\"onClick: doSlideRight\">&#9654;</div>\n\t<div class='dijitTabListWrapper' data-dojo-attach-point='tablistWrapper'>\n\t\t<div role='tablist' data-dojo-attach-event='onkeypress:onkeypress'\n\t\t\t\tdata-dojo-attach-point='containerNode' class='nowrapTabStrip'></div>\n\t</div>\n</div>",
'dojox/grid/cells/_base':function(){
define("dojox/grid/cells/_base", [
	"dojo/_base/kernel",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"dojo/_base/event",
	"dojo/_base/connect",
	"dojo/_base/array",
	"dojo/_base/sniff",
	"dojo/dom",
	"dojo/dom-attr",
	"dojo/dom-construct",
	"dijit/_Widget",
	"../util"
], function(dojo, declare, lang, event, connect, array, has, dom, domAttr, domConstruct, _Widget, util){

	var _DeferredTextWidget = declare("dojox.grid._DeferredTextWidget", _Widget, {
		deferred: null,
		_destroyOnRemove: true,
		postCreate: function(){
			if(this.deferred){
				this.deferred.addBoth(lang.hitch(this, function(text){
					if(this.domNode){
						this.domNode.innerHTML = text;
					}
				}));
			}
		}
	});

	var focusSelectNode = function(inNode){
		try{
			util.fire(inNode, "focus");
			util.fire(inNode, "select");
		}catch(e){// IE sux bad
		}
	};
	
	var whenIdle = function(/*inContext, inMethod, args ...*/){
		setTimeout(lang.hitch.apply(dojo, arguments), 0);
	};

	var BaseCell = declare("dojox.grid.cells._Base", null, {
		// summary:
		//	Respresents a grid cell and contains information about column options and methods
		//	for retrieving cell related information.
		//	Each column in a grid layout has a cell object and most events and many methods
		//	provide access to these objects.
		styles: '',
		classes: '',
		editable: false,
		alwaysEditing: false,
		formatter: null,
		defaultValue: '...',
		value: null,
		hidden: false,
		noresize: false,
		draggable: true,
		//private
		_valueProp: "value",
		_formatPending: false,

		constructor: function(inProps){
			this._props = inProps || {};
			lang.mixin(this, inProps);
			if(this.draggable === undefined){
				this.draggable = true;
			}
		},

		_defaultFormat: function(inValue, callArgs){
			var s = this.grid.formatterScope || this;
			var f = this.formatter;
			if(f && s && typeof f == "string"){
				f = this.formatter = s[f];
			}
			var v = (inValue != this.defaultValue && f) ? f.apply(s, callArgs) : inValue;
			if(typeof v == "undefined"){
				return this.defaultValue;
			}
			if(v && v.addBoth){
				// Check if it's a deferred
				v = new _DeferredTextWidget({deferred: v},
									domConstruct.create("span", {innerHTML: this.defaultValue}));
			}
			if(v && v.declaredClass && v.startup){
				return "<div class='dojoxGridStubNode' linkWidget='" +
						v.id +
						"' cellIdx='" +
						this.index +
						"'>" +
						this.defaultValue +
						"</div>";
			}
			return v;
		},
		
		// data source
		format: function(inRowIndex, inItem){
			// summary:
			//	provides the html for a given grid cell.
			// inRowIndex: int
			// grid row index
			// returns: html for a given grid cell
			var f, i=this.grid.edit.info, d=this.get ? this.get(inRowIndex, inItem) : (this.value || this.defaultValue);
			d = (d && d.replace && this.grid.escapeHTMLInData) ? d.replace(/&/g, '&amp;').replace(/</g, '&lt;') : d;
			if(this.editable && (this.alwaysEditing || (i.rowIndex==inRowIndex && i.cell==this))){
				return this.formatEditing(d, inRowIndex);
			}else{
				return this._defaultFormat(d, [d, inRowIndex, this]);
			}
		},
		formatEditing: function(inDatum, inRowIndex){
			// summary:
			//	formats the cell for editing
			// inDatum: anything
			//	cell data to edit
			// inRowIndex: int
			//	grid row index
			// returns: string of html to place in grid cell
		},
		// utility
		getNode: function(inRowIndex){
			// summary:
			//	gets the dom node for a given grid cell.
			// inRowIndex: int
			// grid row index
			// returns: dom node for a given grid cell
			return this.view.getCellNode(inRowIndex, this.index);
		},
		getHeaderNode: function(){
			return this.view.getHeaderCellNode(this.index);
		},
		getEditNode: function(inRowIndex){
			return (this.getNode(inRowIndex) || 0).firstChild || 0;
		},
		canResize: function(){
			var uw = this.unitWidth;
			return uw && (uw!=='auto');
		},
		isFlex: function(){
			var uw = this.unitWidth;
			return uw && lang.isString(uw) && (uw=='auto' || uw.slice(-1)=='%');
		},
		// edit support
		applyEdit: function(inValue, inRowIndex){
			this.grid.edit.applyCellEdit(inValue, this, inRowIndex);
		},
		cancelEdit: function(inRowIndex){
			this.grid.doCancelEdit(inRowIndex);
		},
		_onEditBlur: function(inRowIndex){
			if(this.grid.edit.isEditCell(inRowIndex, this.index)){
				//console.log('editor onblur', e);
				this.grid.edit.apply();
			}
		},
		registerOnBlur: function(inNode, inRowIndex){
			if(this.commitOnBlur){
				connect.connect(inNode, "onblur", function(e){
					// hack: if editor still thinks this editor is current some ms after it blurs, assume we've focused away from grid
					setTimeout(lang.hitch(this, "_onEditBlur", inRowIndex), 250);
				});
			}
		},
		//protected
		needFormatNode: function(inDatum, inRowIndex){
			this._formatPending = true;
			whenIdle(this, "_formatNode", inDatum, inRowIndex);
		},
		cancelFormatNode: function(){
			this._formatPending = false;
		},
		//private
		_formatNode: function(inDatum, inRowIndex){
			if(this._formatPending){
				this._formatPending = false;
				// make cell selectable
				if(!has("ie")){
					dom.setSelectable(this.grid.domNode, true);
				}
				this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
			}
		},
		//protected
		formatNode: function(inNode, inDatum, inRowIndex){
			// summary:
			//	format the editing dom node. Use when editor is a widget.
			// inNode: dom node
			// dom node for the editor
			// inDatum: anything
			//	cell data to edit
			// inRowIndex: int
			//	grid row index
			if(has("ie")){
				// IE sux bad
				whenIdle(this, "focus", inRowIndex, inNode);
			}else{
				this.focus(inRowIndex, inNode);
			}
		},
		dispatchEvent: function(m, e){
			if(m in this){
				return this[m](e);
			}
		},
		//public
		getValue: function(inRowIndex){
			// summary:
			//	returns value entered into editor
			// inRowIndex: int
			// grid row index
			// returns:
			//	value of editor
			return this.getEditNode(inRowIndex)[this._valueProp];
		},
		setValue: function(inRowIndex, inValue){
			// summary:
			//	set the value of the grid editor
			// inRowIndex: int
			// grid row index
			// inValue: anything
			//	value of editor
			var n = this.getEditNode(inRowIndex);
			if(n){
				n[this._valueProp] = inValue;
			}
		},
		focus: function(inRowIndex, inNode){
			// summary:
			//	focus the grid editor
			// inRowIndex: int
			// grid row index
			// inNode: dom node
			//	editor node
			focusSelectNode(inNode || this.getEditNode(inRowIndex));
		},
		save: function(inRowIndex){
			// summary:
			//	save editor state
			// inRowIndex: int
			// grid row index
			this.value = this.value || this.getValue(inRowIndex);
			//console.log("save", this.value, inCell.index, inRowIndex);
		},
		restore: function(inRowIndex){
			// summary:
			//	restore editor state
			// inRowIndex: int
			// grid row index
			this.setValue(inRowIndex, this.value);
			//console.log("restore", this.value, inCell.index, inRowIndex);
		},
		//protected
		_finish: function(inRowIndex){
			// summary:
			//	called when editing is completed to clean up editor
			// inRowIndex: int
			// grid row index
			dom.setSelectable(this.grid.domNode, false);
			this.cancelFormatNode();
		},
		//public
		apply: function(inRowIndex){
			// summary:
			//	apply edit from cell editor
			// inRowIndex: int
			// grid row index
			this.applyEdit(this.getValue(inRowIndex), inRowIndex);
			this._finish(inRowIndex);
		},
		cancel: function(inRowIndex){
			// summary:
			//	cancel cell edit
			// inRowIndex: int
			// grid row index
			this.cancelEdit(inRowIndex);
			this._finish(inRowIndex);
		}
	});
	BaseCell.markupFactory = function(node, cellDef){
		var formatter = lang.trim(domAttr.get(node, "formatter")||"");
		if(formatter){
			cellDef.formatter = lang.getObject(formatter)||formatter;
		}
		var get = lang.trim(domAttr.get(node, "get")||"");
		if(get){
			cellDef.get = lang.getObject(get);
		}
		var getBoolAttr = function(attr, cell, cellAttr){
			var value = lang.trim(domAttr.get(node, attr)||"");
			if(value){ cell[cellAttr||attr] = !(value.toLowerCase()=="false"); }
		};
		getBoolAttr("sortDesc", cellDef);
		getBoolAttr("editable", cellDef);
		getBoolAttr("alwaysEditing", cellDef);
		getBoolAttr("noresize", cellDef);
		getBoolAttr("draggable", cellDef);

		var value = lang.trim(domAttr.get(node, "loadingText")||domAttr.get(node, "defaultValue")||"");
		if(value){
			cellDef.defaultValue = value;
		}

		var getStrAttr = function(attr, cell, cellAttr){
			var value = lang.trim(domAttr.get(node, attr)||"")||undefined;
			if(value){ cell[cellAttr||attr] = value; }
		};
		getStrAttr("styles", cellDef);
		getStrAttr("headerStyles", cellDef);
		getStrAttr("cellStyles", cellDef);
		getStrAttr("classes", cellDef);
		getStrAttr("headerClasses", cellDef);
		getStrAttr("cellClasses", cellDef);
	};

	var Cell = declare("dojox.grid.cells.Cell", BaseCell, {
		// summary
		// grid cell that provides a standard text input box upon editing
		constructor: function(){
			this.keyFilter = this.keyFilter;
		},
		// keyFilter: RegExp
		//		optional regex for disallowing keypresses
		keyFilter: null,
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			return '<input class="dojoxGridInput" type="text" value="' + inDatum + '">';
		},
		formatNode: function(inNode, inDatum, inRowIndex){
			this.inherited(arguments);
			// FIXME: feels too specific for this interface
			this.registerOnBlur(inNode, inRowIndex);
		},
		doKey: function(e){
			if(this.keyFilter){
				var key = String.fromCharCode(e.charCode);
				if(key.search(this.keyFilter) == -1){
					event.stop(e);
				}
			}
		},
		_finish: function(inRowIndex){
			this.inherited(arguments);
			var n = this.getEditNode(inRowIndex);
			try{
				util.fire(n, "blur");
			}catch(e){}
		}
	});
	Cell.markupFactory = function(node, cellDef){
		BaseCell.markupFactory(node, cellDef);
		var keyFilter = lang.trim(domAttr.get(node, "keyFilter")||"");
		if(keyFilter){
			cellDef.keyFilter = new RegExp(keyFilter);
		}
	};

	var RowIndex = declare("dojox.grid.cells.RowIndex", Cell, {
		name: 'Row',

		postscript: function(){
			this.editable = false;
		},
		get: function(inRowIndex){
			return inRowIndex + 1;
		}
	});
	RowIndex.markupFactory = function(node, cellDef){
		Cell.markupFactory(node, cellDef);
	};

	var Select = declare("dojox.grid.cells.Select", Cell, {
		// summary:
		// grid cell that provides a standard select for editing

		// options: Array
		// 		text of each item
		options: null,

		// values: Array
		//		value for each item
		values: null,

		// returnIndex: Integer
		// 		editor returns only the index of the selected option and not the value
		returnIndex: -1,

		constructor: function(inCell){
			this.values = this.values || this.options;
		},
		formatEditing: function(inDatum, inRowIndex){
			this.needFormatNode(inDatum, inRowIndex);
			var h = [ '<select class="dojoxGridSelect">' ];
			for (var i=0, o, v; ((o=this.options[i]) !== undefined)&&((v=this.values[i]) !== undefined); i++){
				v = v.replace ? v.replace(/&/g, '&amp;').replace(/</g, '&lt;') : v;
				o = o.replace ? o.replace(/&/g, '&amp;').replace(/</g, '&lt;') : o;
				h.push("<option", (inDatum==v ? ' selected' : ''), ' value="' + v + '"', ">", o, "</option>");
			}
			h.push('</select>');
			return h.join('');
		},
		_defaultFormat: function(inValue, callArgs){
			var v = this.inherited(arguments);
			// when 'values' and 'options' both provided and there is no cutomized formatter,
			// then we use 'options' as label in order to be consistent
			if(!this.formatter && this.values && this.options){
				var i = array.indexOf(this.values, v);
				if(i >= 0){
					v = this.options[i];
				}
			}
			return v;
		},
		getValue: function(inRowIndex){
			var n = this.getEditNode(inRowIndex);
			if(n){
				var i = n.selectedIndex, o = n.options[i];
				return this.returnIndex > -1 ? i : o.value || o.innerHTML;
			}
		}
	});
	Select.markupFactory = function(node, cell){
		Cell.markupFactory(node, cell);
		var options = lang.trim(domAttr.get(node, "options")||"");
		if(options){
			var o = options.split(',');
			if(o[0] != options){
				cell.options = o;
			}
		}
		var values = lang.trim(domAttr.get(node, "values")||"");
		if(values){
			var v = values.split(',');
			if(v[0] != values){
				cell.values = v;
			}
		}
	};

	var AlwaysEdit = declare("dojox.grid.cells.AlwaysEdit", Cell, {
		// summary:
		// grid cell that is always in an editable state, regardless of grid editing state
		alwaysEditing: true,
		_formatNode: function(inDatum, inRowIndex){
			this.formatNode(this.getEditNode(inRowIndex), inDatum, inRowIndex);
		},
		applyStaticValue: function(inRowIndex){
			var e = this.grid.edit;
			e.applyCellEdit(this.getValue(inRowIndex), this, inRowIndex);
			e.start(this, inRowIndex, true);
		}
	});
	AlwaysEdit.markupFactory = function(node, cell){
		Cell.markupFactory(node, cell);
	};

	var Bool = declare("dojox.grid.cells.Bool", AlwaysEdit, {
		// summary:
		// grid cell that provides a standard checkbox that is always on for editing
		_valueProp: "checked",
		formatEditing: function(inDatum, inRowIndex){
			return '<input class="dojoxGridInput" type="checkbox"' + (inDatum ? ' checked="checked"' : '') + ' style="width: auto" />';
		},
		doclick: function(e){
			if(e.target.tagName == 'INPUT'){
				this.applyStaticValue(e.rowIndex);
			}
		}
	});
	Bool.markupFactory = function(node, cell){
		AlwaysEdit.markupFactory(node, cell);
	};

	return BaseCell;

});
},
'dijit/Dialog':function(){
require({cache:{
'url:dijit/templates/Dialog.html':"<div class=\"dijitDialog\" role=\"dialog\" aria-labelledby=\"${id}_title\">\n\t<div data-dojo-attach-point=\"titleBar\" class=\"dijitDialogTitleBar\">\n\t<span data-dojo-attach-point=\"titleNode\" class=\"dijitDialogTitle\" id=\"${id}_title\"></span>\n\t<span data-dojo-attach-point=\"closeButtonNode\" class=\"dijitDialogCloseIcon\" data-dojo-attach-event=\"ondijitclick: onCancel\" title=\"${buttonCancel}\" role=\"button\" tabIndex=\"-1\">\n\t\t<span data-dojo-attach-point=\"closeText\" class=\"closeText\" title=\"${buttonCancel}\">x</span>\n\t</span>\n\t</div>\n\t\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitDialogPaneContent\"></div>\n</div>\n"}});
define("dijit/Dialog", [
	"require",
	"dojo/_base/array", // array.forEach array.indexOf array.map
	"dojo/_base/connect", // connect._keypress
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.contains
	"dojo/dom-geometry", // domGeometry.position
	"dojo/dom-style", // domStyle.set
	"dojo/_base/event", // event.stop
	"dojo/_base/fx", // fx.fadeIn fx.fadeOut
	"dojo/i18n", // i18n.getLocalization
	"dojo/_base/kernel", // kernel.isAsync
	"dojo/keys",
	"dojo/_base/lang", // lang.mixin lang.hitch
	"dojo/on",
	"dojo/ready",
	"dojo/_base/sniff", // has("ie") has("opera")
	"dojo/_base/window", // win.body
	"dojo/window", // winUtils.getBox
	"dojo/dnd/Moveable", // Moveable
	"dojo/dnd/TimedMoveable", // TimedMoveable
	"./focus",
	"./_base/manager",	// manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_CssStateMixin",
	"./form/_FormMixin",
	"./_DialogMixin",
	"./DialogUnderlay",
	"./layout/ContentPane",
	"dojo/text!./templates/Dialog.html",
	".",			// for back-compat, exporting dijit._underlay (remove in 2.0)
	"dojo/i18n!./nls/common"
], function(require, array, connect, declare, Deferred,
			dom, domClass, domGeometry, domStyle, event, fx, i18n, kernel, keys, lang, on, ready, has, win, winUtils,
			Moveable, TimedMoveable, focus, manager, _Widget, _TemplatedMixin, _CssStateMixin, _FormMixin, _DialogMixin,
			DialogUnderlay, ContentPane, template, dijit){
	
/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _CssStateMixin = dijit._CssStateMixin;
	var _FormMixin = dijit.form._FormMixin;
	var _DialogMixin = dijit._DialogMixin;
=====*/	


	// module:
	//		dijit/Dialog
	// summary:
	//		A modal dialog Widget


	/*=====
	dijit._underlay = function(kwArgs){
		// summary:
		//		A shared instance of a `dijit.DialogUnderlay`
		//
		// description:
		//		A shared instance of a `dijit.DialogUnderlay` created and
		//		used by `dijit.Dialog`, though never created until some Dialog
		//		or subclass thereof is shown.
	};
	=====*/

	var _DialogBase = declare("dijit._DialogBase", [_TemplatedMixin, _FormMixin, _DialogMixin, _CssStateMixin], {
		// summary:
		//		A modal dialog Widget
		//
		// description:
		//		Pops up a modal dialog window, blocking access to the screen
		//		and also graying out the screen Dialog is extended from
		//		ContentPane so it supports all the same parameters (href, etc.)
		//
		// example:
		// |	<div data-dojo-type="dijit.Dialog" data-dojo-props="href: 'test.html'"></div>
		//
		// example:
		// |	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		// |	dojo.body().appendChild(foo.domNode);
		// |	foo.startup();

		templateString: template,

		baseClass: "dijitDialog",

		cssStateNodes: {
			closeButtonNode: "dijitDialogCloseIcon"
		},

		// Map widget attributes to DOMNode attributes.
		_setTitleAttr: [
			{ node: "titleNode", type: "innerHTML" },
			{ node: "titleBar", type: "attribute" }
		],

		// open: [readonly] Boolean
		//		True if Dialog is currently displayed on screen.
		open: false,

		// duration: Integer
		//		The time in milliseconds it takes the dialog to fade in and out
		duration: manager.defaultDuration,

		// refocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to re-focus the element which had focus before being opened.
		//		False will disable refocusing. Default: true
		refocus: true,

		// autofocus: Boolean
		// 		A Toggle to modify the default focus behavior of a Dialog, which
		// 		is to focus on the first dialog element after opening the dialog.
		//		False will disable autofocusing. Default: true
		autofocus: true,

		// _firstFocusItem: [private readonly] DomNode
		//		The pointer to the first focusable node in the dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_firstFocusItem: null,

		// _lastFocusItem: [private readonly] DomNode
		//		The pointer to which node has focus prior to our dialog.
		//		Set by `dijit._DialogMixin._getFocusItems`.
		_lastFocusItem: null,

		// doLayout: [protected] Boolean
		//		Don't change this parameter from the default value.
		//		This ContentPane parameter doesn't make sense for Dialog, since Dialog
		//		is never a child of a layout container, nor can you specify the size of
		//		Dialog in order to control the size of an inner widget.
		doLayout: false,

		// draggable: Boolean
		//		Toggles the moveable aspect of the Dialog. If true, Dialog
		//		can be dragged by it's title. If false it will remain centered
		//		in the viewport.
		draggable: true,

		//aria-describedby: String
		//		Allows the user to add an aria-describedby attribute onto the dialog.   The value should
		//		be the id of the container element of text that describes the dialog purpose (usually
		//		the first text in the dialog).
		//		<div data-dojo-type="dijit.Dialog" aria-describedby="intro" .....>
		//			<div id="intro">Introductory text</div>
		//			<div>rest of dialog contents</div>
		//		</div>
		"aria-describedby":"",

		postMixInProperties: function(){
			var _nlsResources = i18n.getLocalization("dijit", "common");
			lang.mixin(this, _nlsResources);
			this.inherited(arguments);
		},

		postCreate: function(){
			domStyle.set(this.domNode, {
				display: "none",
				position:"absolute"
			});
			win.body().appendChild(this.domNode);

			this.inherited(arguments);

			this.connect(this, "onExecute", "hide");
			this.connect(this, "onCancel", "hide");
			this._modalconnects = [];
		},

		onLoad: function(){
			// summary:
			//		Called when data has been loaded from an href.
			//		Unlike most other callbacks, this function can be connected to (via `dojo.connect`)
			//		but should *not* be overridden.
			// tags:
			//		callback

			// when href is specified we need to reposition the dialog after the data is loaded
			// and find the focusable elements
			this._position();
			if(this.autofocus && DialogLevelManager.isTop(this)){
				this._getFocusItems(this.domNode);
				focus.focus(this._firstFocusItem);
			}
			this.inherited(arguments);
		},

		_endDrag: function(){
			// summary:
			//		Called after dragging the Dialog. Saves the position of the dialog in the viewport,
			//		and also adjust position to be fully within the viewport, so user doesn't lose access to handle
			var nodePosition = domGeometry.position(this.domNode),
				viewport = winUtils.getBox();
			nodePosition.y = Math.min(Math.max(nodePosition.y, 0), (viewport.h - nodePosition.h));
			nodePosition.x = Math.min(Math.max(nodePosition.x, 0), (viewport.w - nodePosition.w));
			this._relativePosition = nodePosition;
			this._position();
		},

		_setup: function(){
			// summary:
			//		Stuff we need to do before showing the Dialog for the first
			//		time (but we defer it until right beforehand, for
			//		performance reasons).
			// tags:
			//		private

			var node = this.domNode;

			if(this.titleBar && this.draggable){
				this._moveable = new ((has("ie") == 6) ? TimedMoveable // prevent overload, see #5285
					: Moveable)(node, { handle: this.titleBar });
				this.connect(this._moveable, "onMoveStop", "_endDrag");
			}else{
				domClass.add(node,"dijitDialogFixed");
			}

			this.underlayAttrs = {
				dialogId: this.id,
				"class": array.map(this["class"].split(/\s/), function(s){ return s+"_underlay"; }).join(" ")
			};
		},

		_size: function(){
			// summary:
			// 		If necessary, shrink dialog contents so dialog fits in viewport
			// tags:
			//		private

			this._checkIfSingleChild();

			// If we resized the dialog contents earlier, reset them back to original size, so
			// that if the user later increases the viewport size, the dialog can display w/out a scrollbar.
			// Need to do this before the domGeometry.position(this.domNode) call below.
			if(this._singleChild){
				if(this._singleChildOriginalStyle){
					this._singleChild.domNode.style.cssText = this._singleChildOriginalStyle;
				}
				delete this._singleChildOriginalStyle;
			}else{
				domStyle.set(this.containerNode, {
					width:"auto",
					height:"auto"
				});
			}

			var bb = domGeometry.position(this.domNode);
			var viewport = winUtils.getBox();
			if(bb.w >= viewport.w || bb.h >= viewport.h){
				// Reduce size of dialog contents so that dialog fits in viewport

				var w = Math.min(bb.w, Math.floor(viewport.w * 0.75)),
					h = Math.min(bb.h, Math.floor(viewport.h * 0.75));

				if(this._singleChild && this._singleChild.resize){
					this._singleChildOriginalStyle = this._singleChild.domNode.style.cssText;
					this._singleChild.resize({w: w, h: h});
				}else{
					domStyle.set(this.containerNode, {
						width: w + "px",
						height: h + "px",
						overflow: "auto",
						position: "relative"	// workaround IE bug moving scrollbar or dragging dialog
					});
				}
			}else{
				if(this._singleChild && this._singleChild.resize){
					this._singleChild.resize();
				}
			}
		},

		_position: function(){
			// summary:
			//		Position modal dialog in the viewport. If no relative offset
			//		in the viewport has been determined (by dragging, for instance),
			//		center the node. Otherwise, use the Dialog's stored relative offset,
			//		and position the node to top: left: values based on the viewport.
			if(!domClass.contains(win.body(), "dojoMove")){	// don't do anything if called during auto-scroll
				var node = this.domNode,
					viewport = winUtils.getBox(),
					p = this._relativePosition,
					bb = p ? null : domGeometry.position(node),
					l = Math.floor(viewport.l + (p ? p.x : (viewport.w - bb.w) / 2)),
					t = Math.floor(viewport.t + (p ? p.y : (viewport.h - bb.h) / 2))
				;
				domStyle.set(node,{
					left: l + "px",
					top: t + "px"
				});
			}
		},

		_onKey: function(/*Event*/ evt){
			// summary:
			//		Handles the keyboard events for accessibility reasons
			// tags:
			//		private

			if(evt.charOrCode){
				var node = evt.target;
				if(evt.charOrCode === keys.TAB){
					this._getFocusItems(this.domNode);
				}
				var singleFocusItem = (this._firstFocusItem == this._lastFocusItem);
				// see if we are shift-tabbing from first focusable item on dialog
				if(node == this._firstFocusItem && evt.shiftKey && evt.charOrCode === keys.TAB){
					if(!singleFocusItem){
						focus.focus(this._lastFocusItem); // send focus to last item in dialog
					}
					event.stop(evt);
				}else if(node == this._lastFocusItem && evt.charOrCode === keys.TAB && !evt.shiftKey){
					if(!singleFocusItem){
						focus.focus(this._firstFocusItem); // send focus to first item in dialog
					}
					event.stop(evt);
				}else{
					// see if the key is for the dialog
					while(node){
						if(node == this.domNode || domClass.contains(node, "dijitPopup")){
							if(evt.charOrCode == keys.ESCAPE){
								this.onCancel();
							}else{
								return; // just let it go
							}
						}
						node = node.parentNode;
					}
					// this key is for the disabled document window
					if(evt.charOrCode !== keys.TAB){ // allow tabbing into the dialog for a11y
						event.stop(evt);
					// opera won't tab to a div
					}else if(!has("opera")){
						try{
							this._firstFocusItem.focus();
						}catch(e){ /*squelch*/ }
					}
				}
			}
		},

		show: function(){
			// summary:
			//		Display the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the display animation is complete

			if(this.open){ return; }

			if(!this._started){
				this.startup();
			}

			// first time we show the dialog, there's some initialization stuff to do
			if(!this._alreadyInitialized){
				this._setup();
				this._alreadyInitialized=true;
			}

			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}

			this._modalconnects.push(on(window, "scroll", lang.hitch(this, "layout")));
			this._modalconnects.push(on(window, "resize", lang.hitch(this, function(){
				// IE gives spurious resize events and can actually get stuck
				// in an infinite loop if we don't ignore them
				var viewport = winUtils.getBox();
				if(!this._oldViewport ||
						viewport.h != this._oldViewport.h ||
						viewport.w != this._oldViewport.w){
					this.layout();
					this._oldViewport = viewport;
				}
			})));
			this._modalconnects.push(on(this.domNode, connect._keypress, lang.hitch(this, "_onKey")));

			domStyle.set(this.domNode, {
				opacity:0,
				display:""
			});

			this._set("open", true);
			this._onShow(); // lazy load trigger

			this._size();
			this._position();

			// fade-in Animation object, setup below
			var fadeIn;

			this._fadeInDeferred = new Deferred(lang.hitch(this, function(){
				fadeIn.stop();
				delete this._fadeInDeferred;
			}));

			fadeIn = fx.fadeIn({
				node: this.domNode,
				duration: this.duration,
				beforeBegin: lang.hitch(this, function(){
					DialogLevelManager.show(this, this.underlayAttrs);
				}),
				onEnd: lang.hitch(this, function(){
					if(this.autofocus && DialogLevelManager.isTop(this)){
						// find focusable items each time dialog is shown since if dialog contains a widget the
						// first focusable items can change
						this._getFocusItems(this.domNode);
						focus.focus(this._firstFocusItem);
					}
					this._fadeInDeferred.callback(true);
					delete this._fadeInDeferred;
				})
			}).play();

			return this._fadeInDeferred;
		},

		hide: function(){
			// summary:
			//		Hide the dialog
			// returns: dojo.Deferred
			//		Deferred object that resolves when the hide animation is complete

			// if we haven't been initialized yet then we aren't showing and we can just return
			if(!this._alreadyInitialized){
				return;
			}
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}

			// fade-in Animation object, setup below
			var fadeOut;

			this._fadeOutDeferred = new Deferred(lang.hitch(this, function(){
				fadeOut.stop();
				delete this._fadeOutDeferred;
			}));
			// fire onHide when the promise resolves.
			this._fadeOutDeferred.then(lang.hitch(this, 'onHide'));

			fadeOut = fx.fadeOut({
				node: this.domNode,
				duration: this.duration,
				onEnd: lang.hitch(this, function(){
					this.domNode.style.display = "none";
					DialogLevelManager.hide(this);
					this._fadeOutDeferred.callback(true);
					delete this._fadeOutDeferred;
				})
			 }).play();

			if(this._scrollConnected){
				this._scrollConnected = false;
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			if(this._relativePosition){
				delete this._relativePosition;
			}
			this._set("open", false);

			return this._fadeOutDeferred;
		},

		layout: function(){
			// summary:
			//		Position the Dialog and the underlay
			// tags:
			//		private
			if(this.domNode.style.display != "none"){
				if(dijit._underlay){	// avoid race condition during show()
					dijit._underlay.layout();
				}
				this._position();
			}
		},

		destroy: function(){
			if(this._fadeInDeferred){
				this._fadeInDeferred.cancel();
			}
			if(this._fadeOutDeferred){
				this._fadeOutDeferred.cancel();
			}
			if(this._moveable){
				this._moveable.destroy();
			}
			var h;
			while(h = this._modalconnects.pop()){
				h.remove();
			}

			DialogLevelManager.hide(this);

			this.inherited(arguments);
		}
	});

	var Dialog = declare("dijit.Dialog", [ContentPane, _DialogBase], {});
	Dialog._DialogBase = _DialogBase;	// for monkey patching

	var DialogLevelManager = Dialog._DialogLevelManager = {
		// summary:
		//		Controls the various active "levels" on the page, starting with the
		//		stuff initially visible on the page (at z-index 0), and then having an entry for
		//		each Dialog shown.

		_beginZIndex: 950,

		show: function(/*dijit._Widget*/ dialog, /*Object*/ underlayAttrs){
			// summary:
			//		Call right before fade-in animation for new dialog.
			//		Saves current focus, displays/adjusts underlay for new dialog,
			//		and sets the z-index of the dialog itself.
			//
			//		New dialog will be displayed on top of all currently displayed dialogs.
			//
			//		Caller is responsible for setting focus in new dialog after the fade-in
			//		animation completes.

			// Save current focus
			ds[ds.length-1].focus = focus.curNode;

			// Display the underlay, or if already displayed then adjust for this new dialog
			var underlay = dijit._underlay;
			if(!underlay || underlay._destroyed){
				underlay = dijit._underlay = new DialogUnderlay(underlayAttrs);
			}else{
				underlay.set(dialog.underlayAttrs);
			}

			// Set z-index a bit above previous dialog
			var zIndex = ds[ds.length-1].dialog ? ds[ds.length-1].zIndex + 2 : Dialog._DialogLevelManager._beginZIndex;
			if(ds.length == 1){	// first dialog
				underlay.show();
			}
			domStyle.set(dijit._underlay.domNode, 'zIndex', zIndex - 1);

			// Dialog
			domStyle.set(dialog.domNode, 'zIndex', zIndex);

			ds.push({dialog: dialog, underlayAttrs: underlayAttrs, zIndex: zIndex});
		},

		hide: function(/*dijit._Widget*/ dialog){
			// summary:
			//		Called when the specified dialog is hidden/destroyed, after the fade-out
			//		animation ends, in order to reset page focus, fix the underlay, etc.
			//		If the specified dialog isn't open then does nothing.
			//
			//		Caller is responsible for either setting display:none on the dialog domNode,
			//		or calling dijit.popup.hide(), or removing it from the page DOM.

			if(ds[ds.length-1].dialog == dialog){
				// Removing the top (or only) dialog in the stack, return focus
				// to previous dialog

				ds.pop();

				var pd = ds[ds.length-1];	// the new active dialog (or the base page itself)

				// Adjust underlay
				if(ds.length == 1){
					// Returning to original page.
					// Hide the underlay, unless the underlay widget has already been destroyed
					// because we are being called during page unload (when all widgets are destroyed)
					if(!dijit._underlay._destroyed){
						dijit._underlay.hide();
					}
				}else{
					// Popping back to previous dialog, adjust underlay
					domStyle.set(dijit._underlay.domNode, 'zIndex', pd.zIndex - 1);
					dijit._underlay.set(pd.underlayAttrs);
				}

				// Adjust focus
				if(dialog.refocus){
					// If we are returning control to a previous dialog but for some reason
					// that dialog didn't have a focused field, set focus to first focusable item.
					// This situation could happen if two dialogs appeared at nearly the same time,
					// since a dialog doesn't set it's focus until the fade-in is finished.
					var focus = pd.focus;
					if(pd.dialog && (!focus || !dom.isDescendant(focus, pd.dialog.domNode))){
						pd.dialog._getFocusItems(pd.dialog.domNode);
						focus = pd.dialog._firstFocusItem;
					}

					if(focus){
						focus.focus();
					}
				}
			}else{
				// Removing a dialog out of order (#9944, #10705).
				// Don't need to mess with underlay or z-index or anything.
				var idx = array.indexOf(array.map(ds, function(elem){return elem.dialog}), dialog);
				if(idx != -1){
					ds.splice(idx, 1);
				}
			}
		},

		isTop: function(/*dijit._Widget*/ dialog){
			// summary:
			//		Returns true if specified Dialog is the top in the task
			return ds[ds.length-1].dialog == dialog;
		}
	};

	// Stack representing the various active "levels" on the page, starting with the
	// stuff initially visible on the page (at z-index 0), and then having an entry for
	// each Dialog shown.
	// Each element in stack has form {
	//		dialog: dialogWidget,
	//		focus: returnFromGetFocus(),
	//		underlayAttrs: attributes to set on underlay (when this widget is active)
	// }
	var ds = Dialog._dialogStack = [
		{dialog: null, focus: null, underlayAttrs: null}	// entry for stuff at z-index: 0
	];

	// Back compat w/1.6, remove for 2.0
	if(!kernel.isAsync){
		ready(0, function(){
			var requires = ["dijit/TooltipDialog"];
			require(requires);	// use indirection so modules not rolled into a build
		});
	}

	return Dialog;
});

},
'dijit/a11y':function(){
define("dijit/a11y", [
	"dojo/_base/array", // array.forEach array.map
	"dojo/_base/config", // defaultDuration
	"dojo/_base/declare", // declare
	"dojo/dom",			// dom.byId
	"dojo/dom-attr", // domAttr.attr domAttr.has
	"dojo/dom-style", // style.style
	"dojo/_base/sniff", // has("ie")
	"./_base/manager",	// manager._isElementShown
	"."	// for exporting methods to dijit namespace
], function(array, config, declare, dom, domAttr, domStyle, has, manager, dijit){

	// module:
	//		dijit/a11y
	// summary:
	//		Accessibility utility functions (keyboard, tab stops, etc.)

	var shown = (dijit._isElementShown = function(/*Element*/ elem){
		var s = domStyle.get(elem);
		return (s.visibility != "hidden")
			&& (s.visibility != "collapsed")
			&& (s.display != "none")
			&& (domAttr.get(elem, "type") != "hidden");
	});

	dijit.hasDefaultTabStop = function(/*Element*/ elem){
		// summary:
		//		Tests if element is tab-navigable even without an explicit tabIndex setting

		// No explicit tabIndex setting, need to investigate node type
		switch(elem.nodeName.toLowerCase()){
			case "a":
				// An <a> w/out a tabindex is only navigable if it has an href
				return domAttr.has(elem, "href");
			case "area":
			case "button":
			case "input":
			case "object":
			case "select":
			case "textarea":
				// These are navigable by default
				return true;
			case "iframe":
				// If it's an editor <iframe> then it's tab navigable.
				var body;
				try{
					// non-IE
					var contentDocument = elem.contentDocument;
					if("designMode" in contentDocument && contentDocument.designMode == "on"){
						return true;
					}
					body = contentDocument.body;
				}catch(e1){
					// contentWindow.document isn't accessible within IE7/8
					// if the iframe.src points to a foreign url and this
					// page contains an element, that could get focus
					try{
						body = elem.contentWindow.document.body;
					}catch(e2){
						return false;
					}
				}
				return body && (body.contentEditable == 'true' ||
					(body.firstChild && body.firstChild.contentEditable == 'true'));
			default:
				return elem.contentEditable == 'true';
		}
	};

	var isTabNavigable = (dijit.isTabNavigable = function(/*Element*/ elem){
		// summary:
		//		Tests if an element is tab-navigable

		// TODO: convert (and rename method) to return effective tabIndex; will save time in _getTabNavigable()
		if(domAttr.get(elem, "disabled")){
			return false;
		}else if(domAttr.has(elem, "tabIndex")){
			// Explicit tab index setting
			return domAttr.get(elem, "tabIndex") >= 0; // boolean
		}else{
			// No explicit tabIndex setting, so depends on node type
			return dijit.hasDefaultTabStop(elem);
		}
	});

	dijit._getTabNavigable = function(/*DOMNode*/ root){
		// summary:
		//		Finds descendants of the specified root node.
		//
		// description:
		//		Finds the following descendants of the specified root node:
		//		* the first tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the last tab-navigable element in document order
		//		  without a tabIndex or with tabIndex="0"
		//		* the first element in document order with the lowest
		//		  positive tabIndex value
		//		* the last element in document order with the highest
		//		  positive tabIndex value
		var first, last, lowest, lowestTabindex, highest, highestTabindex, radioSelected = {};

		function radioName(node){
			// If this element is part of a radio button group, return the name for that group.
			return node && node.tagName.toLowerCase() == "input" &&
				node.type && node.type.toLowerCase() == "radio" &&
				node.name && node.name.toLowerCase();
		}

		var walkTree = function(/*DOMNode*/parent){
			for(var child = parent.firstChild; child; child = child.nextSibling){
				// Skip text elements, hidden elements, and also non-HTML elements (those in custom namespaces) in IE,
				// since show() invokes getAttribute("type"), which crash on VML nodes in IE.
				if(child.nodeType != 1 || (has("ie") && child.scopeName !== "HTML") || !shown(child)){
					continue;
				}

				if(isTabNavigable(child)){
					var tabindex = domAttr.get(child, "tabIndex");
					if(!domAttr.has(child, "tabIndex") || tabindex == 0){
						if(!first){
							first = child;
						}
						last = child;
					}else if(tabindex > 0){
						if(!lowest || tabindex < lowestTabindex){
							lowestTabindex = tabindex;
							lowest = child;
						}
						if(!highest || tabindex >= highestTabindex){
							highestTabindex = tabindex;
							highest = child;
						}
					}
					var rn = radioName(child);
					if(domAttr.get(child, "checked") && rn){
						radioSelected[rn] = child;
					}
				}
				if(child.nodeName.toUpperCase() != 'SELECT'){
					walkTree(child);
				}
			}
		};
		if(shown(root)){
			walkTree(root);
		}
		function rs(node){
			// substitute checked radio button for unchecked one, if there is a checked one with the same name.
			return radioSelected[radioName(node)] || node;
		}

		return { first: rs(first), last: rs(last), lowest: rs(lowest), highest: rs(highest) };
	};
	dijit.getFirstInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is first in the tabbing order
		var elems = dijit._getTabNavigable(dom.byId(root));
		return elems.lowest ? elems.lowest : elems.first; // DomNode
	};

	dijit.getLastInTabbingOrder = function(/*String|DOMNode*/ root){
		// summary:
		//		Finds the descendant of the specified root node
		//		that is last in the tabbing order
		var elems = dijit._getTabNavigable(dom.byId(root));
		return elems.last ? elems.last : elems.highest; // DomNode
	};

	return {
		hasDefaultTabStop: dijit.hasDefaultTabStop,
		isTabNavigable: dijit.isTabNavigable,
		_getTabNavigable: dijit._getTabNavigable,
		getFirstInTabbingOrder: dijit.getFirstInTabbingOrder,
		getLastInTabbingOrder: dijit.getLastInTabbingOrder
	};
});

},
'dojox/grid/_Scroller':function(){
define("dojox/grid/_Scroller", [
	"dijit/registry",
	"dojo/_base/declare",
	"dojo/_base/lang",
	"./util",
	"dojo/_base/html"
], function(dijitRegistry, declare, lang, util, html){

	var indexInParent = function(inNode){
		var i=0, n, p=inNode.parentNode;
		while((n = p.childNodes[i++])){
			if(n == inNode){
				return i - 1;
			}
		}
		return -1;
	};
	
	var cleanNode = function(inNode){
		if(!inNode){
			return;
		}
		dojo.forEach(dijitRegistry.toArray(), function(w){
			if(w.domNode && html.isDescendant(w.domNode, inNode, true)){
				w.destroy();
			}
		});
	};

	var getTagName = function(inNodeOrId){
		var node = html.byId(inNodeOrId);
		return (node && node.tagName ? node.tagName.toLowerCase() : '');
	};
	
	var nodeKids = function(inNode, inTag){
		var result = [];
		var i=0, n;
		while((n = inNode.childNodes[i])){
			i++;
			if(getTagName(n) == inTag){
				result.push(n);
			}
		}
		return result;
	};
	
	var divkids = function(inNode){
		return nodeKids(inNode, 'div');
	};

	return declare("dojox.grid._Scroller", null, {
		constructor: function(inContentNodes){
			this.setContentNodes(inContentNodes);
			this.pageHeights = [];
			this.pageNodes = [];
			this.stack = [];
		},
		// specified
		rowCount: 0, // total number of rows to manage
		defaultRowHeight: 32, // default height of a row
		keepRows: 100, // maximum number of rows that should exist at one time
		contentNode: null, // node to contain pages
		scrollboxNode: null, // node that controls scrolling
		// calculated
		defaultPageHeight: 0, // default height of a page
		keepPages: 10, // maximum number of pages that should exists at one time
		pageCount: 0,
		windowHeight: 0,
		firstVisibleRow: 0,
		lastVisibleRow: 0,
		averageRowHeight: 0, // the average height of a row
		// private
		page: 0,
		pageTop: 0,
		// init
		init: function(inRowCount, inKeepRows, inRowsPerPage){
			switch(arguments.length){
				case 3: this.rowsPerPage = inRowsPerPage;
				case 2: this.keepRows = inKeepRows;
				case 1: this.rowCount = inRowCount;
				default: break;
			}
			this.defaultPageHeight = this.defaultRowHeight * this.rowsPerPage;
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			this.setKeepInfo(this.keepRows);
			this.invalidate();
			if(this.scrollboxNode){
				this.scrollboxNode.scrollTop = 0;
				this.scroll(0);
				this.scrollboxNode.onscroll = lang.hitch(this, 'onscroll');
			}
		},
		_getPageCount: function(rowCount, rowsPerPage){
			return rowCount ? (Math.ceil(rowCount / rowsPerPage) || 1) : 0;
		},
		destroy: function(){
			this.invalidateNodes();
			delete this.contentNodes;
			delete this.contentNode;
			delete this.scrollboxNode;
		},
		setKeepInfo: function(inKeepRows){
			this.keepRows = inKeepRows;
			this.keepPages = !this.keepRows ? this.keepPages : Math.max(Math.ceil(this.keepRows / this.rowsPerPage), 2);
		},
		// nodes
		setContentNodes: function(inNodes){
			this.contentNodes = inNodes;
			this.colCount = (this.contentNodes ? this.contentNodes.length : 0);
			this.pageNodes = [];
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i] = [];
			}
		},
		getDefaultNodes: function(){
			return this.pageNodes[0] || [];
		},
		// updating
		invalidate: function(){
			this._invalidating = true;
			this.invalidateNodes();
			this.pageHeights = [];
			this.height = (this.pageCount ? (this.pageCount - 1)* this.defaultPageHeight + this.calcLastPageHeight() : 0);
			this.resize();
			this._invalidating = false;
		},
		updateRowCount: function(inRowCount){
			this.invalidateNodes();
			this.rowCount = inRowCount;
			// update page count, adjust document height
			var oldPageCount = this.pageCount;
			if(oldPageCount === 0){
				//We want to have at least 1px in height to keep scroller.  Otherwise with an
				//empty grid you can't scroll to see the header.
				this.height = 1;
			}
			this.pageCount = this._getPageCount(this.rowCount, this.rowsPerPage);
			if(this.pageCount < oldPageCount){
				for(var i=oldPageCount-1; i>=this.pageCount; i--){
					this.height -= this.getPageHeight(i);
					delete this.pageHeights[i];
				}
			}else if(this.pageCount > oldPageCount){
				this.height += this.defaultPageHeight * (this.pageCount - oldPageCount - 1) + this.calcLastPageHeight();
			}
			this.resize();
		},
		// implementation for page manager
		pageExists: function(inPageIndex){
			return Boolean(this.getDefaultPageNode(inPageIndex));
		},
		measurePage: function(inPageIndex){
			if(this.grid.rowHeight){
				var height = this.grid.rowHeight + 1;
				return ((inPageIndex + 1) * this.rowsPerPage > this.rowCount ?
					this.rowCount - inPageIndex * this.rowsPerPage :
					this.rowsPerPage) * height;
					 
			}
			var n = this.getDefaultPageNode(inPageIndex);
			return (n && n.innerHTML) ? n.offsetHeight : undefined;
		},
		positionPage: function(inPageIndex, inPos){
			for(var i=0; i<this.colCount; i++){
				this.pageNodes[i][inPageIndex].style.top = inPos + 'px';
			}
		},
		repositionPages: function(inPageIndex){
			var nodes = this.getDefaultNodes();
			var last = 0;

			for(var i=0; i<this.stack.length; i++){
				last = Math.max(this.stack[i], last);
			}
			//
			var n = nodes[inPageIndex];
			var y = (n ? this.getPageNodePosition(n) + this.getPageHeight(inPageIndex) : 0);
			for(var p=inPageIndex+1; p<=last; p++){
				n = nodes[p];
				if(n){
					if(this.getPageNodePosition(n) == y){
						return;
					}
					this.positionPage(p, y);
				}
				y += this.getPageHeight(p);
			}
		},
		installPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				this.contentNodes[i].appendChild(this.pageNodes[i][inPageIndex]);
			}
		},
		preparePage: function(inPageIndex, inReuseNode){
			var p = (inReuseNode ? this.popPage() : null);
			for(var i=0; i<this.colCount; i++){
				var nodes = this.pageNodes[i];
				var new_p = (p === null ? this.createPageNode() : this.invalidatePageNode(p, nodes));
				new_p.pageIndex = inPageIndex;
				nodes[inPageIndex] = new_p;
			}
		},
		// rendering implementation
		renderPage: function(inPageIndex){
			var nodes = [];
			var i, j;
			for(i=0; i<this.colCount; i++){
				nodes[i] = this.pageNodes[i][inPageIndex];
			}
			for(i=0, j=inPageIndex*this.rowsPerPage; (i<this.rowsPerPage)&&(j<this.rowCount); i++, j++){
				this.renderRow(j, nodes);
			}
		},
		removePage: function(inPageIndex){
			for(var i=0, j=inPageIndex*this.rowsPerPage; i<this.rowsPerPage; i++, j++){
				this.removeRow(j);
			}
		},
		destroyPage: function(inPageIndex){
			for(var i=0; i<this.colCount; i++){
				var n = this.invalidatePageNode(inPageIndex, this.pageNodes[i]);
				if(n){
					html.destroy(n);
				}
			}
		},
		pacify: function(inShouldPacify){
		},
		// pacification
		pacifying: false,
		pacifyTicks: 200,
		setPacifying: function(inPacifying){
			if(this.pacifying != inPacifying){
				this.pacifying = inPacifying;
				this.pacify(this.pacifying);
			}
		},
		startPacify: function(){
			this.startPacifyTicks = new Date().getTime();
		},
		doPacify: function(){
			var result = (new Date().getTime() - this.startPacifyTicks) > this.pacifyTicks;
			this.setPacifying(true);
			this.startPacify();
			return result;
		},
		endPacify: function(){
			this.setPacifying(false);
		},
		// default sizing implementation
		resize: function(){
			if(this.scrollboxNode){
				this.windowHeight = this.scrollboxNode.clientHeight;
			}
			for(var i=0; i<this.colCount; i++){
				//We want to have 1px in height min to keep scroller.  Otherwise can't scroll
				//and see header in empty grid.
				util.setStyleHeightPx(this.contentNodes[i], Math.max(1,this.height));
			}
			
			// Calculate the average row height and update the defaults (row and page).
			var needPage = (!this._invalidating);
			if(!needPage){
				var ah = this.grid.get("autoHeight");
				if(typeof ah == "number" && ah <= Math.min(this.rowsPerPage, this.rowCount)){
					needPage = true;
				}
			}
			if(needPage){
				this.needPage(this.page, this.pageTop);
			}
			var rowsOnPage = (this.page < this.pageCount - 1) ? this.rowsPerPage : ((this.rowCount % this.rowsPerPage) || this.rowsPerPage);
			var pageHeight = this.getPageHeight(this.page);
			this.averageRowHeight = (pageHeight > 0 && rowsOnPage > 0) ? (pageHeight / rowsOnPage) : 0;
		},
		calcLastPageHeight: function(){
			if(!this.pageCount){
				return 0;
			}
			var lastPage = this.pageCount - 1;
			var lastPageHeight = ((this.rowCount % this.rowsPerPage)||(this.rowsPerPage)) * this.defaultRowHeight;
			this.pageHeights[lastPage] = lastPageHeight;
			return lastPageHeight;
		},
		updateContentHeight: function(inDh){
			this.height += inDh;
			this.resize();
		},
		updatePageHeight: function(inPageIndex, fromBuild, fromAsynRendering){
			if(this.pageExists(inPageIndex)){
				var oh = this.getPageHeight(inPageIndex);
				var h = (this.measurePage(inPageIndex));
				if(h === undefined){
					h = oh;
				}
				this.pageHeights[inPageIndex] = h;
				if(oh != h){
					this.updateContentHeight(h - oh);
					var ah = this.grid.get("autoHeight");
					if((typeof ah == "number" && ah > this.rowCount)||(ah === true && !fromBuild)){
						if(!fromAsynRendering){
							this.grid.sizeChange();
						}else{//fix #11101 by using fromAsynRendering to avoid deadlock
							var ns = this.grid.viewsNode.style;
							ns.height = parseInt(ns.height) + h - oh + 'px';
							this.repositionPages(inPageIndex);
						}
					}else{
						this.repositionPages(inPageIndex);
					}
				}
				return h;
			}
			return 0;
		},
		rowHeightChanged: function(inRowIndex, fromAsynRendering){
			this.updatePageHeight(Math.floor(inRowIndex / this.rowsPerPage), false, fromAsynRendering);
		},
		// scroller core
		invalidateNodes: function(){
			while(this.stack.length){
				this.destroyPage(this.popPage());
			}
		},
		createPageNode: function(){
			var p = document.createElement('div');
			html.attr(p,"role","presentation");
			p.style.position = 'absolute';
			//p.style.width = '100%';
			p.style[this.grid.isLeftToRight() ? "left" : "right"] = '0';
			return p;
		},
		getPageHeight: function(inPageIndex){
			var ph = this.pageHeights[inPageIndex];
			return (ph !== undefined ? ph : this.defaultPageHeight);
		},
		// FIXME: this is not a stack, it's a FIFO list
		pushPage: function(inPageIndex){
			return this.stack.push(inPageIndex);
		},
		popPage: function(){
			return this.stack.shift();
		},
		findPage: function(inTop){
			var i = 0, h = 0;
			for(var ph = 0; i<this.pageCount; i++, h += ph){
				ph = this.getPageHeight(i);
				if(h + ph >= inTop){
					break;
				}
			}
			this.page = i;
			this.pageTop = h;
		},
		buildPage: function(inPageIndex, inReuseNode, inPos){
			this.preparePage(inPageIndex, inReuseNode);
			this.positionPage(inPageIndex, inPos);
			// order of operations is key below
			this.installPage(inPageIndex);
			this.renderPage(inPageIndex);
			// order of operations is key above
			this.pushPage(inPageIndex);
		},
		needPage: function(inPageIndex, inPos){
			var h = this.getPageHeight(inPageIndex), oh = h;
			if(!this.pageExists(inPageIndex)){
				this.buildPage(inPageIndex, (!this.grid._autoHeight/*fix #10543*/ && this.keepPages&&(this.stack.length >= this.keepPages)), inPos);
				h = this.updatePageHeight(inPageIndex, true);
			}else{
				this.positionPage(inPageIndex, inPos);
			}
			return h;
		},
		onscroll: function(){
			this.scroll(this.scrollboxNode.scrollTop);
		},
		scroll: function(inTop){
			this.grid.scrollTop = inTop;
			if(this.colCount){
				this.startPacify();
				this.findPage(inTop);
				var h = this.height;
				var b = this.getScrollBottom(inTop);
				for(var p=this.page, y=this.pageTop; (p<this.pageCount)&&((b<0)||(y<b)); p++){
					y += this.needPage(p, y);
				}
				this.firstVisibleRow = this.getFirstVisibleRow(this.page, this.pageTop, inTop);
				this.lastVisibleRow = this.getLastVisibleRow(p - 1, y, b);
				// indicates some page size has been updated
				if(h != this.height){
					this.repositionPages(p-1);
				}
				this.endPacify();
			}
		},
		getScrollBottom: function(inTop){
			return (this.windowHeight >= 0 ? inTop + this.windowHeight : -1);
		},
		// events
		processNodeEvent: function(e, inNode){
			var t = e.target;
			while(t && (t != inNode) && t.parentNode && (t.parentNode.parentNode != inNode)){
				t = t.parentNode;
			}
			if(!t || !t.parentNode || (t.parentNode.parentNode != inNode)){
				return false;
			}
			var page = t.parentNode;
			e.topRowIndex = page.pageIndex * this.rowsPerPage;
			e.rowIndex = e.topRowIndex + indexInParent(t);
			e.rowTarget = t;
			return true;
		},
		processEvent: function(e){
			return this.processNodeEvent(e, this.contentNode);
		},
		// virtual rendering interface
		renderRow: function(inRowIndex, inPageNode){
		},
		removeRow: function(inRowIndex){
		},
		// page node operations
		getDefaultPageNode: function(inPageIndex){
			return this.getDefaultNodes()[inPageIndex];
		},
		positionPageNode: function(inNode, inPos){
		},
		getPageNodePosition: function(inNode){
			return inNode.offsetTop;
		},
		invalidatePageNode: function(inPageIndex, inNodes){
			var p = inNodes[inPageIndex];
			if(p){
				delete inNodes[inPageIndex];
				this.removePage(inPageIndex, p);
				cleanNode(p);
				p.innerHTML = '';
			}
			return p;
		},
		// scroll control
		getPageRow: function(inPage){
			return inPage * this.rowsPerPage;
		},
		getLastPageRow: function(inPage){
			return Math.min(this.rowCount, this.getPageRow(inPage + 1)) - 1;
		},
		getFirstVisibleRow: function(inPage, inPageTop, inScrollTop){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var row = this.getPageRow(inPage);
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[inPage]);
			for(var i=0,l=rows.length; i<l && inPageTop<inScrollTop; i++, row++){
				inPageTop += rows[i].offsetHeight;
			}
			return (row ? row - 1 : row);
		},
		getLastVisibleRow: function(inPage, inBottom, inScrollBottom){
			if(!this.pageExists(inPage)){
				return 0;
			}
			var nodes = this.getDefaultNodes();
			var row = this.getLastPageRow(inPage);
			var rows = divkids(nodes[inPage]);
			for(var i=rows.length-1; i>=0 && inBottom>inScrollBottom; i--, row--){
				inBottom -= rows[i].offsetHeight;
			}
			return row + 1;
		},
		findTopRow: function(inScrollTop){
			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[this.page]);
			for(var i=0,l=rows.length,t=this.pageTop,h; i<l; i++){
				h = rows[i].offsetHeight;
				t += h;
				if(t >= inScrollTop){
					this.offset = h - (t - inScrollTop);
					return i + this.page * this.rowsPerPage;
				}
			}
			return -1;
		},
		findScrollTop: function(inRow){
			var rowPage = Math.floor(inRow / this.rowsPerPage);
			var t = 0;
			var i, l;
			for(i=0; i<rowPage; i++){
				t += this.getPageHeight(i);
			}
			this.pageTop = t;
			this.page = rowPage;//fix #10543
			this.needPage(rowPage, this.pageTop);

			var nodes = this.getDefaultNodes();
			var rows = divkids(nodes[rowPage]);
			var r = inRow - this.rowsPerPage * rowPage;
			for(i=0,l=rows.length; i<l && i<r; i++){
				t += rows[i].offsetHeight;
			}
			return t;
		},
		dummy: 0
	});
});

},
'ibm/tivoli/tip/dijit/Images':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
dojo.provide("ibm.tivoli.tip.dijit.Images");

// images cache
ibm.tivoli.tip.dijit.Images._images = 
{
    ICON_COLLAPSED:         dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "icon_collapsed.gif"),
    ICON_EXPANDED:          dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "icon_expanded.gif"),
    ICON_TREE_EMPTY:        dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "icon_tree_empty.gif"),
    OK_ICON:                dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "blank.gif"),
    WARNING_ICON:           dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "warning.gif"),
    WARNING_16_ICON:        dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "tree_warning.gif"),
    ERROR_ICON:             dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "error.gif"),
    ERROR_16_ICON:          dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "tree_error.gif"),
    BLANK_ICON:             dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "blank.gif"),
    ASTERISK_ICON:          dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "asterisk.gif"),
    PICKER_ICON:            dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "asterisk.gif"),
    CALENDAR_ICON:          dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "datatype_date.gif"),
    TIME_ICON:              dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "datatype_time.gif"),
    UP_ARROW_ICON:          dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "uparrow.gif"),
    DOWN_ARROW_ICON:        dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "downarrow.gif"),
    TABLE_ADD_ROW_ICON:     dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "add_row.gif"),
    TABLE_REMOVE_ROW_ICON:  dojo.moduleUrl("ibm.tivoli.tip.dijit.templates.images", "remove_row.gif")
};

ibm.tivoli.tip.dijit.Images.get = function() 
{
    return ibm.tivoli.tip.dijit.Images._images; 
};

});

},
'dojox/gfx/gradient':function(){
define("dojox/gfx/gradient", ["dojo/_base/lang", "./matrix", "dojo/_base/Color"], 
  function(lang, m, Color){
// Various utilities to deal with a linear gradient (mostly VML-specific)
	var grad = lang.getObject("dojox.gfx.gradient", true);
	var C = Color;
	/*===== grad = dojox.gfx.gradient;  =====*/
	
	grad.rescale = function(stops, from, to){
		// summary:
		//		Recalculates a gradient from 0-1 window to
		//		"from"-"to" window blending and replicating colors,
		//		if necessary.
		// stops: Array
		//		input gradient as a list of colors with offsets
		//		(see dojox.gfx.defaultLinearGradient and dojox.gfx.defaultRadialGradient)
		// from: Number
		//		the beginning of the window, should be less than "to"
		// to: Number
		//		the end of the window, should be more than "from"

		var len = stops.length, reverseFlag = (to < from), newStops;

		// do we need to reverse the color table?
		if(reverseFlag){
			var tmp = from;
			from = to;
			to = tmp;
		}
		
		// various edge cases
		if(!len){
			// no colors
			return [];
		}
		if(to <= stops[0].offset){
			// all colors are before the color table
			newStops = [
				{offset: 0, color: stops[0].color},
				{offset: 1, color: stops[0].color}
			];
		}else if(from >= stops[len - 1].offset){
			// all colors are after the color table
			newStops = [
				{offset: 0, color: stops[len - 1].color},
				{offset: 1, color: stops[len - 1].color}
			];
		}else{
			// main scanning algorithm
			var span = to - from, stop, prev, i;
			newStops = [];
			if(from < 0){
				newStops.push({offset: 0, color: new C(stops[0].color)});
			}
			for(i = 0; i < len; ++i){
				stop = stops[i];
				if(stop.offset >= from){
					break;
				}
				// skip this color
			}
			if(i){
				prev = stops[i - 1];
				newStops.push({
					offset: 0,
					color: Color.blendColors(new C(prev.color), new C(stop.color), (from - prev.offset) / (stop.offset - prev.offset))
				});
			}else{
				newStops.push({offset: 0, color: new C(stop.color)});
			}
			for(; i < len; ++i){
				stop = stops[i];
				if(stop.offset >= to){
					break;
				}
				newStops.push({offset: (stop.offset - from) / span, color: new C(stop.color)});
			}
			if(i < len){
				prev = stops[i - 1];
				newStops.push({
					offset: 1,
					color: Color.blendColors(new C(prev.color), new C(stop.color), (to - prev.offset) / (stop.offset - prev.offset))
				});
			}else{
				newStops.push({offset: 1, color: new C(stops[len - 1].color)});
			}
		}
		
		// reverse the color table, if needed
		if(reverseFlag){
			newStops.reverse();
			for(i = 0, len = newStops.length; i < len; ++i){
				stop = newStops[i];
				stop.offset = 1 - stop.offset;
			}
		}
		
		return newStops;
	};
	
	function getPoint(x, y, matrix, project, shiftAndRotate, scale){
		var r = m.multiplyPoint(matrix, x, y),
			p = m.multiplyPoint(project, r);
		return {r: r, p: p, o: m.multiplyPoint(shiftAndRotate, p).x / scale};
	}
	
	function sortPoints(a, b){
		return a.o - b.o;
	}
	
	grad.project = function(matrix, gradient, tl, rb, ttl, trb){
		// summary:
		//		Returns a new gradient using the "VML algorithm" and suitable for VML.
		// matrix: dojox.gfx.Matrix2D|Null:
		//		matrix to apply to a shape and its gradient
		// gradient: Object:
		//		a linear gradient object to be transformed
		// tl: dojox.gfx.Point:
		//		top-left corner of shape's bounding box
		// rb: dojox.gfx.Point:
		//		right-bottom corner of shape's bounding box
		// ttl: dojox.gfx.Point:
		//		top-left corner of shape's transformed bounding box
		// trb: dojox.gfx.Point:
		//		right-bottom corner of shape's transformed bounding box
		
		matrix = matrix || m.identity;

		var f1 = m.multiplyPoint(matrix, gradient.x1, gradient.y1),
			f2 = m.multiplyPoint(matrix, gradient.x2, gradient.y2),
			angle = Math.atan2(f2.y - f1.y, f2.x - f1.x),
			project = m.project(f2.x - f1.x, f2.y - f1.y),
			pf1 = m.multiplyPoint(project, f1),
			pf2 = m.multiplyPoint(project, f2),
			shiftAndRotate = new m.Matrix2D([m.rotate(-angle), {dx: -pf1.x, dy: -pf1.y}]),
			scale = m.multiplyPoint(shiftAndRotate, pf2).x,
			//comboMatrix = new m.Matrix2D([shiftAndRotate, project, matrix]),
			// bbox-specific calculations
			points = [
					getPoint(tl.x, tl.y, matrix, project, shiftAndRotate, scale),
					getPoint(rb.x, rb.y, matrix, project, shiftAndRotate, scale),
					getPoint(tl.x, rb.y, matrix, project, shiftAndRotate, scale),
					getPoint(rb.x, tl.y, matrix, project, shiftAndRotate, scale)
				].sort(sortPoints),
			from = points[0].o,
			to   = points[3].o,
			stops = grad.rescale(gradient.colors, from, to),
			//angle2 = Math.atan2(Math.abs(points[3].r.y - points[0].r.y) * (f2.y - f1.y), Math.abs(points[3].r.x - points[0].r.x) * (f2.x - f1.x));
			angle2 = Math.atan2(points[3].r.y - points[0].r.y, points[3].r.x - points[0].r.x);

		return {
			type: "linear",
			x1: points[0].p.x, y1: points[0].p.y, x2: points[3].p.x, y2: points[3].p.y,
			colors: stops,
			// additional helpers (for VML)
			angle: angle
		};
	};
	
	return grad;
});

},
'dijit/form/_ToggleButtonMixin':function(){
define("dijit/form/_ToggleButtonMixin", [
	"dojo/_base/declare", // declare
	"dojo/dom-attr" // domAttr.set
], function(declare, domAttr){

// module:
//		dijit/form/_ToggleButtonMixin
// summary:
//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

return declare("dijit.form._ToggleButtonMixin", null, {
	// summary:
	//		A mixin to provide functionality to allow a button that can be in two states (checked or not).

	// checked: Boolean
	//		Corresponds to the native HTML <input> element's attribute.
	//		In markup, specified as "checked='checked'" or just "checked".
	//		True if the button is depressed, or the checkbox is checked,
	//		or the radio button is selected, etc.
	checked: false,

	// aria-pressed for toggle buttons, and aria-checked for checkboxes
	_aria_attr: "aria-pressed",

	_onClick: function(/*Event*/ evt){
		var original = this.checked;
		this._set('checked', !original); // partially set the toggled value, assuming the toggle will work, so it can be overridden in the onclick handler
		var ret = this.inherited(arguments); // the user could reset the value here
		this.set('checked', ret ? this.checked : original); // officially set the toggled or user value, or reset it back
		return ret;
	},

	_setCheckedAttr: function(/*Boolean*/ value, /*Boolean?*/ priorityChange){
		this._set("checked", value);
		domAttr.set(this.focusNode || this.domNode, "checked", value);
		(this.focusNode || this.domNode).setAttribute(this._aria_attr, value ? "true" : "false"); // aria values should be strings
		this._handleOnChange(value, priorityChange);
	},

	reset: function(){
		// summary:
		//		Reset the widget's value to what it was at initialization time

		this._hasBeenBlurred = false;

		// set checked state to original setting
		this.set('checked', this.params.checked || false);
	}
});

});

},
'dojo/dnd/Container':function(){
define("dojo/dnd/Container", ["../main", "../Evented", "./common", "../parser"], function(dojo, Evented) {
	// module:
	//		dojo/dnd/Container
	// summary:
	//		TODOC


/*
	Container states:
		""		- normal state
		"Over"	- mouse over a container
	Container item states:
		""		- normal state
		"Over"	- mouse over a container item
*/

/*=====
dojo.declare("dojo.dnd.__ContainerArgs", [], {
	creator: function(){
		// summary:
		//		a creator function, which takes a data item, and returns an object like that:
		//		{node: newNode, data: usedData, type: arrayOfStrings}
	},

	// skipForm: Boolean
	//		don't start the drag operation, if clicked on form elements
	skipForm: false,

	// dropParent: Node||String
	//		node or node's id to use as the parent node for dropped items
	//		(must be underneath the 'node' parameter in the DOM)
	dropParent: null,

	// _skipStartup: Boolean
	//		skip startup(), which collects children, for deferred initialization
	//		(this is used in the markup mode)
	_skipStartup: false
});

dojo.dnd.Item = function(){
	// summary:
	//		Represents (one of) the source node(s) being dragged.
	//		Contains (at least) the "type" and "data" attributes.
	// type: String[]
	//		Type(s) of this item, by default this is ["text"]
	// data: Object
	//		Logical representation of the object being dragged.
	//		If the drag object's type is "text" then data is a String,
	//		if it's another type then data could be a different Object,
	//		perhaps a name/value hash.

	this.type = type;
	this.data = data;
}
=====*/

dojo.declare("dojo.dnd.Container", Evented, {
	// summary:
	//		a Container object, which knows when mouse hovers over it,
	//		and over which element it hovers

	// object attributes (for markup)
	skipForm: false,

	/*=====
	// current: DomNode
	//		The DOM node the mouse is currently hovered over
	current: null,

	// map: Hash<String, dojo.dnd.Item>
	//		Map from an item's id (which is also the DOMNode's id) to
	//		the dojo.dnd.Item itself.
	map: {},
	=====*/

	constructor: function(node, params){
		// summary:
		//		a constructor of the Container
		// node: Node
		//		node or node's id to build the container on
		// params: dojo.dnd.__ContainerArgs
		//		a dictionary of parameters
		this.node = dojo.byId(node);
		if(!params){ params = {}; }
		this.creator = params.creator || null;
		this.skipForm = params.skipForm;
		this.parent = params.dropParent && dojo.byId(params.dropParent);

		// class-specific variables
		this.map = {};
		this.current = null;

		// states
		this.containerState = "";
		dojo.addClass(this.node, "dojoDndContainer");

		// mark up children
		if(!(params && params._skipStartup)){
			this.startup();
		}

		// set up events
		this.events = [
			dojo.connect(this.node, "onmouseover", this, "onMouseOver"),
			dojo.connect(this.node, "onmouseout",  this, "onMouseOut"),
			// cancel text selection and text dragging
			dojo.connect(this.node, "ondragstart",   this, "onSelectStart"),
			dojo.connect(this.node, "onselectstart", this, "onSelectStart")
		];
	},

	// object attributes (for markup)
	creator: function(){
		// summary:
		//		creator function, dummy at the moment
	},

	// abstract access to the map
	getItem: function(/*String*/ key){
		// summary:
		//		returns a data item by its key (id)
		return this.map[key];	// dojo.dnd.Item
	},
	setItem: function(/*String*/ key, /*dojo.dnd.Item*/ data){
		// summary:
		//		associates a data item with its key (id)
		this.map[key] = data;
	},
	delItem: function(/*String*/ key){
		// summary:
		//		removes a data item from the map by its key (id)
		delete this.map[key];
	},
	forInItems: function(/*Function*/ f, /*Object?*/ o){
		// summary:
		//		iterates over a data map skipping members that
		//		are present in the empty object (IE and/or 3rd-party libraries).
		o = o || dojo.global;
		var m = this.map, e = dojo.dnd._empty;
		for(var i in m){
			if(i in e){ continue; }
			f.call(o, m[i], i, this);
		}
		return o;	// Object
	},
	clearItems: function(){
		// summary:
		//		removes all data items from the map
		this.map = {};
	},

	// methods
	getAllNodes: function(){
		// summary:
		//		returns a list (an array) of all valid child nodes
		return dojo.query("> .dojoDndItem", this.parent);	// NodeList
	},
	sync: function(){
		// summary:
		//		sync up the node list with the data map
		var map = {};
		this.getAllNodes().forEach(function(node){
			if(node.id){
				var item = this.getItem(node.id);
				if(item){
					map[node.id] = item;
					return;
				}
			}else{
				node.id = dojo.dnd.getUniqueId();
			}
			var type = node.getAttribute("dndType"),
				data = node.getAttribute("dndData");
			map[node.id] = {
				data: data || node.innerHTML,
				type: type ? type.split(/\s*,\s*/) : ["text"]
			};
		}, this);
		this.map = map;
		return this;	// self
	},
	insertNodes: function(data, before, anchor){
		// summary:
		//		inserts an array of new nodes before/after an anchor node
		// data: Array
		//		a list of data items, which should be processed by the creator function
		// before: Boolean
		//		insert before the anchor, if true, and after the anchor otherwise
		// anchor: Node
		//		the anchor node to be used as a point of insertion
		if(!this.parent.firstChild){
			anchor = null;
		}else if(before){
			if(!anchor){
				anchor = this.parent.firstChild;
			}
		}else{
			if(anchor){
				anchor = anchor.nextSibling;
			}
		}
		if(anchor){
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.insertBefore(t.node, anchor);
			}
		}else{
			for(var i = 0; i < data.length; ++i){
				var t = this._normalizedCreator(data[i]);
				this.setItem(t.node.id, {data: t.data, type: t.type});
				this.parent.appendChild(t.node);
			}
		}
		return this;	// self
	},
	destroy: function(){
		// summary:
		//		prepares this object to be garbage-collected
		dojo.forEach(this.events, dojo.disconnect);
		this.clearItems();
		this.node = this.parent = this.current = null;
	},

	// markup methods
	markupFactory: function(params, node, ctor){
		params._skipStartup = true;
		return new ctor(node, params);
	},
	startup: function(){
		// summary:
		//		collects valid child items and populate the map

		// set up the real parent node
		if(!this.parent){
			// use the standard algorithm, if not assigned
			this.parent = this.node;
			if(this.parent.tagName.toLowerCase() == "table"){
				var c = this.parent.getElementsByTagName("tbody");
				if(c && c.length){ this.parent = c[0]; }
			}
		}
		this.defaultCreator = dojo.dnd._defaultCreator(this.parent);

		// process specially marked children
		this.sync();
	},

	// mouse events
	onMouseOver: function(e){
		// summary:
		//		event processor for onmouseover
		// e: Event
		//		mouse event
		var n = e.relatedTarget;
		while(n){
			if(n == this.node){ break; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(!n){
			this._changeState("Container", "Over");
			this.onOverEvent();
		}
		n = this._getChildByEvent(e);
		if(this.current == n){ return; }
		if(this.current){ this._removeItemClass(this.current, "Over"); }
		if(n){ this._addItemClass(n, "Over"); }
		this.current = n;
	},
	onMouseOut: function(e){
		// summary:
		//		event processor for onmouseout
		// e: Event
		//		mouse event
		for(var n = e.relatedTarget; n;){
			if(n == this.node){ return; }
			try{
				n = n.parentNode;
			}catch(x){
				n = null;
			}
		}
		if(this.current){
			this._removeItemClass(this.current, "Over");
			this.current = null;
		}
		this._changeState("Container", "");
		this.onOutEvent();
	},
	onSelectStart: function(e){
		// summary:
		//		event processor for onselectevent and ondragevent
		// e: Event
		//		mouse event
		if(!this.skipForm || !dojo.dnd.isFormElement(e)){
			dojo.stopEvent(e);
		}
	},

	// utilities
	onOverEvent: function(){
		// summary:
		//		this function is called once, when mouse is over our container
	},
	onOutEvent: function(){
		// summary:
		//		this function is called once, when mouse is out of our container
	},
	_changeState: function(type, newState){
		// summary:
		//		changes a named state to new state value
		// type: String
		//		a name of the state to change
		// newState: String
		//		new state
		var prefix = "dojoDnd" + type;
		var state  = type.toLowerCase() + "State";
		//dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		dojo.replaceClass(this.node, prefix + newState, prefix + this[state]);
		this[state] = newState;
	},
	_addItemClass: function(node, type){
		// summary:
		//		adds a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.addClass(node, "dojoDndItem" + type);
	},
	_removeItemClass: function(node, type){
		// summary:
		//		removes a class with prefix "dojoDndItem"
		// node: Node
		//		a node
		// type: String
		//		a variable suffix for a class name
		dojo.removeClass(node, "dojoDndItem" + type);
	},
	_getChildByEvent: function(e){
		// summary:
		//		gets a child, which is under the mouse at the moment, or null
		// e: Event
		//		a mouse event
		var node = e.target;
		if(node){
			for(var parent = node.parentNode; parent; node = parent, parent = node.parentNode){
				if(parent == this.parent && dojo.hasClass(node, "dojoDndItem")){ return node; }
			}
		}
		return null;
	},
	_normalizedCreator: function(/*dojo.dnd.Item*/ item, /*String*/ hint){
		// summary:
		//		adds all necessary data to the output of the user-supplied creator function
		var t = (this.creator || this.defaultCreator).call(this, item, hint);
		if(!dojo.isArray(t.type)){ t.type = ["text"]; }
		if(!t.node.id){ t.node.id = dojo.dnd.getUniqueId(); }
		dojo.addClass(t.node, "dojoDndItem");
		return t;
	}
});

dojo.dnd._createNode = function(tag){
	// summary:
	//		returns a function, which creates an element of given tag
	//		(SPAN by default) and sets its innerHTML to given text
	// tag: String
	//		a tag name or empty for SPAN
	if(!tag){ return dojo.dnd._createSpan; }
	return function(text){	// Function
		return dojo.create(tag, {innerHTML: text});	// Node
	};
};

dojo.dnd._createTrTd = function(text){
	// summary:
	//		creates a TR/TD structure with given text as an innerHTML of TD
	// text: String
	//		a text for TD
	var tr = dojo.create("tr");
	dojo.create("td", {innerHTML: text}, tr);
	return tr;	// Node
};

dojo.dnd._createSpan = function(text){
	// summary:
	//		creates a SPAN element with given text as its innerHTML
	// text: String
	//		a text for SPAN
	return dojo.create("span", {innerHTML: text});	// Node
};

// dojo.dnd._defaultCreatorNodes: Object
//		a dictionary that maps container tag names to child tag names
dojo.dnd._defaultCreatorNodes = {ul: "li", ol: "li", div: "div", p: "div"};

dojo.dnd._defaultCreator = function(node){
	// summary:
	//		takes a parent node, and returns an appropriate creator function
	// node: Node
	//		a container node
	var tag = node.tagName.toLowerCase();
	var c = tag == "tbody" || tag == "thead" ? dojo.dnd._createTrTd :
			dojo.dnd._createNode(dojo.dnd._defaultCreatorNodes[tag]);
	return function(item, hint){	// Function
		var isObj = item && dojo.isObject(item), data, type, n;
		if(isObj && item.tagName && item.nodeType && item.getAttribute){
			// process a DOM node
			data = item.getAttribute("dndData") || item.innerHTML;
			type = item.getAttribute("dndType");
			type = type ? type.split(/\s*,\s*/) : ["text"];
			n = item;	// this node is going to be moved rather than copied
		}else{
			// process a DnD item object or a string
			data = (isObj && item.data) ? item.data : item;
			type = (isObj && item.type) ? item.type : ["text"];
			n = (hint == "avatar" ? dojo.dnd._createSpan : c)(String(data));
		}
		if(!n.id){
			n.id = dojo.dnd.getUniqueId();
		}
		return {node: n, data: data, type: type};
	};
};

return dojo.dnd.Container;
});

},
'dijit/_Widget':function(){
define("dijit/_Widget", [
	"dojo/aspect",	// aspect.around
	"dojo/_base/config",	// config.isDebug
	"dojo/_base/connect",	// connect.connect
	"dojo/_base/declare", // declare
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/_base/lang", // lang.hitch
	"dojo/query",
	"dojo/ready",
	"./registry",	// registry.byNode
	"./_WidgetBase",
	"./_OnDijitClickMixin",
	"./_FocusMixin",
	"dojo/uacss",		// browser sniffing (included for back-compat; subclasses may be using)
	"./hccss"		// high contrast mode sniffing (included to set CSS classes on <body>, module ret value unused)
], function(aspect, config, connect, declare, kernel, lang, query, ready,
			registry, _WidgetBase, _OnDijitClickMixin, _FocusMixin){

/*=====
	var _WidgetBase = dijit._WidgetBase;
	var _OnDijitClickMixin = dijit._OnDijitClickMixin;
	var _FocusMixin = dijit._FocusMixin;
=====*/


// module:
//		dijit/_Widget
// summary:
//		Old base for widgets.   New widgets should extend _WidgetBase instead


function connectToDomNode(){
	// summary:
	//		If user connects to a widget method === this function, then they will
	//		instead actually be connecting the equivalent event on this.domNode
}

// Trap dojo.connect() calls to connectToDomNode methods, and redirect to _Widget.on()
function aroundAdvice(originalConnect){
	return function(obj, event, scope, method){
		if(obj && typeof event == "string" && obj[event] == connectToDomNode){
			return obj.on(event.substring(2).toLowerCase(), lang.hitch(scope, method));
		}
		return originalConnect.apply(connect, arguments);
	};
}
aspect.around(connect, "connect", aroundAdvice);
if(kernel.connect){
	aspect.around(kernel, "connect", aroundAdvice);
}

var _Widget = declare("dijit._Widget", [_WidgetBase, _OnDijitClickMixin, _FocusMixin], {
	// summary:
	//		Base class for all Dijit widgets.
	//
	//		Extends _WidgetBase, adding support for:
	//			- declaratively/programatically specifying widget initialization parameters like
	//				onMouseMove="foo" that call foo when this.domNode gets a mousemove event
	//			- ondijitclick
	//				Support new data-dojo-attach-event="ondijitclick: ..." that is triggered by a mouse click or a SPACE/ENTER keypress
	//			- focus related functions
	//				In particular, the onFocus()/onBlur() callbacks.   Driven internally by
	//				dijit/_base/focus.js.
	//			- deprecated methods
	//			- onShow(), onHide(), onClose()
	//
	//		Also, by loading code in dijit/_base, turns on:
	//			- browser sniffing (putting browser id like .dj_ie on <html> node)
	//			- high contrast mode sniffing (add .dijit_a11y class to <body> if machine is in high contrast mode)


	////////////////// DEFERRED CONNECTS ///////////////////

	onClick: connectToDomNode,
	/*=====
	onClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onDblClick: connectToDomNode,
	/*=====
	onDblClick: function(event){
		// summary:
		//		Connect to this function to receive notifications of mouse double click events.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onKeyDown: connectToDomNode,
	/*=====
	onKeyDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being pressed down.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyPress: connectToDomNode,
	/*=====
	onKeyPress: function(event){
		// summary:
		//		Connect to this function to receive notifications of printable keys being typed.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onKeyUp: connectToDomNode,
	/*=====
	onKeyUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of keys being released.
		// event:
		//		key Event
		// tags:
		//		callback
	},
	=====*/
	onMouseDown: connectToDomNode,
	/*=====
	onMouseDown: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is pressed down.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseMove: connectToDomNode,
	/*=====
	onMouseMove: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOut: connectToDomNode,
	/*=====
	onMouseOut: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseOver: connectToDomNode,
	/*=====
	onMouseOver: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseLeave: connectToDomNode,
	/*=====
	onMouseLeave: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves off of this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseEnter: connectToDomNode,
	/*=====
	onMouseEnter: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse moves onto this widget.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/
	onMouseUp: connectToDomNode,
	/*=====
	onMouseUp: function(event){
		// summary:
		//		Connect to this function to receive notifications of when the mouse button is released.
		// event:
		//		mouse Event
		// tags:
		//		callback
	},
	=====*/

	constructor: function(params){
		// extract parameters like onMouseMove that should connect directly to this.domNode
		this._toConnect = {};
		for(var name in params){
			if(this[name] === connectToDomNode){
				this._toConnect[name.replace(/^on/, "").toLowerCase()] = params[name];
				delete params[name];
			}
		}
	},

	postCreate: function(){
		this.inherited(arguments);

		// perform connection from this.domNode to user specified handlers (ex: onMouseMove)
		for(var name in this._toConnect){
			this.on(name, this._toConnect[name]);
		}
		delete this._toConnect;
	},

	on: function(/*String*/ type, /*Function*/ func){
		if(this[this._onMap(type)] === connectToDomNode){
			// Use connect.connect() rather than on() to get handling for "onmouseenter" on non-IE, etc.
			// Also, need to specify context as "this" rather than the default context of the DOMNode
			return connect.connect(this.domNode, type.toLowerCase(), this, func);
		}
		return this.inherited(arguments);
	},

	_setFocusedAttr: function(val){
		// Remove this method in 2.0 (or sooner), just here to set _focused == focused, for back compat
		// (but since it's a private variable we aren't required to keep supporting it).
		this._focused = val;
		this._set("focused", val);
	},

	////////////////// DEPRECATED METHODS ///////////////////

	setAttribute: function(/*String*/ attr, /*anything*/ value){
		// summary:
		//		Deprecated.  Use set() instead.
		// tags:
		//		deprecated
		kernel.deprecated(this.declaredClass+"::setAttribute(attr, value) is deprecated. Use set() instead.", "", "2.0");
		this.set(attr, value);
	},

	attr: function(/*String|Object*/name, /*Object?*/value){
		// summary:
		//		Set or get properties on a widget instance.
		//	name:
		//		The property to get or set. If an object is passed here and not
		//		a string, its keys are used as names of attributes to be set
		//		and the value of the object as values to set in the widget.
		//	value:
		//		Optional. If provided, attr() operates as a setter. If omitted,
		//		the current value of the named property is returned.
		// description:
		//		This method is deprecated, use get() or set() directly.

		// Print deprecation warning but only once per calling function
		if(config.isDebug){
			var alreadyCalledHash = arguments.callee._ach || (arguments.callee._ach = {}),
				caller = (arguments.callee.caller || "unknown caller").toString();
			if(!alreadyCalledHash[caller]){
				kernel.deprecated(this.declaredClass + "::attr() is deprecated. Use get() or set() instead, called from " +
				caller, "", "2.0");
				alreadyCalledHash[caller] = true;
			}
		}

		var args = arguments.length;
		if(args >= 2 || typeof name === "object"){ // setter
			return this.set.apply(this, arguments);
		}else{ // getter
			return this.get(name);
		}
	},

	getDescendants: function(){
		// summary:
		//		Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
		//		This method should generally be avoided as it returns widgets declared in templates, which are
		//		supposed to be internal/hidden, but it's left here for back-compat reasons.

		kernel.deprecated(this.declaredClass+"::getDescendants() is deprecated. Use getChildren() instead.", "", "2.0");
		return this.containerNode ? query('[widgetId]', this.containerNode).map(registry.byNode) : []; // dijit._Widget[]
	},

	////////////////// MISCELLANEOUS METHODS ///////////////////

	_onShow: function(){
		// summary:
		//		Internal method called when this widget is made visible.
		//		See `onShow` for details.
		this.onShow();
	},

	onShow: function(){
		// summary:
		//		Called when this widget becomes the selected pane in a
		//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
		//		`dijit.layout.AccordionContainer`, etc.
		//
		//		Also called to indicate display of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
		// tags:
		//		callback
	},

	onHide: function(){
		// summary:
			//		Called when another widget becomes the selected pane in a
			//		`dijit.layout.TabContainer`, `dijit.layout.StackContainer`,
			//		`dijit.layout.AccordionContainer`, etc.
			//
			//		Also called to indicate hide of a `dijit.Dialog`, `dijit.TooltipDialog`, or `dijit.TitlePane`.
			// tags:
			//		callback
	},

	onClose: function(){
		// summary:
		//		Called when this widget is being displayed as a popup (ex: a Calendar popped
		//		up from a DateTextBox), and it is hidden.
		//		This is called from the dijit.popup code, and should not be called directly.
		//
		//		Also used as a parameter for children of `dijit.layout.StackContainer` or subclasses.
		//		Callback if a user tries to close the child.   Child will be closed if this function returns true.
		// tags:
		//		extension

		return true;		// Boolean
	}
});

// For back-compat, remove in 2.0.
if(!kernel.isAsync){
	ready(0, function(){
		var requires = ["dijit/_base"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}
return _Widget;
});

},
'dojo/touch':function(){
define("dojo/touch", ["./_base/kernel", "./on", "./has", "./mouse"], function(dojo, on, has, mouse){
// module:
//		dojo/touch

/*=====
	dojo.touch = {
		// summary:
		//		This module provides unified touch event handlers by exporting
		//		press, move, release and cancel which can also run well on desktop.
		//		Based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
		//
		// example:
		//		1. Used with dojo.connect()
		//		|	dojo.connect(node, dojo.touch.press, function(e){});
		//		|	dojo.connect(node, dojo.touch.move, function(e){});
		//		|	dojo.connect(node, dojo.touch.release, function(e){});
		//		|	dojo.connect(node, dojo.touch.cancel, function(e){});
		//
		//		2. Used with dojo.on
		//		|	define(["dojo/on", "dojo/touch"], function(on, touch){
		//		|		on(node, touch.press, function(e){});
		//		|		on(node, touch.move, function(e){});
		//		|		on(node, touch.release, function(e){});
		//		|		on(node, touch.cancel, function(e){});
		//
		//		3. Used with dojo.touch.* directly
		//		|	dojo.touch.press(node, function(e){});
		//		|	dojo.touch.move(node, function(e){});
		//		|	dojo.touch.release(node, function(e){});
		//		|	dojo.touch.cancel(node, function(e){});
		
		press: function(node, listener){
			// summary:
			//		Register a listener to 'touchstart'|'mousedown' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		move: function(node, listener){
			// summary:
			//		Register a listener to 'touchmove'|'mousemove' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		release: function(node, listener){
			// summary:
			//		Register a listener to 'touchend'|'mouseup' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		},
		cancel: function(node, listener){
			// summary:
			//		Register a listener to 'touchcancel'|'mouseleave' for the given node
			// node: Dom
			//		Target node to listen to
			// listener: Function
			//		Callback function
			// returns:
			//		A handle which will be used to remove the listener by handle.remove()
		}
	};
=====*/

	function _handle(/*String - press | move | release | cancel*/type){
		return function(node, listener){//called by on(), see dojo.on
			return on(node, type, listener);
		};
	}
	var touch = has("touch");
	//device neutral events - dojo.touch.press|move|release|cancel
	dojo.touch = {
		press: _handle(touch ? "touchstart": "mousedown"),
		move: _handle(touch ? "touchmove": "mousemove"),
		release: _handle(touch ? "touchend": "mouseup"),
		cancel: touch ? _handle("touchcancel") : mouse.leave
	};
	return dojo.touch;
});
},
'dojox/grid/DataSelection':function(){
define("dojox/grid/DataSelection", [
	"dojo/_base/declare",
	"./_SelectionPreserver",
	"./Selection"
], function(declare, _SelectionPreserver, Selection){
	
return declare("dojox.grid.DataSelection", Selection, {
	constructor: function(grid){
		if(grid.keepSelection){
			this.preserver = new _SelectionPreserver(this);
		}
	},
	
	destroy: function(){
		if(this.preserver){
			this.preserver.destroy();
		}
	},
	
	getFirstSelected: function(){
		var idx = Selection.prototype.getFirstSelected.call(this);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getNextSelected: function(inPrev){
		var old_idx = this.grid.getItemIndex(inPrev);
		var idx = Selection.prototype.getNextSelected.call(this, old_idx);

		if(idx == -1){ return null; }
		return this.grid.getItem(idx);
	},

	getSelected: function(){
		var result = [];
		for(var i=0, l=this.selected.length; i<l; i++){
			if(this.selected[i]){
				result.push(this.grid.getItem(i));
			}
		}
		return result;
	},

	addToSelection: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		Selection.prototype.addToSelection.call(this, idx);
	},

	deselect: function(inItemOrIndex){
		if(this.mode == 'none'){ return; }
		var idx = null;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			idx = inItemOrIndex;
		}else{
			idx = this.grid.getItemIndex(inItemOrIndex);
		}
		Selection.prototype.deselect.call(this, idx);
	},

	deselectAll: function(inItemOrIndex){
		var idx = null;
		if(inItemOrIndex || typeof inItemOrIndex == "number"){
			if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
				idx = inItemOrIndex;
			}else{
				idx = this.grid.getItemIndex(inItemOrIndex);
			}
			Selection.prototype.deselectAll.call(this, idx);
		}else{
			this.inherited(arguments);
		}
	}
});
});
},
'dojo/fx':function(){
define("dojo/fx", [
	"./_base/lang",
	"./Evented",
	"./_base/kernel",
	"./_base/array",
	"./_base/connect",
	"./_base/fx",
	"./dom",
	"./dom-style",
	"./dom-geometry",
	"./ready",
	"require" // for context sensitive loading of Toggler
], function(lang, Evented, dojo, arrayUtil, connect, baseFx, dom, domStyle, geom, ready, require) {

	// module:
	//		dojo/fx
	// summary:
	//		TODOC


	/*=====
	dojo.fx = {
		// summary: Effects library on top of Base animations
	};
	var coreFx = dojo.fx;
	=====*/
	
// For back-compat, remove in 2.0.
if(!dojo.isAsync){
	ready(0, function(){
		var requires = ["./fx/Toggler"];
		require(requires);	// use indirection so modules not rolled into a build
	});
}

	var coreFx = dojo.fx = {};

	var _baseObj = {
			_fire: function(evt, args){
				if(this[evt]){
					this[evt].apply(this, args||[]);
				}
				return this;
			}
		};

	var _chain = function(animations){
		this._index = -1;
		this._animations = animations||[];
		this._current = this._onAnimateCtx = this._onEndCtx = null;

		this.duration = 0;
		arrayUtil.forEach(this._animations, function(a){
			this.duration += a.duration;
			if(a.delay){ this.duration += a.delay; }
		}, this);
	};
	_chain.prototype = new Evented();
	lang.extend(_chain, {
		_onAnimate: function(){
			this._fire("onAnimate", arguments);
		},
		_onEnd: function(){
			connect.disconnect(this._onAnimateCtx);
			connect.disconnect(this._onEndCtx);
			this._onAnimateCtx = this._onEndCtx = null;
			if(this._index + 1 == this._animations.length){
				this._fire("onEnd");
			}else{
				// switch animations
				this._current = this._animations[++this._index];
				this._onAnimateCtx = connect.connect(this._current, "onAnimate", this, "_onAnimate");
				this._onEndCtx = connect.connect(this._current, "onEnd", this, "_onEnd");
				this._current.play(0, true);
			}
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			if(!this._current){ this._current = this._animations[this._index = 0]; }
			if(!gotoStart && this._current.status() == "playing"){ return this; }
			var beforeBegin = connect.connect(this._current, "beforeBegin", this, function(){
					this._fire("beforeBegin");
				}),
				onBegin = connect.connect(this._current, "onBegin", this, function(arg){
					this._fire("onBegin", arguments);
				}),
				onPlay = connect.connect(this._current, "onPlay", this, function(arg){
					this._fire("onPlay", arguments);
					connect.disconnect(beforeBegin);
					connect.disconnect(onBegin);
					connect.disconnect(onPlay);
				});
			if(this._onAnimateCtx){
				connect.disconnect(this._onAnimateCtx);
			}
			this._onAnimateCtx = connect.connect(this._current, "onAnimate", this, "_onAnimate");
			if(this._onEndCtx){
				connect.disconnect(this._onEndCtx);
			}
			this._onEndCtx = connect.connect(this._current, "onEnd", this, "_onEnd");
			this._current.play.apply(this._current, arguments);
			return this;
		},
		pause: function(){
			if(this._current){
				var e = connect.connect(this._current, "onPause", this, function(arg){
						this._fire("onPause", arguments);
						connect.disconnect(e);
					});
				this._current.pause();
			}
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			this.pause();
			var offset = this.duration * percent;
			this._current = null;
			arrayUtil.some(this._animations, function(a){
				if(a.duration <= offset){
					this._current = a;
					return true;
				}
				offset -= a.duration;
				return false;
			});
			if(this._current){
				this._current.gotoPercent(offset / this._current.duration, andPlay);
			}
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			if(this._current){
				if(gotoEnd){
					for(; this._index + 1 < this._animations.length; ++this._index){
						this._animations[this._index].stop(true);
					}
					this._current = this._animations[this._index];
				}
				var e = connect.connect(this._current, "onStop", this, function(arg){
						this._fire("onStop", arguments);
						connect.disconnect(e);
					});
				this._current.stop();
			}
			return this;
		},
		status: function(){
			return this._current ? this._current.status() : "stopped";
		},
		destroy: function(){
			if(this._onAnimateCtx){ connect.disconnect(this._onAnimateCtx); }
			if(this._onEndCtx){ connect.disconnect(this._onEndCtx); }
		}
	});
	lang.extend(_chain, _baseObj);

	coreFx.chain = /*===== dojo.fx.chain = =====*/ function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Chain a list of `dojo.Animation`s to run in sequence
		//
		// description:
		//		Return a `dojo.Animation` which will play all passed
		//		`dojo.Animation` instances in sequence, firing its own
		//		synthesized events simulating a single animation. (eg:
		//		onEnd of this animation means the end of the chain,
		//		not the individual animations within)
		//
		// example:
		//	Once `node` is faded out, fade in `otherNode`
		//	|	dojo.fx.chain([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		return new _chain(animations); // dojo.Animation
	};

	var _combine = function(animations){
		this._animations = animations||[];
		this._connects = [];
		this._finished = 0;

		this.duration = 0;
		arrayUtil.forEach(animations, function(a){
			var duration = a.duration;
			if(a.delay){ duration += a.delay; }
			if(this.duration < duration){ this.duration = duration; }
			this._connects.push(connect.connect(a, "onEnd", this, "_onEnd"));
		}, this);

		this._pseudoAnimation = new baseFx.Animation({curve: [0, 1], duration: this.duration});
		var self = this;
		arrayUtil.forEach(["beforeBegin", "onBegin", "onPlay", "onAnimate", "onPause", "onStop", "onEnd"],
			function(evt){
				self._connects.push(connect.connect(self._pseudoAnimation, evt,
					function(){ self._fire(evt, arguments); }
				));
			}
		);
	};
	lang.extend(_combine, {
		_doAction: function(action, args){
			arrayUtil.forEach(this._animations, function(a){
				a[action].apply(a, args);
			});
			return this;
		},
		_onEnd: function(){
			if(++this._finished > this._animations.length){
				this._fire("onEnd");
			}
		},
		_call: function(action, args){
			var t = this._pseudoAnimation;
			t[action].apply(t, args);
		},
		play: function(/*int?*/ delay, /*Boolean?*/ gotoStart){
			this._finished = 0;
			this._doAction("play", arguments);
			this._call("play", arguments);
			return this;
		},
		pause: function(){
			this._doAction("pause", arguments);
			this._call("pause", arguments);
			return this;
		},
		gotoPercent: function(/*Decimal*/percent, /*Boolean?*/ andPlay){
			var ms = this.duration * percent;
			arrayUtil.forEach(this._animations, function(a){
				a.gotoPercent(a.duration < ms ? 1 : (ms / a.duration), andPlay);
			});
			this._call("gotoPercent", arguments);
			return this;
		},
		stop: function(/*boolean?*/ gotoEnd){
			this._doAction("stop", arguments);
			this._call("stop", arguments);
			return this;
		},
		status: function(){
			return this._pseudoAnimation.status();
		},
		destroy: function(){
			arrayUtil.forEach(this._connects, connect.disconnect);
		}
	});
	lang.extend(_combine, _baseObj);

	coreFx.combine = /*===== dojo.fx.combine = =====*/ function(/*dojo.Animation[]*/ animations){
		// summary:
		//		Combine a list of `dojo.Animation`s to run in parallel
		//
		// description:
		//		Combine an array of `dojo.Animation`s to run in parallel,
		//		providing a new `dojo.Animation` instance encompasing each
		//		animation, firing standard animation events.
		//
		// example:
		//	Fade out `node` while fading in `otherNode` simultaneously
		//	|	dojo.fx.combine([
		//	|		dojo.fadeIn({ node:node }),
		//	|		dojo.fadeOut({ node:otherNode })
		//	|	]).play();
		//
		// example:
		//	When the longest animation ends, execute a function:
		//	|	var anim = dojo.fx.combine([
		//	|		dojo.fadeIn({ node: n, duration:700 }),
		//	|		dojo.fadeOut({ node: otherNode, duration: 300 })
		//	|	]);
		//	|	dojo.connect(anim, "onEnd", function(){
		//	|		// overall animation is done.
		//	|	});
		//	|	anim.play(); // play the animation
		//
		return new _combine(animations); // dojo.Animation
	};

	coreFx.wipeIn = /*===== dojo.fx.wipeIn = =====*/ function(/*Object*/ args){
		// summary:
		//		Expand a node to it's natural height.
		//
		// description:
		//		Returns an animation that will expand the
		//		node defined in 'args' object from it's current height to
		//		it's natural height (with no scrollbar).
		//		Node must have no margin/border/padding.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeIn({
		//	|		node:"someId"
		//	|	}).play()
		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					// wrapped in functions so we wait till the last second to query (in case value has changed)
					start: function(){
						// start at current [computed] height, but use 1px rather than 0
						// because 0 causes IE to display the whole panel
						o = s.overflow;
						s.overflow = "hidden";
						if(s.visibility == "hidden" || s.display == "none"){
							s.height = "1px";
							s.display = "";
							s.visibility = "";
							return 1;
						}else{
							var height = domStyle.get(node, "height");
							return Math.max(height, 1);
						}
					},
					end: function(){
						return node.scrollHeight;
					}
				}
			}
		}, args));

		var fini = function(){
			s.height = "auto";
			s.overflow = o;
		};
		connect.connect(anim, "onStop", fini);
		connect.connect(anim, "onEnd", fini);

		return anim; // dojo.Animation
	};

	coreFx.wipeOut = /*===== dojo.fx.wipeOut = =====*/ function(/*Object*/ args){
		// summary:
		//		Shrink a node to nothing and hide it.
		//
		// description:
		//		Returns an animation that will shrink node defined in "args"
		//		from it's current height to 1px, and then hide it.
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on)
		//
		// example:
		//	|	dojo.fx.wipeOut({ node:"someId" }).play()

		var node = args.node = dom.byId(args.node), s = node.style, o;

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				height: {
					end: 1 // 0 causes IE to display the whole panel
				}
			}
		}, args));

		connect.connect(anim, "beforeBegin", function(){
			o = s.overflow;
			s.overflow = "hidden";
			s.display = "";
		});
		var fini = function(){
			s.overflow = o;
			s.height = "auto";
			s.display = "none";
		};
		connect.connect(anim, "onStop", fini);
		connect.connect(anim, "onEnd", fini);

		return anim; // dojo.Animation
	};

	coreFx.slideTo = /*===== dojo.fx.slideTo = =====*/ function(/*Object*/ args){
		// summary:
		//		Slide a node to a new top/left position
		//
		// description:
		//		Returns an animation that will slide "node"
		//		defined in args Object from its current position to
		//		the position defined by (args.left, args.top).
		//
		// args: Object
		//		A hash-map of standard `dojo.Animation` constructor properties
		//		(such as easing: node: duration: and so on). Special args members
		//		are `top` and `left`, which indicate the new position to slide to.
		//
		// example:
		//	|	.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()

		var node = args.node = dom.byId(args.node),
			top = null, left = null;

		var init = (function(n){
			return function(){
				var cs = domStyle.getComputedStyle(n);
				var pos = cs.position;
				top = (pos == 'absolute' ? n.offsetTop : parseInt(cs.top) || 0);
				left = (pos == 'absolute' ? n.offsetLeft : parseInt(cs.left) || 0);
				if(pos != 'absolute' && pos != 'relative'){
					var ret = geom.position(n, true);
					top = ret.y;
					left = ret.x;
					n.style.position="absolute";
					n.style.top=top+"px";
					n.style.left=left+"px";
				}
			};
		})(node);
		init();

		var anim = baseFx.animateProperty(lang.mixin({
			properties: {
				top: args.top || 0,
				left: args.left || 0
			}
		}, args));
		connect.connect(anim, "beforeBegin", anim, init);

		return anim; // dojo.Animation
	};

	return coreFx;
});

},
'dijit/form/nls/ComboBox':function(){
define({ root:
//begin v1.x content
({
		previousMessage: "Previous choices",
		nextMessage: "More choices"
})
//end v1.x content
,
"zh": true,
"zh-tw": true,
"tr": true,
"th": true,
"sv": true,
"sl": true,
"sk": true,
"ru": true,
"ro": true,
"pt": true,
"pt-pt": true,
"pl": true,
"nl": true,
"nb": true,
"ko": true,
"kk": true,
"ja": true,
"it": true,
"hu": true,
"hr": true,
"he": true,
"fr": true,
"fi": true,
"es": true,
"el": true,
"de": true,
"da": true,
"cs": true,
"ca": true,
"az": true,
"ar": true
});

},
'dojox/grid/_SelectionPreserver':function(){
define("dojox/grid/_SelectionPreserver", [
	"dojo/_base/declare",
	"dojo/_base/connect",
	"dojo/_base/lang",
	"dojo/_base/array"
], function(declare, connect, lang, array){

return declare("dojox.grid._SelectionPreserver", null, {
	// summary:
	//		Preserve selections across various user actions.
	//
	// description:
	//		When this feature is turned on, Grid will try to preserve selections across actions, e.g. sorting, filtering etc.
	//
	//		Precondition - Identifier(id) is required for store since id is the only way for differentiating row items.
	//		Known issue - The preserved selections might be inaccurate if some unloaded rows are previously selected by range(e.g.SHIFT + click)
	//
	// example:
	// |	//To turn on this - please set 'keepSelection' attribute to true
	// |	<div dojoType="dojox.grid.DataGrid" keepSelection = true .../>
	// |	<div dojoType="dojox.grid.TreeGrid" keepSelection = true .../>
	// |	<div dojoType="dojox.grid.LazyTreeGrid" keepSelection = true .../>
	
	constructor: function(selection){
		this.selection = selection;
		var grid = this.grid = selection.grid;
		this.reset();
		this._connects = [
			connect.connect(grid, '_setStore', this, 'reset'),
			connect.connect(grid, '_addItem', this, '_reSelectById'),
			connect.connect(selection, 'addToSelection', lang.hitch(this, '_selectById', true)),
			connect.connect(selection, 'deselect', lang.hitch(this, '_selectById', false)),
			connect.connect(selection, 'deselectAll', this, 'reset')
		];
	},
	destroy: function(){
		this.reset();
		array.forEach(this._connects, connect.disconnect);
		delete this._connects;
	},
	reset: function(){
		this._selectedById = {};
	},
	_reSelectById: function(item, index){
		// summary:
		//		When some rows is fetched, determine whether it should be selected.
		if(item && this.grid._hasIdentity){
			this.selection.selected[index] = this._selectedById[this.grid.store.getIdentity(item)];
		}
	},
	_selectById: function(toSelect, inItemOrIndex){
		// summary:
		//		Record selected rows by ID.
		if(this.selection.mode == 'none' || !this.grid._hasIdentity){ return; }
		var item = inItemOrIndex, g = this.grid;
		if(typeof inItemOrIndex == "number" || typeof inItemOrIndex == "string"){
			var entry = g._by_idx[inItemOrIndex];
			item = entry && entry.item;
		}
		if(item){
			this._selectedById[g.store.getIdentity(item)] = !!toSelect;
		}
		return item;
	}
});
});
},
'dojox/gfx/vml':function(){
define("dojox/gfx/vml", ["dojo/_base/lang", "dojo/_base/declare", "dojo/_base/array", "dojo/_base/Color", "dojo/_base/sniff",
		"dojo/_base/config", "dojo/dom", "dojo/dom-geometry", "dojo/_base/window", 
		"./_base", "./shape", "./path", "./arc", "./gradient", "./matrix"],
  function(lang, declare, arr, Color, has, config, dom, domGeom, win, g, gs, pathLib, arcLib, gradient, m){
/*===== 
	dojox.gfx.vml = {
	// module:
	//		dojox/gfx/vml
	// summary:
	//		This the default graphics rendering bridge for IE6-7.
	//		This renderer is very slow.  For best performance on IE6-8, use Silverlight plugin.
	//		IE9+ defaults to the standard W3C SVG renderer.
	};
	g = dojox.gfx;
	pathLib.Path = dojox.gfx.path.Path;
	pathLib.TextPath = dojox.gfx.path.TextPath;
	vml.Shape = dojox.gfx.canvas.Shape;
	gs.Shape = dojox.gfx.shape.Shape;
	gs.Rect = dojox.gfx.shape.Rect;
	gs.Ellipse = dojox.gfx.shape.Ellipse;
	gs.Circle = dojox.gfx.shape.Circle;
	gs.Line = dojox.gfx.shape.Line;
	gs.PolyLine = dojox.gfx.shape.PolyLine;
	gs.Image = dojox.gfx.shape.Image;
	gs.Text = dojox.gfx.shape.Text;
	gs.Surface = dojox.gfx.shape.Surface;
  =====*/
	var vml = g.vml = {};

	// dojox.gfx.vml.xmlns: String: a VML's namespace
	vml.xmlns = "urn:schemas-microsoft-com:vml";

	document.namespaces.add("v", vml.xmlns);
	var vmlElems = ["*", "group", "roundrect", "oval", "shape", "rect", "imagedata", "path", "textpath", "text"],
		i = 0, l = 1, s = document.createStyleSheet();
	if(has("ie") >= 8){
		i = 1;
		l = vmlElems.length;
	}
	for (; i < l; ++i) {
		s.addRule("v\\:" + vmlElems[i], "behavior:url(#default#VML); display:inline-block");
	}

	// dojox.gfx.vml.text_alignment: Object: mapping from SVG alignment to VML alignment
	vml.text_alignment = {start: "left", middle: "center", end: "right"};

	vml._parseFloat = function(str) {
		// summary: a helper function to parse VML-specific floating-point values
		// str: String: a representation of a floating-point number
		return str.match(/^\d+f$/i) ? parseInt(str) / 65536 : parseFloat(str);	// Number
	};

	vml._bool = {"t": 1, "true": 1};

	declare("dojox.gfx.vml.Shape", gs.Shape, {
		// summary: VML-specific implementation of dojox.gfx.Shape methods

		setFill: function(fill){
			// summary: sets a fill object (VML)
			// fill: Object: a fill object
			//	(see dojox.gfx.defaultLinearGradient,
			//	dojox.gfx.defaultRadialGradient,
			//	dojox.gfx.defaultPattern,
			//	or dojo.Color)

			if(!fill){
				// don't fill
				this.fillStyle = null;
				this.rawNode.filled = "f";
				return this;
			}
			var i, f, fo, a, s;
			if(typeof fill == "object" && "type" in fill){
				// gradient
				switch(fill.type){
					case "linear":
						var matrix = this._getRealMatrix(), bbox = this.getBoundingBox(),
							tbbox = this._getRealBBox ? this._getRealBBox() : this.getTransformedBoundingBox();
						s = [];
						if(this.fillStyle !== fill){
							this.fillStyle = g.makeParameters(g.defaultLinearGradient, fill);
						}
						f = g.gradient.project(matrix, this.fillStyle,
								{x: bbox.x, y: bbox.y},
								{x: bbox.x + bbox.width, y: bbox.y + bbox.height},
								tbbox[0], tbbox[2]);
						a = f.colors;
						if(a[0].offset.toFixed(5) != "0.00000"){
							s.push("0 " + g.normalizeColor(a[0].color).toHex());
						}
						for(i = 0; i < a.length; ++i){
							s.push(a[i].offset.toFixed(5) + " " + g.normalizeColor(a[i].color).toHex());
						}
						i = a.length - 1;
						if(a[i].offset.toFixed(5) != "1.00000"){
							s.push("1 " + g.normalizeColor(a[i].color).toHex());
						}
						fo = this.rawNode.fill;
						fo.colors.value = s.join(";");
						fo.method = "sigma";
						fo.type = "gradient";
						fo.angle = (270 - m._radToDeg(f.angle)) % 360;
						fo.on = true;
						break;
					case "radial":
						f = g.makeParameters(g.defaultRadialGradient, fill);
						this.fillStyle = f;
						var l = parseFloat(this.rawNode.style.left),
							t = parseFloat(this.rawNode.style.top),
							w = parseFloat(this.rawNode.style.width),
							h = parseFloat(this.rawNode.style.height),
							c = isNaN(w) ? 1 : 2 * f.r / w;
						a = [];
						// add a color at the offset 0 (1 in VML coordinates)
						if(f.colors[0].offset > 0){
							a.push({offset: 1, color: g.normalizeColor(f.colors[0].color)});
						}
						// massage colors
						arr.forEach(f.colors, function(v, i){
							a.push({offset: 1 - v.offset * c, color: g.normalizeColor(v.color)});
						});
						i = a.length - 1;
						while(i >= 0 && a[i].offset < 0){ --i; }
						if(i < a.length - 1){
							// correct excessive colors
							var q = a[i], p = a[i + 1];
							p.color = Color.blendColors(q.color, p.color, q.offset / (q.offset - p.offset));
							p.offset = 0;
							while(a.length - i > 2) a.pop();
						}
						// set colors
						i = a.length - 1, s = [];
						if(a[i].offset > 0){
							s.push("0 " + a[i].color.toHex());
						}
						for(; i >= 0; --i){
							s.push(a[i].offset.toFixed(5) + " " + a[i].color.toHex());
						}
						fo = this.rawNode.fill;
						fo.colors.value = s.join(";");
						fo.method = "sigma";
						fo.type = "gradientradial";
						if(isNaN(w) || isNaN(h) || isNaN(l) || isNaN(t)){
							fo.focusposition = "0.5 0.5";
						}else{
							fo.focusposition = ((f.cx - l) / w).toFixed(5) + " " + ((f.cy - t) / h).toFixed(5);
						}
						fo.focussize = "0 0";
						fo.on = true;
						break;
					case "pattern":
						f = g.makeParameters(g.defaultPattern, fill);
						this.fillStyle = f;
						fo = this.rawNode.fill;
						fo.type = "tile";
						fo.src = f.src;
						if(f.width && f.height){
							// in points
							fo.size.x = g.px2pt(f.width);
							fo.size.y = g.px2pt(f.height);
						}
						fo.alignShape = "f";
						fo.position.x = 0;
						fo.position.y = 0;
						fo.origin.x = f.width  ? f.x / f.width  : 0;
						fo.origin.y = f.height ? f.y / f.height : 0;
						fo.on = true;
						break;
				}
				this.rawNode.fill.opacity = 1;
				return this;
			}
			// color object
			this.fillStyle = g.normalizeColor(fill);
			fo = this.rawNode.fill;
			if(!fo){
				fo = this.rawNode.ownerDocument.createElement("v:fill");
			}
			fo.method = "any";
			fo.type = "solid";
			fo.opacity = this.fillStyle.a;
			var alphaFilter = this.rawNode.filters["DXImageTransform.Microsoft.Alpha"];
			if(alphaFilter){
				alphaFilter.opacity = Math.round(this.fillStyle.a * 100);
			}
			this.rawNode.fillcolor = this.fillStyle.toHex();
			this.rawNode.filled = true;
			return this;	// self
		},

		setStroke: function(stroke){
			// summary: sets a stroke object (VML)
			// stroke: Object: a stroke object
			//	(see dojox.gfx.defaultStroke)

			if(!stroke){
				// don't stroke
				this.strokeStyle = null;
				this.rawNode.stroked = "f";
				return this;
			}
			// normalize the stroke
			if(typeof stroke == "string" || lang.isArray(stroke) || stroke instanceof Color){
				stroke = {color: stroke};
			}
			var s = this.strokeStyle = g.makeParameters(g.defaultStroke, stroke);
			s.color = g.normalizeColor(s.color);
			// generate attributes
			var rn = this.rawNode;
			rn.stroked = true;
			rn.strokecolor = s.color.toCss();
			rn.strokeweight = s.width + "px";	// TODO: should we assume that the width is always in pixels?
			if(rn.stroke) {
				rn.stroke.opacity = s.color.a;
				rn.stroke.endcap = this._translate(this._capMap, s.cap);
				if(typeof s.join == "number") {
					rn.stroke.joinstyle = "miter";
					rn.stroke.miterlimit = s.join;
				}else{
					rn.stroke.joinstyle = s.join;
					// rn.stroke.miterlimit = s.width;
				}
				rn.stroke.dashstyle = s.style == "none" ? "Solid" : s.style;
			}
			return this;	// self
		},

		_capMap: { butt: 'flat' },
		_capMapReversed: { flat: 'butt' },

		_translate: function(dict, value) {
			return (value in dict) ? dict[value] : value;
		},

		_applyTransform: function() {
			var matrix = this._getRealMatrix();
			if(matrix){
				var skew = this.rawNode.skew;
				if(typeof skew == "undefined"){
					for(var i = 0; i < this.rawNode.childNodes.length; ++i){
						if(this.rawNode.childNodes[i].tagName == "skew"){
							skew = this.rawNode.childNodes[i];
							break;
						}
					}
				}
				if(skew){
					skew.on = "f";
					var mt = matrix.xx.toFixed(8) + " " + matrix.xy.toFixed(8) + " " +
						matrix.yx.toFixed(8) + " " + matrix.yy.toFixed(8) + " 0 0",
						offset = Math.floor(matrix.dx).toFixed() + "px " + Math.floor(matrix.dy).toFixed() + "px",
						s = this.rawNode.style,
						l = parseFloat(s.left),
						t = parseFloat(s.top),
						w = parseFloat(s.width),
						h = parseFloat(s.height);
					if(isNaN(l)) l = 0;
					if(isNaN(t)) t = 0;
					if(isNaN(w) || !w) w = 1;
					if(isNaN(h) || !h) h = 1;
					var origin = (-l / w - 0.5).toFixed(8) + " " + (-t / h - 0.5).toFixed(8);
					skew.matrix =  mt;
					skew.origin = origin;
					skew.offset = offset;
					skew.on = true;
				}
			}
			if(this.fillStyle && this.fillStyle.type == "linear"){
				this.setFill(this.fillStyle);
			}
			return this;
		},

		_setDimensions: function(width, height){
			// summary: sets the width and height of the rawNode,
			//	if the surface sixe has been changed
			// width: String: width in pixels
			// height: String: height in pixels

			// default implementation does nothing
			return this; // self
		},

		setRawNode: function(rawNode){
			// summary:
			//	assigns and clears the underlying node that will represent this
			//	shape. Once set, transforms, gradients, etc, can be applied.
			//	(no fill & stroke by default)
			rawNode.stroked = "f";
			rawNode.filled  = "f";
			this.rawNode = rawNode;
			this.rawNode.__gfxObject__ = this.getUID();
		},

		// move family

		_moveToFront: function(){
			// summary: moves a shape to front of its parent's list of shapes (VML)
			this.rawNode.parentNode.appendChild(this.rawNode);
			return this;
		},
		_moveToBack: function(){
			// summary: moves a shape to back of its parent's list of shapes (VML)
			var r = this.rawNode, p = r.parentNode, n = p.firstChild;
			p.insertBefore(r, n);
			if(n.tagName == "rect"){
				// surface has a background rectangle, which position should be preserved
				n.swapNode(r);
			}
			return this;
		},

		_getRealMatrix: function(){
			// summary: returns the cumulative ("real") transformation matrix
			//	by combining the shape's matrix with its parent's matrix
			return this.parentMatrix ? new m.Matrix2D([this.parentMatrix, this.matrix]) : this.matrix;	// dojox.gfx.Matrix2D
		}
	});

	declare("dojox.gfx.vml.Group", vml.Shape, {
		// summary: a group shape (VML), which can be used
		//	to logically group shapes (e.g, to propagate matricies)
		constructor: function(){
			gs.Container._init.call(this);
		},
		// apply transformation
		_applyTransform: function(){
			// summary: applies a transformation matrix to a group
			var matrix = this._getRealMatrix();
			for(var i = 0; i < this.children.length; ++i){
				this.children[i]._updateParentMatrix(matrix);
			}
			return this;	// self
		},
		_setDimensions: function(width, height){
			// summary: sets the width and height of the rawNode,
			//	if the surface sixe has been changed
			// width: String: width in pixels
			// height: String: height in pixels
			var r = this.rawNode, rs = r.style,
				bs = this.bgNode.style;
			rs.width = width;
			rs.height = height;
			r.coordsize = width + " " + height;
			bs.width = width;
			bs.height = height;
			for(var i = 0; i < this.children.length; ++i){
				this.children[i]._setDimensions(width, height);
			}
			return this; // self
		}
	});
	vml.Group.nodeType = "group";

	declare("dojox.gfx.vml.Rect", [vml.Shape, gs.Rect], {
		// summary: a rectangle shape (VML)
		setShape: function(newShape){
			// summary: sets a rectangle shape object (VML)
			// newShape: Object: a rectangle shape object
			var shape = this.shape = g.makeParameters(this.shape, newShape);
			this.bbox = null;
			var r = Math.min(1, (shape.r / Math.min(parseFloat(shape.width), parseFloat(shape.height)))).toFixed(8);
			// a workaround for the VML's arcsize bug: cannot read arcsize of an instantiated node
			var parent = this.rawNode.parentNode, before = null;
			if(parent){
				if(parent.lastChild !== this.rawNode){
					for(var i = 0; i < parent.childNodes.length; ++i){
						if(parent.childNodes[i] === this.rawNode){
							before = parent.childNodes[i + 1];
							break;
						}
					}
				}
				parent.removeChild(this.rawNode);
			}
			if(has("ie") > 7){
				var node = this.rawNode.ownerDocument.createElement("v:roundrect");
				node.arcsize = r;
				node.style.display = "inline-block";
				this.rawNode = node;
				this.rawNode.__gfxObject__ = this.getUID();						
			}else{
				this.rawNode.arcsize = r;
			}
			if(parent){
				if(before){
					parent.insertBefore(this.rawNode, before);
				}else{
					parent.appendChild(this.rawNode);
				}
			}
			var style = this.rawNode.style;
			style.left   = shape.x.toFixed();
			style.top    = shape.y.toFixed();
			style.width  = (typeof shape.width == "string" && shape.width.indexOf("%") >= 0)  ? shape.width  : Math.max(shape.width.toFixed(),0);
			style.height = (typeof shape.height == "string" && shape.height.indexOf("%") >= 0) ? shape.height : Math.max(shape.height.toFixed(),0);
			// set all necessary styles, which are lost by VML (yes, it's a VML's bug)
			return this.setTransform(this.matrix).setFill(this.fillStyle).setStroke(this.strokeStyle);	// self
		}
	});
	vml.Rect.nodeType = "roundrect"; // use a roundrect so the stroke join type is respected

	declare("dojox.gfx.vml.Ellipse", [vml.Shape, gs.Ellipse], {
		// summary: an ellipse shape (VML)
		setShape: function(newShape){
			// summary: sets an ellipse shape object (VML)
			// newShape: Object: an ellipse shape object
			var shape = this.shape = g.makeParameters(this.shape, newShape);
			this.bbox = null;
			var style = this.rawNode.style;
			style.left   = (shape.cx - shape.rx).toFixed();
			style.top    = (shape.cy - shape.ry).toFixed();
			style.width  = (shape.rx * 2).toFixed();
			style.height = (shape.ry * 2).toFixed();
			return this.setTransform(this.matrix);	// self
		}
	});
	vml.Ellipse.nodeType = "oval";

	declare("dojox.gfx.vml.Circle", [vml.Shape, gs.Circle], {
		// summary: a circle shape (VML)
		setShape: function(newShape){
			// summary: sets a circle shape object (VML)
			// newShape: Object: a circle shape object
			var shape = this.shape = g.makeParameters(this.shape, newShape);
			this.bbox = null;
			var style = this.rawNode.style;
			style.left   = (shape.cx - shape.r).toFixed();
			style.top    = (shape.cy - shape.r).toFixed();
			style.width  = (shape.r * 2).toFixed();
			style.height = (shape.r * 2).toFixed();
			return this;	// self
		}
	});
	vml.Circle.nodeType = "oval";

	declare("dojox.gfx.vml.Line", [vml.Shape, gs.Line], {
		// summary: a line shape (VML)
		constructor: function(rawNode){
			if(rawNode) rawNode.setAttribute("dojoGfxType", "line");
		},
		setShape: function(newShape){
			// summary: sets a line shape object (VML)
			// newShape: Object: a line shape object
			var shape = this.shape = g.makeParameters(this.shape, newShape);
			this.bbox = null;
			this.rawNode.path.v = "m" + shape.x1.toFixed() + " " + shape.y1.toFixed() +
				"l" + shape.x2.toFixed() + " " + shape.y2.toFixed() + "e";
			return this.setTransform(this.matrix);	// self
		}
	});
	vml.Line.nodeType = "shape";

	declare("dojox.gfx.vml.Polyline", [vml.Shape, gs.Polyline], {
		// summary: a polyline/polygon shape (VML)
		constructor: function(rawNode){
			if(rawNode) rawNode.setAttribute("dojoGfxType", "polyline");
		},
		setShape: function(points, closed){
			// summary: sets a polyline/polygon shape object (VML)
			// points: Object: a polyline/polygon shape object
			// closed: Boolean?: if true, close the polyline explicitely
			if(points && points instanceof Array){
				// branch
				// points: Array: an array of points
				this.shape = g.makeParameters(this.shape, { points: points });
				if(closed && this.shape.points.length) this.shape.points.push(this.shape.points[0]);
			}else{
				this.shape = g.makeParameters(this.shape, points);
			}
			this.bbox = null;
			this._normalizePoints();
			var attr = [], p = this.shape.points;
			if(p.length > 0){
				attr.push("m");
				attr.push(p[0].x.toFixed(), p[0].y.toFixed());
				if(p.length > 1){
					attr.push("l");
					for(var i = 1; i < p.length; ++i){
						attr.push(p[i].x.toFixed(), p[i].y.toFixed());
					}
				}
			}
			attr.push("e");
			this.rawNode.path.v = attr.join(" ");
			return this.setTransform(this.matrix);	// self
		}
	});
	vml.Polyline.nodeType = "shape";

	declare("dojox.gfx.vml.Image", [vml.Shape, gs.Image], {
		// summary: an image (VML)
		setShape: function(newShape){
			// summary: sets an image shape object (VML)
			// newShape: Object: an image shape object
			var shape = this.shape = g.makeParameters(this.shape, newShape);
			this.bbox = null;
			this.rawNode.firstChild.src = shape.src;
			return this.setTransform(this.matrix);	// self
		},
		_applyTransform: function() {
			var matrix = this._getRealMatrix(),
				rawNode = this.rawNode,
				s = rawNode.style,
				shape = this.shape;
			if(matrix){
				matrix = m.multiply(matrix, {dx: shape.x, dy: shape.y});
			}else{
				matrix = m.normalize({dx: shape.x, dy: shape.y});
			}
			if(matrix.xy == 0 && matrix.yx == 0 && matrix.xx > 0 && matrix.yy > 0){
				// special case to avoid filters
				s.filter = "";
				s.width  = Math.floor(matrix.xx * shape.width);
				s.height = Math.floor(matrix.yy * shape.height);
				s.left   = Math.floor(matrix.dx);
				s.top    = Math.floor(matrix.dy);
			}else{
				var ps = rawNode.parentNode.style;
				s.left   = "0px";
				s.top    = "0px";
				s.width  = ps.width;
				s.height = ps.height;
				matrix = m.multiply(matrix,
					{xx: shape.width / parseInt(s.width), yy: shape.height / parseInt(s.height)});
				var f = rawNode.filters["DXImageTransform.Microsoft.Matrix"];
				if(f){
					f.M11 = matrix.xx;
					f.M12 = matrix.xy;
					f.M21 = matrix.yx;
					f.M22 = matrix.yy;
					f.Dx = matrix.dx;
					f.Dy = matrix.dy;
				}else{
					s.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + matrix.xx +
						", M12=" + matrix.xy + ", M21=" + matrix.yx + ", M22=" + matrix.yy +
						", Dx=" + matrix.dx + ", Dy=" + matrix.dy + ")";
				}
			}
			return this; // self
		},
		_setDimensions: function(width, height){
			// summary: sets the width and height of the rawNode,
			//	if the surface sixe has been changed
			// width: String: width in pixels
			// height: String: height in pixels

			var r = this.rawNode, f = r.filters["DXImageTransform.Microsoft.Matrix"];
			if(f){
				var s = r.style;
				s.width  = width;
				s.height = height;
				return this._applyTransform(); // self
			}
			return this;	// self
		}
	});
	vml.Image.nodeType = "rect";

	declare("dojox.gfx.vml.Text", [vml.Shape, gs.Text], {
		// summary: an anchored text (VML)
		constructor: function(rawNode){
			if(rawNode){rawNode.setAttribute("dojoGfxType", "text");}
			this.fontStyle = null;
		},
		_alignment: {start: "left", middle: "center", end: "right"},
		setShape: function(newShape){
			// summary: sets a text shape object (VML)
			// newShape: Object: a text shape object
			this.shape = g.makeParameters(this.shape, newShape);
			this.bbox = null;
			var r = this.rawNode, s = this.shape, x = s.x, y = s.y.toFixed(), path;
			switch(s.align){
				case "middle":
					x -= 5;
					break;
				case "end":
					x -= 10;
					break;
			}
			path = "m" + x.toFixed() + "," + y + "l" + (x + 10).toFixed() + "," + y + "e";
			// find path and text path
			var p = null, t = null, c = r.childNodes;
			for(var i = 0; i < c.length; ++i){
				var tag = c[i].tagName;
				if(tag == "path"){
					p = c[i];
					if(t) break;
				}else if(tag == "textpath"){
					t = c[i];
					if(p) break;
				}
			}
			if(!p){
				p = r.ownerDocument.createElement("v:path");
				r.appendChild(p);
			}
			if(!t){
				t = r.ownerDocument.createElement("v:textpath");
				r.appendChild(t);
			}
			p.v = path;
			p.textPathOk = true;
			t.on = true;
			var a = vml.text_alignment[s.align];
			t.style["v-text-align"] = a ? a : "left";
			t.style["text-decoration"] = s.decoration;
			t.style["v-rotate-letters"] = s.rotated;
			t.style["v-text-kern"] = s.kerning;
			t.string = s.text;
			return this.setTransform(this.matrix);	// self
		},
		_setFont: function(){
			// summary: sets a font object (VML)
			var f = this.fontStyle, c = this.rawNode.childNodes;
			for(var i = 0; i < c.length; ++i){
				if(c[i].tagName == "textpath"){
					c[i].style.font = g.makeFontString(f);
					break;
				}
			}
			this.setTransform(this.matrix);
		},
		_getRealMatrix: function(){
			// summary: returns the cumulative ("real") transformation matrix
			//	by combining the shape's matrix with its parent's matrix;
			//	it makes a correction for a font size
			var matrix = this.inherited(arguments);
			// It appears that text is always aligned vertically at a middle of x-height (???).
			// It is impossible to obtain these metrics from VML => I try to approximate it with
			// more-or-less util value of 0.7 * FontSize, which is typical for European fonts.
			if(matrix){
				matrix = m.multiply(matrix,
					{dy: -g.normalizedLength(this.fontStyle ? this.fontStyle.size : "10pt") * 0.35});
			}
			return matrix;	// dojox.gfx.Matrix2D
		},
		getTextWidth: function(){
			// summary: get the text width, in px
			var rawNode = this.rawNode, _display = rawNode.style.display;
			rawNode.style.display = "inline";
			var _width = g.pt2px(parseFloat(rawNode.currentStyle.width));
			rawNode.style.display = _display;
			return _width;
		}
	});
	vml.Text.nodeType = "shape";

	declare("dojox.gfx.vml.Path", [vml.Shape, pathLib.Path], {
		// summary: a path shape (VML)
		constructor: function(rawNode){
			if(rawNode && !rawNode.getAttribute("dojoGfxType")){
				rawNode.setAttribute("dojoGfxType", "path");
			}
			this.vmlPath = "";
			this.lastControl = {};
		},
		_updateWithSegment: function(segment){
			// summary: updates the bounding box of path with new segment
			// segment: Object: a segment
			var last = lang.clone(this.last);
			this.inherited(arguments);
			if(arguments.length > 1){ return; } // skip transfomed bbox calculations
			// add a VML path segment
			var path = this[this.renderers[segment.action]](segment, last);
			if(typeof this.vmlPath == "string"){
				this.vmlPath += path.join("");
				this.rawNode.path.v = this.vmlPath + " r0,0 e";
			}else{
				Array.prototype.push.apply(this.vmlPath, path); //FIXME: why not push()?
			}
		},
		setShape: function(newShape){
			// summary: forms a path using a shape (VML)
			// newShape: Object: an VML path string or a path object (see dojox.gfx.defaultPath)
			this.vmlPath = [];
			this.lastControl.type = "";	// no prior control point
			this.inherited(arguments);
			this.vmlPath = this.vmlPath.join("");
			this.rawNode.path.v = this.vmlPath + " r0,0 e";
			return this;
		},
		_pathVmlToSvgMap: {m: "M", l: "L", t: "m", r: "l", c: "C", v: "c", qb: "Q", x: "z", e: ""},
		// VML-specific segment renderers
		renderers: {
			M: "_moveToA", m: "_moveToR",
			L: "_lineToA", l: "_lineToR",
			H: "_hLineToA", h: "_hLineToR",
			V: "_vLineToA", v: "_vLineToR",
			C: "_curveToA", c: "_curveToR",
			S: "_smoothCurveToA", s: "_smoothCurveToR",
			Q: "_qCurveToA", q: "_qCurveToR",
			T: "_qSmoothCurveToA", t: "_qSmoothCurveToR",
			A: "_arcTo", a: "_arcTo",
			Z: "_closePath", z: "_closePath"
		},
		_addArgs: function(path, segment, from, upto){
			var n = segment instanceof Array ? segment : segment.args;
			for(var i = from; i < upto; ++i){
				path.push(" ", n[i].toFixed());
			}
		},
		_adjustRelCrd: function(last, segment, step){
			var n = segment instanceof Array ? segment : segment.args, l = n.length,
				result = new Array(l), i = 0, x = last.x, y = last.y;
			if(typeof x != "number"){
				// there is no last coordinate =>
				// treat the first pair as an absolute coordinate
				result[0] = x = n[0];
				result[1] = y = n[1];
				i = 2;
			}
			if(typeof step == "number" && step != 2){
				var j = step;
				while(j <= l){
					for(; i < j; i += 2){
						result[i] = x + n[i];
						result[i + 1] = y + n[i + 1];
					}
					x = result[j - 2];
					y = result[j - 1];
					j += step;
				}
			}else{
				for(; i < l; i += 2){
					result[i] = (x += n[i]);
					result[i + 1] = (y += n[i + 1]);
				}
			}
			return result;
		},
		_adjustRelPos: function(last, segment){
			var n = segment instanceof Array ? segment : segment.args, l = n.length,
				result = new Array(l);
			for(var i = 0; i < l; ++i){
				result[i] = (last += n[i]);
			}
			return result;
		},
		_moveToA: function(segment){
			var p = [" m"], n = segment instanceof Array ? segment : segment.args, l = n.length;
			this._addArgs(p, n, 0, 2);
			if(l > 2){
				p.push(" l");
				this._addArgs(p, n, 2, l);
			}
			this.lastControl.type = "";	// no control point after this primitive
			return p;
		},
		_moveToR: function(segment, last){
			return this._moveToA(this._adjustRelCrd(last, segment));
		},
		_lineToA: function(segment){
			var p = [" l"], n = segment instanceof Array ? segment : segment.args;
			this._addArgs(p, n, 0, n.length);
			this.lastControl.type = "";	// no control point after this primitive
			return p;
		},
		_lineToR: function(segment, last){
			return this._lineToA(this._adjustRelCrd(last, segment));
		},
		_hLineToA: function(segment, last){
			var p = [" l"], y = " " + last.y.toFixed(),
				n = segment instanceof Array ? segment : segment.args, l = n.length;
			for(var i = 0; i < l; ++i){
				p.push(" ", n[i].toFixed(), y);
			}
			this.lastControl.type = "";	// no control point after this primitive
			return p;
		},
		_hLineToR: function(segment, last){
			return this._hLineToA(this._adjustRelPos(last.x, segment), last);
		},
		_vLineToA: function(segment, last){
			var p = [" l"], x = " " + last.x.toFixed(),
				n = segment instanceof Array ? segment : segment.args, l = n.length;
			for(var i = 0; i < l; ++i){
				p.push(x, " ", n[i].toFixed());
			}
			this.lastControl.type = "";	// no control point after this primitive
			return p;
		},
		_vLineToR: function(segment, last){
			return this._vLineToA(this._adjustRelPos(last.y, segment), last);
		},
		_curveToA: function(segment){
			var p = [], n = segment instanceof Array ? segment : segment.args, l = n.length,
				lc = this.lastControl;
			for(var i = 0; i < l; i += 6){
				p.push(" c");
				this._addArgs(p, n, i, i + 6);
			}
			lc.x = n[l - 4];
			lc.y = n[l - 3];
			lc.type = "C";
			return p;
		},
		_curveToR: function(segment, last){
			return this._curveToA(this._adjustRelCrd(last, segment, 6));
		},
		_smoothCurveToA: function(segment, last){
			var p = [], n = segment instanceof Array ? segment : segment.args, l = n.length,
				lc = this.lastControl, i = 0;
			if(lc.type != "C"){
				p.push(" c");
				this._addArgs(p, [last.x, last.y], 0, 2);
				this._addArgs(p, n, 0, 4);
				lc.x = n[0];
				lc.y = n[1];
				lc.type = "C";
				i = 4;
			}
			for(; i < l; i += 4){
				p.push(" c");
				this._addArgs(p, [
					2 * last.x - lc.x,
					2 * last.y - lc.y
				], 0, 2);
				this._addArgs(p, n, i, i + 4);
				lc.x = n[i];
				lc.y = n[i + 1];
			}
			return p;
		},
		_smoothCurveToR: function(segment, last){
			return this._smoothCurveToA(this._adjustRelCrd(last, segment, 4), last);
		},
		_qCurveToA: function(segment){
			var p = [], n = segment instanceof Array ? segment : segment.args, l = n.length,
				lc = this.lastControl;
			for(var i = 0; i < l; i += 4){
				p.push(" qb");
				this._addArgs(p, n, i, i + 4);
			}
			lc.x = n[l - 4];
			lc.y = n[l - 3];
			lc.type = "Q";
			return p;
		},
		_qCurveToR: function(segment, last){
			return this._qCurveToA(this._adjustRelCrd(last, segment, 4));
		},
		_qSmoothCurveToA: function(segment, last){
			var p = [], n = segment instanceof Array ? segment : segment.args, l = n.length,
				lc = this.lastControl, i = 0;
			if(lc.type != "Q"){
				p.push(" qb");
				this._addArgs(p, [
					lc.x = last.x,
					lc.y = last.y
				], 0, 2);
				lc.type = "Q";
				this._addArgs(p, n, 0, 2);
				i = 2;
			}
			for(; i < l; i += 2){
				p.push(" qb");
				this._addArgs(p, [
					lc.x = 2 * last.x - lc.x,
					lc.y = 2 * last.y - lc.y
				], 0, 2);
				this._addArgs(p, n, i, i + 2);
			}
			return p;
		},
		_qSmoothCurveToR: function(segment, last){
			return this._qSmoothCurveToA(this._adjustRelCrd(last, segment, 2), last);
		},
		_arcTo: function(segment, last){
			var p = [], n = segment.args, l = n.length, relative = segment.action == "a";
			for(var i = 0; i < l; i += 7){
				var x1 = n[i + 5], y1 = n[i + 6];
				if(relative){
					x1 += last.x;
					y1 += last.y;
				}
				var result = arcLib.arcAsBezier(
					last, n[i], n[i + 1], n[i + 2],
					n[i + 3] ? 1 : 0, n[i + 4] ? 1 : 0,
					x1, y1
				);
				for(var j = 0; j < result.length; ++j){
					p.push(" c");
					var t = result[j];
					this._addArgs(p, t, 0, t.length);
					this._updateBBox(t[0], t[1]);
					this._updateBBox(t[2], t[3]);
					this._updateBBox(t[4], t[5]);
				}
				last.x = x1;
				last.y = y1;
			}
			this.lastControl.type = "";	// no control point after this primitive
			return p;
		},
		_closePath: function(){
			this.lastControl.type = "";	// no control point after this primitive
			return ["x"];
		}
	});
	vml.Path.nodeType = "shape";

	declare("dojox.gfx.vml.TextPath", [vml.Path, pathLib.TextPath], {
		// summary: a textpath shape (VML)
		constructor: function(rawNode){
			if(rawNode){rawNode.setAttribute("dojoGfxType", "textpath");}
			this.fontStyle = null;
			if(!("text" in this)){
				this.text = lang.clone(g.defaultTextPath);
			}
			if(!("fontStyle" in this)){
				this.fontStyle = lang.clone(g.defaultFont);
			}
		},
		setText: function(newText){
			// summary: sets a text to be drawn along the path
			this.text = g.makeParameters(this.text,
				typeof newText == "string" ? {text: newText} : newText);
			this._setText();
			return this;	// self
		},
		setFont: function(newFont){
			// summary: sets a font for text
			this.fontStyle = typeof newFont == "string" ?
				g.splitFontString(newFont) :
				g.makeParameters(g.defaultFont, newFont);
			this._setFont();
			return this;	// self
		},

		_setText: function(){
			// summary: sets a text shape object (VML)
			this.bbox = null;
			var r = this.rawNode, s = this.text,
				// find path and text path
				p = null, t = null, c = r.childNodes;
			for(var i = 0; i < c.length; ++i){
				var tag = c[i].tagName;
				if(tag == "path"){
					p = c[i];
					if(t) break;
				}else if(tag == "textpath"){
					t = c[i];
					if(p) break;
				}
			}
			if(!p){
				p = this.rawNode.ownerDocument.createElement("v:path");
				r.appendChild(p);
			}
			if(!t){
				t = this.rawNode.ownerDocument.createElement("v:textpath");
				r.appendChild(t);
			}
			p.textPathOk = true;
			t.on = true;
			var a = vml.text_alignment[s.align];
			t.style["v-text-align"] = a ? a : "left";
			t.style["text-decoration"] = s.decoration;
			t.style["v-rotate-letters"] = s.rotated;
			t.style["v-text-kern"] = s.kerning;
			t.string = s.text;
		},
		_setFont: function(){
			// summary: sets a font object (VML)
			var f = this.fontStyle, c = this.rawNode.childNodes;
			for(var i = 0; i < c.length; ++i){
				if(c[i].tagName == "textpath"){
					c[i].style.font = g.makeFontString(f);
					break;
				}
			}
		}
	});
	vml.TextPath.nodeType = "shape";

	declare("dojox.gfx.vml.Surface", gs.Surface, {
		// summary: a surface object to be used for drawings (VML)
		constructor: function(){
			gs.Container._init.call(this);
		},
		setDimensions: function(width, height){
			// summary: sets the width and height of the rawNode
			// width: String: width of surface, e.g., "100px"
			// height: String: height of surface, e.g., "100px"
			this.width  = g.normalizedLength(width);	// in pixels
			this.height = g.normalizedLength(height);	// in pixels
			if(!this.rawNode) return this;
			var cs = this.clipNode.style,
				r = this.rawNode, rs = r.style,
				bs = this.bgNode.style,
				ps = this._parent.style, i;
			ps.width = width;
			ps.height = height;
			cs.width  = width;
			cs.height = height;
			cs.clip = "rect(0px " + width + "px " + height + "px 0px)";
			rs.width = width;
			rs.height = height;
			r.coordsize = width + " " + height;
			bs.width = width;
			bs.height = height;
			for(i = 0; i < this.children.length; ++i){
				this.children[i]._setDimensions(width, height);
			}
			return this;	// self
		},
		getDimensions: function(){
			// summary: returns an object with properties "width" and "height"
			var t = this.rawNode ? {
				width:  g.normalizedLength(this.rawNode.style.width),
				height: g.normalizedLength(this.rawNode.style.height)} : null;
			if(t.width  <= 0){ t.width  = this.width; }
			if(t.height <= 0){ t.height = this.height; }
			return t;	// Object
		}
	});

	vml.createSurface = function(parentNode, width, height){
		// summary: creates a surface (VML)
		// parentNode: Node: a parent node
		// width: String: width of surface, e.g., "100px"
		// height: String: height of surface, e.g., "100px"

		if(!width && !height){
			var pos = domGeom.position(parentNode);
			width  = width  || pos.w;
			height = height || pos.h;
		}
		if(typeof width == "number"){
			width = width + "px";
		}
		if(typeof height == "number"){
			height = height + "px";
		}

		var s = new vml.Surface(), p = dom.byId(parentNode),
			c = s.clipNode = p.ownerDocument.createElement("div"),
			r = s.rawNode = p.ownerDocument.createElement("v:group"),
			cs = c.style, rs = r.style;

		if(has("ie") > 7){
			rs.display = "inline-block";
		}

		s._parent = p;
		s._nodes.push(c);	// other elements will be deleted as parts of "c"

		p.style.width  = width;
		p.style.height = height;

//		cs.position = "absolute";
		cs.width  = width;
		cs.height = height;
		cs.clip = "rect(0px " + width + " " + height + " 0px)";
//		rs.position = "absolute";
		rs.width  = width;
		rs.height = height;
		r.coordsize = (width === "100%" ? width : parseFloat(width)) + " " +
			(height === "100%" ? height : parseFloat(height));
		r.coordorigin = "0 0";

		// create a background rectangle, which is required to show all other shapes
		var b = s.bgNode = r.ownerDocument.createElement("v:rect"), bs = b.style;
		bs.left = bs.top = 0;
		bs.width  = rs.width;
		bs.height = rs.height;
		b.filled = b.stroked = "f";

		r.appendChild(b);
		c.appendChild(r);
		p.appendChild(c);

		s.width  = g.normalizedLength(width);	// in pixels
		s.height = g.normalizedLength(height);	// in pixels

		return s;	// dojox.gfx.Surface
	};

	// Extenders
	
	// copied from dojox.gfx.utils
	function forEach(object, f, o){
		o = o || win.global;
		f.call(o, object);
		if(object instanceof g.Surface || object instanceof g.Group){
			arr.forEach(object.children, function(shape){
				forEach(shape, f, o);
			});
		}
	}

	var addPatch9624 = function(shape){
		if(this != shape.getParent()){
			// cleanup from old parent
			var oldParent = shape.getParent();
			if(oldParent) { oldParent.remove(shape); }
			// then move the raw node
			this.rawNode.appendChild(shape.rawNode);
			C.add.apply(this, arguments);
			// reapply visual attributes (slow..)
			forEach(this, function(s){
				if (typeof(s.getFont) == 'function'){ // text shapes need to be completely refreshed
					s.setShape(s.getShape());
					s.setFont(s.getFont());
				}
				if (typeof(s.setFill) == 'function'){ // if setFill is available a setStroke should be safe to assume also
					s.setFill(s.getFill());
					s.setStroke(s.getStroke());
				}
			});
		}
		return this;	// self
	};
	
	var add15 = function(shape){
		if(this != shape.getParent()){
			this.rawNode.appendChild(shape.rawNode);
			if(!shape.getParent()){ 
				// reapply visual attributes 
				shape.setFill(shape.getFill()); 
				shape.setStroke(shape.getStroke()); 
			} 
			C.add.apply(this, arguments);
		}
		return this;	// self
	};

	var C = gs.Container, Container = {
		add: config.fixVmlAdd === true ? addPatch9624 : add15,
		remove: function(shape, silently){
			// summary: remove a shape from a group/surface
			// shape: dojox.gfx.Shape: an VML shape object
			// silently: Boolean?: if true, regenerate a picture
			if(this == shape.getParent()){
				if(this.rawNode == shape.rawNode.parentNode){
					this.rawNode.removeChild(shape.rawNode);
				}
				C.remove.apply(this, arguments);
			}
			return this;	// self
		},
		clear: function(){
			// summary: removes all shapes from a group/surface
			var r = this.rawNode;
			while(r.firstChild != r.lastChild){
				if(r.firstChild != this.bgNode){
					r.removeChild(r.firstChild);
				}
				if(r.lastChild != this.bgNode){
					r.removeChild(r.lastChild);
				}
			}
			return C.clear.apply(this, arguments);
		},
		_moveChildToFront: C._moveChildToFront,
		_moveChildToBack:  C._moveChildToBack
	};

	var Creator = {
		// summary: VML shape creators
		createGroup: function(){
			// summary: creates a VML group shape
			var node = this.createObject(vml.Group, null);	// dojox.gfx.Group
			// create a background rectangle, which is required to show all other shapes
			var r = node.rawNode.ownerDocument.createElement("v:rect");
			r.style.left = r.style.top = 0;
			r.style.width  = node.rawNode.style.width;
			r.style.height = node.rawNode.style.height;
			r.filled = r.stroked = "f";
			node.rawNode.appendChild(r);
			node.bgNode = r;
			return node;	// dojox.gfx.Group
		},
		createImage: function(image){
			// summary: creates a VML image shape
			// image: Object: an image object (see dojox.gfx.defaultImage)
			if(!this.rawNode) return null;
			var shape = new vml.Image(),
				doc = this.rawNode.ownerDocument,
				node = doc.createElement('v:rect');
			node.stroked = "f";
			node.style.width  = this.rawNode.style.width;
			node.style.height = this.rawNode.style.height;
			var img  = doc.createElement('v:imagedata');
			node.appendChild(img);
			shape.setRawNode(node);
			this.rawNode.appendChild(node);
			shape.setShape(image);
			this.add(shape);
			return shape;	// dojox.gfx.Image
		},
		createRect: function(rect){
			// summary: creates a rectangle shape
			// rect: Object: a path object (see dojox.gfx.defaultRect)
			if(!this.rawNode) return null;
			var shape = new vml.Rect,
				node = this.rawNode.ownerDocument.createElement("v:roundrect");
			if(has("ie") > 7){
				node.style.display = "inline-block";
			}
			shape.setRawNode(node);
			this.rawNode.appendChild(node);
			shape.setShape(rect);
			this.add(shape);
			return shape;	// dojox.gfx.Rect
		},
		createObject: function(shapeType, rawShape) {
			// summary: creates an instance of the passed shapeType class
			// shapeType: Function: a class constructor to create an instance of
			// rawShape: Object: properties to be passed in to the classes "setShape" method
			// overrideSize: Boolean: set the size explicitly, if true
			if(!this.rawNode) return null;
			var shape = new shapeType(),
				node = this.rawNode.ownerDocument.createElement('v:' + shapeType.nodeType);
			shape.setRawNode(node);
			this.rawNode.appendChild(node);
			switch(shapeType){
				case vml.Group:
				case vml.Line:
				case vml.Polyline:
				case vml.Image:
				case vml.Text:
				case vml.Path:
				case vml.TextPath:
					this._overrideSize(node);
			}
			shape.setShape(rawShape);
			this.add(shape);
			return shape;	// dojox.gfx.Shape
		},
		_overrideSize: function(node){
			var s = this.rawNode.style, w = s.width, h = s.height;
			node.style.width  = w;
			node.style.height = h;
			node.coordsize = parseInt(w) + " " + parseInt(h);
		}
	};

	lang.extend(vml.Group, Container);
	lang.extend(vml.Group, gs.Creator);
	lang.extend(vml.Group, Creator);

	lang.extend(vml.Surface, Container);
	lang.extend(vml.Surface, gs.Creator);
	lang.extend(vml.Surface, Creator);

	// Mouse/Touch event
	vml.fixTarget = function(event, gfxElement){
		// summary: 
		//     Adds the gfxElement to event.gfxTarget if none exists. This new 
		//     property will carry the GFX element associated with this event.
		// event: Object 
		//     The current input event (MouseEvent or TouchEvent)
		// gfxElement: Object
		//     The GFX target element
		if (!event.gfxTarget) {
			event.gfxTarget = gs.byId(event.target.__gfxObject__);
		}
		return true;
	};
	
	return vml;
});

},
'dijit/_DialogMixin':function(){
define("dijit/_DialogMixin", [
	"dojo/_base/declare", // declare
	"./a11y"	// _getTabNavigable
], function(declare, a11y){

	// module:
	//		dijit/_DialogMixin
	// summary:
	//		_DialogMixin provides functions useful to Dialog and TooltipDialog

	return declare("dijit._DialogMixin", null, {
		// summary:
		//		This provides functions useful to Dialog and TooltipDialog

		execute: function(/*Object*/ /*===== formContents =====*/){
			// summary:
			//		Callback when the user hits the submit button.
			//		Override this method to handle Dialog execution.
			// description:
			//		After the user has pressed the submit button, the Dialog
			//		first calls onExecute() to notify the container to hide the
			//		dialog and restore focus to wherever it used to be.
			//
			//		*Then* this method is called.
			// type:
			//		callback
		},

		onCancel: function(){
			// summary:
			//	    Called when user has pressed the Dialog's cancel button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		onExecute: function(){
			// summary:
			//	    Called when user has pressed the dialog's OK button, to notify container.
			// description:
			//	    Developer shouldn't override or connect to this method;
			//		it's a private communication device between the TooltipDialog
			//		and the thing that opened it (ex: `dijit.form.DropDownButton`)
			// type:
			//		protected
		},

		_onSubmit: function(){
			// summary:
			//		Callback when user hits submit button
			// type:
			//		protected
			this.onExecute();	// notify container that we are about to execute
			this.execute(this.get('value'));
		},

		_getFocusItems: function(){
			// summary:
			//		Finds focusable items in dialog,
			//		and sets this._firstFocusItem and this._lastFocusItem
			// tags:
			//		protected

			var elems = a11y._getTabNavigable(this.containerNode);
			this._firstFocusItem = elems.lowest || elems.first || this.closeButtonNode || this.domNode;
			this._lastFocusItem = elems.last || elems.highest || this._firstFocusItem;
		}
	});
});

},
'dijit/nls/common':function(){
define({ root:
//begin v1.x content
({
	buttonOk: "OK",
	buttonCancel: "Cancel",
	buttonSave: "Save",
	itemClose: "Close"
})
//end v1.x content
,
"zh": true,
"zh-tw": true,
"tr": true,
"th": true,
"sv": true,
"sl": true,
"sk": true,
"ru": true,
"ro": true,
"pt": true,
"pt-pt": true,
"pl": true,
"nl": true,
"nb": true,
"ko": true,
"kk": true,
"ja": true,
"it": true,
"hu": true,
"hr": true,
"he": true,
"fr": true,
"fi": true,
"es": true,
"el": true,
"de": true,
"da": true,
"cs": true,
"ca": true,
"az": true,
"ar": true
});

},
'ibm/tivoli/simplesrm/srm/dojo/SimpleSRMError':function(){
// wrapped by build app
define(["dijit","dojo","dojox"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dojo.SimpleSRMMessage");
dojo.provide("ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError");

/**
 * Create a message object, and log it on the server
 * @param msg: the message text
 * @param level: the log level.  one of ["fine", "finer", "finest", "info", "severe", "warning"
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.SimpleSRMMessage", null, 
{
	level: "info",
	constructor: function(/*string*/msg, /*string?*/level)
	{
		try {
			if(undefined !== level){ 
				this.level = level;
			}
			this.message = msg;
			this.log();
		}
		catch(ex) {
			try {
				console.warn("Failed creating SimpleSRMMessage object: ", ex);
			}
			catch(ex2) {
				// this ctor is often called during exception handling.  can't afford to fail
			}
		}
	},

	log: function()
	{
		// TODO: show a popup?
		console.log("Error: (" + this.level + ") " + this.message);
		try {
			dojo.xhrPost({
				url: "/SRMCommonsWeb/MessageLogger",
				content: {level: this.level, message: this.message},
				sync: false,
				error: function(response, ioArgs) {
					console.warn("Failed logging message: ", this.content.message);
				}
			});
		}
		catch(ex) {
			try {
				console.warn("Failed logging SimpleSRMMEssage: ", this.message);
			}
			catch(ex2){
				// we're hosed.  ignore
			}
		}
	}
});
/**
 * An Error object. Use in place of javascript Error()
 * 
 * If you construct a SimpleSRMError using a javascript Error object
 * 		new ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError(new Error("error message"));
 * then the logged error message will include the filename and line number.
 */
dojo.declare("ibm.tivoli.simplesrm.srm.dojo.SimpleSRMError", null, 
{
	constructor: function(/*object|string*/err, /*string?*/severity)
	{
		try {
			this.message = "";
			this.severity = "severe";
			
			if("object" === typeof err) {
				if(undefined !== err.message) {
					this.message = err.message;
					if(undefined !== err.fileName) {
						this.message += " at " + err.fileName;
					}
					if(undefined !== err.lineNumber) {
						this.message += " (" + err.lineNumber + ")";
					}
				}
				else {
					this.message = err.toString();
				}
			}
			else {
				this.message = err;
			} 
			if(undefined !== severity) {
				this.severity = severity;
			}
			new ibm.tivoli.simplesrm.srm.dojo.SimpleSRMMessage(this.message, this.severity);
		}
		catch(ex) {
			try {
				console.warn("Failed creating SimpleSRMError object: ", ex);
			}
			catch(ex2) {
				// this ctor is often called during exception handling.  can't afford to fail
			}
		}
	}
});


});

},
'ibm/tivoli/simplesrm/srm/dijit/MessageDialog':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiStringTable","dojo/require!dojo/i18n,ibm/tivoli/tip/dijit/TIPMessageDialog,ibm/tivoli/simplesrm/srm/dijit/OpenHelp,ibm/tivoli/simplesrm/srm/dijit/MultipleModal,dijit/DialogUnderlay"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MessageDialog");
dojo.require("dojo.i18n");
dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");

// include modules
dojo.require("ibm.tivoli.tip.dijit.TIPMessageDialog");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.OpenHelp");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MultipleModal");
dojo.require("dijit.DialogUnderlay");

// the CreateCatalogRequest class is a widget that makes an
// XMLHttpRequest to a proxy servlet to reach an SRM object structure
// web service that can create service catalog requests
// Events:
//	onSrmRequestCreated(null)
//
// TODO: parameterize for the type of request.
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.MessageDialog",
	[ibm.tivoli.tip.dijit.TIPMessageDialog , ibm.tivoli.simplesrm.srm.dijit.OpenHelp, ibm.tivoli.simplesrm.srm.dijit.MultipleModal],
{
	_uiStringTable: null,

	constructor: function()
	{
		this._uiStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiStringTable");
	},
	postMixInProperties: function()
	{
		if (this.message==null)
		   this.message = this._uiStringTable[this.messageId];		
		this.url = null; // url is provided dynamically via openHelp handler 		
	},
	
	postCreate: function(){
		this.inherited(arguments);		
	
		var link = dojo.byId(this.id + "_" + this.messageId);
		this.connect(link , "onclick" , "openHelp");
		this.connect(dojo.doc.documentElement, "onkeypress", this._onKey);
	},
	
	show: function(){
		var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
		if (product==null || product.indexOf("srm")<0)
			this.patchCode();
		this.dialog_.supportsMultipleModal=true; //hack to support multiple modal panels
		this.inherited(arguments);
		if (product==null || product.indexOf("srm")<0)
			this.dialog_.domNode.style.zIndex = dijit._underlay.getDialogZIndex();
	},
	
	_onKey: function(event){		
		//changes original method to support multiple modal dialogs
		if(!this.preOnKeyTest(event)){
			return;// it's not your event
		}
		if(this.dialog_){
			this.dialog_._onKey(event);
		}
	},
	
	//handler
	openHelp: function(event){
		dojo.stopEvent(event);
		var params = [
		              {helpKey: "PMRDP_Messages.htm"},
		              {messageCode: this.messageId},
		              {messageType: this.type}
		             ];
		this.openHelpWindow(params);
		return false;
	},
	
	_dummy:null	
});
});

},
'dojox/layout/ResizeHandle':function(){
define("dojox/layout/ResizeHandle", ["dojo/_base/kernel","dojo/_base/lang","dojo/_base/connect","dojo/_base/array","dojo/_base/event",
	"dojo/_base/fx","dojo/_base/window","dojo/fx","dojo/window","dojo/dom","dojo/dom-class",
	"dojo/dom-geometry","dojo/dom-style","dijit/_base/manager","dijit/_Widget","dijit/_TemplatedMixin",
	"dojo/_base/declare"], function (
	kernel, lang, connect, arrayUtil, eventUtil, fxBase, windowBase, fxUtil, windowUtil, 
	domUtil, domClass, domGeometry, domStyle, manager, Widget, TemplatedMixin, declare) {

kernel.experimental("dojox.layout.ResizeHandle");

/*===== 
	var Widget = dijit._Widget;
	var TemplatedMixin = dijit._TemplatedMixin;
=====*/
var ResizeHandle = declare("dojox.layout.ResizeHandle",[Widget, TemplatedMixin],
	{
	// summary: A dragable handle used to resize an attached node.
	//
	// description:
	//	The handle on the bottom-right corner of FloatingPane or other widgets that allows
	//	the widget to be resized.
	//	Typically not used directly.
	//
	// targetId: String
	//	id of the Widget OR DomNode that I will size
	targetId: "",
	
	// targetContainer: DomNode
	//	over-ride targetId and attch this handle directly to a reference of a DomNode
	targetContainer: null,
	
	// resizeAxis: String
	//	one of: x|y|xy limit resizing to a single axis, default to xy ...
	resizeAxis: "xy",
	
	// activeResize: Boolean
	// 	if true, node will size realtime with mouse movement,
	//	if false, node will create virtual node, and only resize target on mouseUp
	activeResize: false,
	
	// activeResizeClass: String
	//	css class applied to virtual resize node.
	activeResizeClass: "dojoxResizeHandleClone",
	
	// animateSizing: Boolean
	//	only applicable if activeResize = false. onMouseup, animate the node to the
	//	new size
	animateSizing: true,
	
	// animateMethod: String
	// 	one of "chain" or "combine" ... visual effect only. combine will "scale"
	// 	node to size, "chain" will alter width, then height
	animateMethod: "chain",

	// animateDuration: Integer
	//	time in MS to run sizing animation. if animateMethod="chain", total animation
	//	playtime is 2*animateDuration
	animateDuration: 225,

	// minHeight: Integer
	//	smallest height in px resized node can be
	minHeight: 100,

	// minWidth: Integer
	//	smallest width in px resize node can be
	minWidth: 100,

	// constrainMax: Boolean
	//	Toggle if this widget cares about the maxHeight and maxWidth
	//	parameters.
	constrainMax: false,

	// maxHeight: Integer
	//	Largest height size in px the resize node can become.
	maxHeight:0,
	
	// maxWidth: Integer
	//	Largest width size in px the reize node can become.
	maxWidth:0,

	// fixedAspect: Boolean
	//		Toggle to enable this widget to maintain the aspect
	//		ratio of the attached node.
	fixedAspect: false,

	// intermediateChanges: Boolean
	//		Toggle to enable/disable this widget from firing onResize
	//		events at every step of a resize. If `activeResize` is true,
	//		and this is false, onResize only fires _after_ the drop
	//		operation. Animated resizing is not affected by this setting.
	intermediateChanges: false,

	// startTopic: String
	//		The name of the topic this resizehandle publishes when resize is starting
	startTopic: "/dojo/resize/start",
	
	// endTopic: String
	//		The name of the topic this resizehandle publishes when resize is complete
	endTopic:"/dojo/resize/stop",

	templateString: '<div dojoAttachPoint="resizeHandle" class="dojoxResizeHandle"><div></div></div>',

	postCreate: function(){
		// summary: setup our one major listener upon creation
		this.connect(this.resizeHandle, "onmousedown", "_beginSizing");
		if(!this.activeResize){
			// there shall be only a single resize rubberbox that at the top
			// level so that we can overlay it on anything whenever the user
			// resizes something. Since there is only one mouse pointer he
			// can't at once resize multiple things interactively.
			this._resizeHelper = manager.byId('dojoxGlobalResizeHelper');
			if(!this._resizeHelper){
				this._resizeHelper = new _ResizeHelper({
						id: 'dojoxGlobalResizeHelper'
				}).placeAt(windowBase.body());
				domClass.add(this._resizeHelper.domNode, this.activeResizeClass);
			}
		}else{ this.animateSizing = false; }

		if(!this.minSize){
			this.minSize = { w: this.minWidth, h: this.minHeight };
		}
		
		if(this.constrainMax){
			this.maxSize = { w: this.maxWidth, h: this.maxHeight }
		}
		
		// should we modify the css for the cursor hover to n-resize nw-resize and w-resize?
		this._resizeX = this._resizeY = false;
		var addClass = lang.partial(domClass.add, this.resizeHandle);
		switch(this.resizeAxis.toLowerCase()){
			case "xy" :
				this._resizeX = this._resizeY = true;
				// FIXME: need logic to determine NW or NE class to see
				// based on which [todo] corner is clicked
				addClass("dojoxResizeNW");
				break;
			case "x" :
				this._resizeX = true;
				addClass("dojoxResizeW");
				break;
			case "y" :
				this._resizeY = true;
				addClass("dojoxResizeN");
				break;
		}
	},

	_beginSizing: function(/*Event*/ e){
		// summary: setup movement listeners and calculate initial size
		
		if(this._isSizing){ return; }

		connect.publish(this.startTopic, [ this ]);
		this.targetWidget = manager.byId(this.targetId);

		this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : domUtil.byId(this.targetId);
		if(this.targetContainer){ this.targetDomNode = this.targetContainer; }
		if(!this.targetDomNode){ return; }

		if(!this.activeResize){
			var c = domGeometry.position(this.targetDomNode, true);
			this._resizeHelper.resize({l: c.x, t: c.y, w: c.w, h: c.h});
			this._resizeHelper.show();
		}

		this._isSizing = true;
		this.startPoint  = { x:e.clientX, y:e.clientY };

		// widget.resize() or setting style.width/height expects native box model dimension 
		// (in most cases content-box, but it may be border-box if in backcompact mode)
		var style = domStyle.getComputedStyle(this.targetDomNode), 
			borderModel = domGeometry.boxModel==='border-model',
			padborder = borderModel?{w:0,h:0}:domGeometry.getPadBorderExtents(this.targetDomNode, style),
			margin = domGeometry.getMarginExtents(this.targetDomNode, style),
			mb;
		mb = this.startSize = { 
				w: domStyle.get(this.targetDomNode, 'width', style), 
				h: domStyle.get(this.targetDomNode, 'height', style),
				//ResizeHelper.resize expects a bounding box of the
				//border box, so let's keep track of padding/border
				//width/height as well
				pbw: padborder.w, pbh: padborder.h,
				mw: margin.w, mh: margin.h};
		
		this._pconnects = [
			connect.connect(windowBase.doc,"onmousemove",this,"_updateSizing"),
			connect.connect(windowBase.doc,"onmouseup", this, "_endSizing")
		];
		
		eventUtil.stop(e);
	},

	_updateSizing: function(/*Event*/ e){
		// summary: called when moving the ResizeHandle ... determines
		//	new size based on settings/position and sets styles.

		if(this.activeResize){
			this._changeSizing(e);
		}else{
			var tmp = this._getNewCoords(e, 'border');
			if(tmp === false){ return; }
			this._resizeHelper.resize(tmp);
		}
		e.preventDefault();
	},

	_getNewCoords: function(/* Event */ e, /* String */ box){
		
		// On IE, if you move the mouse above/to the left of the object being resized,
		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
		try{
			if(!e.clientX  || !e.clientY){ return false; }
		}catch(e){
			// sometimes you get an exception accessing above fields...
			return false;
		}
		this._activeResizeLastEvent = e;

		var dx = (this.isLeftToRight()?1:-1) * (this.startPoint.x - e.clientX),
			dy = this.startPoint.y - e.clientY,
			newW = this.startSize.w - (this._resizeX ? dx : 0),
			newH = this.startSize.h - (this._resizeY ? dy : 0),
			r = this._checkConstraints(newW, newH)
		;
		
		switch(box){
			case 'margin':
				r.w += this.startSize.mw;
				r.h += this.startSize.mh;
				//pass through
			case "border":
				r.w += this.startSize.pbw;
				r.h += this.startSize.pbh;
				break;
			//default: //native, do nothing
		}

		return r; // Object
	},
	
	_checkConstraints: function(newW, newH){
		// summary: filter through the various possible constaint possibilities.
				
		// minimum size check
		if(this.minSize){
			var tm = this.minSize;
			if(newW < tm.w){
				newW = tm.w;
			}
			if(newH < tm.h){
				newH = tm.h;
			}
		}
		
		// maximum size check:
		if(this.constrainMax && this.maxSize){
			var ms = this.maxSize;
			if(newW > ms.w){
				newW = ms.w;
			}
			if(newH > ms.h){
				newH = ms.h;
			}
		}
		
		if(this.fixedAspect){
			var w = this.startSize.w, h = this.startSize.h,
				delta = w * newH - h * newW;
			if(delta<0){
				newW = newH * w / h;
			}else if(delta>0){
				newH = newW * h / w;
			}
		}
		
		return { w: newW, h: newH }; // Object
	},
		
	_changeSizing: function(/*Event*/ e){
		// summary: apply sizing information based on information in (e) to attached node
		
		var isWidget = this.targetWidget && lang.isFunction(this.targetWidget.resize),
			tmp = this._getNewCoords(e, isWidget && 'margin');
		if(tmp === false){ return; }

		if(isWidget){
			this.targetWidget.resize(tmp);
		}else{
			if(this.animateSizing){
				var anim = fxUtil[this.animateMethod]([
					fxBase.animateProperty({
						node: this.targetDomNode,
						properties: {
							width: { start: this.startSize.w, end: tmp.w }
						},
						duration: this.animateDuration
					}),
					fxBase.animateProperty({
						node: this.targetDomNode,
						properties: {
							height: { start: this.startSize.h, end: tmp.h }
						},
						duration: this.animateDuration
					})
				]);
				anim.play();
			}else{
				domStyle.set(this.targetDomNode,{
					width: tmp.w + "px",
					height: tmp.h + "px"
				});
			}
		}
		if(this.intermediateChanges){
			this.onResize(e);
		}
	},

	_endSizing: function(/*Event*/ e){
		// summary: disconnect listenrs and cleanup sizing
		arrayUtil.forEach(this._pconnects, connect.disconnect);
		var pub = lang.partial(connect.publish, this.endTopic, [ this ]);
		if(!this.activeResize){
			this._resizeHelper.hide();
			this._changeSizing(e);
			setTimeout(pub, this.animateDuration + 15);
		}else{
			pub();
		}
		this._isSizing = false;
		this.onResize(e);
	},
	
	onResize: function(e){
		// summary: Stub fired when sizing is done. Fired once
		//	after resize, or often when `intermediateChanges` is
		//	set to true.
	}
	
});

var _ResizeHelper = dojo.declare("dojox.layout._ResizeHelper", Widget, {
	// summary: A global private resize helper shared between any
	//		`dojox.layout.ResizeHandle` with activeSizing off.
	
	show: function(){
		// summary: show helper to start resizing
		domStyle.set(this.domNode, "display", "");
	},
	
	hide: function(){
		// summary: hide helper after resizing is complete
		domStyle.set(this.domNode, "display", "none");
	},
	
	resize: function(/* Object */dim){
		// summary: size the widget and place accordingly
		domGeometry.setMarginBox(this.domNode, dim);
	}
	
});
return ResizeHandle;
});

},
'dijit/Tree':function(){
require({cache:{
'url:dijit/templates/TreeNode.html':"<div class=\"dijitTreeNode\" role=\"presentation\"\n\t><div data-dojo-attach-point=\"rowNode\" class=\"dijitTreeRow\" role=\"presentation\" data-dojo-attach-event=\"onmouseenter:_onMouseEnter, onmouseleave:_onMouseLeave, onclick:_onClick, ondblclick:_onDblClick\"\n\t\t><img src=\"${_blankGif}\" alt=\"\" data-dojo-attach-point=\"expandoNode\" class=\"dijitTreeExpando\" role=\"presentation\"\n\t\t/><span data-dojo-attach-point=\"expandoNodeText\" class=\"dijitExpandoText\" role=\"presentation\"\n\t\t></span\n\t\t><span data-dojo-attach-point=\"contentNode\"\n\t\t\tclass=\"dijitTreeContent\" role=\"presentation\">\n\t\t\t<img src=\"${_blankGif}\" alt=\"\" data-dojo-attach-point=\"iconNode\" class=\"dijitIcon dijitTreeIcon\" role=\"presentation\"\n\t\t\t/><span data-dojo-attach-point=\"labelNode\" class=\"dijitTreeLabel\" role=\"treeitem\" tabindex=\"-1\" aria-selected=\"false\" data-dojo-attach-event=\"onfocus:_onLabelFocus\"></span>\n\t\t</span\n\t></div>\n\t<div data-dojo-attach-point=\"containerNode\" class=\"dijitTreeContainer\" role=\"presentation\" style=\"display: none;\"></div>\n</div>\n",
'url:dijit/templates/Tree.html':"<div class=\"dijitTree dijitTreeContainer\" role=\"tree\"\n\tdata-dojo-attach-event=\"onkeypress:_onKeyPress\">\n\t<div class=\"dijitInline dijitTreeIndent\" style=\"position: absolute; top: -9999px\" data-dojo-attach-point=\"indentDetector\"></div>\n</div>\n"}});
define("dijit/Tree", [
	"dojo/_base/array", // array.filter array.forEach array.map
	"dojo/_base/connect",	// connect.isCopyKey()
	"dojo/cookie", // cookie
	"dojo/_base/declare", // declare
	"dojo/_base/Deferred", // Deferred
	"dojo/DeferredList", // DeferredList
	"dojo/dom", // dom.isDescendant
	"dojo/dom-class", // domClass.add domClass.remove domClass.replace domClass.toggle
	"dojo/dom-geometry", // domGeometry.setMarginBox domGeometry.position
	"dojo/dom-style",// domStyle.set
	"dojo/_base/event", // event.stop
	"dojo/fx", // fxUtils.wipeIn fxUtils.wipeOut
	"dojo/_base/kernel", // kernel.deprecated
	"dojo/keys",	// arrows etc.
	"dojo/_base/lang", // lang.getObject lang.mixin lang.hitch
	"dojo/topic",
	"./focus",
	"./registry",	// registry.getEnclosingWidget(), manager.defaultDuration
	"./_base/manager",	// manager.getEnclosingWidget(), manager.defaultDuration
	"./_Widget",
	"./_TemplatedMixin",
	"./_Container",
	"./_Contained",
	"./_CssStateMixin",
	"dojo/text!./templates/TreeNode.html",
	"dojo/text!./templates/Tree.html",
	"./tree/TreeStoreModel",
	"./tree/ForestStoreModel",
	"./tree/_dndSelector"
], function(array, connect, cookie, declare, Deferred, DeferredList,
			dom, domClass, domGeometry, domStyle, event, fxUtils, kernel, keys, lang, topic,
			focus, registry, manager, _Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin,
			treeNodeTemplate, treeTemplate, TreeStoreModel, ForestStoreModel, _dndSelector){

/*=====
	var _Widget = dijit._Widget;
	var _TemplatedMixin = dijit._TemplatedMixin;
	var _CssStateMixin = dijit._CssStateMixin;
	var _Container = dijit._Container;
	var _Contained = dijit._Contained;
=====*/

// module:
//		dijit/Tree
// summary:
//		dijit.Tree widget, and internal dijit._TreeNode widget


var TreeNode = declare(
	"dijit._TreeNode",
	[_Widget, _TemplatedMixin, _Container, _Contained, _CssStateMixin],
{
	// summary:
	//		Single node within a tree.   This class is used internally
	//		by Tree and should not be accessed directly.
	// tags:
	//		private

	// item: [const] Item
	//		the dojo.data entry this tree represents
	item: null,

	// isTreeNode: [protected] Boolean
	//		Indicates that this is a TreeNode.   Used by `dijit.Tree` only,
	//		should not be accessed directly.
	isTreeNode: true,

	// label: String
	//		Text of this tree node
	label: "",
	_setLabelAttr: {node: "labelNode", type: "innerText"},

	// isExpandable: [private] Boolean
	//		This node has children, so show the expando node (+ sign)
	isExpandable: null,

	// isExpanded: [readonly] Boolean
	//		This node is currently expanded (ie, opened)
	isExpanded: false,

	// state: [private] String
	//		Dynamic loading-related stuff.
	//		When an empty folder node appears, it is "UNCHECKED" first,
	//		then after dojo.data query it becomes "LOADING" and, finally "LOADED"
	state: "UNCHECKED",

	templateString: treeNodeTemplate,

	baseClass: "dijitTreeNode",

	// For hover effect for tree node, and focus effect for label
	cssStateNodes: {
		rowNode: "dijitTreeRow",
		labelNode: "dijitTreeLabel"
	},

	// Tooltip is defined in _WidgetBase but we need to handle the mapping to DOM here
	_setTooltipAttr: {node: "rowNode", type: "attribute", attribute: "title"},

	buildRendering: function(){
		this.inherited(arguments);

		// set expand icon for leaf
		this._setExpando();

		// set icon and label class based on item
		this._updateItemClasses(this.item);

		if(this.isExpandable){
			this.labelNode.setAttribute("aria-expanded", this.isExpanded);
		}

		//aria-selected should be false on all selectable elements.
		this.setSelected(false);
	},

	_setIndentAttr: function(indent){
		// summary:
		//		Tell this node how many levels it should be indented
		// description:
		//		0 for top level nodes, 1 for their children, 2 for their
		//		grandchildren, etc.

		// Math.max() is to prevent negative padding on hidden root node (when indent == -1)
		var pixels = (Math.max(indent, 0) * this.tree._nodePixelIndent) + "px";

		domStyle.set(this.domNode, "backgroundPosition",	pixels + " 0px");
		domStyle.set(this.rowNode, this.isLeftToRight() ? "paddingLeft" : "paddingRight", pixels);

		array.forEach(this.getChildren(), function(child){
			child.set("indent", indent+1);
		});

		this._set("indent", indent);
	},

	markProcessing: function(){
		// summary:
		//		Visually denote that tree is loading data, etc.
		// tags:
		//		private
		this.state = "LOADING";
		this._setExpando(true);
	},

	unmarkProcessing: function(){
		// summary:
		//		Clear markup from markProcessing() call
		// tags:
		//		private
		this._setExpando(false);
	},

	_updateItemClasses: function(item){
		// summary:
		//		Set appropriate CSS classes for icon and label dom node
		//		(used to allow for item updates to change respective CSS)
		// tags:
		//		private
		var tree = this.tree, model = tree.model;
		if(tree._v10Compat && item === model.root){
			// For back-compat with 1.0, need to use null to specify root item (TODO: remove in 2.0)
			item = null;
		}
		this._applyClassAndStyle(item, "icon", "Icon");
		this._applyClassAndStyle(item, "label", "Label");
		this._applyClassAndStyle(item, "row", "Row");
	},

	_applyClassAndStyle: function(item, lower, upper){
		// summary:
		//		Set the appropriate CSS classes and styles for labels, icons and rows.
		//
		// item:
		//		The data item.
		//
		// lower:
		//		The lower case attribute to use, e.g. 'icon', 'label' or 'row'.
		//
		// upper:
		//		The upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.
		//
		// tags:
		//		private

		var clsName = "_" + lower + "Class";
		var nodeName = lower + "Node";
		var oldCls = this[clsName];

		this[clsName] = this.tree["get" + upper + "Class"](item, this.isExpanded);
		domClass.replace(this[nodeName], this[clsName] || "", oldCls || "");

		domStyle.set(this[nodeName], this.tree["get" + upper + "Style"](item, this.isExpanded) || {});
 	},

	_updateLayout: function(){
		// summary:
		//		Set appropriate CSS classes for this.domNode
		// tags:
		//		private
		var parent = this.getParent();
		if(!parent || !parent.rowNode || parent.rowNode.style.display == "none"){
			/* if we are hiding the root node then make every first level child look like a root node */
			domClass.add(this.domNode, "dijitTreeIsRoot");
		}else{
			domClass.toggle(this.domNode, "dijitTreeIsLast", !this.getNextSibling());
		}
	},

	_setExpando: function(/*Boolean*/ processing){
		// summary:
		//		Set the right image for the expando node
		// tags:
		//		private

		var styles = ["dijitTreeExpandoLoading", "dijitTreeExpandoOpened",
						"dijitTreeExpandoClosed", "dijitTreeExpandoLeaf"],
			_a11yStates = ["*","-","+","*"],
			idx = processing ? 0 : (this.isExpandable ?	(this.isExpanded ? 1 : 2) : 3);

		// apply the appropriate class to the expando node
		domClass.replace(this.expandoNode, styles[idx], styles);

		// provide a non-image based indicator for images-off mode
		this.expandoNodeText.innerHTML = _a11yStates[idx];

	},

	expand: function(){
		// summary:
		//		Show my children
		// returns:
		//		Deferred that fires when expansion is complete

		// If there's already an expand in progress or we are already expanded, just return
		if(this._expandDeferred){
			return this._expandDeferred;		// dojo.Deferred
		}

		// cancel in progress collapse operation
		this._wipeOut && this._wipeOut.stop();

		// All the state information for when a node is expanded, maybe this should be
		// set when the animation completes instead
		this.isExpanded = true;
		this.labelNode.setAttribute("aria-expanded", "true");
		if(this.tree.showRoot || this !== this.tree.rootNode){
			this.containerNode.setAttribute("role", "group");
		}
		domClass.add(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);
		if(this == this.tree.rootNode){
			this.tree.domNode.setAttribute("aria-expanded", "true");
		}

		var def,
			wipeIn = fxUtils.wipeIn({
				node: this.containerNode, duration: manager.defaultDuration,
				onEnd: function(){
					def.callback(true);
				}
			});

		// Deferred that fires when expand is complete
		def = (this._expandDeferred = new Deferred(function(){
			// Canceller
			wipeIn.stop();
		}));

		wipeIn.play();

		return def;		// dojo.Deferred
	},

	collapse: function(){
		// summary:
		//		Collapse this node (if it's expanded)

		if(!this.isExpanded){ return; }

		// cancel in progress expand operation
		if(this._expandDeferred){
			this._expandDeferred.cancel();
			delete this._expandDeferred;
		}

		this.isExpanded = false;
		this.labelNode.setAttribute("aria-expanded", "false");
		if(this == this.tree.rootNode){
			this.tree.domNode.setAttribute("aria-expanded", "false");
		}
		domClass.remove(this.contentNode,'dijitTreeContentExpanded');
		this._setExpando();
		this._updateItemClasses(this.item);

		if(!this._wipeOut){
			this._wipeOut = fxUtils.wipeOut({
				node: this.containerNode, duration: manager.defaultDuration
			});
		}
		this._wipeOut.play();
	},

	// indent: Integer
	//		Levels from this node to the root node
	indent: 0,

	setChildItems: function(/* Object[] */ items){
		// summary:
		//		Sets the child items of this node, removing/adding nodes
		//		from current children to match specified items[] array.
		//		Also, if this.persist == true, expands any children that were previously
		// 		opened.
		// returns:
		//		Deferred object that fires after all previously opened children
		//		have been expanded again (or fires instantly if there are no such children).

		var tree = this.tree,
			model = tree.model,
			defs = [];	// list of deferreds that need to fire before I am complete


		// Orphan all my existing children.
		// If items contains some of the same items as before then we will reattach them.
		// Don't call this.removeChild() because that will collapse the tree etc.
		array.forEach(this.getChildren(), function(child){
			_Container.prototype.removeChild.call(this, child);
		}, this);

		this.state = "LOADED";

		if(items && items.length > 0){
			this.isExpandable = true;

			// Create _TreeNode widget for each specified tree node, unless one already
			// exists and isn't being used (presumably it's from a DnD move and was recently
			// released
			array.forEach(items, function(item){
				var id = model.getIdentity(item),
					existingNodes = tree._itemNodesMap[id],
					node;
				if(existingNodes){
					for(var i=0;i<existingNodes.length;i++){
						if(existingNodes[i] && !existingNodes[i].getParent()){
							node = existingNodes[i];
							node.set('indent', this.indent+1);
							break;
						}
					}
				}
				if(!node){
					node = this.tree._createTreeNode({
							item: item,
							tree: tree,
							isExpandable: model.mayHaveChildren(item),
							label: tree.getLabel(item),
							tooltip: tree.getTooltip(item),
							dir: tree.dir,
							lang: tree.lang,
							textDir: tree.textDir,
							indent: this.indent + 1
						});
					if(existingNodes){
						existingNodes.push(node);
					}else{
						tree._itemNodesMap[id] = [node];
					}
				}
				this.addChild(node);

				// If node was previously opened then open it again now (this may trigger
				// more data store accesses, recursively)
				if(this.tree.autoExpand || this.tree._state(node)){
					defs.push(tree._expandNode(node));
				}
			}, this);

			// note that updateLayout() needs to be called on each child after
			// _all_ the children exist
			array.forEach(this.getChildren(), function(child){
				child._updateLayout();
			});
		}else{
			this.isExpandable=false;
		}

		if(this._setExpando){
			// change expando to/from dot or + icon, as appropriate
			this._setExpando(false);
		}

		// Set leaf icon or folder icon, as appropriate
		this._updateItemClasses(this.item);

		// On initial tree show, make the selected TreeNode as either the root node of the tree,
		// or the first child, if the root node is hidden
		if(this == tree.rootNode){
			var fc = this.tree.showRoot ? this : this.getChildren()[0];
			if(fc){
				fc.setFocusable(true);
				tree.lastFocused = fc;
			}else{
				// fallback: no nodes in tree so focus on Tree <div> itself
				tree.domNode.setAttribute("tabIndex", "0");
			}
		}

		return new DeferredList(defs);	// dojo.Deferred
	},

	getTreePath: function(){
		var node = this;
		var path = [];
		while(node && node !== this.tree.rootNode){
				path.unshift(node.item);
				node = node.getParent();
		}
		path.unshift(this.tree.rootNode.item);

		return path;
	},

	getIdentity: function(){
		return this.tree.model.getIdentity(this.item);
	},

	removeChild: function(/* treeNode */ node){
		this.inherited(arguments);

		var children = this.getChildren();
		if(children.length == 0){
			this.isExpandable = false;
			this.collapse();
		}

		array.forEach(children, function(child){
				child._updateLayout();
		});
	},

	makeExpandable: function(){
		// summary:
		//		if this node wasn't already showing the expando node,
		//		turn it into one and call _setExpando()

		// TODO: hmm this isn't called from anywhere, maybe should remove it for 2.0

		this.isExpandable = true;
		this._setExpando(false);
	},

	_onLabelFocus: function(){
		// summary:
		//		Called when this row is focused (possibly programatically)
		//		Note that we aren't using _onFocus() builtin to dijit
		//		because it's called when focus is moved to a descendant TreeNode.
		// tags:
		//		private
		this.tree._onNodeFocus(this);
	},

	setSelected: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) currently selected node.
		//		Mark that this node is/isn't that currently selected node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).
		this.labelNode.setAttribute("aria-selected", selected);
		domClass.toggle(this.rowNode, "dijitTreeRowSelected", selected);
	},

	setFocusable: function(/*Boolean*/ selected){
		// summary:
		//		A Tree has a (single) node that's focusable.
		//		Mark that this node is/isn't that currently focsuable node.
		// description:
		//		In particular, setting a node as selected involves setting tabIndex
		//		so that when user tabs to the tree, focus will go to that node (only).

		this.labelNode.setAttribute("tabIndex", selected ? "0" : "-1");
	},

	_onClick: function(evt){
		// summary:
		//		Handler for onclick event on a node
		// tags:
		//		private
		this.tree._onClick(this, evt);
	},
	_onDblClick: function(evt){
		// summary:
		//		Handler for ondblclick event on a node
		// tags:
		//		private
		this.tree._onDblClick(this, evt);
	},

	_onMouseEnter: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseEnter(this, evt);
	},

	_onMouseLeave: function(evt){
		// summary:
		//		Handler for onmouseenter event on a node
		// tags:
		//		private
		this.tree._onNodeMouseLeave(this, evt);
	},

	_setTextDirAttr: function(textDir){
		if(textDir &&((this.textDir != textDir) || !this._created)){
			this._set("textDir", textDir);
			this.applyTextDir(this.labelNode, this.labelNode.innerText || this.labelNode.textContent || "");
			array.forEach(this.getChildren(), function(childNode){
				childNode.set("textDir", textDir);
			}, this);
		}
	}
});

var Tree = declare("dijit.Tree", [_Widget, _TemplatedMixin], {
	// summary:
	//		This widget displays hierarchical data from a store.

	// store: [deprecated] String||dojo.data.Store
	//		Deprecated.  Use "model" parameter instead.
	//		The store to get data to display in the tree.
	store: null,

	// model: dijit.Tree.model
	//		Interface to read tree data, get notifications of changes to tree data,
	//		and for handling drop operations (i.e drag and drop onto the tree)
	model: null,

	// query: [deprecated] anything
	//		Deprecated.  User should specify query to the model directly instead.
	//		Specifies datastore query to return the root item or top items for the tree.
	query: null,

	// label: [deprecated] String
	//		Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	//		Used in conjunction with query parameter.
	//		If a query is specified (rather than a root node id), and a label is also specified,
	//		then a fake root node is created and displayed, with this label.
	label: "",

	// showRoot: [const] Boolean
	//		Should the root node be displayed, or hidden?
	showRoot: true,

	// childrenAttr: [deprecated] String[]
	//		Deprecated.   This information should be specified in the model.
	//		One ore more attributes that holds children of a tree node
	childrenAttr: ["children"],

	// paths: String[][] or Item[][]
	//		Full paths from rootNode to selected nodes expressed as array of items or array of ids.
	//		Since setting the paths may be asynchronous (because ofwaiting on dojo.data), set("paths", ...)
	//		returns a Deferred to indicate when the set is complete.
	paths: [],

	// path: String[] or Item[]
	//      Backward compatible singular variant of paths.
	path: [],

	// selectedItems: [readonly] Item[]
	//		The currently selected items in this tree.
	//		This property can only be set (via set('selectedItems', ...)) when that item is already
	//		visible in the tree.   (I.e. the tree has already been expanded to show that node.)
	//		Should generally use `paths` attribute to set the selected items instead.
	selectedItems: null,

	// selectedItem: [readonly] Item
	//      Backward compatible singular variant of selectedItems.
	selectedItem: null,

	// openOnClick: Boolean
	//		If true, clicking a folder node's label will open it, rather than calling onClick()
	openOnClick: false,

	// openOnDblClick: Boolean
	//		If true, double-clicking a folder node's label will open it, rather than calling onDblClick()
	openOnDblClick: false,

	templateString: treeTemplate,

	// persist: Boolean
	//		Enables/disables use of cookies for state saving.
	persist: true,

	// autoExpand: Boolean
	//		Fully expand the tree on load.   Overrides `persist`.
	autoExpand: false,

	// dndController: [protected] Function|String
	//		Class to use as as the dnd controller.  Specifying this class enables DnD.
	//		Generally you should specify this as dijit.tree.dndSource.
	//      Setting of dijit.tree._dndSelector handles selection only (no actual DnD).
	dndController: _dndSelector,

	// parameters to pull off of the tree and pass on to the dndController as its params
	dndParams: ["onDndDrop","itemCreator","onDndCancel","checkAcceptance", "checkItemAcceptance", "dragThreshold", "betweenThreshold"],

	//declare the above items so they can be pulled from the tree's markup

	// onDndDrop: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndDrop`.
	//		Generally this doesn't need to be set.
	onDndDrop: null,

	/*=====
	itemCreator: function(nodes, target, source){
		// summary:
		//		Returns objects passed to `Tree.model.newItem()` based on DnD nodes
		//		dropped onto the tree.   Developer must override this method to enable
		// 		dropping from external sources onto this Tree, unless the Tree.model's items
		//		happen to look like {id: 123, name: "Apple" } with no other attributes.
		// description:
		//		For each node in nodes[], which came from source, create a hash of name/value
		//		pairs to be passed to Tree.model.newItem().  Returns array of those hashes.
		// nodes: DomNode[]
		//		The DOMNodes dragged from the source container
		// target: DomNode
		//		The target TreeNode.rowNode
		// source: dojo.dnd.Source
		//		The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source
		// returns: Object[]
		//		Array of name/value hashes for each new item to be added to the Tree, like:
		// |	[
		// |		{ id: 123, label: "apple", foo: "bar" },
		// |		{ id: 456, label: "pear", zaz: "bam" }
		// |	]
		// tags:
		//		extension
		return [{}];
	},
	=====*/
	itemCreator: null,

	// onDndCancel: [protected] Function
	//		Parameter to dndController, see `dijit.tree.dndSource.onDndCancel`.
	//		Generally this doesn't need to be set.
	onDndCancel: null,

/*=====
	checkAcceptance: function(source, nodes){
		// summary:
		//		Checks if the Tree itself can accept nodes from this source
		// source: dijit.tree._dndSource
		//		The source which provides items
		// nodes: DOMNode[]
		//		Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
		//		source is a dijit.Tree.
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkAcceptance: null,

/*=====
	checkItemAcceptance: function(target, source, position){
		// summary:
		//		Stub function to be overridden if one wants to check for the ability to drop at the node/item level
		// description:
		//		In the base case, this is called to check if target can become a child of source.
		//		When betweenThreshold is set, position="before" or "after" means that we
		//		are asking if the source node can be dropped before/after the target node.
		// target: DOMNode
		//		The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
		//		Use dijit.getEnclosingWidget(target) to get the TreeNode.
		// source: dijit.tree.dndSource
		//		The (set of) nodes we are dropping
		// position: String
		//		"over", "before", or "after"
		// tags:
		//		extension
		return true;	// Boolean
	},
=====*/
	checkItemAcceptance: null,

	// dragThreshold: Integer
	//		Number of pixels mouse moves before it's considered the start of a drag operation
	dragThreshold: 5,

	// betweenThreshold: Integer
	//		Set to a positive value to allow drag and drop "between" nodes.
	//
	//		If during DnD mouse is over a (target) node but less than betweenThreshold
	//		pixels from the bottom edge, dropping the the dragged node will make it
	//		the next sibling of the target node, rather than the child.
	//
	//		Similarly, if mouse is over a target node but less that betweenThreshold
	//		pixels from the top edge, dropping the dragged node will make it
	//		the target node's previous sibling rather than the target node's child.
	betweenThreshold: 0,

	// _nodePixelIndent: Integer
	//		Number of pixels to indent tree nodes (relative to parent node).
	//		Default is 19 but can be overridden by setting CSS class dijitTreeIndent
	//		and calling resize() or startup() on tree after it's in the DOM.
	_nodePixelIndent: 19,

	_publish: function(/*String*/ topicName, /*Object*/ message){
		// summary:
		//		Publish a message for this widget/topic
		topic.publish(this.id, lang.mixin({tree: this, event: topicName}, message || {}));	// publish
	},

	postMixInProperties: function(){
		this.tree = this;

		if(this.autoExpand){
			// There's little point in saving opened/closed state of nodes for a Tree
			// that initially opens all it's nodes.
			this.persist = false;
		}

		this._itemNodesMap={};

		if(!this.cookieName && this.id){
			this.cookieName = this.id + "SaveStateCookie";
		}

		this._loadDeferred = new Deferred();

		this.inherited(arguments);
	},

	postCreate: function(){
		this._initState();

		// Create glue between store and Tree, if not specified directly by user
		if(!this.model){
			this._store2model();
		}

		// monitor changes to items
		this.connect(this.model, "onChange", "_onItemChange");
		this.connect(this.model, "onChildrenChange", "_onItemChildrenChange");
		this.connect(this.model, "onDelete", "_onItemDelete");

		this._load();

		this.inherited(arguments);

		if(this.dndController){
			if(lang.isString(this.dndController)){
				this.dndController = lang.getObject(this.dndController);
			}
			var params={};
			for(var i=0; i<this.dndParams.length;i++){
				if(this[this.dndParams[i]]){
					params[this.dndParams[i]] = this[this.dndParams[i]];
				}
			}
			this.dndController = new this.dndController(this, params);
		}
	},

	_store2model: function(){
		// summary:
		//		User specified a store&query rather than model, so create model from store/query
		this._v10Compat = true;
		kernel.deprecated("Tree: from version 2.0, should specify a model object rather than a store/query");

		var modelParams = {
			id: this.id + "_ForestStoreModel",
			store: this.store,
			query: this.query,
			childrenAttrs: this.childrenAttr
		};

		// Only override the model's mayHaveChildren() method if the user has specified an override
		if(this.params.mayHaveChildren){
			modelParams.mayHaveChildren = lang.hitch(this, "mayHaveChildren");
		}

		if(this.params.getItemChildren){
			modelParams.getChildren = lang.hitch(this, function(item, onComplete, onError){
				this.getItemChildren((this._v10Compat && item === this.model.root) ? null : item, onComplete, onError);
			});
		}
		this.model = new ForestStoreModel(modelParams);

		// For backwards compatibility, the visibility of the root node is controlled by
		// whether or not the user has specified a label
		this.showRoot = Boolean(this.label);
	},

	onLoad: function(){
		// summary:
		//		Called when tree finishes loading and expanding.
		// description:
		//		If persist == true the loading may encompass many levels of fetches
		//		from the data store, each asynchronous.   Waits for all to finish.
		// tags:
		//		callback
	},

	_load: function(){
		// summary:
		//		Initial load of the tree.
		//		Load root node (possibly hidden) and it's children.
		this.model.getRoot(
			lang.hitch(this, function(item){
				var rn = (this.rootNode = this.tree._createTreeNode({
					item: item,
					tree: this,
					isExpandable: true,
					label: this.label || this.getLabel(item),
					textDir: this.textDir,
					indent: this.showRoot ? 0 : -1
				}));
				if(!this.showRoot){
					rn.rowNode.style.display="none";
					// if root is not visible, move tree role to the invisible
					// root node's containerNode, see #12135
					this.domNode.setAttribute("role", "presentation");

					rn.labelNode.setAttribute("role", "presentation");
					rn.containerNode.setAttribute("role", "tree");
				}
				this.domNode.appendChild(rn.domNode);
				var identity = this.model.getIdentity(item);
				if(this._itemNodesMap[identity]){
					this._itemNodesMap[identity].push(rn);
				}else{
					this._itemNodesMap[identity] = [rn];
				}

				rn._updateLayout();		// sets "dijitTreeIsRoot" CSS classname

				// load top level children and then fire onLoad() event
				this._expandNode(rn).addCallback(lang.hitch(this, function(){
					this._loadDeferred.callback(true);
					this.onLoad();
				}));
			}),
			function(err){
				console.error(this, ": error loading root: ", err);
			}
		);
	},

	getNodesByItem: function(/*Item or id*/ item){
		// summary:
		//		Returns all tree nodes that refer to an item
		// returns:
		//		Array of tree nodes that refer to passed item

		if(!item){ return []; }
		var identity = lang.isString(item) ? item : this.model.getIdentity(item);
		// return a copy so widget don't get messed up by changes to returned array
		return [].concat(this._itemNodesMap[identity]);
	},

	_setSelectedItemAttr: function(/*Item or id*/ item){
		this.set('selectedItems', [item]);
	},

	_setSelectedItemsAttr: function(/*Items or ids*/ items){
		// summary:
		//		Select tree nodes related to passed items.
		//		WARNING: if model use multi-parented items or desired tree node isn't already loaded
		//		behavior is undefined. Use set('paths', ...) instead.
		var tree = this;
		this._loadDeferred.addCallback( lang.hitch(this, function(){
			var identities = array.map(items, function(item){
				return (!item || lang.isString(item)) ? item : tree.model.getIdentity(item);
			});
			var nodes = [];
			array.forEach(identities, function(id){
				nodes = nodes.concat(tree._itemNodesMap[id] || []);
			});
			this.set('selectedNodes', nodes);
		}));
	},

	_setPathAttr: function(/*Item[] || String[]*/ path){
		// summary:
		//      Singular variant of _setPathsAttr
		if(path.length){
			return this.set("paths", [path]);
		}else{
			// Empty list is interpreted as "select nothing"
			return this.set("paths", []);
		}
	},

	_setPathsAttr: function(/*Item[][] || String[][]*/ paths){
		// summary:
		//		Select the tree nodes identified by passed paths.
		// paths:
		//		Array of arrays of items or item id's
		// returns:
		//		Deferred to indicate when the set is complete
		var tree = this;

		// We may need to wait for some nodes to expand, so setting
		// each path will involve a Deferred. We bring those deferreds
		// together witha DeferredList.
		return new DeferredList(array.map(paths, function(path){
			var d = new Deferred();

			// normalize path to use identity
			path = array.map(path, function(item){
				return lang.isString(item) ? item : tree.model.getIdentity(item);
			});

			if(path.length){
				// Wait for the tree to load, if it hasn't already.
				tree._loadDeferred.addCallback(function(){ selectPath(path, [tree.rootNode], d); });
			}else{
				d.errback("Empty path");
			}
			return d;
		})).addCallback(setNodes);

		function selectPath(path, nodes, def){
			// Traverse path; the next path component should be among "nodes".
			var nextPath = path.shift();
			var nextNode = array.filter(nodes, function(node){
				return node.getIdentity() == nextPath;
			})[0];
			if(!!nextNode){
				if(path.length){
					tree._expandNode(nextNode).addCallback(function(){ selectPath(path, nextNode.getChildren(), def); });
				}else{
					//Successfully reached the end of this path
					def.callback(nextNode);
				}
			}else{
				def.errback("Could not expand path at " + nextPath);
			}
		}

		function setNodes(newNodes){
			//After all expansion is finished, set the selection to
			//the set of nodes successfully found.
			tree.set("selectedNodes", array.map(
				array.filter(newNodes,function(x){return x[0];}),
				function(x){return x[1];}));
		}
	},

	_setSelectedNodeAttr: function(node){
		this.set('selectedNodes', [node]);
	},
	_setSelectedNodesAttr: function(nodes){
		this._loadDeferred.addCallback( lang.hitch(this, function(){
			this.dndController.setSelection(nodes);
		}));
	},


	////////////// Data store related functions //////////////////////
	// These just get passed to the model; they are here for back-compat

	mayHaveChildren: function(/*dojo.data.Item*/ /*===== item =====*/){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		//		Overridable function to tell if an item has or may have children.
		//		Controls whether or not +/- expando icon is shown.
		//		(For efficiency reasons we may not want to check if an element actually
		//		has children until user clicks the expando node)
		// tags:
		//		deprecated
	},

	getItemChildren: function(/*===== parentItem, onComplete =====*/){
		// summary:
		//		Deprecated.   This should be specified on the model itself.
		//
		// 		Overridable function that return array of child items of given parent item,
		//		or if parentItem==null then return top items in tree
		// tags:
		//		deprecated
	},

	///////////////////////////////////////////////////////
	// Functions for converting an item to a TreeNode
	getLabel: function(/*dojo.data.Item*/ item){
		// summary:
		//		Overridable function to get the label for a tree node (given the item)
		// tags:
		//		extension
		return this.model.getLabel(item);	// String
	},

	getIconClass: function(/*dojo.data.Item*/ item, /*Boolean*/ opened){
		// summary:
		//		Overridable function to return CSS class name to display icon
		// tags:
		//		extension
		return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitFolderOpened" : "dijitFolderClosed") : "dijitLeaf"
	},

	getLabelClass: function(/*===== item, opened =====*/){
		// summary:
		//		Overridable function to return CSS class name to display label
		// item: dojo.data.Item
		// opened: Boolean
		// returns: String
		//		CSS class name
		// tags:
		//		extension
	},

	getRowClass: function(/*===== item, opened =====*/){
		// summary:
		//		Overridable function to return CSS class name to display row
		// item: dojo.data.Item
		// opened: Boolean
		// returns: String
		//		CSS class name
		// tags:
		//		extension
	},

	getIconStyle: function(/*===== item, opened =====*/){
		// summary:
		//		Overridable function to return CSS styles to display icon
		// item: dojo.data.Item
		// opened: Boolean
		// returns: Object
		//		Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}
		// tags:
		//		extension
	},

	getLabelStyle: function(/*===== item, opened =====*/){
		// summary:
		//		Overridable function to return CSS styles to display label
		// item: dojo.data.Item
		// opened: Boolean
		// returns:
		//		Object suitable for input to dojo.style() like {color: "red", background: "green"}
		// tags:
		//		extension
	},

	getRowStyle: function(/*===== item, opened =====*/){
		// summary:
		//		Overridable function to return CSS styles to display row
		// item: dojo.data.Item
		// opened: Boolean
		// returns:
		//		Object suitable for input to dojo.style() like {background-color: "#bbb"}
		// tags:
		//		extension
	},

	getTooltip: function(/*dojo.data.Item*/ /*===== item =====*/){
		// summary:
		//		Overridable function to get the tooltip for a tree node (given the item)
		// tags:
		//		extension
		return "";	// String
	},

	/////////// Keyboard and Mouse handlers ////////////////////

	_onKeyPress: function(/*Event*/ e){
		// summary:
		//		Translates keypress events into commands for the controller
		if(e.altKey){ return; }
		var treeNode = registry.getEnclosingWidget(e.target);
		if(!treeNode){ return; }

		var key = e.charOrCode;
		if(typeof key == "string" && key != " "){	// handle printables (letter navigation)
			// Check for key navigation.
			if(!e.altKey && !e.ctrlKey && !e.shiftKey && !e.metaKey){
				this._onLetterKeyNav( { node: treeNode, key: key.toLowerCase() } );
				event.stop(e);
			}
		}else{	// handle non-printables (arrow keys)
			// clear record of recent printables (being saved for multi-char letter navigation),
			// because "a", down-arrow, "b" shouldn't search for "ab"
			if(this._curSearch){
				clearTimeout(this._curSearch.timer);
				delete this._curSearch;
			}

			var map = this._keyHandlerMap;
			if(!map){
				// setup table mapping keys to events
				map = {};
				map[keys.ENTER]="_onEnterKey";
				//On WebKit based browsers, the combination ctrl-enter
				//does not get passed through. To allow accessible
				//multi-select on those browsers, the space key is
				//also used for selection.
				map[keys.SPACE]= map[" "] = "_onEnterKey";
				map[this.isLeftToRight() ? keys.LEFT_ARROW : keys.RIGHT_ARROW]="_onLeftArrow";
				map[this.isLeftToRight() ? keys.RIGHT_ARROW : keys.LEFT_ARROW]="_onRightArrow";
				map[keys.UP_ARROW]="_onUpArrow";
				map[keys.DOWN_ARROW]="_onDownArrow";
				map[keys.HOME]="_onHomeKey";
				map[keys.END]="_onEndKey";
				this._keyHandlerMap = map;
			}
			if(this._keyHandlerMap[key]){
				this[this._keyHandlerMap[key]]( { node: treeNode, item: treeNode.item, evt: e } );
				event.stop(e);
			}
		}
	},

	_onEnterKey: function(/*Object*/ message){
		this._publish("execute", { item: message.item, node: message.node } );
		this.dndController.userSelect(message.node, connect.isCopyKey( message.evt ), message.evt.shiftKey);
		this.onClick(message.item, message.node, message.evt);
	},

	_onDownArrow: function(/*Object*/ message){
		// summary:
		//		down arrow pressed; get next visible node, set focus there
		var node = this._getNextNode(message.node);
		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onUpArrow: function(/*Object*/ message){
		// summary:
		//		Up arrow pressed; move to previous visible node

		var node = message.node;

		// if younger siblings
		var previousSibling = node.getPreviousSibling();
		if(previousSibling){
			node = previousSibling;
			// if the previous node is expanded, dive in deep
			while(node.isExpandable && node.isExpanded && node.hasChildren()){
				// move to the last child
				var children = node.getChildren();
				node = children[children.length-1];
			}
		}else{
			// if this is the first child, return the parent
			// unless the parent is the root of a tree with a hidden root
			var parent = node.getParent();
			if(!(!this.showRoot && parent === this.rootNode)){
				node = parent;
			}
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	_onRightArrow: function(/*Object*/ message){
		// summary:
		//		Right arrow pressed; go to child node
		var node = message.node;

		// if not expanded, expand, else move to 1st child
		if(node.isExpandable && !node.isExpanded){
			this._expandNode(node);
		}else if(node.hasChildren()){
			node = node.getChildren()[0];
			if(node && node.isTreeNode){
				this.focusNode(node);
			}
		}
	},

	_onLeftArrow: function(/*Object*/ message){
		// summary:
		//		Left arrow pressed.
		//		If not collapsed, collapse, else move to parent.

		var node = message.node;

		if(node.isExpandable && node.isExpanded){
			this._collapseNode(node);
		}else{
			var parent = node.getParent();
			if(parent && parent.isTreeNode && !(!this.showRoot && parent === this.rootNode)){
				this.focusNode(parent);
			}
		}
	},

	_onHomeKey: function(){
		// summary:
		//		Home key pressed; get first visible node, and set focus there
		var node = this._getRootOrFirstNode();
		if(node){
			this.focusNode(node);
		}
	},

	_onEndKey: function(){
		// summary:
		//		End key pressed; go to last visible node.

		var node = this.rootNode;
		while(node.isExpanded){
			var c = node.getChildren();
			node = c[c.length - 1];
		}

		if(node && node.isTreeNode){
			this.focusNode(node);
		}
	},

	// multiCharSearchDuration: Number
	//		If multiple characters are typed where each keystroke happens within
	//		multiCharSearchDuration of the previous keystroke,
	//		search for nodes matching all the keystrokes.
	//
	//		For example, typing "ab" will search for entries starting with
	//		"ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
	multiCharSearchDuration: 250,

	_onLetterKeyNav: function(message){
		// summary:
		//		Called when user presses a prinatable key; search for node starting with recently typed letters.
		// message: Object
		//		Like { node: TreeNode, key: 'a' } where key is the key the user pressed.

		// Branch depending on whether this key starts a new search, or modifies an existing search
		var cs = this._curSearch;
		if(cs){
			// We are continuing a search.  Ex: user has pressed 'a', and now has pressed
			// 'b', so we want to search for nodes starting w/"ab".
			cs.pattern = cs.pattern + message.key;
			clearTimeout(cs.timer);
		}else{
			// We are starting a new search
			cs = this._curSearch = {
					pattern: message.key,
					startNode: message.node
			};
		}

		// set/reset timer to forget recent keystrokes
		var self = this;
		cs.timer = setTimeout(function(){
			delete self._curSearch;
		}, this.multiCharSearchDuration);

		// Navigate to TreeNode matching keystrokes [entered so far].
		var node = cs.startNode;
		do{
			node = this._getNextNode(node);
			//check for last node, jump to first node if necessary
			if(!node){
				node = this._getRootOrFirstNode();
			}
		}while(node !== cs.startNode && (node.label.toLowerCase().substr(0, cs.pattern.length) != cs.pattern));
		if(node && node.isTreeNode){
			// no need to set focus if back where we started
			if(node !== cs.startNode){
				this.focusNode(node);
			}
		}
	},

	isExpandoNode: function(node, widget){
		// summary:
		//		check whether a dom node is the expandoNode for a particular TreeNode widget
		return dom.isDescendant(node, widget.expandoNode);
	},
	_onClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = this.isExpandoNode(domElement, nodeWidget);

		if( (this.openOnClick && nodeWidget.isExpandable) || isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		event.stop(e);
	},
	_onDblClick: function(/*TreeNode*/ nodeWidget, /*Event*/ e){
		// summary:
		//		Translates double-click events into commands for the controller to process

		var domElement = e.target,
			isExpandoClick = (domElement == nodeWidget.expandoNode || domElement == nodeWidget.expandoNodeText);

		if( (this.openOnDblClick && nodeWidget.isExpandable) ||isExpandoClick ){
			// expando node was clicked, or label of a folder node was clicked; open it
			if(nodeWidget.isExpandable){
				this._onExpandoClick({node:nodeWidget});
			}
		}else{
			this._publish("execute", { item: nodeWidget.item, node: nodeWidget, evt: e } );
			this.onDblClick(nodeWidget.item, nodeWidget, e);
			this.focusNode(nodeWidget);
		}
		event.stop(e);
	},

	_onExpandoClick: function(/*Object*/ message){
		// summary:
		//		User clicked the +/- icon; expand or collapse my children.
		var node = message.node;

		// If we are collapsing, we might be hiding the currently focused node.
		// Also, clicking the expando node might have erased focus from the current node.
		// For simplicity's sake just focus on the node with the expando.
		this.focusNode(node);

		if(node.isExpanded){
			this._collapseNode(node);
		}else{
			this._expandNode(node);
		}
	},

	onClick: function(/*===== item, node, evt =====*/){
		// summary:
		//		Callback when a tree node is clicked
		// item: dojo.data.Item
		// node: TreeNode
		// evt: Event
		// tags:
		//		callback
	},
	onDblClick: function(/*===== item, node, evt =====*/){
		// summary:
		//		Callback when a tree node is double-clicked
		// item: dojo.data.Item
		// node: TreeNode
		// evt: Event
		// tags:
		//		callback
	},
	onOpen: function(/*===== item, node =====*/){
		// summary:
		//		Callback when a node is opened
		// item: dojo.data.Item
		// node: TreeNode
		// tags:
		//		callback
	},
	onClose: function(/*===== item, node =====*/){
		// summary:
		//		Callback when a node is closed
		// item: dojo.data.Item
		// node: TreeNode
		// tags:
		//		callback
	},

	_getNextNode: function(node){
		// summary:
		//		Get next visible node

		if(node.isExpandable && node.isExpanded && node.hasChildren()){
			// if this is an expanded node, get the first child
			return node.getChildren()[0];		// _TreeNode
		}else{
			// find a parent node with a sibling
			while(node && node.isTreeNode){
				var returnNode = node.getNextSibling();
				if(returnNode){
					return returnNode;		// _TreeNode
				}
				node = node.getParent();
			}
			return null;
		}
	},

	_getRootOrFirstNode: function(){
		// summary:
		//		Get first visible node
		return this.showRoot ? this.rootNode : this.rootNode.getChildren()[0];
	},

	_collapseNode: function(/*_TreeNode*/ node){
		// summary:
		//		Called when the user has requested to collapse the node

		if(node._expandNodeDeferred){
			delete node._expandNodeDeferred;
		}

		if(node.isExpandable){
			if(node.state == "LOADING"){
				// ignore clicks while we are in the process of loading data
				return;
			}

			node.collapse();
			this.onClose(node.item, node);

			this._state(node, false);
		}
	},

	_expandNode: function(/*_TreeNode*/ node, /*Boolean?*/ recursive){
		// summary:
		//		Called when the user has requested to expand the node
		// recursive:
		//		Internal flag used when _expandNode() calls itself, don't set.
		// returns:
		//		Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
		//		that were previously opened too

		if(node._expandNodeDeferred && !recursive){
			// there's already an expand in progress (or completed), so just return
			return node._expandNodeDeferred;	// dojo.Deferred
		}

		var model = this.model,
			item = node.item,
			_this = this;

		switch(node.state){
			case "UNCHECKED":
				// need to load all the children, and then expand
				node.markProcessing();

				// Setup deferred to signal when the load and expand are finished.
				// Save that deferred in this._expandDeferred as a flag that operation is in progress.
				var def = (node._expandNodeDeferred = new Deferred());

				// Get the children
				model.getChildren(
					item,
					function(items){
						node.unmarkProcessing();

						// Display the children and also start expanding any children that were previously expanded
						// (if this.persist == true).   The returned Deferred will fire when those expansions finish.
						var scid = node.setChildItems(items);

						// Call _expandNode() again but this time it will just to do the animation (default branch).
						// The returned Deferred will fire when the animation completes.
						// TODO: seems like I can avoid recursion and just use a deferred to sequence the events?
						var ed = _this._expandNode(node, true);

						// After the above two tasks (setChildItems() and recursive _expandNode()) finish,
						// signal that I am done.
						scid.addCallback(function(){
							ed.addCallback(function(){
								def.callback();
							})
						});
					},
					function(err){
						console.error(_this, ": error loading root children: ", err);
					}
				);
				break;

			default:	// "LOADED"
				// data is already loaded; just expand node
				def = (node._expandNodeDeferred = node.expand());

				this.onOpen(node.item, node);

				this._state(node, true);
		}

		return def;	// dojo.Deferred
	},

	////////////////// Miscellaneous functions ////////////////

	focusNode: function(/* _tree.Node */ node){
		// summary:
		//		Focus on the specified node (which must be visible)
		// tags:
		//		protected

		// set focus so that the label will be voiced using screen readers
		focus.focus(node.labelNode);
	},

	_onNodeFocus: function(/*dijit._Widget*/ node){
		// summary:
		//		Called when a TreeNode gets focus, either by user clicking
		//		it, or programatically by arrow key handling code.
		// description:
		//		It marks that the current node is the selected one, and the previously
		//		selected node no longer is.

		if(node && node != this.lastFocused){
			if(this.lastFocused && !this.lastFocused._destroyed){
				// mark that the previously focsable node is no longer focusable
				this.lastFocused.setFocusable(false);
			}

			// mark that the new node is the currently selected one
			node.setFocusable(true);
			this.lastFocused = node;
		}
	},

	_onNodeMouseEnter: function(/*dijit._Widget*/ /*===== node =====*/){
		// summary:
		//		Called when mouse is over a node (onmouseenter event),
		//		this is monitored by the DND code
	},

	_onNodeMouseLeave: function(/*dijit._Widget*/ /*===== node =====*/){
		// summary:
		//		Called when mouse leaves a node (onmouseleave event),
		//		this is monitored by the DND code
	},

	//////////////// Events from the model //////////////////////////

	_onItemChange: function(/*Item*/ item){
		// summary:
		//		Processes notification of a change to an item's scalar values like label
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			var label = this.getLabel(item),
				tooltip = this.getTooltip(item);
			array.forEach(nodes, function(node){
				node.set({
					item: item,		// theoretically could be new JS Object representing same item
					label: label,
					tooltip: tooltip
				});
				node._updateItemClasses(item);
			});
		}
	},

	_onItemChildrenChange: function(/*dojo.data.Item*/ parent, /*dojo.data.Item[]*/ newChildrenList){
		// summary:
		//		Processes notification of a change to an item's children
		var model = this.model,
			identity = model.getIdentity(parent),
			parentNodes = this._itemNodesMap[identity];

		if(parentNodes){
			array.forEach(parentNodes,function(parentNode){
				parentNode.setChildItems(newChildrenList);
			});
		}
	},

	_onItemDelete: function(/*Item*/ item){
		// summary:
		//		Processes notification of a deletion of an item
		var model = this.model,
			identity = model.getIdentity(item),
			nodes = this._itemNodesMap[identity];

		if(nodes){
			array.forEach(nodes,function(node){
				// Remove node from set of selected nodes (if it's selected)
				this.dndController.removeTreeNode(node);

				var parent = node.getParent();
				if(parent){
					// if node has not already been orphaned from a _onSetItem(parent, "children", ..) call...
					parent.removeChild(node);
				}
				node.destroyRecursive();
			}, this);
			delete this._itemNodesMap[identity];
		}
	},

	/////////////// Miscellaneous funcs

	_initState: function(){
		// summary:
		//		Load in which nodes should be opened automatically
		this._openedNodes = {};
		if(this.persist && this.cookieName){
			var oreo = cookie(this.cookieName);
			if(oreo){
				array.forEach(oreo.split(','), function(item){
					this._openedNodes[item] = true;
				}, this);
			}
		}
	},
	_state: function(node, expanded){
		// summary:
		//		Query or set expanded state for an node
		if(!this.persist){
			return false;
		}
		var path = array.map(node.getTreePath(), function(item){
				return this.model.getIdentity(item);
			}, this).join("/");
		if(arguments.length === 1){
			return this._openedNodes[path];
		}else{
			if(expanded){
				this._openedNodes[path] = true;
			}else{
				delete this._openedNodes[path];
			}
			var ary = [];
			for(var id in this._openedNodes){
				ary.push(id);
			}
			cookie(this.cookieName, ary.join(","), {expires:365});
		}
	},

	destroy: function(){
		if(this._curSearch){
			clearTimeout(this._curSearch.timer);
			delete this._curSearch;
		}
		if(this.rootNode){
			this.rootNode.destroyRecursive();
		}
		if(this.dndController && !lang.isString(this.dndController)){
			this.dndController.destroy();
		}
		this.rootNode = null;
		this.inherited(arguments);
	},

	destroyRecursive: function(){
		// A tree is treated as a leaf, not as a node with children (like a grid),
		// but defining destroyRecursive for back-compat.
		this.destroy();
	},

	resize: function(changeSize){
		if(changeSize){
			domGeometry.setMarginBox(this.domNode, changeSize);
		}

		// The only JS sizing involved w/tree is the indentation, which is specified
		// in CSS and read in through this dummy indentDetector node (tree must be
		// visible and attached to the DOM to read this)
		this._nodePixelIndent = domGeometry.position(this.tree.indentDetector).w;

		if(this.tree.rootNode){
			// If tree has already loaded, then reset indent for all the nodes
			this.tree.rootNode.set('indent', this.showRoot ? 0 : -1);
		}
	},

	_createTreeNode: function(/*Object*/ args){
		// summary:
		//		creates a TreeNode
		// description:
		//		Developers can override this method to define their own TreeNode class;
		//		However it will probably be removed in a future release in favor of a way
		//		of just specifying a widget for the label, rather than one that contains
		//		the children too.
		return new TreeNode(args);
	},

	_setTextDirAttr: function(textDir){
		if(textDir && this.textDir!= textDir){
			this._set("textDir",textDir);
			this.rootNode.set("textDir", textDir);
		}
	}
});

Tree._TreeNode = TreeNode;	// for monkey patching

return Tree;
});

},
'dijit/form/_FormValueWidget':function(){
define("dijit/form/_FormValueWidget", [
	"dojo/_base/declare", // declare
	"dojo/_base/sniff", // has("ie")
	"./_FormWidget",
	"./_FormValueMixin"
], function(declare, has, _FormWidget, _FormValueMixin){

/*=====
var _FormWidget = dijit.form._FormWidget;
var _FormValueMixin = dijit.form._FormValueMixin;
=====*/

// module:
//		dijit/form/_FormValueWidget
// summary:
//		FormValueWidget


return declare("dijit.form._FormValueWidget", [_FormWidget, _FormValueMixin],
{
	// summary:
	//		Base class for widgets corresponding to native HTML elements such as <input> or <select> that have user changeable values.
	// description:
	//		Each _FormValueWidget represents a single input value, and has a (possibly hidden) <input> element,
	//		to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	//		works as expected.

	// Don't attempt to mixin the 'type', 'name' attributes here programatically -- they must be declared
	// directly in the template as read by the parser in order to function. IE is known to specifically
	// require the 'name' attribute at element creation time.  See #8484, #8660.

	_layoutHackIE7: function(){
		// summary:
		//		Work around table sizing bugs on IE7 by forcing redraw

		if(has("ie") == 7){ // fix IE7 layout bug when the widget is scrolled out of sight
			var domNode = this.domNode;
			var parent = domNode.parentNode;
			var pingNode = domNode.firstChild || domNode; // target node most unlikely to have a custom filter
			var origFilter = pingNode.style.filter; // save custom filter, most likely nothing
			var _this = this;
			while(parent && parent.clientHeight == 0){ // search for parents that haven't rendered yet
				(function ping(){
					var disconnectHandle = _this.connect(parent, "onscroll",
						function(){
							_this.disconnect(disconnectHandle); // only call once
							pingNode.style.filter = (new Date()).getMilliseconds(); // set to anything that's unique
							setTimeout(function(){ pingNode.style.filter = origFilter }, 0); // restore custom filter, if any
						}
					);
				})();
				parent = parent.parentNode;
			}
		}
	}
});

});

},
'ibm/tivoli/simplesrm/srm/dijit/Navigator':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/i18n!ibm/tivoli/simplesrm/srm/dijit/nls/uiNavigatorStringTable","dojo/require!dijit/_Widget,dijit/registry,dijit/WidgetSet,dijit/_Templated,dojo/fx,dojo/parser,dojo/cookie,dojo/DeferredList,dijit/ProgressBar,ibm/tivoli/simplesrm/srm/dijit/WidgetBase,ibm/tivoli/simplesrm/srm/dijit/ListTree,ibm/tivoli/simplesrm/srm/dijit/Breadcrumb,ibm/tivoli/simplesrm/srm/dijit/CreateCatalogRequest,ibm/tivoli/tip/dijit/TIPButton,ibm/tivoli/tip/dijit/TextInputBox,ibm/tivoli/simplesrm/srm/dijit/ToolbarButton,ibm/tivoli/simplesrm/srm/dojo/data/srmQuery,ibm/tivoli/simplesrm/srm/dojo/Logger,dijit/Tree,dojo/data/ItemFileReadStore,dijit/tree/ForestStoreModel,dijit/layout/BorderContainer,dijit/layout/ContentPane"], function(dijit,dojo,dojox){
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

// TODO:
// 	 - do I need to expose list pushing and popping events to the outside?

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.Navigator");

dojo.require("dijit._Widget");
dojo.require("dijit.registry");  
dojo.require("dijit.WidgetSet");
dojo.require("dijit._Templated");
dojo.require("dojo.fx");
dojo.require("dojo.parser");
dojo.require("dojo.cookie");
dojo.require("dojo.DeferredList");
dojo.require("dijit.ProgressBar");

//dojo.require("dojox.widget.Standby");

dojo.require("ibm.tivoli.simplesrm.srm.dijit.WidgetBase");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ListTree");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.Breadcrumb");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.CreateCatalogRequest");
dojo.require("ibm.tivoli.tip.dijit.TIPButton");
dojo.require("ibm.tivoli.tip.dijit.TextInputBox");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.ToolbarButton");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.data.srmQuery");
dojo.require("ibm.tivoli.simplesrm.srm.dojo.Logger");
dojo.require("dijit.Tree"); 

dojo.require("dojo.data.ItemFileReadStore");
dojo.require("dijit.tree.ForestStoreModel");
dojo.require("dijit.layout.BorderContainer");
dojo.require("dijit.layout.ContentPane");


dojo.requireLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiNavigatorStringTable");

/*
 * Navigator
 * Loads data representing the taxonomy of Service Request and Incident categories
 * Events:
 * 	onSrmNavigatorClick(item_label): fired when user clicks on a leaf node of the tree
*/
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.Navigator", 
	[dijit._Widget, dijit._Templated, ibm.tivoli.simplesrm.srm.dijit.WidgetBase, ibm.tivoli.simplesrm.srm.dijit.CreatorFactory], 
	{	
		widgetsInTemplate: true,
		templateString:"<div class='srmnavigator'>\n<!--\n @HTML_LONG_COPYRIGHT_BEGIN@\n @HTML_LONG_COPYRIGHT_END@\n-->\n\t<div class=\"navigator_head\" style=\"position:relative; padding: .625em;\">\n\t\t<table STYLE='width:100%'>\t   \n\t\t  \t\t   \t\t   \n\t\t   <tr>\n\t\t\t<td>\n\t  \t       <button dojoattachpoint=\"home_btn\" dojotype=\"dijit.form.Button\" baseClass=\"srm_button\" showLabel=\"false\" label=\"${_uiStringTable.Home}\" iconClass=\"navigator_home\" title=\"${_uiStringTable.Home}\"> </button>\t\t\t \n\t\t\t</td>\n\t\t\t\n\t\t\t<td>\n\t\t\t   <img src=\"../webclient/images/img_divider_tablebtns.gif\" alt=\"|\" />\n\t\t\t</td>\t\n\t\t\t\n\t\t\t<td>\n               <DIV>\n\t\t\t      <div>\n\t\t\t\t    <button id=\"${id}_createSR_btn\" dojoattachpoint=\"createSR_btn\" dojotype=\"dijit.form.Button\" baseClass=\"srm_button\" showLabel=\"false\" label=\"Create Request\" baseClass=\"srm_button\" iconClass=\"createSR_btn\" ></button>                        \n\t\t\t\t<!--    <span id=\"${id}_createSR_label\" style='margin-left:-0px;'  dojoattachpoint=\"createSR_text_btn\" dojoAttachEvent=\"onclick:_createSR,onmouseover:_createSROnRollover,onmouseout:_createSROnRollout\"  class=\"srm_cart\" >${_uiStringTable.CreateSR}  </span> -->\t\t\t\t    \n\t\t\t     </div>\n               </DIV>\n\t\t\t</td>\n\t\t\t\n\t\t\t<td>\t\t\t   \t\t\t\n   \t\t\t   <img src=\"../webclient/images/img_divider_tablebtns.gif\" alt=\"|\" />\n\t\t\t</td>\t\n\t\t\t\n\t\t\t<td >\n\t\t\t   <button id=\"${id}_shoppingCart_btn\" dojoattachpoint=\"shoppingCart_btn\" dojotype=\"dijit.form.Button\" baseClass=\"srm_button\" showLabel=\"false\" label=\"Shopping Cart\" baseClass=\"srm_button\" iconClass=\"shoppingCart_btn\"></button>\n\t\t\t   <sup id=\"${id}_cart_amount\"  class=\"srm_cart_amount\"  > </sup>\t\t\t\n\t\t\t   \t\t\t   \n\t\t\t</td>\n\n\t\t\t<td>\t\t\t    \n\t\t\t    <button id=\"${id}_template_btn\" dojoattachpoint=\"template_btn\" dojotype=\"dijit.form.Button\" baseClass=\"srm_button\" showLabel=\"false\" label=\"Cart Templates\" baseClass=\"srm_button\" iconClass=\"template_btn\" ></button>\t\t\t\t\n\t\t\t</td>\t\t\t\n\t\t\t\t\t\t\n\t\t\t<td>\t\t\t     \t\n   \t\t\t    <img src=\"../webclient/images/img_divider_tablebtns.gif\" alt=\"|\" />\n\t\t\t</td>\t\n\t\t\t\t\t\t\t\n\t\t\t \n\t\t\t<td>\n\t\t\t    <div style=\"display:none;\"> <label id=\"${id}_search_label\" for=\"${id}_list_search_term\">${_uiStringTable.Search}</label></div>\n\t\t\t    <input id='${id}_list_search_term' dojoattachpoint=\"list_search_term\" type='text' name='ticket_search' style='width: 350px;' class=\"vm placeholder\" value=\"${_uiStringTable.SearchFieldText}\"   dojoAttachEvent=\"onblur:_placeholder, onfocus:_placeholder\" >\t\t        \t\t\t      \n\t\t\t    <button      id=\"${id}_list_search_btn\"  dojoattachpoint=\"list_search_btn\" dojotype=\"dijit.form.Button\" showLabel=\"false\" label=\"Search\" baseClass=\"srm_button\" iconClass=\"header_search_btn\" ></button>                        \n\t\t\t</td>\n\n\t\t\t<td>\t\t\t    \t\t\n   \t\t\t   <img src=\"../webclient/images/img_divider_tablebtns.gif\" alt=\"|\" />\n\t\t\t</td>           \n\t\t\t \n\t\t\t \n\t\t\t<td  class=\"maximize_nav_td\">\n\t\t        <img id = \"${id}_maximize_nav\" src=\"../webclient/javascript/simplesrm/srm/dijit/images/nav_icon_fullScreen.png\" alt=\"m\" class=\"maximize_nav\"   title=\"${_uiStringTable.Maximize}\"/>\t\t        \n\t\t    </td>\n\n\t\t   </tr>\n\t\t</table>\t\n\t</div>\n\t\n\t<!-- <div class=\"navigator_srmhead\" style=\"position:relative; padding: .225em;\">\n\t\t<div style=\"position:absolute; left:.625em; top: 50%; height: 34px; width: 120px; margin-top: -17px;\">\n\t\t <input id='${id}_list_createSR_btn'  dojoattachpoint=\"createSR_btn\" type=\"Button\" dojoType=\"ibm.tivoli.tip.dijit.TIPButton\" label=\"${_uiStringTable.CreateSR}\" title=\"${_uiStringTable.CreateSR}\" value=\"${_uiStringTable.CreateSR}\" > \n\t\t</div>\n\t</div>\n\t-->\n\t\n\n\t<div id='${id}_box' class='navigator_body' >\n\t\t<div dojoAttachPoint=\"breadcrumbContainer\">\n\t\t\t\t<div id='${id}_crumbs' dojoType='ibm.tivoli.simplesrm.srm.dijit.Breadcrumb' ></div>\n\t\t</div>\n\t\t\n\t\t<div class='tree_box' id='${id}_tree_box' style=\"height:100%;\">\n\t\t\n\t\t <div dojoType=\"dijit.layout.BorderContainer\" class='borderContainer' design='sidebar' gutters='true' liveSplitters='true' id=\"${id}_borderContainer\">\n\n               <div dojoType=\"dijit.layout.ContentPane\" splitter='true' region='leading' class='borderContainerLeft' id='${id}_borderContainerLeft' style=\"padding: 0px;background-color: #FAFAFA\">           \n                   \n               </div>\n                \n              <div dojoType=\"dijit.layout.ContentPane\" splitter='true' region='center' id=\"${id}_borderContainerCenter\" class='borderContainerCenter' style=\"background-color: #FAFAFA\">\n            \n                 <div dojoAttachPoint=\"treeContainer\">\n\t\t\t\t    <div id=\"${id}_list\" dojoType=\"ibm.tivoli.simplesrm.srm.dijit.ListTree\" dojoAttachPoint=\"rootListNode\" \n\t\t\t\t\t   fillOrder=\"${fillOrder}\" label=\"${_uiStringTable.HomeBreadcrumb}\" \n\t\t\t\t\t   keyField=\"${keyField}\" labelField=\"${labelField}\" descField=\"${descField}\" iconField=\"${iconField}\" iconSizeField=\"${iconSizeField}\" iconClassField=\"${iconClassField}\" \n\t\t\t\t\t   childField=\"${childField}\" leafField=\"${leafField}\" toolTip=\"${toolTip}\" colCount=\"1\">\n\t\t\t\t   </div>\n\t\t\t     </div>\n            \n              </div>\n\t\t\t\t \n\t    </div>\n\t\t\n\t\t<div class='clear'></div>\n\t</div>\n\t<div class='clear'></div>\n\t<div dojoType=\"dijit.DialogUnderlay\" id=\"loading-dialog\" bgColor=\"gray\" bgOpacity=\"0.5\" toggle=\"fade\" toggleDuration=\"250\" >\n\t</div>\n\t\n\t<div dojoType=\"ibm.tivoli.simplesrm.srm.dijit.PopupDialog\" id=\"search-dialog\"  title=\"${_uiStringTable.HelpFixLabel}\" >\n\t\t<br>\t\n\t \t<table>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t&nbsp;&nbsp;&nbsp;&nbsp;<font size=\"3\"><b>${_uiStringTable.SearchTextLabel}</b>\n\t\t\t\t</td>\n\t\t\t\t<td>\t\n\t\t\t\t\t&nbsp;&nbsp;<input id='${id}_dialog_search_term' dojoattachpoint=\"dialog_search_term\" type='text' name='ticket_search' style='width: 400px;' placeholder='type your search terms...' title=\"Search\" class=\"vmSearchDialog\">&nbsp;&nbsp;&nbsp;&nbsp;\n\t\t\t\t</td>\n\t\t\t\t<td>\t\n\t\t\t\t\t<button  id=\"${id}_dialog_search_btn\"  dojoattachpoint=\"dialog_search_btn\" dojotype=\"dijit.form.Button\" showLabel=\"false\" label=\"Search\" baseClass=\"dialog_srm_button\" iconClass=\"dialog_search_btn\" ></button>  \n\t\t\t\t</td>\t\t\t\t\n\t\t\t\t \t\t\t\t\t\n\t\t\t</tr>\n\t\t\t\n\t\t\t<tr><td colspan=\"2\">&nbsp</td></tr>\t\t\t\t\n\t\t\t \n\t\t</table>\t\t\n\t\t<br>\n\t\t<div id='${id}_dialog_search_holder'></div>\t\n\t\t\t\n\t</div>\n</div>\n\n</div>",

		listLabel: '',
		imagesPath: '',
		requestsOP: '$_unset_$',
		//incidentsOP: '$_unset_$',
		frequentRequestsOP: '$_unset_$',
		rootList: null,
		_UIComplete: false,
		fillOrder: "NavFrontPage",
		keyField: "ItemNum", 
		labelField: "Description",
		descField: "LongDescription",
		iconField: "ImagePath",
		iconSizeField: "iconSize",
		iconClassField: "iconClass",
		childField: "Category",
		leafField: "Offering",
		toolTip: true,
		hidecarticon: false,
		hidecreatesricon: false,
        hidetemplateicon: false,
		offering_fd: '',
		nav_node: '',
         _subscriptionHandle: null,
        config75: false,   //new 7.5 config?
        catalog_link_index: 0,   //default Navigator link elements
        solution_link_index: 1,
        favorites_link_index: 2,
        search_link_index: 3,
        issues_link_index: 4,
        solution_browse_link_index: 5, 
        _maxRestItems: 500, //max number of records to get at one time        
        _SCOfferingsStartIndex: 0,   //rest api index for SC Offering query
        _SDOfferingsStartIndex: 0, // rest api index for SD Offering query

        _uiNavigatorStringTable: null,  //Globalized strings for Navigator links
        //_sigoptions: null,  //app sigoptions for user
        _maximized: false,   //Navigator maximized?  
        _cat_treeview: false,    //catalog tree or folder view? 
        _treeContentPane: null,   //contentPane  for tree view
        //_standby: null,
				
		// ******** lifecycle methods ********
		constructor: function(/*object*/params, /*domNode*/domNode) 
		{
			console.log("Navigator.ctor()");			 
			this.hidecarticon = (this.hidecarticon=='true');
			this.hidecreatesricon = (this.hidecreatesricon=='true');
			this.hidetemplateicon = (this.hidetemplateicon=='true');
			
			//Globalized strings for Navigator links
			try {
				this._uiNavigatorStringTable = dojo.i18n.getLocalization("ibm.tivoli.simplesrm.srm.dijit", "uiNavigatorStringTable");				 
			} catch(ex) {							
				console.log("Navigator.constructor(), uiNavigatorStringTable not loaded - " + ex);
			}			
						
			this.rootList = null;
			if(!this.imagesPath){
				this.imagesPath = dojo.moduleUrl("ibm.tivoli.simplesrm.srm.dijit", "images");
			}

         console.log("Navigator - subscribing to command: /srmssctr/cmd/createoffering");
  		   this._subscriptionHandle = dojo.subscribe("/srmssctr/cmd/createoffering", this, function(params) {
				if(params.ItemNum && params.ItemSetID) {
					this.createAndShowInputForm(params, false);
				}
			});
  		    
  		   console.log("Navigator - subscribing to command: /srmssctr/cmd/viewsolution");
		   this._subscriptionHandle = dojo.subscribe("/srmssctr/cmd/viewsolution", this, function(params) {
				if(params.ID) {
					this.createAndShowInputForm(params, false);
				}
			});
		    
		   console.log("Navigator - subscribing to command: /srmssctr/cmd/quickinsert");
		   this._subscriptionHandle = dojo.subscribe("/srmssctr/cmd/quickinsert", this, function(params) {
				if(params.ID) {
					this.createAndShowInputForm(params, false);
				}
			});
  		    
  		   console.log("Navigator - subscribing to command: /srmssctr/cmd/createsr");
     		this._subscriptionHandle = dojo.subscribe("/srmssctr/cmd/createsr", this, this._createSR);
     		
     		console.log("Navigator - subscribing to command: /srmssctr/cmd/viewsr");
  		   this._subscriptionHandle = dojo.subscribe("/srmssctr/cmd/viewsr", this, function(params) {
  		    	console.log("Navigator - launch viewsr ticketUID = ",params.ticketuid);
  		    	if(params.ticketuid) {			
		    	   sendEvent("srmssviewsr",  this.nav_node.id,  params.ticketuid);
				}
			});
  					
     		
	   },

      destroy: function()
      {
          dojo.unsubscribe(this._subscriptionHandle);
          this._subscriptionHandle = null;
      },

		buildRendering: function() {
			 
			this.inherited(arguments);
		},
		
		solutionsOP: '$_unset_$',
		
		postCreate: function()
		{
			this.inherited(arguments);
			this.nav_node = dojo.byId(this.id);  //navigator DOM node
			
			//Initialize logger
			ibm.tivoli.logger = new ibm.tivoli.simplesrm.srm.dojo.Logger({id:this.nav_node.id});
			
			//New format?
			if (ibm.tivoli.tpae.dojo.data.getConfigProperty("link0")!=null) {
				this.config75=true;
			}
			
			if(this.config75==false && "$_unset_$" == this.requestsOP){
				this.requestsOP = ibm.tivoli.tpae.dojo.data.getConfigProperty("RequestsCatalog");				 
			}
			 	 
			//FrequentRequests key is not in config.properties by default. So we can't check if it exists or on upgrade
			//it will disappear from Navigator. We need a new key to hide it
			if(this.config75==false && "$_unset_$" == this.frequentRequestsOP){
				var hideFQR =  ibm.tivoli.tpae.dojo.data.getConfigProperty("HideFrequentRequests");
				if(hideFQR!=null && hideFQR.length > 0 && dojo.trim(hideFQR)=='true') {  
					this.frequentRequestsOP=null;								
				} else {
					this.frequentRequestsOP="frequentrequests";		
				}
			}			
			
			if(this.config75 ==false && "$_unset_$" == this.solutionsOP){
				this.solutionsOP = ibm.tivoli.tpae.dojo.data.getConfigProperty("Solution");
			}	
			//title not needed as we use tooltip for help
			var shopping_cart_icon = dojo.byId(this.id + "_shoppingCart_btn");
			if (shopping_cart_icon!=undefined)
			   shopping_cart_icon.title="";
			var createSR_icon = dojo.byId(this.id + "_createSR_btn");
			if (createSR_icon!=undefined)
			   createSR_icon.title=""; 

			var template_icon = dojo.byId(this.id + "_template_btn");
			if (template_icon!=undefined)
			   template_icon.title="";

			var listsearch_icon = dojo.byId(this.id + "_list_search_btn");
			if (listsearch_icon!=undefined)
			   listsearch_icon.title="";
			
			var dialogsearch_icon = dojo.byId(this.id + "_dialog_search_btn");
			if (dialogsearch_icon!=undefined)
			   dialogsearch_icon.title="";

			//set navigator width to 66%. This is a hack because in maximo width on sectioncol doesn't seem to work			
			var sectioncols = dojo.query("td[sc='true']");  //get all td with sc="true"  I think sc stands for sectioncol			
			for (var i=0;i<sectioncols.length; i++) {
		    	if (dojo.isDescendant(this.nav_node, sectioncols[i]))  //Is navigator a descendant of this sectioncol?
			        dojo.style(sectioncols[i],"width", "66%");
			}
 
		},
		startup: function() {			
		
			if(this._started)
				return;
			console.log("Navigator.startup()");
			console.log("Navigator parms: hidecarticon=" + this.hidecarticon + " hidecreatesricon=" + this.hidecreatesricon + " offering_fd=" + this.offering_fd + " tooltip=" + this.toolTip);
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");  		
			var iconpath = this.getRelativePath("images/icons/");
			this.inherited(arguments);
			
			//default links - 7.2.1
			var frontPage = {
					Category: [					 
					{   //[1]Request a new service
						Description: this._uiStringTable.RequestsLabel,
						LongDescription: this._uiStringTable.RequestsDesc,
						ImagePath: iconpath+"default_request.png",
						ImagePath2: iconpath+"transp.gif",
						iconSize: 48,
						iconClass: "",
                         ClassStructureID: -2,
                         type: "Catalog",
						Category: null
					},
					{   //[2]Help me fix a problem
						Description: this._uiStringTable.HelpFixLabel,
						LongDescription: this._uiStringTable.HelpFixDesc,
						ImagePath: iconpath+"default_helpfix.png",
						ImagePath2: iconpath+"transp.gif",
						iconSize: 48,
						iconClass: "",
						type: "Solution",
                        ClassStructureID: -3,
						Category: null
					},
					{  //[3]Frequent Requests
						Description: this._uiStringTable.RecentsLabel,
						LongDescription: this._uiStringTable.RecentsDesc,
						ImagePath: iconpath+"recent_request.png",
						ImagePath2: iconpath+"transp.gif",
						iconSize: 48,
						iconClass: "",
                        ClassStructureID: -4,
                        type: "Favorites",
						Category: null
					},
					{   //[4]Report an Issue
						Description: this._uiStringTable.IssuesLabel,
						LongDescription: this._uiStringTable.IssuesDesc,
						ImagePath: iconpath+"default_request.png",
						ImagePath2: iconpath+"transp.gif",
						iconSize: 48,
						iconClass: "",
                         ClassStructureID: -5,
                         type: "Issues",
						Category: null
					},
					{   //[5] Search results
						Description: this._uiStringTable.SearchResults,
						LongDescription: "",						
						ImagePath: iconpath+"transp.gif",  
						ImagePath2: iconpath+"transp.gif",
						iconClass: "",
						Category: null
					}					
					
				]
			};
			 
						
			//config75 processing
			//Do we have a 7.5 link configuration record? If so, we create a new configuration of Navigator links
			if (ibm.tivoli.tpae.dojo.data.getConfigProperty("link0")!=null) {
				//this.config75=true;
				frontPage = {Category:[]};
				this.catalog_link_index= -1;  //reset link index
				this.solution_link_index = -1;
				this.favorites_link_index = -1;
				this.search_link_index = -1;
				this.issues_link_index = -1;
				this.solution_browse_link_index = -1; 
						
			   //parse link config parms	
			   var index = 0;
			   var frontPage_index=0;
			   var done=false;
			
			   while (!done) {
				   var link_record = ibm.tivoli.tpae.dojo.data.getConfigProperty("link" + index);  //linkx record
				   console.log("Navigator.startup() - link record" + index + " - " + link_record);
				   if (link_record!=null) {					
				      var parms = link_record.split(",");  //parms array
				      //process each link parm
				      var link = {};
				      link.Category=null;
				      link.ImagePath = iconpath+"default_incident.png";  //TODO - different default icon
				      link.ImagePath2= iconpath+"transp.gif";
				      link.iconClass= "";
				      link.iconSize= 48;
                      link.ClassStructureID=-index;
                      link.LongDescription =  "";		           
				   
                      //process each parm (key:value)
 			          for (var i=0;i<parms.length;i++) { 
 			              var parm = parms[i].split(":");  //key:value
 			              if (parm!=null && parm.length==2) {
 			           		   var key=dojo.trim(parm[0]).toLowerCase();
 			           		   var val=dojo.trim(parm[1]);
 			           		   if (key =="id") { 			           			
 			           			   link.id = val;
 			           			   if (link.id=='Catalog') {
 			           				   this.catalog_link_index = frontPage_index;
   		                              //link.ClassStructureID=-2; 								   
                                      //defaults 								   
 								      link.Description = this._uiStringTable.RequestsLabel;
 								      link.LongDescription  = this._uiStringTable.RequestsDesc;
 								     link.ImagePath = iconpath+"transp.gif";
 								      if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") {      
 								    	 //link.ImagePath = iconpath+"ge64_service_request_24_RTL.png";
 								         link.iconClass = "sprite-ge64_service_request_24_RTL"; 
 								      } else { 								    	 
 								    	 //link.ImagePath = iconpath+"ge64_service_request_24.png";
 								    	 link.iconClass = "sprite-ge64_service_request_24";
 								      }
 								    	  
 								      link.type='Catalog';
 			           			   } else if (link.id=='Solution') {
 			           				  this.solution_link_index = frontPage_index; 
 			           			       								   
 								      link.Description =  this._uiStringTable.HelpFixLabel;
 								      link.LongDescription = this._uiStringTable.HelpFixDesc;
 								      link.ImagePath = iconpath+"transp.gif";
 								      if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") { 
 								         //link.ImagePath  = iconpath+"ge64_search_solutions_24_RTL.png";
 								         link.iconClass = "sprite-ge64_search_solutions_24_RTL"; 
 								      } else {
 								    	 //link.ImagePath  = iconpath+"ge64_search_solutions_24.png";
 								    	 link.iconClass = "sprite-ge64_search_solutions_24";
 								      }
 								    	  
 								      link.type='Solution';
 			           			   } else if (link.id=='Favorites') {
 			           				  this.favorites_link_index = frontPage_index;  			           			      				   
  								      
  								      link.Description =  this._uiStringTable.RecentsLabel;
  								      link.LongDescription = this._uiStringTable.RecentsDesc;
  								      link.ImagePath = iconpath+"transp.gif";
  								      if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") { 
  								         //link.ImagePath  = iconpath+"ge64_frequent_request_24_RTL.png";
  								         link.iconClass = "sprite-ge64_frequent_request_24_RTL"; 
  								      } else {
  								    	 //link.ImagePath  = iconpath+"ge64_frequent_request_24.png";
  								    	 link.iconClass = "sprite-ge64_frequent_request_24"; 
  								      }
  								    	  
  								    	  
  								      link.type='Favorites';
  			           		 	   }else if (link.id=='Issues') {
 			           				  this.issues_link_index = frontPage_index;  			           			      				   
  								      
  								      link.Description =  this._uiStringTable.IssuesLabel;
  								      link.LongDescription = this._uiStringTable.IssuesDesc;
  								      link.ImagePath = iconpath+"transp.gif";
  								      if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") {
  								         //link.ImagePath  = iconpath+"ge64_incident_request_24_RTL.png";
  								         link.iconClass = "sprite-ge64_incident_request_24_RTL"; 
  								      } else {
  								    	  //link.ImagePath  = iconpath+"ge64_incident_request_24.png";
  								    	  link.iconClass = "sprite-ge64_incident_request_24"; 
  								      }
  								    	  
  								      link.type='Issues';
  			           		 	   
  			           		 	   } else if (link.id=='BrowseSolution') { //Browse Solution link  
  			           		 		   this.solution_browse_link_index = frontPage_index; 
          			       								   
  			           		 		   link.Description =  this._uiStringTable.BrowseSolutionsLabel; 
  			           		 		   link.LongDescription =  this._uiStringTable.BrowseSolutionsDesc;
  			           		 		   if(isBidiEnabled==true && dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") 
  			           		 			   link.ImagePath  = iconpath+"ge64_browseSolutions_24_RTL.png";  
  			           		 		   else
  			           		 			   link.ImagePath  = iconpath+"ge64_browseSolutions_24.png";  
					    	  
  			           		 		   link.type='BrowseSolution';
  			           		 	   }		           		 	   

 			           		   } else if (key =="image") {
 			           		       link.ImagePath=iconpath+val;
 			           		       link.iconClass= "";
 			           		   } else if (key == "label") {
 			           		       link.Description=val;
 			           		   } else if (key == "labelkey") {
 			           			   if (this._uiNavigatorStringTable!=null) {
 			           		          link.Description=this._uiNavigatorStringTable[val];
 			           			   }
 			           		   } else if (key == "labelmsgkey") {
 			           			   //TODO - get message  for msggroup=srmsslabels and msgkey = val
 			           		       //link.Description=this._uiStringTable.val;
 			           		   }else if (key=='description') {
 			           		      link.LongDescription=val;
 			           		   } else if (key=='desckey') {
 			           			  if (this._uiNavigatorStringTable!=null) {
 			           		        link.LongDescription=this._uiNavigatorStringTable[val];
 			           			  }
 			           		   } else if (key == "descmsgkey") {
 			           			   //TODO get message  for msggroup=srmsslabels and msgkey = val
 			           		       //link.LongDescription=this._uiStringTable.val;
 			           		   } else if (key=='type') {
 			           			   if (val=='dialog' || val=='script' || val=='url' || val=='application') {
 			           				   link.type = val;
 			           			   }   
   			           		   } else if (key=='target') { 			           		      
 			           		      link.target = val;          		    
                    		   }      		 		    		 		    		 		    		 		      		 			           		
      			          }
 			           
 			          }  //end of linkx record
 			       
                      //Done processing  link record				   
 			          //If we have an id, add to frontPage
	           	      if (link.id!=undefined) {
	           	    	  
	           	    	  //shortcut for create SR dialog which we display be default in config75.properties
	           	    	  if (link.type=='dialog' && link.id=='createSR' && link.target=='srmsscreatesr' && link.Description==undefined) {
	           	    		 link.Description =  this._uiStringTable.CreateSRLabel;
						     link.LongDescription = this._uiStringTable.createSRToolTip;
						     link.ImagePath  = iconpath+"default_request.png";
						     link.iconClass = "";
	           	    	  }
	           	    	  
	           		      //Defaults			            
			              if (link.Description==undefined) {
		        	         link.Description =  link.id;
		                  }			              
			              			                       
			              //Add pre-defined link to list of links
			              if ((link.id =='Catalog' || link.id=='Solution' || link.id=='Favorites' || link.id == 'Issues' || link.id =='BrowseSolution') ||  
			            		    (link.type!=undefined && link.target!=undefined)) {			            	     
	           	    			 frontPage.Category[frontPage_index] = {};  
	           	    			 frontPage.Category[frontPage_index] = link;
	           	    			 frontPage_index++;           	    			 	           	    		    
	           	    			 
	           	    	  } else { 
	           	    		 console.error("Navigator.startup() - invalid record skipped " + index + " - " + link_record);
	           	    	  }               
	           	      }
	           	      index++;
	           	   
				   } else {  //no link record - index
					   done=true;
				   }		 		
			   } //end loop of links
			   if (frontPage_index>0) {
			      //Add Search at end
				  this.search_link_index = frontPage_index;
			      frontPage.Category[frontPage_index] = {};
			      frontPage.Category[frontPage_index].id='Search';
			      frontPage.Category[frontPage_index].Description = this._uiStringTable.SearchResults;
			      frontPage.Category[frontPage_index].ImagePath=iconpath+"transp.gif";  
			      frontPage.Category[frontPage_index].ImagePath2=iconpath+"transp.gif";
			      frontPage.Category[frontPage_index].iconClass= ""; 
			      
			    } 
			}			
		    //config75 end						
			
			//Get top level node Strings from maximo so customer can customize them (721 only)
			if (this.config75==false) {
			   var getNodeStrings = ibm.tivoli.tpae.dojo.data.getConfigProperty("getTopNodeTextStrings");
			   if (getNodeStrings!=null && getNodeStrings == 'true'){		   
			      var deferred  =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMaxMessages("srmsslabels");			
    		      if (deferred) {
				      deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {				   
					      messages = response.MAXMESSAGESMboSet.MAXMESSAGES;
					      for (var i=0;i<messages.length;i++) {
					         var key = messages[i].MSGKEY;
					         var value = messages[i].VALUE;
					         if (key=="RequestsLabel")
					    	    frontPage.Category[this.catalog_link_index].Description = value;			
					         else if (key=="RequestsLabelDesc")
					    	    frontPage.Category[this.catalog_link_index].LongDescription = value;
					      
					         if (key=="HelpFixLabel")
						       	 frontPage.Category[this.solution_link_index].Description = value;	
					         else if (key=="HelpFixLabelDesc")
					    	     frontPage.Category[this.solution_link_index].LongDescription = value;
					      
					         if (key=="RecentsLabel")
						      	 frontPage.Category[this.favorites_link_index].Description = value;	
					         else if (key=="RecentsDesc")
					    	     frontPage.Category[this.favorites_link_index].LongDescription = value;
					      
					         if (key=="SystemWideFrequentFolderLabel")
					    	     this._SystemWideFolderLabel = value;
					      
  					         if (key=="MyFrequentFolderLabel")
					    	    this._MyFrequentFolderLabel = value;
					      
					      }
				       }));				  				   
			      }		    					
			   }
		    }
			
			this.rootList = dijit.byId(this.id + "_list");  //Navigator root (ListTree)
			
			//Get config property to not use tooltip in Navigator
   		    var tooltip_prop = ibm.tivoli.tpae.dojo.data.getConfigProperty("tooltip");  //config.properties
			if (tooltip_prop!=null && tooltip_prop=='false') {
				this.toolTip=false;					
	   		}			
			this.rootList.toolTip=this.toolTip; //enable-disable using dojo tooltip  
			
			this.rootList.addChildren(frontPage, "NavFrontPage Waiting", 1); // even though this is NavFrontPage, the children will be RowMajor
															  		// TODO: fix that if you can.
			
			var event = null;	 
			
			 //Get sigoptions and hide links and icons based on returned options 
			sendXHREvent("pmsc_getAppOptions", dojo.byId(this.id).id, event, REQUESTTYPE_HIGHASYNC, "json", "application/json", dojo.hitch(this,"_getAppOptions_resp"),
		   	   function(response) {console.error("Navigator.startup() - sendXHREvent error - " + response);dojo.hitch(this,"_getAppOptions_resp")});			
						
			 //Send request to server to check if user is authorized for app or LIC
			var nodeid = this.nav_node.id;
			 dojo.forEach(this.rootList.subitems, dojo.hitch(this,function(link) { 			 
               if (link.type && link.type=='application' && link.target) {
            	   var event = "app;" + link.target;
      	  	       sendXHREvent("pmsc_app_auth", this.nav_node.id, event, REQUESTTYPE_HIGHASYNC, "json", "application/json", dojo.hitch(this,"_sendasync_resp"),
      	  			   function(response) {console.error("Navigator.startup() - sendXHREvent error - " + response);});
               } else if (link.type && link.type=='url' && link.target) {
            	   var event = "lic;" + link.target;
      	  	       sendXHREvent("pmsc_app_auth", this.nav_node.id, event, REQUESTTYPE_HIGHASYNC, "json", "application/json", dojo.hitch(this,"_sendasync_resp"),
          	  			   function(response) {console.error("Navigator.startup() - sendXHREvent error - " + response);});
                   }  
		     }));
									
			// these ids have to be kept in sync with their defs in the template
			this.crumb_id = this.id + "_crumbs";	// id of my Breadcrumb object
			this.list_id = this.id + "_list";		// id of the domNode housing the lists
			this.connect(this.list_search_btn, 'onClick', '_search');			
			this.connect(this.list_search_term, 'onkeypress', '_search');
			
			//connect navigator maximime/minimize icon 
			dojo.connect(dojo.byId(this.id+ "_maximize_nav"), "onclick", this, '_maximize_nav');
			//change icon if RTL
			 if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") 
				 dojo.byId(this.id+ "_maximize_nav").src = "../webclient/javascript/simplesrm/srm/dijit/images/nav_icon_fullScreenRTL.png";
						
			//connect navigator tree or folder icon 
			dojo.connect(dojo.byId(this.id+ "_crumbs_treeview_nav"), "onclick", this, '_treeview_nav_clicked');			
			 			 			
			//toolbar tooltips
			if (product!=null && product.indexOf("srm")>=0){				
			    var tip = "<span style='font-size:x-small;'>" + this._uiStringTable.SearchToolTip + "</span>";			    
				new dijit.Tooltip({connectId: [this.id + "_list_search_btn"],label: tip});				
				new dijit.Tooltip({connectId: [this.id + "_dialog_search_btn"],label: tip});	
				
				tip = "<span style='font-size:x-small;'>" + this._uiStringTable.createSRToolTip + "</span>";			    
				new dijit.Tooltip({connectId: [this.id + "_createSR_label"],label: tip});				
				new dijit.Tooltip({connectId: [this.id + "_createSR_btn"],label: tip});
				
				//tooltip
				tip = "<span style='font-size:x-small;'>" + this._uiStringTable.templateToolTip + "</span>";	
				new dijit.Tooltip({connectId: [this.id + "_template_btn"],label:  tip});			

			}	

			// connect the navigation buttons
			this.connect(this.home_btn, 'onClick', '_goHome');
			
			 			
			//connect create SR button or hide it 
			if (product!=null && product.indexOf("srm")>=0){
			   this.connect(this.dialog_search_btn, 'onClick', '_helpFixSumit');
			   this.connect(this.dialog_search_term, 'onkeypress', '_helpFixSumit');
			   //this.connect(this.dialog_search_close_btn, 'onClick', '_helpFixClose');
			   //this.connect(this.dialog_search_close_term, 'onkeypress', '_helpFixClose');
			   this.connect(dijit.byId('search-dialog').closeButtonNode, 'onclick', '_helpFixClose');
			   var search_typeahead_prop = ibm.tivoli.tpae.dojo.data.getConfigProperty("Searchtypeahead");  //config.properties
			   //search type ahead is on by default and can be disabled if Searchtypeahead=false 
			   if (search_typeahead_prop==null || search_typeahead_prop!='false') {
			      this.connect(this.dialog_search_term, 'onkeyup', '_helpFixSumit');  //for Search dialog typeahread
			     
			   }
			   
			}else 
				dojo.query(".navigator_srmhead").orphan();		  	
			
			this.rootList.show();
			
			// hide unused branches (you have to show() before the dom nodes exist to hide)
			//if(this.config75==false && (this.incidentsOP==null || this.incidentsOP.length === 0)) {  
			//	dojo.style(this.rootList.subitems[0].domNode, "display", "none"); 
			//}

			 
			// hide Favorite branch (if not removed) (you have to show() before the dom nodes exist to hide)			 
			if(this.config75==false && (this.frequentRequestsOP==null || this.frequentRequestsOP.length === 0)) {  
				dojo.style(this.rootList.subitems[this.favorites_link_index].domNode, "display", "none");
				this.favorites_link_index=-1;
			}
			
			//shopping cart icon
			var shopping_cart_icon = dijit.byId(this.id + "_shoppingCart_btn");		
			var shopping_cart_label = dojo.byId(this.id + '_cart_label');
			console.log("shopping_cart_label = " + shopping_cart_label);
			
			//Hide Catalog link if commented out in config.properties
			if(this.config75==false && (this.requestsOP==null || this.requestsOP.length === 0)) {  
				dojo.style(this.rootList.subitems[this.catalog_link_index].domNode, "display", "none");
				this.catalog_link_index = -1;			    
		    }		   			
			 						
			// always hide the search results list
			this._searchResultsList = this.rootList.subitems[this.search_link_index];
			dojo.style(this._searchResultsList.domNode , "display", "none");			
									
			//hide solutions if not commented out in config
			if(this.config75==false && (this.solutionsOP==null || this.solutionsOP.length === 0)) {  
				dojo.style(this.rootList.subitems[this.solution_link_index].domNode, "display", "none");
				this.solution_link_index = -1;							
			}
			
			 //Initialize placeholder for Search
			var search_field = dojo.byId(this.id + "_list_search_term"); 	
			if (this.solution_link_index == -1 && this.solution_browse_link_index == -1) {  //Update search placeholder to String with Search 
				search_field.value = this._uiStringTable.SearchFieldTextNoSol;				 
			} else
			    search_field.value = this._uiStringTable.SearchFieldText;				
			
			//7.5 hack to remove background on tip buttons. It didn't show up in 721 (Dojo 1.4)
			//var template_icon = dijit.byId(this.id + "_template_btn");
			dojo.forEach(dojo.query(".dijitInline.dijitButtonNode", null), function(elem) {
				if (dojo.isIE) {
					dojo.style(elem, {"background":  "none",  "border":  "0px"});				  
				} else {
					 dojo.style(elem, {"background":  "none",  "border":  "hidden"});
				}			
			});		
			 						
			// the event handlers aren't connected yet
			// manually call a couple
			this._onpushlist(null, this.rootList);
			this._onactivatelist(this.rootList);
			this._setNavButtonState();				 
			
			this._loadUI();
			
			//resize border container automatically when Window resized. Border container needs a fixed height 
			dojo.connect(window, "onresize", dojo.hitch(this,function() {
				var h = dojo.window.getBox().h;   //window size
				if (h==null)
					return;
				var start_height = dojo.style(dojo.byId(this.id +  "_borderContainer"), "height");  //start size of border container
				console.log("onresize: window size = " + h + " start height = " + start_height);
				if (start_height==null)
					return;

				h = h - dojo.position(dojo.query(".srmnavigator")[0]).y            //position of nav
						-  dojo.marginBox(dojo.query(".navigator_head")[0]).h	   //size of nav header
						-  dojo.marginBox(dojo.byId(this.id + "_crumbs")).h;	   //size of breadcrumbs
				if (dojo.isIE) 
					h = h - 60; 													   //padding
				else
					h = h - 25;
							
				console.log("onresize: new height = " + h);				 
				dojo.style(dojo.byId(this.id +  "_borderContainer"), "height",h + "px");
				dijit.byId(this.id+'_borderContainer').resize();
			}));
			
			//Give a warning if Silverlight not installed (IE)
	         var checkedSilverlight=null;
	         if (dojo.isIE && dojo.cookie.isSupported())
	            checkedSilverlight = dojo.cookie("checkedsilverlight");
			 if (dojo.isIE && checkedSilverlight==null) {
				try {
	               if (dojo.cookie.isSupported())
	                  dojo.cookie("checkedsilverlight", "true");
				   new ActiveXObject('AgControl.AgControl');				
				} catch(ex) {
				   	(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2362I"})).show();				
				}
			}						 
			
		},
		
		_loadUI: function() {			
			 
			//tree view or folder view to start with?
			var treeView = ibm.tivoli.tpae.dojo.data.getConfigProperty("navigatorView"); 
			if (treeView!=null || treeView=="tree") { 			 
				this._cat_treeview=true;
			}			
			
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");   	
			var data_deferreds = [];
			
			if (product==null || product.indexOf("srm")<0){ //Not SRM
				var numberOfFrequentRequests = 4;
				var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getFrequentRequests(numberOfFrequentRequests);
				data_deferreds.push(deferred); // no callback here - we have to wait untill whole navigator will be populated
			}	
			
			if (com.ibm.ism.pmsc.dojo._SC_installed == true) {			 
					
				if (this.catalog_link_index!=-1) {
				   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getCatalogs();  //get and cache catalogs
				   
	               var amt = ibm.tivoli.tpae.dojo.data.getConfigProperty("MaxRestItems");  //default=500   	
	               if (amt!=null && amt>0 && amt<=500) {
	                  this._maxRestItems=amt;
	               }
						
				   //var params = {itemid:"~gt~0"};  //use _rsStart instead
	               var params = {};
						
                   if (this._offering_fd!=null && this.offering_fd.length>0) {  //Add filtering domain passed in as parm
		              params._fd = this.offering_fd;
		           }
	                   
                   params._usembo=true;  //get mbo instead of OS 
					  
				   this._getRequestsCatalog(params,data_deferreds);   //SC installed. This is what gets called!!
				}
				
			} else {  //SC not installed
                //Quick inserts only in this case (no SC installed) 			
				if (product!=null && product.indexOf("srm")>=0){
					if (this.catalog_link_index!=-1) {
					   this._loadTemplates(data_deferreds);
					}					
				}
			 		
			}	
	
			 						
			if (product!=null && product.indexOf("srm")>=0){
				if (this.solution_link_index!=-1) {
					dojo.removeClass(this.rootList.subitems[this.solution_link_index].domNode, "leaf");
					dojo.addClass(this.rootList.subitems[this.solution_link_index].domNode, "branch");	
				}
				
				if (this.favorites_link_index!=-1) {
				    dojo.removeClass(this.rootList.subitems[this.favorites_link_index].domNode, "leaf");
				    dojo.addClass(this.rootList.subitems[this.favorites_link_index].domNode, "branch");
				}
								
				//This removes the Waiting icon from the links. We skip over th Catalog until we receive all the data
				dojo.forEach(this.rootList.subitems, function(item) {	
					if(item.type && item.type!="") {
						if (item.type!='Catalog') {
						   dojo.removeClass(item.domNode, "leaf");
						   dojo.addClass(item.domNode, "branch");
						}
					}
				});
			}			
						
			//get User's cart information and add tooltip to hitch to method to create tooltip
			//TODO - only do this if SC installed
			 if (product!=null && product.indexOf("srm")>=0) {  
			    
			     if (this.hidecarticon!=true) {  //when cart not hidden
			    	//connect click to shopping cart button
				    this.connect(this.shoppingCart_btn, 'onClick', '_shoppingCart');	
				 
                    //Initialize tooltip			 
				    this.shoppingCartTooltip();
				    
				    //Event listener to refresh tooltip if dialog closes.
				    //The function addModalWaitLayer is a maximo function that is called on display of a Maximo dialog				     
				    //dojo.connect(null,"addModalWaitLayer",this,"shoppingCartTooltip");
			     }
			 }
						
			// don't wire-up list event handlers until all the data is in
			var last_deferred = new dojo.DeferredList(data_deferreds);
			
			if (product==null || product.indexOf("srm")<0){  //Not SRM
				last_deferred.addCallback(dojo.hitch(this,function(results){
					if(results[0][0]){
						this.refreshRecentRequests(results[0][1]);
					}
					else{
						console.error("Navigator._loadUI.getFrequentRequests has failed");
					}
				}));
			}
			
			last_deferred.addCallback(dojo.hitch(this, function(results) 
			{
				// wire up ListTree events
				this.connect(this.rootList, "onPushList", "_onpushlist");
				this.connect(this.rootList, "onPopList", "_onpoplist");
				this.connect(this.rootList, "onActivateList",  "_onactivatelist");
				this.connect(this.rootList, "onClick", "_onlistclick");				 
				
				// wire up the breadcrumbs
				var my_crumbs = dijit.byId(this.crumb_id);
				this.connect(my_crumbs, "onClick", "_oncrumbclick");
				
				//Remove the link Waiting icon
				dojo.forEach(dojo.query(".Waiting", this.rootList.domNode), function(elem)
				{
					dojo.removeClass(elem, "Waiting");
				});
				
				this._UIComplete = true;
				return results;
			}));
		},		
		 
		
		//Refresh Shopping Cart info and add tooltip to Shopping cart icon
		//TODO - when user add offering to cart this tooltip needs to be refreshed.
		_tooltip_dijit: null,
		_tooltip_text_dijit: null,
		_cartid: null,           //current cart id
		_itemsincart:0,		
		shoppingCartTooltip: function() {
            		
			console.log("Navigator.shoppingCartTooltip(): ");
			if (this._tooltip_dijit!=null)
			   this._tooltip_dijit.destroy();
			 if (this._tooltip_text_dijit!=null) 
			   this._tooltip_text_dijit.destroy();			   
	
			 this._itemsincart=0;
			 
			//get shopping cart data	
			deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getShoppingCart();
			if (deferred) {
				   deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
					   if (this.hidecarticon==true) { 
						   return;						   
					   }					   
					   var tooltip = "<span style='font-size:x-small;'>" + this._uiStringTable.CTJZH2359I + "</span>";
					   
					   if (response.QuerySRM_CARTResponse.rsCount>0) {		
						   var pmsccr = response.QuerySRM_CARTResponse.SRM_CARTSet.PMSCCR[0];
						   this._cartid=pmsccr.PMSCCRID;					   
						  		  	   						   
						   tooltip = "<span style='font-size:x-small;'>" + this._uiStringTable.CurrentCart + ": <b>" + pmsccr.DESCRIPTION + "</b><ul>";						   
						   
						   if (pmsccr.SR) {
							   var SRs = pmsccr.SR;							  
							   this._itemsincart = SRs.length;							  

                               //Only show first 10 offerings in tooltip.  Add a "... 5 more ..." message at the end of the list
                               var amt_to_show = this._itemsincart;
                               if (this._itemsincart>10) {
                                  amt_to_show=10;
                               }
							   
					           for (var i=0;i<amt_to_show;i++) {
						          var SR = SRs[i];
						          tooltip = tooltip + "<li>" + SR.DESCRIPTION + "</li>";    
						       }	
                               if (this._itemsincart>10) {
                            	 var amt = this._itemsincart - amt_to_show;                            	 
                                  var more_msg = " ... " + amt +  " " + this._uiStringTable.More + " ...";
						          tooltip = tooltip + "<li>" + more_msg + "</li>";    
                               }

					       } 
						   tooltip = tooltip + "</ul>" + "</span>";
					   }
				   
				       if(isBidiEnabled==true && dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") {					       
				    	   //var RLE = '\u202B';  &#x202B;  		
				    	   //var PDF = '\u202C';  &#x202C;
				    	   //This equates to  "<span dir='rtl'>" + tooltip + '</span>';
				           tooltip =  '\u202B' + tooltip + '\u202C';
				       }				           
					   
					   //Add tooltip to shopping cart icon
					   this._tooltip_dijit = new dijit.Tooltip({
			               connectId: [this.id + "_shoppingCart_btn"],
			               label: tooltip			               
			               });					   
			              
 					   //Add tooltip to shopping cart text
					   this._tooltip_text_dijit = new dijit.Tooltip({
			               connectId: [this.id + "_cart_label"],
			               label: tooltip			               
			               });
					   
					   //update cart amount
					   if (this._itemsincart>0)
						      dojo.byId(this.id + '_cart_amount').innerHTML = this._itemsincart;
						   else 
							  dojo.byId(this.id + '_cart_amount').innerHTML = " "; 
				   }));				  				   
			 }		    
		},
		
		//Shopping cart text onmouseover
		_cartOnRollover: function(evt)
		{
			dojo.addClass(evt.target, 'highlight');
			dojo.style(evt.target, 'cursor', 'pointer');
		},
		_cartOnRollout: function(evt)
		{
			dojo.removeClass(evt.target, 'highlight');
			dojo.style(evt.target, 'cursor', 'default');
			dojo.style(evt.target, 'text-decoration', 'none');
		},
		//Create Request button
		_createSROnRollover: function(evt)
		{
			dojo.addClass(evt.target, 'highlight');
			dojo.style(evt.target, 'cursor', 'pointer');
		},
		_createSROnRollout: function(evt)
		{
			dojo.removeClass(evt.target, 'highlight');
			dojo.style(evt.target, 'cursor', 'default');
			dojo.style(evt.target, 'text-decoration', 'none');
		},
		
		//launch Shopping cart dialog when clicked		 
		_shoppingCart: function() {
			console.log("Navigator._shoppingCart - launch shoppingcart dialog, cartid =  " + this._cartid);			 
			
			//dialog handler for shopping cart dialog
			this._addModalWaitLayerHandler = dojo.connect(null,"addModalWaitLayer",this,"_checkDialogConnect");
			
			//Invoke method - shoppingcart and pass cartid
			sendEvent("shoppingcart", this.nav_node.id,  this._cartid);                   			 
		},				
		 		
		_swizzleData: function(rlist, classification, default_folder_icon, default_leaf_icon) {
			var static_iconpath = this.getRelativePath("images/icons/");
			var i;

			for(i in rlist) {
				var r = rlist[i];
				
				if(r.ImageName2)
					r.ImagePath2 = static_iconpath + r.ImageName2;
				else
					r.ImagePath2 = static_iconpath + "transp.gif";
				
				if(!r.ImageName) {  //no image
					if(r.Category || r.Offering) {
						if(default_folder_icon) {
							r.ImageName = default_folder_icon;
						}
					} else {
						if(default_leaf_icon) {
							r.ImageName = default_leaf_icon;
						}else{
							if(r.ItemNum)
								r.ImageName = "default_offering.png";
							if(r.Template)
								r.ImageName = "default_template.png";
							if(r.Solution)	
								r.ImageName = "default_solution.png";
						}
					}
					
					r.ImagePath = static_iconpath + r.ImageName;
				
				} else {  //we have an image for item					
					var useImageServlet = true;  
					
					var usi = ibm.tivoli.tpae.dojo.data.getConfigProperty("UseImageServlet");
					
					var imageid = r.ItemID?r.ItemID:r.ID;   //imageid differs for offerings and templates
					if (usi!=null)
					   useImageServlet = (usi=='true' || usi=='1');
					
					 r.ImageName = r.ImageName.replace(/\+/g, "%2B");  //encode +
					
					 //image cache. This assumes that duplicate image names are the same image. If not we're in trouble!					 
                	 var dontCacheImageNames = ibm.tivoli.tpae.dojo.data.getConfigProperty("DontCacheImageNames");  //if DontCachImageNames = true, we don't reuse image name
                	 if (dontCacheImageNames==null || dontCacheImageNames!='true' ) {   
					    if (!ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[r.ImageName]) {                              	
                		   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[r.ImageName] = {itemid: imageid};  //cache image id locally                            	
                        } else {
                     	   imageid =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[r.ImageName].itemid;  //use cached id
                        }
                	 }

					//this uses a Servlet to cache and return the image
					if (useImageServlet==true)  //tsam
						r.ImagePath = this.imageCacheUrl + r.ImageName + "?REFOBJECTID=" + imageid; 
					else {             										
  					    r.ImagePath = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().baseRestUrl +  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().rest_context_root + "/rest/mbo/imglib/" + "?REFOBJECTID=" + imageid + "&imagename=" + r.ImageName + "&_compact=true"; 
					}			   
				}
				
				// I need to copy ClassificationID from a parent into leaf nodes
				//if(r.ClassificationID) {
				//	classification = r.ClassificationID;
				//}
				//if(classification && !r.ClassificationID) {
				//	r.ClassificationID = classification;
				//}
				if(r.Category) {
					this._swizzleData(r.Category, classification, default_folder_icon, default_leaf_icon);
				}
				if(r.Offering) {
					this._swizzleData(r.Offering, classification, default_folder_icon, default_leaf_icon);				
				}		
						 
			}
			
		},
		// if a branch has only folders
		_pruneTree: function(tree) 
		{
			//console.log("Navigator._pruneTree()", tree);
			console.log("Navigator._pruneTree()");
			for (var i in tree.Category) {
				/* SR Commented out for future use (post GA) */
				/*if ((tree.Category.length == 1)
					 && tree.Category[i].Category) { // check for existence
					if (undefined !== tree.Category[i].Offering
						&& tree.Category[i].Offering.length !== 0) {
						tree.Offering = tree.Category[i].Offering
					}
					console.log("prune 1");
					tree.Category = tree.Category[i].Category;
				}*/
				if ((undefined !== tree.Category[i].Category &&
						 tree.Category[i].Category.length == 1) &&
					  (undefined === tree.Category[i].Offering ||
					 	tree.Category[i].Offering.length === 0)) {
					// console.log("prune 2");
					tree.Category[i] = tree.Category[i].Category[0];
				}
				this._pruneTree(tree.Category);
			}
		},
		_sortTree: function(tree)
		{
			if(undefined !== tree.Offering) {
				tree.Offering.sort(function(a, b)
				{
					if(a.Description && b.Description && (a.Description.toLowerCase() < b.Description.toLowerCase())) {return -1;}
					if(a.Description && b.Description && (a.Description.toLowerCase() > b.Description.toLowerCase())) {return 1;}
					return 0;
				});
			}
			if(undefined !== tree.Category) {
				tree.Category.sort(function(a, b) 
				{
					if(a.Description && b.Description && (a.Description.toLowerCase() < b.Description.toLowerCase())) {return -1;}
					if(a.Description && b.Description && (a.Description.toLowerCase() > b.Description.toLowerCase())) {return 1;}
					return 0;
				});
				for(var i in tree.Category) {
					this._sortTree(tree.Category[i]);
				}
			}
		},
		_saved_req_data: null,
		/* Actually these are the FREQUENT requests */
		refreshRecentRequests: function(data)      
		{
			console.log("Navigator.refreshRecentRequests");
			if(!dojo.isArray(data)){
				return;
			}
			
			var recents = {Category: []};
			dojo.forEach(data, dojo.hitch(this,function(el){
				console.log("el:" + el);
				var request_item = walkNavigatorAndFindItem(this.rootList, el);
				if(request_item) {
					recents.Category.push(request_item);
				}
			}));
			
			this.rootList.subitems[this.solution_link_index].removeChildren();

			if(recents.Category.length > 0) {
				this.rootList.subitems[this.solution_link_index].addChildren(recents, "RowMajor", 2);
			}
			else {
				dojo.removeClass(this.rootList.subitems[this.solution_link_index].domNode, "leaf");
				dojo.addClass(this.rootList.subitems[this.solution_link_index].domNode, "empty");				
			}			
	
			// if the recent requests list is active, re-show it to refresh its contents		
			if(this.rootList.getActiveList() === this.rootList.subitems[this.solution_link_index]){
				this.rootList.subitems[this.solution_link_index].show();
			}
			return;			
			
			/********* local helpers ***********/
			function walkNavigatorAndFindItem(item, target)
			{
				var retval = null;
				//console.group("searching %s (%s) for %s", item.label, (item.data ? item.data[item.keyField] : "no item.data!"), target);
				if(item && (!item.subitems || item.subitems.length === 0 /*only find leaf nodes*/) && item.data && item.data[item.keyField] == target) {
					//console.log("*** found recent: %s ***!", target);
					retval = item.data;
				}
				else {
					for(var i in item.subitems) {
						retval = walkNavigatorAndFindItem(item.subitems[i], target);
						if(retval) {
							break;
						}
					}
				}
				//console.groupEnd();
				return retval;
			}
		},

		/************* search *********************/
		_searchResultsList: null,
		_searchListConn: null,
		 
		/* 
		 * Search
		 * 
		 */  
		_search: function(evt) 	{
			if(evt.type == 'click' || (evt.type == 'keypress' && evt.keyCode == dojo.keys.ENTER && evt.target == this.list_search_term)) {
				var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
				
				var search_str = dojo.byId(this.list_id + '_search_term').value;
				if (product==null || product.indexOf("srm")<0){
					if(search_str.length === 0) {
						return;
					}
				}	
				
				if (product!=null && product.indexOf("srm")>=0){  
					var global = true;
					this._searchRemote(search_str, global);  //call search method
					
				} else {  //Not SRM	
				   var search_results = this.rootList.Search(dojo.byId(this.id+'_list_search_term').value);
				   if(search_results.length === 0) {							
				      var wd = new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2339I", buttons:[this._uiStringTable.OK, this._uiStringTable.CreateSR]});
					  wd.show();						
					  var button = dojo.byId(wd.id + "mmd_button_1");  //create SR button
					  dojo.connect(button, 'onclick', this, '_createSR'); 
				   } else {
		 
				    	//hide tree contentpane
			    	   dijit.byId(this.id+'_borderContainer').removeChild(this._treeContentPane);
					   dojo.style(dojo.byId(this.id+"_crumbs_treeview_nav"), "display", "none");

  					   this._searchResultsList.removeChildren();
					   this._searchResultsList.addChildren({Category: search_results}, "RowMajor", 2);
			 
					   var bPushBreadcrumb = this._searchResultsList !== this.rootList.getActiveList();
					   this._searchResultsList.show();
					   if(bPushBreadcrumb){
						  this._onpushlist(null, this._searchResultsList);	// TODO: something's not quite right with ListTree or Navigator event handlin that I have to do this
					   }
		 
			       }
				}
			}	
		},
		
 
		// ************** Toolbar navigation ****************/
		// experiment with maintaining state an supporting back/forward
		_activeListHistory: [],		// array of what lists have been active
		_activeListIndex: -1,		// index into _activeListHistory where we currently are
		_navInHistory: false,		// true if navigating thru the history, and not via direct clicks in the UI
		_goHome: function()
		{
			console.log("Navigator._goHome [%d[%d]]", this._activeListHistory.length, this._activeListIndex);
			
			this._currentList = "home";
			//if(this._uiStringTable.Search)
			//	dojo.byId(this.id + "_list_search_btn").innerHTML = this._uiStringTable.Search;
			
			this._navInHistory = true;
			this._activeListHistory.splice(1, this._activeListHistory.length);
			this._activeListIndex = 0;
			this._activeListHistory[0].show();
			dijit.byId(this.crumb_id).popToMorsel(0);
		},
		
		//placeholder support
		_placeholder: function(event) {
			var search = dojo.byId(this.id + "_list_search_term");
		
			if(event.type == 'focus') {
			   dojo.removeClass(search, "placeholder");
			   search.value= '';
			} else if (event.type=="blur") {  
				if (search.value=='') {
			       dojo.addClass(search, "placeholder");
			       if (this.solution_link_index == -1 && this.solution_browse_link_index == -1)   //Update search placeholder to String with Search 
					   search.value = this._uiStringTable.SearchFieldTextNoSol;
				   else	
			           search.value = this._uiStringTable.SearchFieldText;
				}
			}
		},
		
		//launch create SR dialog 
		_createSR: function()  
		{
			console.log("Navigator._createSR - launch dialog");			
			arguments.caller=null; //running into a IE bug in stacktrace()
			//this._addModalWaitLayerHandler = dojo.connect(null,"addModalWaitLayer",this,"_checkDialogConnect");
			sendEvent("createsr", this.nav_node.id,  "createSR");                   			 
		},

		//launch template dialog 
		_template: function()  
		{		
			var deferred  =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getCartTemplatesAmt();			
			if (deferred) {
				deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {				   
					var amt =  response.PMSCTMPLMboSet.rsCount;
					console.log("Navigator._template - amt =" + amt);	
					if (amt==0) 
					{        //No templates message
						(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2360I"})).show();
						return;
					}
					else
					{
						console.log("Navigator._template - launch dialog");			
						arguments.caller=null; //running into a IE bug in stacktrace()
						this._addModalWaitLayerHandler = dojo.connect(null,"addModalWaitLayer",this,"_checkDialogConnect");
						sendEvent("templadm", this.nav_node.id,  "templadm");  
					}
				}));
			}                			 
		},
		
		_setNavButtonState: function()
		{
			//dijit.byId(this.id + '_home_btn').attr("disabled",  (this._activeListIndex >= 0 && this._activeListHistory[this._activeListIndex] === this.rootList) );
		},
		// ************** ListTree event handlers ************
		
		//This pushes a listtree onto the breadcrumb stack
		_onpushlist: function(prevList, newList) {
			console.log("Navigator._onpushlist(%s, %s)", prevList?prevList.label:"null", newList?newList.label:"null");
			
			//get list type
			var type = newList.getListType();
			
			//if tree view we need to calculate the breadcrumb trail becuase you can click anywhere in the tree 
			if (this._cat_treeview==true && type!=null && (type=='Catalog' || type=='Issues' || type=='BrowseSolution')) {  
				var bc  = dijit.byId(this.crumb_id);
				bc.popToMorsel(0);		//clear breadcrumb		 
				var treeNode = newList;
				var trail= [];
				trail.push(treeNode);				
				 
				var folderTree = null;
				while(treeNode.parentList) {  //walk up tree
					trail.push(treeNode.parentList)
					treeNode = treeNode.parentList;					 
					
					if (treeNode.folderTree!=null)
						folderTree = treeNode.folderTree;  //save tree
				}
				for (var i = trail.length-2;i>=0;i--) {  //build breadcrumb
					bc.pushMorsel(trail[i].label, trail[i]);	
				}

				//expand tree and set focus to clicked folder in tree			 				
				if (folderTree && newList.ClassStructureID) {
			    	//Can be used to expand and set focus. Isn't working in all cases
					//var idarray = ['csid', '654426', '653926']
					//var d = dijit.byId("mx105Catalog_treeFolder").set('path', idarray )
			    	var item = folderTree.getNodeFromItem(newList.ClassStructureID.toString());
			    	if (item) {
			    	   var node = item[0];	
			    	   folderTree._expandNode(node, false);
			    	   if (folderTree._myLastNode) { //remove focus from previous tree node
	                        folderTree._myLastNode.setSelected(false);
			    	   }
	                   node.setSelected(true);
	                   folderTree._myLastNode = node;		                   				    	  
				       folderTree.focusNode(node);		    	   
				    }			    	 				    	  
				}								 
								
			} else {
			   var newmorsel = dijit.byId(this.crumb_id).pushMorsel(newList.label, newList);
			}
			var scrolling_box = dojo.byId(this.id + "_box");
			if(scrolling_box){
				scrolling_box.scrollTop = 0;
			}
		},
		_onpoplist: function(prevList, newList) {
			console.log("Navigator._onpoplist(%s, %s)", prevList?prevList.label:"null", newList?newList.label:"null");
			dijit.byId(this.crumb_id).popMorsel();
			var scrolling_box = dojo.byId(this.id + "_box");
			if(scrolling_box){
				scrolling_box.scrollTop = 0;
			}
		},
		
		//item in list clicked. Could be a leaf node or the top level node 
		_onlistclick: function(listtree)
		{
			console.log("Navigator._onlistclick()", listtree);
			var bCreatePopup = true;
			
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			if (product!=null && product.indexOf("srm")>=0){
				//Did we click on solution search
				if(listtree.type=='Solution' && this.rootList.subitems[this.solution_link_index] == listtree){
					dijit.byId("search-dialog").show();  //Show Search dialog
					
					//Make search type ahead results normal height
					if (this._default_dialog_height!=undefined) { 
					   dojo.style(dijit.byId("search-dialog").domNode, "height", this._default_dialog_height + "px");
					   dojo.style(dijit.byId("search-dialog").domNode, "width", this._default_dialog_width + "px");
					}					   
					
                    //move it up so the search results fit on screen					
					//var w =  dojo.style(dijit.byId("search-dialog").domNode, "top");
					//dojo.style(dijit.byId("search-dialog").domNode, "top", "40px");
					
					//dijit.byId("search-dialog").resize();  
					
				}
				//Click on Favorites
				if(listtree.type=='Favorites' && this.rootList.subitems[this.favorites_link_index] == listtree){
					this._startWaiting();
					this._loadFrequentRequests();
					this._stopWaiting();
					if(this.rootList.subitems[this.favorites_link_index].subitems.length > 0){
						listtree.show();
						this._onpushlist(null, listtree);
					}else
						(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2353E"})).show();
							
				}	
				//Click on Issues 
				if(listtree.type=='Issues' && this.rootList.subitems[this.issues_link_index] == listtree){
					this._startWaiting();
					this._getDeskOfferings();
					this._stopWaiting();
					if(this.rootList.subitems[this.issues_link_index].subitems.length > 0){
						listtree.show();
						this._onpushlist(null, listtree);
					}							
				}
				//click on browse solutions link
				if(listtree.type=='BrowseSolution' && this.rootList.subitems[this.solution_browse_link_index] == listtree){  
					listtree._loaded = true;
					this._startWaiting();
					this._getSolutionsToBrowse();
					this._stopWaiting();
					if(this.rootList.subitems[this.solution_browse_link_index].subitems.length > 0){ //show solutions
						listtree.show();
						this._onpushlist(null, listtree);
					}							
				}
				
			}			
			
			//special case - folder under Browse solutions clicked - get solutions in folder
			if (listtree.getListType()=='BrowseSolution' && listtree._loaded == false && listtree.data.csid) {  
			//if (listtree.getListType()=='BrowseSolution' && listtree.data.Category == undefined && listtree.data.csid) {   
				listtree._loaded = true;
				var classid = listtree.data.csid;				
				listtree.data.Category = new Array();	
				var params = {_tree:listtree.data.Category};  //Pass tree so unclassified solutions will merged with solution classifications					   	
		        params.classstructureid=classid;   //classificationid of folder
		        params.sync=true;
		        params.selfservaccess="1";  //check for active and ssc solutions
		        var status="ACTIVE";				
				var solStatus_domain = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('SOLUTIONSTATUS');
				status = solStatus_domain.valueByMaxvalue('ACTIVE');
				params.status=status;
		             
		        //get solutions in folder
		        deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getSolutions(params);
		        if (deferred) {
				   deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
				      	this._pruneTree(response);							
						this._swizzleData(response.Category, null, "request_folder.png", "default_solution.png");
						//this._sortTreeScore(response);
						this._sortTree(response);
						listtree.addChildren(response, "RowMajor", 2);				        	
			        }));
				        
		            	
	            	listtree.show();
					this._onpushlist(null, listtree);	
	            }
	            return;						
			}
			
			
			if ("function" == typeof this.onSrmNavigatorClick) {
				bCreatePopup = this.onSrmNavigatorClick(listtree);
			}
			//Click on item (Offering, Solution, etc...) to display dialog
			if (bCreatePopup) {
				if ((listtree.data.Category && listtree.data.Category.length > 0) || listtree.data.ItemNum || (listtree.data.Solution && listtree.data.ID) || (listtree.data.Template && listtree.data.ID) ) {
					if (!listtree.data.Solution)
					   this._addModalWaitLayerHandler = dojo.connect(null,"addModalWaitLayer",this,"_checkDialogConnect");
					this.createAndShowInputForm(listtree.data, false);	// CreatorFactory mixin method
				} else if (listtree.type=='dialog'  || listtree.type=='application'  || listtree.type =='url') {
					this.createAndShowInputForm(listtree.data, false);	// CreatorFactory mixin method   
				 			
				} else if (listtree.type=='script' && listtree.target) {					
					console.log("Navigator._onlistclick(), launch script - " +  listtree.target);
					try {
						dojo._loadModule(listtree.target);
						var cls = dojo.getObject(listtree.target);
						var obj =  new cls( this.nav_node.id);
					    obj.run();
					} catch(ex) {							
						console.log("Navigator._onlistclick(), launch script failed - " + ex);
					}
				} else {
					console.log("Navigator._onlistclick(): click action avoided");
				}
			}			 		
		},
		
		//top level link clicked
		_onactivatelist: function(newList)
		{
			console.log("Navigator._onactivatelist(%s) [%d[%d]]", newList.label, this._activeListHistory.length, this._activeListIndex);
			
			if(!this._navInHistory) {
				// activating a list by clicking in the UI. 
				// truncate the history 
				this._activeListHistory.splice(++this._activeListIndex, this._activeListHistory.length);
				this._activeListHistory.push(newList);
			}
			this._setNavButtonState();
			this._navInHistory = false;
			
			//if catalog or issues link, setup tree or folder clicked			 
			if (this.rootList.subitems[this.catalog_link_index]==newList  || this.rootList.subitems[this.issues_link_index]==newList  || this.rootList.subitems[this.solution_browse_link_index]==newList) { 
				 
				dojo.style(dojo.byId(this.id+"_crumbs_treeview_nav"),"display", "block");   //show tree/folder icon 
				
				var root = dojo.moduleUrl("ibm.tivoli.simplesrm.srm.dijit") + "/";
				
				if (this._cat_treeview==true) { //using tree view
								  
					//show folder icon
					if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") 	
					     dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_folder_icon_RTL.png'; //icon = folder
					else
						 dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_folder_icon.png'; //icon = folder
					    	 
					dojo.byId(this.id+"_crumbs_treeview_nav").title = this._uiStringTable.FolderView;  
														
					//add tree contentpane back
					if (this._treeContentPane==null) {
					    this._treeContentPane = dijit.byId(this.id+'_borderContainerLeft');
					}  else					
					   dijit.byId(this.id+'_borderContainer').addChild(this._treeContentPane);
					
					//create and display tree
					this._setupFolderTree(newList);  //this builds the tree widget 
					
					newList.folderTree.collapseAllNodes();  //collapse all branches/nodes
					newList.folderTree._expandNode(newList.folderTree.rootNode);  //expand root node
					if (newList.folderTree._myLastNode) { //remove focus from node
	                        newList.folderTree._myLastNode.setSelected(false); 
	                }
					
					 dijit.byId(this.id+'_borderContainer').resize();
					
				} else { //using folder view				
					
					//show tree icon
					if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") 
					   dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_treeview_icon_RTL.png'; //icon = tree
					else 
					   dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_treeview_icon.png'; //icon = tree	
						
					dojo.byId(this.id+"_crumbs_treeview_nav").title = this._uiStringTable.TreeView;  
					
					//hide tree contentpane 					
					if (this._treeContentPane==null) {
					    this._treeContentPane = dijit.byId(this.id+'_borderContainerLeft');
					}					
					dijit.byId(this.id+'_borderContainer').removeChild(this._treeContentPane);			 
															 
				}
								 
			} else {
				//hide tree and tree/folder icon if not in request a new service, Open a Issue or Browse solutions link 
				if ((this._activeListHistory[1]!=this.rootList.subitems[this.catalog_link_index]  && this._activeListHistory[1]!=this.rootList.subitems[this.issues_link_index] && this._activeListHistory[1]!=this.rootList.subitems[this.solution_browse_link_index]) || 
						 (newList == newList.getTreeRoot())) { 
										
				   dojo.style(dojo.byId(this.id+"_crumbs_treeview_nav"),"display", "none");
				   
				   if (this._treeContentPane==null) { 
					    this._treeContentPane = dijit.byId(this.id+'_borderContainerLeft');
				   }		
				   
				   dijit.byId(this.id+'_borderContainer').removeChild(this._treeContentPane);	   
				   				   
				}
				
			}			
			
			console.log("-----> [%d[%d]]", this._activeListHistory.length, this._activeListIndex);
		},
		
		//construct the tree widget and place in DOM
		_setupFolderTree: function(newList) {			
			var currentlisttype= newList.getListType();			
			 					
			//where to place tree 
            var tgtid = this.id+'_borderContainerLeft';
            
            //Hide any existing  tree node
            dojo.forEach(dijit.byId(tgtid).getChildren(), function(x) {
            	dojo.style(x.domNode,"display", "none");
            });            	           
            			
			if (newList.folderTree==undefined) {  //Need to create tree?
				//Build folder tree in json format				
				var treeData = {};
				treeData.identifier = 'csid';
				treeData.label = 'desc';
				treeData.items = [];
				//build tree data structure
				this._buildFolderTree(treeData.items, newList.subitems);								
									   
                //Create Store
                var folderStore= new dojo.data.ItemFileReadStore({data: treeData});
                
                //Use different root label
                var rootlabel = this._uiStringTable.Folders;
                if (currentlisttype=="BrowseSolution") 
                	rootlabel = this._uiStringTable.SolutionFolders;
		            
                //create model
                var folderModel= new dijit.tree.ForestStoreModel({
                    store:folderStore, 
                    query:{"type":"root"},
                    rootId:"csid",
                    rootLabel:  rootlabel,
                    childrenAttrs:["children"]
                });             
                                            
		                
                //create tree
                var tree = new dijit.Tree({
                        model: folderModel,                        
                        _myLastNode:  null,
                        id:    this.id+currentlisttype+"_treeFolder",                        
                    	                        
                        collapseAllNodes: function() { //collapse all nodes in tree                           
                            var _tree = this;

                            function collapse(node) {                              
                                
                                if ( _tree.showRoot && node != _tree.rootNode ) {
                                   _tree._collapseNode(node);
                                }

                                var childBranches = dojo.filter(node.getChildren() || [], function(node) {
                                    return node.isExpandable;
                                });

                                var def = new dojo.Deferred();
                                defs = dojo.map(childBranches, collapse);
                            }
                            return collapse(_tree.rootNode);
                        },
                        
                        //Set default folder icon -  
                        getIconClass: function(/*dojo.store.Item*/ item, /*Boolean*/ opened){                        	
                            return (!item || this.model.mayHaveChildren(item)) ? (opened ? "dijitSSCFolderOpened" : "dijitSSCFolderClosed") : "dijitSSCFolderLeaf"
                            //return null;
                        },
                        
                        /* set configurable folder icon in tree (configured in classstructure) */
                        /* Not supported in 7.5.1. Needs more testing. */
                        /*getIconStyle: dojo.hitch(this,function(item, opened){  //fpb
                            var id = -1;
                            if (folderStore.isItem(item)==true) { //if not root?
                               id = folderStore.getValue(item,"csid");  
                            }
                            console.log("getIconStyle:",folderStore.getLabel(item)+" "+ id); //display the label and id
                            if (id==-1)
                            	return;

                            var currentlist = this.rootList.getActiveList();  //this is the current folder in focus              
                            //Follow parent to get the type: Catalog, Issue or Solution 
                            var currentlisttype= currentlist.getListType();                                    
                
                            //Get target folder (ListTree object)
                            var targetFolder=null; 
                             if (currentlisttype=="Catalog") {                                 
                                targetFolder = this.rootList.subitems[this.catalog_link_index].Search(id, true);  //find Catalog folder to display
                             } else if (currentlisttype=="Issues") {                                 
                                targetFolder = this.rootList.subitems[this.issues_link_index].Search(id, true);  //find Issues folder to display
                             } else if (currentlisttype=="BrowseSolution") {                                 
                                targetFolder = this.rootList.subitems[this.solution_browse_link_index].Search(id, true);  //find Browse Solutions folder to display\
                             }

                            if (targetFolder && targetFolder.length>0) {
                              var newlist = targetFolder[0];  
                              var icon = newlist.icon;  //current icon
                              
                              //get imagename for Solution or Offering folder
                              if ((newlist.icon.indexOf("getonserver")>=0 &&  newlist.defaulticon==true)  || (newlist.subitems.length>0) && newlist.defaulticon==true && newlist.parentList!=null ) {
                            	   newlist.defaulticon = false;  //this means we retrieved folder icon from server.                            	   
                            	   var params = {};
                            	   var subitem_id =  newlist.data.ItemID;   //Offering or solution id
                                   if (subitem_id==undefined) {
                                	   subitem_id =  newlist.data.ID; 
                                   }
                            	   params.refobjectid=subitem_id;
                            	   params._exactmatch=0;                            	    
                            	   params.refobject = "ITEM,PMSCOFFERING,CLASSSTRUCTURE";
                            	   params._compact=1;
                            	   params.sync = true;				
                            	   params._includecols="refobjectid,imagename";

                            	   //Get imagename
                            	   var deferred  =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getMbo("IMGLIB",params);
                            	   if (deferred) {
                            	      deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
                            	        if (response.IMGLIBMboSet.rsCount>0) {
                            	           var itemid =  response.IMGLIBMboSet.IMGLIB[0].REFOBJECTID;
                            	           var imagename = response.IMGLIBMboSet.IMGLIB[0].IMAGENAME;                           
                            	           if (imagename!=null) {  //Got an image and found the matching item
                            	               imagename = imagename.replace(/\+/g, "%2B");  //encode +
                            						
                            	               //we cache images and reuse itemid(refobjectid). This assumes that duplicate image names are the same image.
                            	               var dontCacheImageNames = ibm.tivoli.tpae.dojo.data.getConfigProperty("DontCacheImageNames");  //if DontCachImageNames = true, we don't reuse image name
                            	               if (dontCacheImageNames==null || dontCacheImageNames!='true' ) {                            	 
                            	                  if (!ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[imagename]) {  //cache image url data                            	
                            	                     ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[imagename] = {itemid: itemid};                            	
                            	                  } else {
                            	                     itemid =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[imagename].itemid;
                            	                  }   
                            	               }

                            	               //rest url to retrieve image                                        
                            	               newlist.icon = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().baseRestUrl +   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().rest_context_root + "/rest/mbo/imglib/" + "?REFOBJECTID=" + itemid + "&imagename=" + imagename + "&_compact=true";
                            				   icon = newlist.icon;                            				   
                            			   }
                            	        }  					         
                            	   }));
                            	 } //end if deferred
                              }                              
                              
                              //Set folder icon 
                              if (icon!=null && icon.indexOf("request_folder")==-1 &&  icon.indexOf("getonserver")==-1) {  //not default icon
                            	 if (dojo.isIE) {  
                            	    return {"backgroundImage": "url('" + icon + "')",
                            		     "backgroundSize": "16px",
                            		     "filter": "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + icon + "',sizingMethod='scale')"     //IE image size hack                       		     
                            	    };  
                            	 } else { 
                            		 return {"backgroundImage": "url('" + icon + "')",
                            		     "backgroundSize": "16px"                            		                            		     
                            	    };   
                            	 }
                              }
                            }                            
                        }),
                        */
                        
                        /*tree helper function to get the tree node for a id*/
                        getNodeFromItem: function (id) {  
                            return this._itemNodesMap[id];
                        },
                       
                        showRoot:true
                        
                        //id:"menuTree",
                        //openOnClick:"true"
                       		                       
                });  //end new tree
                
                //place tree in DOM
    			tree.placeAt(tgtid);
    			 
    			if (dojo.isIE) {
    			   	 dojo.style(tree.domNode, {display: "block",  fontSize: "0.75em",			 	                	 	                    		 	                    
    			                width: "auto",
    			                height: "100%"    			                
    			 	 	       	});  	        
    			                 	
                } else {
                	 dojo.style(tree.domNode, {display: "block",  fontSize: "0.75em",
                		         width: "auto",
                		         height: "100%",
                    	         borderRadius: "3px 3px 3px 3px",
    			 	 	         boxShadow: "0 5px 5px #CCCCCC"    			 	 	         			 	 	                     	   
    			 	 	        });	        	                	        	
                }              
                
    			newList.folderTree = tree;  //Store tree in list              
      
    			//----------------
    			// click on tree plus
    			//----------------    			
    			/*tree.on("NodeFocus",dojo.hitch(this, function(item,treeNode) {
    			    var id = -1;
  	                if (folderStore.isItem(item)==true)  //is root?
  	        	        id = folderStore.getValue(item,"csid");  
                    //console.log("open:",folderStore.getLabel(item)+" "+ id); //display the label and id                
                }));  //end tree.on		 
    			     
    			tree.on("open",dojo.hitch(this, function(item,treeNode) {
    			    var id = -1;
  	                if (folderStore.isItem(item)==true)  //is root?
  	        	        id = folderStore.getValue(item,"csid");  
                    //console.log("open:",folderStore.getLabel(item)+" "+ id); //display the label and id                
                }));  //end tree.on
                */		 
    			          
    			
    			//----------------------
                 // tree node click event
     			//---------------------
	            tree.on("click",dojo.hitch(this, function(item,treeNode) {  //also - open
	               var id = -1;
	               if (folderStore.isItem(item)==true)  //is root?
	        	      id = folderStore.getValue(item,"csid");  
                   console.log("tree.click:",folderStore.getLabel(item)+" "+ id); //display the label and id
                   
                   //For some reason, FF is not showing the last focused node. So this fixes it
                   //if (!dojo.isIE) {
                      if (treeNode.tree._myLastNode) {
                           treeNode.tree._myLastNode.setSelected(false); 
                      }
	                  treeNode.setSelected(true); 	                 
                   //}
                   treeNode.tree._myLastNode = treeNode;                
                
                   var currentlist = this.rootList.getActiveList();  //this is the current folder in focus              
                   //Follow parent to get the type: Catalog, Issue or Solution 
                   var currentlisttype= currentlist.getListType();
                   //If in search, use breadcrumb to get list type
                   if (currentlisttype==null || currentlisttype=="") {
                        var bc = dijit.byId(this.crumb_id).getChildren();
                        if (bc && bc.length>0)
                 	    currentlisttype = bc[1].data.type;
                   }                 
                   currentlist = this.rootList.getActiveList();  //set back to current list                
                                                    
                   var targetFolder=null; 
                   if (currentlisttype=="Catalog") {
                      if (id==-1) {
                   	     targetFolder =[]; targetFolder[0]= this.rootList.subitems[this.catalog_link_index];
                      } else  
                         targetFolder = this.rootList.subitems[this.catalog_link_index].Search(id, true);  //find Catalog folder to display
                   } else if (currentlisttype=="Issues") {
                      if (id==-1) {
                 	     targetFolder=[]; targetFolder[0] = this.rootList.subitems[this.issues_link_index];
                      } else
                	     targetFolder = this.rootList.subitems[this.issues_link_index].Search(id, true);  //find Issues folder to display
                   } else if (currentlisttype=="BrowseSolution") {  
                       if (id==-1) {
                  	      targetFolder=[]; targetFolder[0] = this.rootList.subitems[this.solution_browse_link_index];
                       } else {
                  	      targetFolder = this.rootList.subitems[this.solution_browse_link_index].Search(id, true);  //find Browse Solutions folder to display
                  	    
            			  if (targetFolder.length>0 && targetFolder[0]._loaded == false && targetFolder[0].data.csid) {  
            				  var newlist = targetFolder[0];   
            				  newlist._loaded = true;
            				  var classid = newlist.data.csid;				
            				  newlist.data.Category = new Array();	
            				  var params = {_tree:newlist.data.Category};  //Pass tree so unclassified solutions will merged with solution classifications					   	
            		          params.classstructureid=classid;  //check for active and ssc solutions?
            		          params.sync=true;
            		          params.selfservaccess="1";
            		          var status="ACTIVE";            				
            				  var solStatus_domain = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('SOLUTIONSTATUS');
            				  status = solStatus_domain.valueByMaxvalue('ACTIVE');
            				  params.status=status;
            		   
            		          //Get solution in this folder
            		          deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getSolutions(params);
            		          if (deferred) {
            				     deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
            				      	this._pruneTree(response);							
            						this._swizzleData(response.Category, null, "request_folder.png", "default_solution.png");
            						//this._sortTreeScore(response);
            						this._sortTree(response);
            						newlist.addChildren(response, "RowMajor", 2);				        	
            			         }));    				        
            		            	
            	            	 //targetFolder.show();
            					 //this._onpushlist(null, targetFolder);	
            	              }            	            					
            			  }           	    
                      }
                   }
                   
                   if (targetFolder && targetFolder.length>0) {
                    	var newlist = targetFolder[0];                    	
                    	if (newlist!=currentlist){
                    	   //newlist._onclick();
                    		if(newlist.subitems.length > 0) {
                    			//this.showSubList();
                    			newlist._stopCrossFade();		                    			
                    			newlist._setActiveList(newlist);
                    			newlist._crossFade(currentlist, newlist);
                    			newlist._onpushlist(currentlist, newlist);
                    		}
                    	}
                   } 
                }));  //end tree.on		               
			}			
			
			//make tree visible
			dojo.style(newList.folderTree.domNode,"display","block");
									  			
		},
		
		
		//Build tree of classifications
		_buildFolderTree: function(folderBranch,subitems)	{ 			
			if(subitems) {				 
			    dojo.forEach(subitems, dojo.hitch(this,function(item) {
			    	if (item.data.Category || item.data.Offering) {  //folder
					   var branch = {};
					   folderBranch.push(branch);
					   if (item.data.ClassStructureID)
						   branch.csid = item.data.ClassStructureID.toString(); 
					   else
					      branch.csid = item.data.ID.toString(); 
					   branch.desc = item.label.htmldecode();
					   branch.type="item";
					   
					   if (item.parentList.data.id && (item.parentList.data.id=="Catalog" || item.parentList.data.id=="Issues" || item.parentList.data.id=="BrowseSolution")) 
						   branch.type = 'root';					   
					   if (item.subitems.length>0) {
						   branch.children=[];
						  this._buildFolderTree(branch.children, item.subitems);
					   }
					   //remove empty children from tree
					   if(branch.children && branch.children.length==0) {
								delete branch.children;
					   }
			    	}  
					
				}));			     
			}
			
		},
		
		//tree or folder view icon clicked - switch view
		_treeview_nav_clicked: function(evt) {  
			this._cat_treeview= !this._cat_treeview;
			console.log("_treeview_nav, tree = " + this._cat_treeview);
			
			var root = dojo.moduleUrl("ibm.tivoli.simplesrm.srm.dijit") + "/";
			
			//get currentlist
			var newList = this.rootList.getActiveList();	

			//enable tree view	
			if (this._cat_treeview==true) {				
				
				if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl") 	
				   dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_folder_icon_RTL.png';  //icon = folder
				else 
				   dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_folder_icon.png'; 
					
				dojo.byId(this.id+"_crumbs_treeview_nav").title =  this._uiStringTable.FolderView;
							
				//add tree contentpane back 
				dijit.byId(this.id+'_borderContainer').addChild(this._treeContentPane); 
				
				//create tree
				if (newList.folderTree==null) {
				   this._setupFolderTree(this._activeListHistory[1]);  //Request a service or Open a Issue list
			    }
				dijit.byId(this.id+'_borderContainer').resize(); 
				
				//Todo - set focus on branch corrsponding to current list		   
			  				
			}  else {  //enable folder view
				//set tree icon
				if(dojo.attr(dojo.body(),"dir") && dojo.attr(dojo.body(),"dir")== "rtl")				   
				   dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_treeview_icon_RTL.png'; //icon = tree
				else					
				    dojo.byId(this.id+"_crumbs_treeview_nav").src = root + 'images/ssc_treeview_icon.png'; //icon = tree
				
				
				dojo.byId(this.id+"_crumbs_treeview_nav").title =  this._uiStringTable.TreeView;
				
				//hide tree contentpane
				dijit.byId(this.id+'_borderContainer').removeChild(this._treeContentPane);  
				 
			}
			
		},
		
		//Maximize/minimize Navigator
		_maximize_nav: function(evt) {		 
			this._maximized=!this._maximized;
			console.log("_maximize nav -" + this._maximized);
			
			if (this._maximized==true) {			  
			   //hide Pods
			   dijit.registry.forEach(function(w) {
				   if (w.dojoAttachPoint.indexOf("srmpod")>=0) {
					 dojo.style(w.domNode,"display","none");	   
				   }
				   
			   });   
			   			   
			   //increase width of navigator
			   dojo.style(this.nav_node,"width", "140%");
			   
			   //set title of image to Minimize			   
			   dojo.attr(this.id+ "_maximize_nav","title", this._uiStringTable.Minimize);

			  			   
			} else {  //minimized			   
			   //show Pods
			   dijit.registry.forEach(function(w) {
				   if (w.dojoAttachPoint.indexOf("srmpod")>=0) {
					 dojo.style(w.domNode,"display","block"); 	   
				   }				   
			   });
			   
				//decrease width of navigator	
			   dojo.style(this.nav_node,"width", "100%");
			   
				//set title to Maximize
			   dojo.attr(this.id+ "_maximize_nav","title", "Maximize");
			}
			 //resize BorderContainer
			   dijit.byId(this.id+'_borderContainer').resize();

		},		
        		
		
		// ************* breadcrumb event handlers **********
		_oncrumbclick: function(morsel)
		{
			console.log("breadcrumb click, morsel=", morsel.text);
							
			if(morsel.text == this._uiStringTable.Home){
				this._currentList = "home";
				//dojo.byId(this.id + "_list_search_btn").innerHTML = this._uiStringTable.Search;
			}	
			console.log("Navigator._oncrumbclick(%s)", morsel.text);
			morsel.trimRight();	// remove all morsels to the right of this one
			if(morsel.data) {
				// walk the history looking for this list, and truncate there
				for(var i = this._activeListHistory.length-1; i >= 0; --i) {
					if(morsel.data === this._activeListHistory[i]) {
						this._activeListHistory.splice(i, this._activeListHistory.length);
						this._activeListIndex = i-1;
						console.log("-----> [%d[%d]]", this._activeListHistory.length, this._activeListIndex);
						break;
					}
				}

				morsel.data.show();	// show the list cached in this morsel's .data
				
				//focus tree folder				
				var newList = morsel.data;
				var type = newList.getListType();  //list type
				var folderTree = dijit.byId(this.id+type+"_treeFolder");

				if (this._cat_treeview==true && type!=null && (type=='Catalog' || type=='Issues' || type=='BrowseSolution')) {				
					//expand tree and set focus to clicked folder in tree			 				
					if (folderTree && newList.ClassStructureID) {
				    	//folderTree.set('path', idarray );
				    	var item = folderTree.getNodeFromItem(newList.ClassStructureID.toString());
				    	if (item) {
				    	   var node = item[0];	
				    	   folderTree._expandNode(node, false);
				    	   if (folderTree._myLastNode) { //remove focus from previous tree node
		                        folderTree._myLastNode.setSelected(false);
				    	   }
		                   node.setSelected(true);
		                   folderTree._myLastNode = node;		                   				    	  
					       folderTree.focusNode(node);		    	   
					    }			    	 				    	  
					}		
					 
				}				
				
			}
		},

		_onUIComplete: function()
		{
			console.log("Navigator._onUIComplete");
			 
			if("function" == typeof this.onUIComplete) {
				try {
					this.OnUIComplete();
				}
				catch(ex) {
					ibm.tivoli.logger.error("",ex);
					console.error("onUIComplete event handler failed:\n", ex);
				}
			}
		},
		_currentList : "home",
		
		/*
		 *  Communicate with server to retreive search results
		 *  called to Search from header or Search link 
		 */	     
		_searchRemote: function(search_str, global) {
            console.log("Navigator._searchRemote");
            
			if(search_str.length == 0 ) {
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2356I"})).show();
			} else {
				this._startWaiting();
				 
				if (this.catalog_link_index!=-1 && this.rootList.getActiveList() === this.rootList.subitems[this.catalog_link_index])
					this._currentList = "request";
								
				var data_deferreds = [];  //list of deferred				 
				var deferredOfferings = null;
				var deferredSolutions = null;
				var deferredTemplates = null;
				var deferred = null;
				
                //Max amt of search results to show
				var MAX_RESULTS = ibm.tivoli.tpae.dojo.data.getConfigProperty("SrmNavigatorMaxResults");

                //default params
				var params = {_search:search_str,sync:false,_maxItems:MAX_RESULTS,_exactmatch:1};

                //Don't query solutions if link is disabled
                if((this._currentList == "help" || this._currentList == "home") && (this.solution_link_index != -1 || 
                     this.solution_browse_link_index != -1) ) {
					params["Cache-Control"] = "no-cache";
					
					//get solution
					deferredSolutions = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getSolutions(params);
					deferred = deferredSolutions;
                    data_deferreds.push(deferredSolutions);                     
					params._orderbydesc = null;
					delete params["Cache-Control"];
				} 

            if (global) {  //if called from header search bar
               //get templates
               deferredTemplates = this._getTemplates(params);
               if (deferred==null)
            	   deferred = deferredTemplates;
               data_deferreds.push(deferredTemplates);
               params._orderbyasc = null;               

               //get offerings
               deferredOfferings = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestsCatalog(params);
               data_deferreds.push(deferredOfferings);
               
            }

            //process results when requests complete
			var deferredlist = new dojo.DeferredList(data_deferreds, false, true, false);  	
			           	                       
            //Called when all three requests complete
            deferredlist.addCallback(dojo.hitch(this,function(results){
                  console.log("Navigator._searchRemote - in Callback");
                  this._stopWaiting();
                  if (results[0]== undefined ||results[0][1]==undefined)   {  //No data
                     var messageId = deferred.ioArgs.xhr.getResponseHeader("errorCode");
                     if (response.status == 500) {
                        // if status is 500, display a message indicating that the search index info isn't available
                        (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2355I"})).show();

                        if(messageId!=null && messageId!="") {
                            (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: messageId})).show();
                        } else {
                           //Add create SR button to no data dialog
                           var wd = new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2339I", buttons:[this._uiStringTable.OK, this._uiStringTable.CreateSR]});
                           wd.show();						
                           var button = dojo.byId(wd.id + "mmd_button_1"); //create sr button
                           dojo.connect(button, 'onclick', this, '_createSR');
                        }
                     }
                  } else {
                     var count = 0;
                     var total = 0
                     var result1=null;
                     var result2 = null;
                     var result3 = null;
                     if (results[0] && results[0][1]) {
                         count = results[0][1].Category!=null?results[0][1].Category.length:0;
                         console.log("Navigator._searchRemote - results[0][1] count= "+ count);
                         if (count > MAX_RESULTS) {   //Only show first 500 (MAX_RESULTS) 
                              count = MAX_RESULTS;
                              results[0][1].Category.length=count;
                         }
                         total = count;
                         result1= results[0][1];
                         //if (count>0 && !result1.Category[0].Solution) {  //sort again if not Solutions
                         //   this._sortTree(result1);
                         //}
                     }
                     if (results[1] && results[1][1] && total<MAX_RESULTS) {
                         count = results[1][1].Category!=null?results[1][1].Category.length:0;
                         console.log("Navigator._searchRemote - results[1][1] count= "+ count);
                         if (total+count > MAX_RESULTS) {   //Only show first 500 (MAX_RESULTS) 
                              count = MAX_RESULTS-total;
                              results[1][1].Category.length=count;
                         }
                         total = total+count;
                         result2= results[1][1];
                         //if (count> 0  && !result2.Category[0].Solution) {  //sort again if not Solutions
                         //   this._sortTree(result2);
                         //}

                     }
                     if (results[2] &&  results[2][1] && total<MAX_RESULTS) {
                         count = results[2][1].Category!=null?results[2][1].Category.length:0;
                         console.log("Navigator._searchRemote - results[2][1] count= "+ count);
                         if (total+count > MAX_RESULTS) {
                              count = MAX_RESULTS- total;
                              results[2][1].Category.length=count;
                         }
                         total = total+count;
                         result3= results[2][1];
                         //if (count> 0  && !result3.Category[0].Solution) {  //sort again if not Solutions
                         //   this._sortTree(result3);
                         //}
                     }

                     if (total==0) {  //nothing returned
                        //Add create SR button
                        var wd = new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2339I", buttons:[this._uiStringTable.OK, this._uiStringTable.CreateSR]});
                        wd.show();						
                        var button = dojo.byId(wd.id + "mmd_button_1"); //create sr button
                        dojo.connect(button, 'onclick', this, '_createSR'); 
                     } else {
                        console.log("Navigator._searchRemote - merge results");
                        if (result1 && result2 ) {  //merge results
                           result1 = this._mergeResults(result1, result2);
                        }
                        if (result2 && result3 ) {
                           result1 = this._mergeResults(result1, result3);
                        }

                        this._searchLoadHandler(result1, null);  //prune and swizzle data
                        
				        var bPushBreadcrumb = this._searchResultsList !== this.rootList.getActiveList();

                        //hide tree contentpane
                        dijit.byId(this.id+'_borderContainer').removeChild(this._treeContentPane);
                        dojo.style(dojo.byId(this.id+"_crumbs_treeview_nav"), "display", "none");

						this._searchResultsList.show();  //display results
						if(bPushBreadcrumb){
						    this._onpushlist(null, this._searchResultsList);	// TODO: something's not quite right with ListTree or Navigator event handlin that I have to do this
						}
                     }
                  }
            }));

            //Called when there is an error 
            deferredlist.addErrback(dojo.hitch(this,function(response){  //Error handling. If search index is being updated for example.
               console.log("Navigator._searchRemote - in Errback, resp=: " +  response.responseText);
               this._stopWaiting();


               if (deferred && deferred.ioArgs.xhr && deferred.ioArgs.xhr.readyState==4 ) {  //check for errCode
                   var messageId = deferred.ioArgs.xhr.getResponseHeader("errorCode");
                   if (response.status == 500) {
                  	  // if status is 500, display a message indicating that the search index info isn't available
                       (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2355I"})).show();
                   } else {
	                   if(messageId!=null && messageId!="") {
                    	  (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: messageId})).show();
	                   }
                   }
                   return;
               }
               
               if (response.responseText==null) {
                  (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "Search failed"})).show();
                  return;
               }
               var startPoint = response.responseText.indexOf("ctjzh");
               var messageId = null;
               if (startPoint>=0) {
                   messageId = response.responseText.toUpperCase().substring(startPoint,(startPoint+10));
                   (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: messageId})).show();
               } else {
                  startPoint = response.responseText.indexOf("ctgrd6010e");
                  if (startPoint>=0) {  //error code ctgrd6010e is same as CTJZH2357I
                     (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2357I"})).show();
                  } else {
                	 //default - just use response text 
                     (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "Search", message: response.responseText})).show();
                  }
               }
            }));
         }
				
		},
					
				
		_mergeResults: function(deferredMerged, deferredForMerge) 	{
			if(deferredMerged!=null && deferredForMerge!=null) {
				var nextIndex = deferredMerged.Category.length;  
												
				var count = deferredForMerge.Category.length;
				
				for(i=0;i<count;i++)
				{
					var result = deferredForMerge.Category[i];
					if(result){
						deferredMerged.Category[nextIndex] = result ;
						nextIndex++;
					}	
				}
            } else if (deferredMerged==null && deferredForMerge!=null){
			 	deferredMerged = deferredForMerge;				
			}
			
			return deferredMerged;			
		},

		
		_searchLoadHandler: function(response, ioArgs)
		{
			console.log("Navigator._searchLoadHandler(): ", response, ioArgs);
			if(!response ||
				  !dojo.isArray(response.Category) ||
				  response.Category.length === 0) {
				dojo.removeClass(this._searchResultsList.domNode, "leaf");
				dojo.addClass(this._searchResultsList, "empty");
			}
			else {
				this._pruneTree(response);
				this._swizzleData(response.Category, null, "request_folder.png", null);
				this._sortTreeScore(response);  //sort all data by score
				this._searchResultsList.removeChildren();
				this._searchResultsList.addChildren(response, "RowMajor", 2);
			}
			return response;
		},
			 
		
		//call getTemplates to get non-SD ticket templates
		_loadTemplates: function(data_deferreds, params) {   
			if (params)
				params.issdtemplate= "~neq~1";   
			else
			   params = {issdtemplate:"~neq~1"};			
						
			var deferred = this._getTemplates(params);
			if(deferred) {
				deferred.addCallback(dojo.hitch(this, "_templatesLoadHandler"));
				//var data_deferreds = [];
				if (data_deferreds!=undefined) {
				   data_deferreds.push(deferred);
				}
			}

		},
		
		//Call getTemplates to get SD ticket templates
		_loadDeskTemplates: function(params)	{   
			if (params) {
				params.issdtemplate= "1";   
				params.sync=true;
			} else			   	
			    params = {issdtemplate:"1", sync:true}; 
			var deferred = this._getTemplates(params);
			if(deferred) {
				deferred.addCallback(dojo.hitch(this, "_issuesTemplatesLoadHandler"));
			
			}

		},
		
		//Get non-SD templates
		_getTemplates: function(params)
		{
			if(undefined == params) { params = {}; }			

			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getTemplates(params);
			return deferred;

		},
		
		//callback function to process non-SD ticket templates
		_templatesLoadHandler: function(response, ioArgs)
		{
			console.log("Navigator._templatesLoadHandler", response, ioArgs);
			if((this.catalog_link_index!=-1 && this.rootList.subitems[this.catalog_link_index].subitems.length == 0) && 
					(!response || !dojo.isArray(response.Category) || response.Category.length == 0)) {
				dojo.removeClass(this.rootList.subitems[this.catalog_link_index].domNode, "leaf");
				dojo.addClass(this.rootList.subitems[this.catalog_link_index].domNode, "empty");
			}
			else if(this.catalog_link_index!=-1 && response && dojo.isArray(response.Category) && response.Category.length > 0) {
				dojo.removeClass(this.rootList.subitems[this.catalog_link_index].domNode, "empty");
				dojo.addClass(this.rootList.subitems[this.catalog_link_index].domNode, "branch");
				
				this._pruneTree(response);
				this._swizzleData(response.Category, null, "request_folder.png", "default_template.png");
				//if (com.ibm.ism.pmsc.dojo._SC_installed == false)  
				this._sortTree(response);
				this.rootList.subitems[this.catalog_link_index].keyField = "ID";    //TODO  What will this affect? 
				this.rootList.subitems[this.catalog_link_index].addChildren(response, "RowMajor", 2);  //ListTree
			}
					
			
			if (com.ibm.ism.pmsc.dojo._SC_installed == true && this.catalog_link_index)
				this._sortFolderSubitems(this.rootList.subitems[this.catalog_link_index].subitems);
			
			return response;
			
		},
		
		//callback function to process SD ticket templates
		_issuesTemplatesLoadHandler: function(response, ioArgs)
		{
			console.log("Navigator._templatesLoadHandler", response, ioArgs);
			if((this.issues_link_index!=-1 && this.rootList.subitems[this.issues_link_index].subitems.length == 0) && 
					(!response || !dojo.isArray(response.Category) || response.Category.length == 0)) {
				dojo.removeClass(this.rootList.subitems[this.issues_link_index].domNode, "leaf");
				dojo.addClass(this.rootList.subitems[this.issues_link_index].domNode, "empty");
				
				var tip = "<span style='font-size:x-small;'>" + this._uiStringTable.CTJZH2361I + "</span>";			    
				new dijit.Tooltip({connectId: [this.rootList.subitems[this.issues_link_index].domNode],label: tip,  position:["above"]});	

			}
			else if(this.issues_link_index!=-1 && response && dojo.isArray(response.Category) && response.Category.length > 0) {
				dojo.removeClass(this.rootList.subitems[this.issues_link_index].domNode, "empty");
				dojo.addClass(this.rootList.subitems[this.issues_link_index].domNode, "branch");
				
				this._pruneTree(response);
				this._swizzleData(response.Category, null, "request_folder.png", "default_template.png");
				//if (com.ibm.ism.pmsc.dojo._SC_installed == false)
				this._sortTree(response);
				this.rootList.subitems[this.issues_link_index].keyField = "ID";
				this.rootList.subitems[this.issues_link_index].addChildren(response, "RowMajor", 2);
			}
					
			
			if (com.ibm.ism.pmsc.dojo._SC_installed == true && this.issues_link_index)
				this._sortFolderSubitems(this.rootList.subitems[this.issues_link_index].subitems);
			
			return response;
			
		},

		
		_startWaiting: function() {	        
			this._showProgressSpinner();
			this._setScreen("wait",true);
			  
			 /*this._standby = new dojox.widget.Standby({target: this.id});
			 document.body.appendChild(this._standby.domNode);
			 this._standby.startup();
			 this._standby.show();
			 */
		},
		_stopWaiting: function() {	       
	        //this._standby.hide();
			this._hideProgressSpinner();
			this._setScreen("default",false);
		},
		
		_setScreen: function(cursor,show){
			dojo.doc.body.style.cursor = cursor;
			try {
			   if(show)
				   dijit.byId("loading-dialog").show();
			   else
				   dijit.byId("loading-dialog").hide();
			} catch(ex) {  
				 //we're getting an exception  here - bgIframe does not exist
				 console.log("Navigator._setScreen :  -  " + ex);
				 //this.domNode.style.display = "none";
			}
		},
		_progressSpinner:null,
		_showProgressSpinner: function() 
		{
			try {
				if(!this._progressSpinner) {
					this._progressSpinner = new ibm.tivoli.simplesrm.srm.dijit.ProgressSpinner({text: this._uiStringTable.Loading + "&nbsp;"});
					var sz = dojo.coords(this.rootList.domNode);
					dojo.style(this._progressSpinner.domNode, {
						height: "1em",
						width: "100%",
						zIndex: "10",
						position: "absolute",
						top: sz.y + "px",
						left: "0px",
						display: "block",
						textAlign: "center"
					});
					dojo.place(this._progressSpinner.domNode, this.domNode, "first");
				}	
				
				this._progressSpinner.show();
			}
			catch(ex) {
				console.error("Failed rendering search progress spinner: ", ex);
				if(this._progressSpinner) {
					this._progressSpinner.destroyRecursive();
					this._progressSpinner = null;
				}
				window.status = "Retrieving...";
			}
		},
		_hideProgressSpinner: function() {
			console.log("Search.hideProgressSpinner");
			if(this._progressSpinner){
				this._progressSpinner.hide();
			}
			else{
				window.status = "Done.";
			}
		},
		
		_default_dialog_height: null,
		_default_dialog_width: null,

		/* 
		 * Click or key pressed in Search for SOlutions dialog
		 * 
		 */
		_helpFixSumit: function(evt)
		{		
			console.log("_helpFixSumit, key = "+ evt.type);
			
		    if (this._default_dialog_height==null) {
		       var search_d = dijit.byId("search-dialog");	
          	   this._default_dialog_height =  dojo.marginBox( search_d.domNode).h;
          	   this._default_dialog_width =  dojo.marginBox( search_d.domNode).w;
            }					    
          
			if(evt.type == 'click' || (evt.type == 'keypress' && evt.keyCode == dojo.keys.ENTER && evt.target == this.dialog_search_term)) {  //enter key
				if (dojo.byId(this.id + "_dialog_search_top_div")) {  //remove search drop down  
	                dojo.destroy(dojo.byId(this.id + "_dialog_search_top_div"));
	            }				
				
				var search_str = dojo.byId(this.id + '_dialog_search_term').value;
				
				if(dojo.trim(search_str).length == 0 ) {  //No search data entered
			        (new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2356I"})).show();
			        return;
				}									
				
				this._currentList = "help";
				var global=false;
				this._searchRemote(search_str, global);
				dijit.byId("search-dialog").hide();
				//dojo.byId(this.id + "_list_search_btn").innerHTML = this._uiStringTable.SearchAdjust;
				dojo.byId(this.list_id + '_search_term').value = search_str;
				
			} else  if (evt.type =='keyup' ) {     //typeahead
				var search_str = dojo.byId(this.id + '_dialog_search_term').value;
				
				if (evt.keyCode == dojo.keys.BACKSPACE)  {//ignore backspace
					if (search_str.length<=0) {  //Backspace and empty string 
					   dojo.style(dijit.byId("search-dialog").domNode, "height", this._default_dialog_height + "px"); //make normal height & width
					   dojo.style(dijit.byId("search-dialog").domNode, "width", this._default_dialog_width + "px"); 
					   //dojo.style(dijit.byId("search-dialog").domNode, "top", "40px");					   	
					}
					return;
				}
				
				if (dojo.byId(this.id + "_dialog_search_top_div")) {  //remove search drop down  
	                dojo.destroy(dojo.byId(this.id + "_dialog_search_top_div"));
	            }			
								
	            //console.log("_helpFixSumit search str =  " + search_str);
	            if (search_str!="" && search_str.length>=3) {  //must enter at least 3 chars
	            	
	                //Issue rest api to get top 10 search results
	            	//Do we need to search based on Description and LD only?  
	            	var params = {_search:search_str,sync:false,_maxItems:10,_exactmatch:1};
	            	params["Cache-Control"] = "no-cache";
				    var  solutions = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getSolutions(params);
				    solutions.addCallback(dojo.hitch(this, function(results) {
				    	 var count = (solutions && solutions.results[0] && solutions.results[0].Category!=null)?solutions.results[0].Category.length:0;
						    if (count==0) {
						    	dojo.style(dijit.byId("search-dialog").domNode, "height", this._default_dialog_height + "px"); //make normal height & width
						    	dojo.style(dijit.byId("search-dialog").domNode, "width", this._default_dialog_width + "px");
						    	//dojo.style(dijit.byId("search-dialog").domNode, "top", "40px"); 
						    	return;
						    }
						    
						    //Sort solutions
						    this._sortTreeScore(solutions.results[0]);
			            
			                //display seasch results in table         
			                var top_div = document.createElement("div");  //top div
			                
			                dojo.style(top_div, {width: "auto"}); 
			                top_div.id=this.id + "_dialog_search_top_div";   
			                top_div.className="typeahead-results";             
			                
			                var hide_div = document.createElement("div");
			                hide_div.innerHTML = "These are the top 10 search results.  Use down and up arrow keys to navigate through the results.";
			                dojo.style(hide_div, {display: "none"});
			                top_div.appendChild(hide_div);

			                var ul = document.createElement("ul");
			                ul.className= "appstore-typeahead-results";
			                //ul.type="none";
			                dojo.style(ul, {display: "block"});
			                top_div.appendChild(ul);
			                
			                //Build list of search results
			                for (var i=0;i<count;i++) {
			                	var solution = solutions.results[0].Category[i];
			                    var li = document.createElement("li");
			                    li.className = "result small-result";
			                    li.id = this.id+ "_dialog_search_listitem"+i;
			                    li.name = solution.ID;
			                    ul.appendChild(li);
			                    
			                    if (solution.ImageName) {	                    
			                      var image =  document.createElement("img");
			                      solution.ImageName = solution.ImageName.replace(/\+/g, "%2B");  //encode +

			                      var itemid = solution.ID;			                      
			                 	  
			                 	 //image cache. This assumes that duplicate image names are the same image. If not we're in trouble!					 
			                 	 var dontCacheImageNames = ibm.tivoli.tpae.dojo.data.getConfigProperty("DontCacheImageNames");  //if DontCachImageNames = true, we don't reuse image name
			                 	 if (dontCacheImageNames==null || dontCacheImageNames!='true' ) {			                 	  
			                        if (!ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[solution.ImageName]) {  //cache image url                             	
	                            	   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[solution.ImageName] = {itemid: itemid};                            	
                                    } else { 
	                               	   itemid =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._image_cache[solution.ImageName].itemid;  //use cached image url
	                                }
			                 	 }
			                      			                      
			                     image.src =  
			                         ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().baseRestUrl +  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().rest_context_root + "/rest/mbo/imglib/" + "?REFOBJECTID=" + itemid + "&imagename=" + solution.ImageName + "&_compact=true"; 
			                      image.alt=solution.Description;
			                      dojo.style(image,{width: 32 + "px"});
			                      li.appendChild(image);
			                   }

			                    var div = document.createElement("div");
			                    li.appendChild(div);

			                    var span = document.createElement("span");
			                    span.className="name";
			                    
			                	//TODOs - include ranking/score, LD in tooltip or below description
			                    var data = solution.Description;	                  
			                    span.innerHTML= data;
			                    div.appendChild(span);
			                  
			                    data = solution.LongDescription;
			                    if (data!=null) {
			                       var ld_div = document.createElement("div");
			                       ld_div.className="description";
			                       span.appendChild(ld_div);    
			                       data =  ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().truncate(data);
			                       ld_div.innerHTML = data; //todo trunc
			                    }
			                    
			                }
			              
			                //place in DOM	              
			                var search_d = dijit.byId("search-dialog");	               
			                //var w =  dojo.marginBox( search_d.domNode).w;
			                var top = dojo.marginBox(search_d.domNode).t; 
			                
			                //dojo.style(search_d.domNode, "top", "40px");  
			               	                
			                dojo.place(top_div,  dojo.byId(this.id + "_dialog_search_holder"), "after");
			                	               
			                var h = dojo.marginBox(this.id + "_dialog_search_top_div").h;
			                	             
			                //adjust height and width of search dialog to include search results	               
			                h = h + this._default_dialog_height + 1;
			                var w = this._default_dialog_width+5;
			                
			                dojo.style( search_d.domNode, "height", h + "px");
			                dojo.style( search_d.domNode, "width", w + "px");
			                
			                //IE seems to resize if height changed so we need to reset it 
			                //if (dojo.isIE) {
			                //dojo.style(search_d.domNode, "top", "40px");  
			                //	                	                	                
			                //search_d.resize();  

			                //click events
			                for (var i=0;i<count;i++) {
			                   var itemid = this.id+"_dialog_search_listitem"+i;
			                   var item = dojo.byId(itemid);                 
			                                 	                   
			                   //When entry in table clicked, display Solution dialog
			                   dojo.connect(item, "onclick",  dojo.hitch(this,function(evt) {
			                       console.log("Solution clicked - " + evt.currentTarget.name);
			                       
			                       //Clear table of search results
			                       //dojo.style(dijit.byId("search-dialog").domNode, "height", this._default_dialog_height + "px");
			                       
			                       //fix zindex so view tpae dialogs are not behind dojo search-dialog	                      
			                       //dojo.style(dijit.byId("search-dialog").domNode, "zIndex", "10000");
			                       //dojo.style(dojo.byId("search-dialog_underlay").parentNode, "zIndex", "9999");
			                       
			                       if (dojo.byId("dialogholder")) {	                    	   
			                          dojo.style(dojo.byId("dialogholder"), "zIndex", "100001");
			                       }

			                       //Hide Search dialog and underlay because of IE zindex bug 
			                       //dojo.style(dojo.byId("search-dialog_underlay").parentNode, "display", "none"); 
			                       //dojo.style(dijit.byId("search-dialog").domNode, "display", "none");

			                       //set eventhander when View Solution dialog is dismissed so we can make Search dialog visible again (IE zindex bug)
			                       //Launch View Solution dialog
		  	                       //this._addSearchSolutionModalWaitLayerHandler = dojo.connect(null,"removeModalWaitLayer",this,"_checkSearchSolutionDialogConnect");
			                       
			                       var node = dojo.byId(this.id);	                       
			                       sendEvent("viewsolution", node.id,  evt.currentTarget.name);                  
			                   	                   
			                   }));
			                   
			                   dojo.connect(item, "onmouseover", function(evt) {
			                       dojo.addClass(evt.currentTarget, "selected");
		   	                       //console.dir(evt);
			                   });
			                   dojo.connect(item, "onmouseout", function(evt) {
			                       dojo.removeClass(evt.currentTarget, "selected");
			                       //console.dir(evt);
			                   });
			              }    	
				    					    	
				    }));
				    				    
				   
	           } else {  //less than 3 chars entered
					 dojo.style(dijit.byId("search-dialog").domNode, "height", this._default_dialog_height + "px"); //make normal height & width
					 dojo.style(dijit.byId("search-dialog").domNode, "width", this._default_dialog_width + "px"); 
					 //dojo.style(dijit.byId("search-dialog").domNode, "top", "40px"); 
			   }
	             
			} 
			return;
			
		},
      				
		_helpFixClose: function(evt) {			
			if(evt.type == 'click' || (evt.type == 'keypress' && evt.keyCode == dojo.keys.ENTER && evt.target == this.dialog_search_term)) {
				if (this._default_dialog_height!=undefined) {
				   dojo.style(dijit.byId("search-dialog").domNode, "height", this._default_dialog_height + "px"); //make normal height & width
				   dojo.style(dijit.byId("search-dialog").domNode, "width", this._default_dialog_width + "px");
				   //dojo.style(dijit.byId("search-dialog").domNode, "top", "40px");
				}
				dijit.byId("search-dialog").hide();
				dojo.byId(this.id + '_dialog_search_term').value = "";
			}
			//if (dojo.byId(this.id + "_dialog_search_top_div")) {
            //    dojo.destroy(dojo.byId(this.id + "_dialog_search_top_div"));
            //}	   
			
		},		 
		
       _addModalWaitLayerHandler:null,		
		//Dialog display Handler for clicks on offering dialog, create SR, shopping cart icon
		//in 7.5 dialogid is not pass, instead it is DOM id "mx3426_inner_dialogwait"
		_checkDialogConnect : function(dialogId){
			if(dialogId.indexOf("DialogCR")>=0 || dialogId.indexOf("srmsscreatesr")>=0  || dialogId.indexOf("_dialogwait")>=0)				
				this._loadFrequentRequestsHandler = dojo.connect(null,"removeModalWaitLayer",this,"_loadFrequentRequests");
			
			//Dialog dismiss event to refresh shopping cart							 
			this._shoppingCartDialogID = dojo.connect(null,"removeModalWaitLayer",this,"_shoppingCartDialogHandler");
				
			dojo.disconnect(this._addModalWaitLayerHandler);
		},
			
  	    /*_addSearchSolutionModalWaitLayerHandler:null,			
		//called when View Solution dialog is dismissed. Make Search dialog visible
  	    //TODO - need to check if Create SR button was selected and skip making visible if so 
       _checkSearchSolutionDialogConnect : function(dialogId){
	    	   console.log("in _checkSearchSolutionDialogConnect");
	    	   
	    	   if(modalWaitLayers.length<=0) { 
	    	       dojo.style(dijit.byId("search-dialog").domNode, "display", "block");  //Make Search dialog visible again   	   
            	   dojo.disconnect(this._addSearchSolutionModalWaitLayerHandler);
	    	   }
		},
		*/		
		
		_loadFrequentRequestsHandler:null,
		//Handler for dialog dismissal  
		_loadFrequentRequests: function (){

			if(modalWaitLayers.length>0)
				return;

			dojo.disconnect(this._loadFrequentRequestsHandler);
			
			dojo.publish("refreshpod");		
		 
			this.rootList.subitems[this.favorites_link_index].removeChildren();
			this._loadFavorites();
			this._loadSystemWideRequests();
			this._loadMyRequests();
			if(this.rootList.subitems[this.favorites_link_index] == this.rootList.getActiveList())
				this.rootList.subitems[this.favorites_link_index].show();
			
			if(this.rootList.subitems[this.favorites_link_index] == this.rootList.getActiveList().parentList){
				this.rootList.subitems[this.favorites_link_index].show();
				this._onpoplist(this.rootList.getActiveList(),this.rootList.subitems[this.favorites_link_index].show());
			}	

			return;
		},
		
		_shoppingCartDialogID:null,		
		//Call function to refresh shopping cart
		_shoppingCartDialogHandler: function () {
			if(modalWaitLayers.length>0)
				return;

			dojo.disconnect(this._shoppingCartDialogID);
			
			this.shoppingCartTooltip();  //refresh shopping cart tooltip	
			 
			return;
		},
		
				
		_loadFavorites: function (){
            //filtering domains  filter out inactive templates and offerings 		
			var params = {sync:true, _fd:'SRM_FAVITEM'};			
			 			
			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getFavItem(params);
			
			if(deferred) {
				deferred.addCallback(dojo.hitch(this, "_frequentsLoadHandler"));
			}
			params = {sync:true,  _fd:'SRM_FAVTKTEMPLATE'};
			 
			deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getFavTemplates(params);
			if(deferred) {
				deferred.addCallback(dojo.hitch(this, "_frequentsLoadHandler"));
			}	
			
		},
		
		_SystemWideFolderLabel:null,
		_MyFrequentFolderLabel:null,
		
		_getSystemWideFolderLabel: function(){
			var folder = this._SystemWideFolderLabel==null ? this._uiStringTable.SystemWideFrequentRequest : this._SystemWideFolderLabel; 
			return folder;		
		},
		
		_getMyFrequentFolderLabel: function(){
			var folder = this._MyFrequentFolderLabel==null ? this._uiStringTable.MyFrequentRequests : this._MyFrequentFolderLabel; 
			return folder;		
		},
				
		_loadSystemWideRequests: function (){
			var deferred = null;
			var params = [];
			params.sync = true;
			params.frequentrequest = 1;
			params._folder = this._getSystemWideFolderLabel();			
			 			
			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestsCatalog(params);
			
			if(deferred && deferred.results && deferred.results.length > 0 && deferred.results[0].Category)
				params._tree = deferred.results[0].Category;
			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getTemplates(params);
			
			if(deferred) {
				deferred.addCallback(dojo.hitch(this, "_frequentsLoadHandler"));
			}
			
		},
		
		_loadMyRequests: function (){
			var deferred = null;
			var params = [];
			params.sync = true;
			params._userOffer = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getLoggedInUser().PERSONID; 
			params._folder = this._getMyFrequentFolderLabel();			
			 			
			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestsCatalog(params);
			
			params._userOffer = null;
			params._userQuick = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getLoggedInUser().PERSONID;
			if(deferred && deferred.results && deferred.results.length > 0 && deferred.results[0].Category)
				params._tree = deferred.results[0].Category;
			var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getTemplates(params);

			if(deferred) {
				deferred.addCallback(dojo.hitch(this, "_frequentsLoadHandler"));
			}
			
		},		
		
		_frequentsLoadHandler: function(response, ioArgs)
		{
			if(!response || !dojo.isArray(response.Category) ) {
				dojo.removeClass(this.rootList.subitems[this.favorites_link_index].domNode, "leaf");
				dojo.addClass(this.rootList.subitems[this.favorites_link_index].domNode, "empty");	
			}
			else {

				this._pruneTree(response);
				this._swizzleData(response.Category, null, "request_folder.png", "default_template.png");
				this._sortTree(response);
		
				this.rootList.subitems[this.favorites_link_index].addChildren(response, "RowMajor", 2);
				
			}
			return response;

		},
		
		_sortLabel: function (items){
			items.sort(function(a, b)
			{
				if(a.label.toLowerCase() < b.label.toLowerCase()) {return -1;}
				if(a.label.toLowerCase() > b.label.toLowerCase()) {return 1;}
				return 0;
			});
		},
		
		_sortFolderSubitems: function(items)
		{
			if(items.length>0) {
				this._sortLabel(items);

				var withoutFolder = new Array();
				var withFolder = new Array();
				for(var i in items) {
					if(items[i].subitems.length==0){
						withoutFolder.push(items[i]);
					}else{
						this._sortLabel(items[i].subitems);
						withFolder.push(items[i]);
					}	
				}
				
				// Remove itens  
				while(items.length){
					items.pop();
				}
				
				// Add in the end itens with folder
				for(var i in withFolder) {
					items.push(withFolder[i]);
				}
				
				// Add in the end itens without folder
				for(var i in withoutFolder) {
					items.push(withoutFolder[i]);
				}
				
			}
		},
		
		//Get non-desk Offerings 
		_getRequestsCatalog: function(params,data_deferreds){		  
		   params.navofftype="0";
		   params._maxItems=this._maxRestItems; //default=500  
		   //params._orderbyasc="itemid";		   
		   		   
		   var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestsCatalog(params);
		   if(deferred) {
		      deferred.addCallback(dojo.hitch(this, "_offeringsLoadHandler"));
		      if (data_deferreds)
		         data_deferreds.push(deferred);
		   }
		},
		
		//Get desk Offerings 
		_getDeskOfferings: function(params){
			
			if(undefined == params) { params = {}; }
				
            if (this._offering_fd!=null && this.offering_fd.length>0) {  //Add filtering domain passed in as parm
	              params._fd = this.offering_fd;
	       }
		   params.navofftype="1";
		   params._maxItems=this._maxRestItems; //default=500  	
		   params.sync=true; 
		   params._usembo=true;  //get Mbos instead of OS 
		   		   
		   var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestsCatalog(params);
		   if(deferred) {
		      deferred.addCallback(dojo.hitch(this, "_deskOfferingsLoadHandler"));
		   }
		},

		//Browse solutions link clicked - get folders and solutions with no classification
		_getSolutionsToBrowse: function(params){  
			console.log("Navigator._getSolutionsToBrowse");
			if(undefined == params) { params = {}; }
				
            //if (this._solution_fd!=null && this.solution_fd.length>0) {  //Add filtering domain passed in as parm
	        //      params._fd = this.solution_fd;
	        //}		  
		   //params._maxItems=this._maxRestItems; //default=500
			
		   params.sync=true;
		    		   	
		   //Get solution classstructures
		   //UPS has 700 top level classifications.  Will that be a problem?
		   var deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getSolutionsClassStructures(params);		   
		  
		   if(deferred) {		      
			   deferred.addCallback(dojo.hitch(this, function(response, ioArgs) {
 				    //Get solution with no classification
					params = {_tree:response.Category};  //Pass tree so unclassified solutions will merged with solution classifications					   	
		            params.classstructureid='~NULL~'; 
		            params.sync=true;
		            params.selfservaccess="1";  //check for active and ssc solutions
		            var status="ACTIVE";
					var solStatus_domain = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getDomainSynonymTable('SOLUTIONSTATUS');
					status = solStatus_domain.valueByMaxvalue('ACTIVE');
					params.status=status;
		             
		            //What if >500?
		            deferred = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getSolutions(params);
		            if (deferred) {
				      deferred.addCallback(dojo.hitch(this, "_browseSolutionsLoadHandler"));
		            }			   
			   }));
		   }
		},

		
		//_listResponseRequest:[],
		
		//Process non Desk Offerings
		_offeringsLoadHandler: function(response, ioArgs)
		{
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			var countOffering=0; 
			if(!response ||
				  !dojo.isArray(response.Category) ||
				  response.Category.length === 0) {
				dojo.removeClass(this.rootList.subitems[this.catalog_link_index].domNode, "leaf");
				dojo.addClass(this.rootList.subitems[this.catalog_link_index].domNode, "empty");
				
				var tip = "<span style='font-size:x-small;'>" + this._uiStringTable.CTJZH2361I + "</span>";  //No data tooltip			    
				new dijit.Tooltip({connectId: [this.rootList.subitems[this.catalog_link_index].domNode],label: tip, position:["above"]});	
				
			} else {								
				if (response.count)    //get count of how many we received. We stuffed it in the response 
					countOffering = response.count;
				else
				    countOffering = this._getCountOffering(response.Category);	
						
				if(countOffering==this._maxRestItems){ //Did we receive 500?
					//this._listResponseRequest.push(response);
					
		            this._SCOfferingsStartIndex = this._SCOfferingsStartIndex+this._maxRestItems;  //index for next set
		            var params = {_rsStart:this._SCOfferingsStartIndex,sync:true,_usembo:true};  //get next 500
					
					//var lastId=0;  
					//if (response.lastItemID && response.lastItemID!=-1) {
					//	lastId = response.lastItemID;
					//} else {	
					//    var lastCategory = response.Category[response.Category.length-1];
					//    var lastOffer = lastCategory.Offering[lastCategory.Offering.length-1];
					//    lastId = lastOffer.ItemID;
					//}
					//var params = {itemid:"~gt~" + lastId,sync:true};
										 
					this._getRequestsCatalog(params);
					
				}  else  {  //Got less than 500, we're done receiving
					//clear srmQuery tree   
					ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._offTree = null;
					
					//load quick inserts					  
					var params = {_tree:response.Category};        //add tree as parm so templates will be merged with offerings       
					this._loadTemplates(null, params);		 			
												
					//Dataa added to ListTree after templates received
					//if (this._listResponseRequest.length>0)   
					//	this._restoreResponses(response);	
					//this._pruneTree(response);
					//this._swizzleData(response.Category, null, "request_folder.png", "default_request.png");
					
					//this._sortTree(response);
					//this.rootList.subitems[this.catalog_link_index].addChildren(response, "RowMajor", 2);
				}	
			}
			
			return response;
			
		},
		
		//Process non Desk Offerings
		_deskOfferingsLoadHandler: function(response, ioArgs)
		{
			var product = ibm.tivoli.tpae.dojo.data.getConfigProperty("Product");
			var countOffering=0; 
			if(!response ||
				  !dojo.isArray(response.Category) ||
				  response.Category.length === 0) {        //No desk offerings
				//dojo.removeClass(this.rootList.subitems[this.issues_link_index].domNode, "leaf");
				//dojo.addClass(this.rootList.subitems[this.issues_link_index].domNode, "empty");
				ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._offTree = null;							 
				this._loadDeskTemplates(params);   	
				
			} else {								
				if (response.count)    //get count of how many we received. We stuffed it in the response 
					countOffering = response.count;
				else
				    countOffering = this._getCountOffering(response.Category);	
						
				if(countOffering==this._maxRestItems){ //Did we receive 500?
					//this._listResponseRequest.push(response);
					
		            this._SDOfferingsStartIndex = this._SDOfferingsStartIndex+this._maxRestItems;  //index for next set
		            var params = {_rsStart:this._SDOfferingsStartIndex,sync:true,_usembo:true};  //get next 500
										 
					this._getDeskOfferings(params);
					
				}  else  {  //Got less than 500, we're done receiving
					//clear srmQuery tree   
					ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._offTree = null;
					
					var params = {_tree:response.Category};  //Pass tree so templates will merged with Offerings  
					this._loadDeskTemplates(params);   	
					
					//Added to ListTree when templates received
					//if (this._listResponseRequest.length>0)
					//	this._restoreResponses(response);	
					//this._pruneTree(response);
					//this._swizzleData(response.Category, null, "request_folder.png", "default_request.png");
					
					//this._sortTree(response);
					//this.rootList.subitems[this.issues_link_index].addChildren(response, "RowMajor", 2);
				}	
			}			
			 
			return response;				
			
		},
		
		//Browse solutions REST response handler
		_browseSolutionsLoadHandler: function(response, ioArgs)  { 
			console.log("Navigator._browseSolutionsLoadHandler", response, ioArgs);			
						
			if((this.solution_browse_link_index!=-1 && this.rootList.subitems[this.solution_browse_link_index].subitems.length == 0) &&  //No solutions 
					(!response || !dojo.isArray(response.Category) || response.Category.length == 0)) {
				dojo.removeClass(this.rootList.subitems[this.solution_browse_link_index].domNode, "leaf");
				dojo.addClass(this.rootList.subitems[this.solution_browse_link_index].domNode, "empty");		
				(new ibm.tivoli.simplesrm.srm.dijit.MessageDialog({type:"Info", messageId: "CTJZH2363I"})).show();
				 
			} else if(this.solution_browse_link_index!=-1 && response && dojo.isArray(response.Category) && response.Category.length > 0) {
				dojo.removeClass(this.rootList.subitems[this.solution_browse_link_index].domNode, "empty");
				dojo.addClass(this.rootList.subitems[this.solution_browse_link_index].domNode, "branch");
				
				//this._pruneTree(response);
				this._swizzleData(response.Category, null, "request_folder.png", "default_solution.png");				 
				this._sortTree(response);
				this.rootList.subitems[this.solution_browse_link_index].keyField = "ID";
				this.rootList.subitems[this.solution_browse_link_index].addChildren(response, "RowMajor", 2);
			}					
			
			if (com.ibm.ism.pmsc.dojo._SC_installed == true && this.solution_browse_link_index)
				this._sortFolderSubitems(this.rootList.subitems[this.solution_browse_link_index].subitems);											
			 
			return response;			
		},
		
		_getCountOffering: function(categories){
			var count=0;
			for(var category in categories){				
                if (categories[category].Offering)			
                	count = count + categories[category].Offering.length;
                if (categories[category].Category)
                	count = count + this._getCountOffering(categories[category].Category);
			}	
			return count;
		},
				 
		
		//Handle async response from server
		//Hide unauthorized apps and urls from top links
		_sendasync_resp: function(response) { 
			var auth = response.auth;		
			var type = response.type; //app or lic
			var target = response.target;
			console.log("Navigator._sendasync_resp:" + type + "-" + target + "-"+auth);
			if (auth==false) {
			   dojo.forEach(this.rootList.subitems, function(item) {	
				   if(item.type && item.type=="application" && type=='app' && item.target==target) {					 
					 dojo.style(item.domNode, "display", "none");					 
				   } else if (item.type && item.type=="url" && type=='lic' && item.target==target) {					 
					 dojo.style(item.domNode, "display", "none");
				   }				   
			   });			
				
			}		
		},
		
		//Process server async call to get sigoptions. Hide links and icons based on configuration		 
		// hide links based ifn sigoption not granted. If sigoptions not there, just sjow links
		_getAppOptions_resp: function(response) {
			console.log("Navigator._getAppOptions_resp:" + response);
			var sigoptions= null;
			if (response.options) {
			   ibm.tivoli.simplesrm.srm.dojo.data.srmQuery()._sigoptions =  response.options;	
			   sigoptions = response.options;		
			} else
				console.log("Navigator._getAppOptions_resp - no sigoptions, show icons and links");
			
			//Hide create SR icon 
			// -if control property = true (this.hidecreatesricon which is passed as input parm)		
			// -if hidecreatesricon=true in config.properties
			// -if SHOWSSCCREATESRICON sigoption is not on
			var hidecreatesr_prop = ibm.tivoli.tpae.dojo.data.getConfigProperty("hidecreatesricon");  //config.properties
			if (hidecreatesr_prop!=null && hidecreatesr_prop=='true') {
				this.hidecreatesricon=true;					 
    		}		
			if (sigoptions!=null && dojo.indexOf(sigoptions, "SHOWSSCCREATESRICON")<0) {  //sigoption
				this.hidecreatesricon=true;			     				
			}					
			
			if (this.hidecreatesricon==true) { 
				var createsr_icon = dijit.byId(this.id + "_createSR_btn");
				dojo.style(createsr_icon.domNode, "display", "none");
				
				var createSR_label = dojo.byId(this.id + '_createSR_label');				 
				if (createSR_label)
				   createSR_label.innerHTML="";
			} else {
				  //connect onclick to function
			      this.connect(this.createSR_btn, 'onClick', '_createSR');
			      
			      //tooltip
			      var tip = "<span style='font-size:x-small;'>" + this._uiStringTable.createSRToolTip + "</span>";	
				  new dijit.Tooltip({connectId: [this.id + "_createSR_btn"],label:  tip, position:"above"});
			}   
			
			
			//Hide create template icon
			// - if control property = true (this.hidetemplateicon is passed as input parm)
			// - if hidecarttemplateicon=true in config.properties
			// - if SHOWSSCTEMPLATEICON sigoption is not on
			//hide cart template icon if hidecarttemplate=true in config.properties
			var hidecarttemplate_prop = ibm.tivoli.tpae.dojo.data.getConfigProperty("hidecarttemplateicon");  //config.properties
			if (hidecarttemplate_prop!=null && hidecarttemplate_prop=='true') {
			   this.hidetemplateicon=true;					 
			}				
			
			if (sigoptions!=null && dojo.indexOf(sigoptions, "SHOWSSCTEMPLATEICON")<0) {  //sigoption
				this.hidetemplateicon=true;			     				
			}
			
			if (com.ibm.ism.pmsc.dojo._SC_installed == false) {  //MAXVARS- SC not installed
				this.hidetemplateicon=true;	
			}			
			
			if (this.hidetemplateicon==true) { //navigator widget parm (control property)
				var template_icon = dijit.byId(this.id + "_template_btn");
				dojo.style(template_icon.domNode, "display", "none");
			} else {			 
			    this.connect(this.template_btn, 'onClick', '_template');
			    
			    //tooltip
				var	tip = "<span style='font-size:x-small;'>" + this._uiStringTable.templateToolTip + "</span>";	
				new dijit.Tooltip({connectId: [this.id + "_template_btn"],label:  tip, position:"above"});					
			}
			
			
			//Hide shopping cart icon 
			// -if hidecarticon=true in config properties
			// -if hidecarticon=true passed into the navigator control 
			// -if SC not installed (MAXVARS)
			// -if sigoption SHOWSSCCARTICON		
			var hidecart_prop = ibm.tivoli.tpae.dojo.data.getConfigProperty("hidecarticon");  //config.properties
			if (hidecart_prop!=null && hidecart_prop=='true') {				 
				this.hidecarticon=true;					 
			}					            
				
			if (com.ibm.ism.pmsc.dojo._SC_installed == false) {  //MAXVARS				 
			    this.hidecarticon=true;										 
			}
			
			if (sigoptions!=null && dojo.indexOf(sigoptions, "SHOWSSCCARTICON")<0) {  //sigoption
				this.hidecarticon=true;			     				
			}
			
			//Hide cart icon if Catalog disabled  
			//if (this.catalog_link_index==-1)  {
			//	this.hidecarticon=true;			
			//}				
			
			if (this.hidecarticon==true) { //navigator widget parm (control property)
				var shopping_cart_icon = dijit.byId(this.id + "_shoppingCart_btn");
				var shopping_cart_label = dojo.byId(this.id + '_cart_label');
				dojo.style(shopping_cart_icon.domNode, "display", "none");
				if (shopping_cart_label)
				   shopping_cart_label.innerHTML="";
				
				var shopping_cart_amt = dojo.byId(this.id + '_cart_amount'); 
				if (shopping_cart_amt)
				   shopping_cart_amt.innerHTML = " ";
			}			

			//Hide link if sigoption corresponding to link was not granted to the srmssctr app for the security group
			//For example: link id = Solution, sigoption SHOWSSCSOLUTION, grant SHOWSSCSOLUION Option to srmssctr app for security group PMSCADM			
		   dojo.forEach(this.rootList.subitems, dojo.hitch(this,function(link) {
			   if (sigoptions!=null &&  dojo.indexOf(sigoptions, "SHOWSSC" + link.data.id.toUpperCase())<0) {  //sigoption
					 dojo.style(link.domNode, "display", "none");  //hide link	
				}				   
		   }));
		   
		   //Hide new Home icon based on sigoption TSRM_SHOWSTARTCENTER (Show Start Center link in page header) not selected
		   //This is a hack becuase TPAe should be doing this
			if (sigoptions!=null && dojo.indexOf(sigoptions, "TSRM_SHOWSTARTCENTER")<0) {  //sigoption				
				var node = dojo.query(".homebutton")[0];
				if (node!=null) {
					dojo.style(node, "display", "none");  //hide home link
				}
			}
			 //Hide new goto menu  icon based on sigoption TSRM_SHOWSTARTCENTER (Show Start Center link in page header) not selected
			   //This is a hack becuase TPAe should be doing this
			if (sigoptions!=null && dojo.indexOf(sigoptions, "TSRM_SHOWGOTO")<0) {  //sigoption				
				var node = dojo.query(".gotobutton")[0];
				if (node!=null && node.id.indexOf("_gotoButton")>0) {
					dojo.style(node, "display", "none");  //hide goto menu link
				}
			}	  
		   
		},
		
		_sortTreeScore: function(tree)
		{
			if(undefined !== tree.Category) {
				tree.Category.sort(function(a, b)
				{
					if(a.Score && b.Score && (a.Score < b.Score)) {
						return 1;
					}
					if(a.Score && b.Score && (a.Score > b.Score)) {
						return -1;
					}
					return 0;
				});
			}
		}	
		 		
	}
);



});

},
'ibm/tivoli/simplesrm/srm/dijit/MyAssetsGrid':function(){
// wrapped by build app
define(["dijit","dojo","dojox","dojo/require!ibm/tivoli/simplesrm/srm/dijit/MyRecordsGrid,ibm/tivoli/simplesrm/srm/dijit/RequestDetails,dijit/Dialog"], function(dijit,dojo,dojox){
//////////////////////////////////////////////////////////////////
// @JS_LONG_COPYRIGHT_BEGIN@
// @JS_LONG_COPYRIGHT_END@
//////////////////////////////////////////////////////////////////

dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MyAssetsGrid");
dojo.provide("ibm.tivoli.simplesrm.srm.dijit.ShowAssetDetails");
//dojo.provide("ibm.tivoli.simplesrm.srm.dijit.MyApprovalsGrid");

// include modules
dojo.require("ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid");
dojo.require("ibm.tivoli.simplesrm.srm.dijit.RequestDetails");
dojo.require("dijit.Dialog");


// Summary:
//	A mixin for showing request details.
dojo.declare("ibm.tivoli.simplesrm.srm.dijit.ShowAssetDetails",
			 ibm.tivoli.simplesrm.srm.dijit.CreatorFactory,
{

	popup: null,
	
	showRecordDetails: function(selected_record)
	{
		//this.createAndShowInputForm(selected_record, true);
		if(this.popup) {
			this.popup.destroy();
			this.popup = null;
		}
		if(selected_record) {
			console.log("ShowAssetDetails", selected_record);
			var d = ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getRequestDetails(selected_record);
			d.addCallback(dojo.hitch(this, function(response)
			{
				var rd = new ibm.tivoli.simplesrm.srm.dijit.RequestDetails({approval: false});
				rd.setData(response);
			}));
		}
	}
	
	/**
	 * Specify whether the parent grid allows the approval panel to be displayed
	 * or not.
	 */
	//setApprContext: function(approvalContext) {
	//	this._approveRights = approvalContext;
	//}
});

// Summary:
//	TODO: write this
dojo.declare(
	"ibm.tivoli.simplesrm.srm.dijit.MyAssetsGrid",
	[dijit._Widget, ibm.tivoli.simplesrm.srm.dijit.MyRecordsGrid, ibm.tivoli.simplesrm.srm.dijit.ShowAssetDetails],
{
 
	// constructor defines "static" properties for this class, and
	// declares "instance" properties for this class
	constructor: function()
	{
		console.log("MyAssetsGrid.ctor");
		
        //this._hoverer = new  ibm.tivoli.simplesrm.srm.dojo.Hoverer();
        //this._conn_onHover = dojo.connect(this._hoverer, "OnHover", this, "_showGridTooltip");
		
 		// the column definitions
 		// the order they are listed here is the order they will be displayed in the tooltip
		
		//Default asset grid columns
		//Columns can also be set via colAssetAttrNameArray global var set in assetspod jsp using assetspod control columns property 
		this._column_defs = [
				 {field: 'key',			 name: "",							 	width: '5%',	compare: dojo.hitch(this, "_sortDefault"), showInTooltip: false}
				,{field: 'id', 			 name: 'id',							width: '5%',	compare: dojo.hitch(this, "_sortNumber")}
				,{field: 'type', 		 name: "Object Type",					width: '5%',	compare: dojo.hitch(this, "_sortString"), showInTooltip: false}
				,{field: 'ASSETNUM',     name: this._uiStringTable.AssetNumber,	width: '10%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'SERIALNUM',    name: this._uiStringTable.Serial,      width: '10%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}				
				,{field: 'DESCRIPTION',  name: this._uiStringTable.Description,	width: '25%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'StatusString', name: this._uiStringTable.Status,		width: '5%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe")}
				,{field: 'LOCATION',     name: this._uiStringTable.Location,    width: '10%',	compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, "_formatStringSafe")}				
				,{field: 'REFRESHDATE',   name: this._uiStringTable.RefreshDate,  width: '10%',  compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")}
				,{field: 'PLANNEDREFRESHDATE',   name: this._uiStringTable.PlannedRefreshDate,  width: '10%',  compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")}		
				,{field: 'ISPRIMARY',    name: this._uiStringTable.IsPrimary,   width: '5%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe"), editable: true,  type: dojox.grid.cells.Bool}
				,{field: 'ISUSER',       name: this._uiStringTable.IsUser,	    width: '5%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe"), editable: true,  type: dojox.grid.cells.Bool}
				,{field: 'ISCUSTODIAN',  name: this._uiStringTable.IsCustodian, width: '5%',	compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatStringSafe"), editable: true,  type: dojox.grid.cells.Bool}
				,{field: 'CHANGEDATE',   name: this._uiStringTable.ChangeDate,  width: '10%',  compare: dojo.hitch(this, "_sortDefault"), formatter: dojo.hitch(this, "_formatDateTimeReally")}
		];
				 
		indeces = 1;
		this._initial_sort_index = 0;	 	// SR ID (column index, not field index)
		
		//colAssetAttrNameArray is set in assetspod jsp using assetspod control columns property
		if (colAssetAttrNameArray!=null && colAssetAttrNameArray.length>0) {
			
			this._initial_view_cols = [indeces+2];	// indecies into _column_defs
					
			for (key in colAssetAttrNameArray) {
  			    if(key == "STATUS")
					  key= "StatusString";
				
				//Does column key already exist in column defs?
				var exists = false;
				var index = -1;
				for (var i=0; i<this._column_defs.length;i++) {
				   var rec = this._column_defs[i];
				   if (rec.field ==key) {
						exists=true;
						index = i;
						break;						
					}
				} 
				
				//Add new record to column defs
				if (exists ==false) {				
				   formatString = "_formatStringSafe";
				   colWidth = '13%';

				   var dateMatch = key.match(/DATE/gi);
				   if(dateMatch != null)
					   formatString = "_formatDateTimeReally";
				
				   var widthMatch = key.match(/ID/gi);
				   if(widthMatch != null)
					  colWidth = '6%';

				   var colValue = key;
				   if(colValue == "STATUS")
					   colValue= "StatusString";
				   
				   this._column_defs.push({field: colValue,  name: colAttrNameArray[key],   width: colWidth,  compare: dojo.hitch(this, "_sortString"), formatter: dojo.hitch(this, formatString)});				
				   this._initial_view_cols[indeces++] = this._column_defs.length-1;
				   
				} else {  //column already in column def array
				   this._initial_view_cols[indeces++] = index;	
				}
			}			
		} else {
			this._initial_view_cols = [3, 4, 5, 6, 7, 8, 9, 10, 11, 12];  //default columns
		}	
				
			
		this._data_key_field = 0;
		this._initial_sort_asc = false;		// descending
		
		// query parameters
		this._queryErrorMessage = "CTJZH2360E";
	},


	ajaxQueryData: function()
	{
		var params = [];
		if (this._fd!=null)
		   params._fd = this._fd;  //filtering domain
		params.os = this._os;   //OS name
		params.sr_object = this._ticket_object;  //Main object

		return ibm.tivoli.simplesrm.srm.dojo.data.srmQuery().getAssets(params);
	},
	
	// load handler for the data query
	_processQueryResult: function(response)
	{
		if(!dojo.isArray(response.Requests)) {
			response.requests = [];
		}
		var requests = response.Requests;
		this._loadGrid(response.Requests);
		return this.inherited(arguments);
	},

	_dummy:null
});
 

 

});

}}});

define("layers/mbs/SRMUIDojo", [], 1);
